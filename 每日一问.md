1. 解释一下 webpack 插件的实现原理？
本质上，webpack 的插件是一个带有apply函数的对象。当 webpack 创建好 compiler 对象后，会执行注册插件的 apply 函数，同时将 compiler 对象作为参数传入。
在 apply 函数中，开发者可以通过 compiler 对象监听多个钩子函数的执行，不同的钩子函数对应 webpack 编译的不同阶段。当 webpack 进行到一定阶段后，会调用这些监听函数，同时将 compilation 对象传入。开发者可以使用 compilation 对象获取和改变 webpack 的各种信息，从而影响构建过程。

2. 解释一下 npm 模块安装机制是什么？
1. npm 会检查本地的 node_modules 目录中是否已经安装过该模块，如果已经安装，则不再重新安装
2. npm 检查缓存中是否有相同的模块，如果有，直接从缓存中读取安装
3. 如果本地和缓存中均不存在，npm 会从 registry 指定的地址下载安装包，然后将其写入到本地的 node_modules 目录中，同时缓存起来。

6. map 和 forEach 的区别？
 forEach()方法不会返回执行结果，而是undefined。
也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。

适用场景
forEach适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。
map()适用于你要改变数据值的时候。不仅仅在于它更快，而且返回一个新的数组。这样的优点在于你可以使用复合(composition)(map, filter, reduce 等组合使用)来玩出更多的花样。  

4. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别
Set
成员唯一、无序且不重复
键值与键名是一致的（或者说只有键值，没有键名）
可以遍历，方法有 add, delete,has
WeakSet
成员都是对象
成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏
不能遍历，方法有 add, delete,has
Map
本质上是健值对的集合，类似集合
可以遍历，方法很多，可以跟各种数据格式转换
WeakMap
只接受对象作为健名（null 除外），不接受其他类型的值作为健名
键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾机制回收，此时键名是无效的
不能遍历，方法有 get、set、has、delete

5. 如何判断数组或对象
  1. 通过 instanceof 进行判断
var arr = [1,2,3,1];
console.log(arr instanceof Array) // true
2. 通过对象的 constructor 属性
var arr = [1,2,3,1];
console.log(arr.constructor === Array) // true
3. Object.prototype.toString.call(arr)
console.log(Object.prototype.toString.call({name: "jerry"}));//[object Object]
console.log(Object.prototype.toString.call([]));//[object Array]
4. 可以通过 ES6 新提供的方法 Array.isArray( )
Array.isArray([]) //true


6. 事件委托以及冒泡原理
事件委托，又被称之为事件代理。在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面整体的运行性能。导致这一问题的原因是多方面的。

首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间。

对事件处理程序过多问题的解决方案就是事件委托。

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 层次。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。

事件冒泡（event bubbling），是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。 

7. webpack 中是如何处理图片的？
   webpack 本身不处理图片，它会把图片内容仍然当做 JS 代码来解析，结果就是报错，打包失败。如果要处理图片，需要通过 loader 来处理。其中，url-loader 会把图片转换为 base64 编码，然后得到一个 dataurl，file-loader 则会将图片生成到打包目录中，然后得到一个资源路径。但无论是哪一种 loader，它们的核心功能，都是把图片内容转换成 JS 代码，因为只有转换成 JS 代码，webpack 才能识别

8. JavaScript中执行上下文和执行栈是什么？
   执行上下文
简单的来说，执行上下文是一种对Javascript代码执行环境的抽象概念，也就是说只要有Javascript代码运行，那么它就一定是运行在执行上下文中执行上下文的类型分为三种：
- 全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象
- 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文
- Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用

执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段
创建阶段
创建阶段即当函数被调用，但未执行任何其内部代码之前
创建阶段做了三件事：
- 确定 this 的值，也被称为 This Binding
- LexicalEnvironment（词法环境） 组件被创建
- VariableEnvironment（变量环境） 组件被创建

词法环境
词法环境有两个组成部分：
- 全局环境：是一个没有外部环境的词法环境，其外部环境引用为null，有一个全局对象，this 的值指向这个全局对象
- 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境

变量环境
变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性
在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定

执行阶段在这阶段，执行变量赋值、代码执行
如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值

回收阶段执行上下文出栈等待虚拟机回收执行上下文

执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文

当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中
每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中
引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文



9. 讲一讲继承的所有方式都有什么？手写一个寄生组合式继承
  原型链继承
重点：让新实例的原型等于父类的实例。
特点：实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）
缺点：
1、新实例无法向父类构造函数传参。
2、继承单一。
3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）
借用构造函数继承
重点：用 call( ) 和 apply( ) 将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
特点：
1、只继承了父类构造函数的属性，没有继承父类原型的属性。
2、解决了原型链继承缺点1、2、3。
3、可以继承多个构造函数属性（call多个）。
4、在子实例中可向父实例传参。
缺点：
1、只能继承父类构造函数的属性。
2、无法实现构造函数的复用。（每次用每次都要重新调用）
3、每个新实例都有父类构造函数的副本，臃肿。
组合模式
重点：结合了两种模式的优点，传参和复用
特点：
1、可以继承父类原型上的属性，可以传参，可复用。
2、每个新实例引入的构造函数属性是私有的。
缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。
寄生组合式继承
重点：修复了组合继承的问题

```js
function Parent(name) {
  this.name = name;
  this.num = [0, 1, 2];
}

Parent.prototype.sayName = function() {
  return this.name;
};

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

Child.prototype = Object.create(Parent.prototype);

Child.prototype.constructor = Child;

// The first instance
const boy = new Child('Jothan', 22);

boy.num.push(3);
console.log(boy.num);
// [0, 1, 2, 3]

boy.sayName();
// 'Jothan'

// The second instance
const girl = new Child('Kat', 18);

console.log(girl.num);
// [0, 1, 2]

girl.sayName();
// 'Kat'  
```

10. 
```js
console.log(1);
setTimeout(() => {
    console.log(2);
    process.nextTick(() => {
        console.log(3);
    });
    new Promise((resolve) => {
        console.log(4);
        resolve();
    }).then(() => {
        console.log(5);
    });
});
new Promise((resolve) => {
    console.log(7);
    resolve();
}).then(() => {
    console.log(8);
});
process.nextTick(() => {
    console.log(6);
});
setTimeout(() => {
    console.log(9);
    process.nextTick(() => {
        console.log(10);
    });
    new Promise((resolve) => {
        console.log(11);
        resolve();
    }).then(() => {
        console.log(12);
    });
});

// 1
// 7
// 6
// 8
// 2
// 4
// 3
// 5
// 9
// 11
// 10
// 12
```

11. 请手写一个instanceof
    ```js
    function myInstanceof(target, origin) {
    // 非object直接返回false
    if(typeof target !== 'object' || target === null) return false;
    
    var proto = Object.getPrototypeOf(target);
    while (proto) {
      if (proto === origin.prototype) {
        return true
      }
      proto = Object.getPrototypeOf(proto);
    }
    return false
}
    ```

12.  v-if 和 v-for的优先级是什么？
  思路：
1. 先给出结论
2. 为什么是这样的，说出细节
3. 哪些场景可能导致我们这样做，该怎么处理
4. 总结


实践中不应该把v-for和v-if放一起
在vue2中，v-for的优先级是高于v-if，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；另外需要注意的是在vue3中则完全相反，v-if的优先级高于v-for，所以v-if执行时，它调用的变量还不存在，就会导致异常
通常有两种情况下导致我们这样做：
为了过滤列表中的项目 (比如 v-for="user in users" v-if="user.isActive")。此时定义一个计算属性 (比如 activeUsers)，让其返回过滤后的列表即可（比如users.filter(u=>u.isActive)）。
为了避免渲染本应该被隐藏的列表 (比如 v-for="user in users" v-if="shouldShowUsers")。此时把 v-if 移动至容器元素上 (比如 ul、ol)或者外面包一层template即可。
文档中明确指出永远不要把 v-if 和 v-for 同时用在同一个元素上，显然这是一个重要的注意事项。
源码里面关于代码生成的部分，能够清晰的看到是先处理v-if还是v-for，顺序上vue2和vue3正好相反，因此产生了一些症状的不同，但是不管怎样都是不能把它们写在一起的


13. JS 的基本数据类型有哪些？基本数据类型和引用数据类型的区别
    
基本数据类型，一共有 8 种
string，symbol，number，boolean，undefined，null，bigInt
其中 symbol、bigInt 类型是在 ES6 及后续版本里面新添加的基本数据类型。
引用数据类型： object
基本数据类型的值又被称之为原始值或简单值，而引用数据类型的值又被称之为复杂值或引用值。
两者的区别在于：原始值是表示 JavaScript 中可用的数据或信息的最底层形式或最简单形式。简单类型的值被称为原始值，是因为它们是不可细化的。原始值的数据是存储于内存中的栈区里面的。
引用值在内存中的大小是未知的，因为引用值可以包含任何值，而不是一个特定的已知值，所以引用值的数据都是存储于堆区里面。

14. 
```js
// 题目
// 分析下面代码的导出结果为 {d:4}
this.a = 1
exports.b = 2
exports = {
 c: 3
}

module.exports = {
 d: 4
}

exports.e = 5
this.f = 6

// 这里面做了特殊处理了，在执行require的时候，内部实现了一个模块，在调用的时候 this指向了 exports

```

15.  
跳跃游戏 II
https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&envId=top-interview-150

```js
var jump = function (nums) {
  let curIndex = 0
  let nextIndex = 0
  let step = 0
  for (let i = 0; i < nums.length - 1; i++) {
    nextIndex = Math.max(nums[i] + i, nextIndex)
    if (i === curIndex) {
      curIndex = nextIndex;
      step++
    }
  }

  return step
};
```

16.  
function sum(){}
var total = sum();

实现：
total[1][2][3] =6;
total[10][20][30] = 60;
total[20][30][50] = 100;
要适配所有数字，请问这个方法怎么实现
```js
// 方法一
function sum(value = 0) {
  let count = 0;
  function createProxy(value) {
    return new Proxy(
      {},
      {
        get(target, prop) {
          count++;
          if (count < 3) {
            return createProxy(value + Number(prop));
          } else {
            count = 0;
            return value + Number(prop);
          }
        },
      },
    );
  }
  return createProxy(value);
}

// 方法二
function sum() {
  let count = 0;
  let value = 0
  return new Proxy(
    {},
    {
      get(target, prop, receiver) {
        count++;
        value += Number(prop);
        if (count < 3) {
          return receiver;
        } else {
          const res = value;
          count = 0;
          value = 0
          return res
        }
      },
    },
  );
}
const total = sum();
console.log(total[1][2][3]);
console.log(total[10][20][30]);
console.log(total[20][30][50]);
```

17.  
买卖股票的最佳时机
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?envType=study-plan-v2&envId=top-interview-150

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
// 贪心
var maxProfit1 = function (prices) {
  let ret = 0
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] - prices[i - 1] > 0) {
      ret += prices[i] - prices[i - 1]
    }
  }
  return ret
};




var maxProfit = function (prices) {
  let len = prices.length

  // dp[i] = [第i天持有股票的钱，不持有股票的钱]
  // 初始状态
  let has = -prices[0]
  let notHas = 0

  for (let i = 1; i < len; i++) {
    has = Math.max(has, notHas - prices[i])
    notHas = Math.max(notHas, has + prices[i])
  }
  return notHas
};



```

18.  买卖股票的最佳时机 II
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/?envType=study-plan-v2&envId=top-interview-150
```js
**
 * @param {number[]} prices
 * @return {number}
 */
// 贪心
var maxProfit1 = function (prices) {
  let ret = 0
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] - prices[i - 1] > 0) {
      ret += prices[i] - prices[i - 1]
    }
  }
  return ret
};




var maxProfit = function (prices) {
  let len = prices.length

  // dp[i] = [第i天持有股票的钱，不持有股票的钱]
  // 初始状态
  let has = -prices[0]
  let notHas = 0

  for (let i = 1; i < len; i++) {
    has = Math.max(has, notHas - prices[i])
    notHas = Math.max(notHas, has + prices[i])
  }
  return notHas
};
```

19. 爬楼梯
https://leetcode.cn/problems/climbing-stairs/description/

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    let dp = [1,1]
    for(let i = 2; i<= n; i++) {
        dp[i] = dp[i-1] + dp[i - 2]
    }
    return dp[n]
};

```


20. 轮转数组
https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150

```js
方法一：
var rotate = function(nums, k) {
   const n = nums.length
   const arr = new Array(n)
    for(let i = 0; i < n;  i++) {
        arr[(i+k) % n] = nums[i] 
    }

    for(let i = 0; i < n; i++) {
        nums[i] = arr[i]
    }
};

方法二：
var rotate = function (nums, k) {
    const n = nums.length
    k %= n
    reverse(nums, 0, n - 1)
    reverse(nums, 0, k - 1)
    reverse(nums, k, n - 1)
};

function reverse(nums, start, end) {
    while (start < end) {
        [nums[start], nums[end]] = [nums[end], nums[start]]
        start++
        end--
    }
}
```


21.  多数元素
https://leetcode.cn/problems/majority-element/?envType=study-plan-v2&envId=top-interview-150

```js

答案一：
var majorityElement = function(nums) {
    nums = nums.sort()
    return nums[Math.floor(nums.length / 2)]
};
答案二：
var majorityElement = function(nums) {
   let mid = nums.length / 2
   let map = new Map()
   for(let num of nums) {
    if(map.has(num)) {
        let currNum = map.get(num)
        map.set(num, currNum + 1)
    } else {
        map.set(num, 1)
    }

    if(map.get(num) >mid) {
        return num
    }
   }
};
```

22. defer 与 async 的区别
    
按照惯例，所有 script 元素都应该放在页面的 head 元素中。这种做法的目的就是把所有外部文件（CSS 文件和 JavaScript 文件）的引用都放在相同的地方。可是，在文档的 head 元素中包含所有 JavaScript 文件，意味着必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到 body 标签时才开始呈现内容）。

对于那些需要很多 JavaScript 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。为了避免这个问题，现在 Web 应用程序一般都全部 JavaScript 引用放在 body 元素中页面的内容后面。这样一来，在解析包含的 JavaScript 代码之前，页面的内容将完全呈现在浏览器中。而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。

有了 defer 和 async 后，这种局面得到了改善。

defer （延迟脚本）

延迟脚本：defer 属性只适用于外部脚本文件。

如果给 script 标签定义了defer 属性，这个属性的作用是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，如果 script 元素中设置了 defer 属性，相当于告诉浏览器立即下载，但延迟执行。

async（异步脚本）

异步脚本：async 属性也只适用于外部脚本文件，并告诉浏览器立即下载文件。

但与 defer 不同的是：标记为 async 的脚本并不保证按照指定它们的先后顺序执行。

所以总结起来，两者之间最大的差异就是在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的。

defer 是立即下载但延迟执行，加载后续文档元素的过程将和脚本的加载并行进行（异步），但是脚本的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。async 是立即下载并执行，加载和渲染后续文档元素的过程将和 js 脚本的加载与执行并行进行（异步）

具体可看这个文档
https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html


23. 
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(function () {
    console.log('setTimeout');
}, 0);
async1();
new Promise(function (resolve) {
    console.log('promise1');
    resolve();
}).then(function () {
    console.log('promise2');
});
console.log('script end');
输出结果是什么？
1. 执行同步代码，打印script start
2. 立即将console.log('setTimeout')加入宏仁务队列
3. 同步执行async1，打印async1 start，在await async2();处等待
4. 执行 async2，打印async2，状态改变，将console.log('async1 end')放入微任务队列
5. 同步执行promise，打印promise1，resolve状态改变，注册then，将console.log('promise2')放入微任务队列
6. 执行最后的同步代码，打印script end
7. 查看微任务队列，先打印async1 end，再打印promise2
8. 查看宏仁务队列，打印setTimeout
最后输出结果：
script start 
async1 start 
async2 
promise1
script end
async1 end 
promise2
setTimeout

24. apply call bind 区别，手写
call 和 apply 的功能相同，区别在于传参的方式不一样:
fn.call(obj, arg1, arg2, ...) 调用一个函数, 具有一个指定的 this 值和分别地提供的参数(参数的列表)。
fn.apply(obj, [argsArray]) 调用一个函数，具有一个指定的 this 值，以及作为一个数组（或类数组对象）提供的参数。
bind 和 call/apply 有一个很重要的区别，一个函数被 call/apply 的时候，会直接调用，但是 bind 会创建一个新函数。当这个新函数被调用时，bind( ) 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。

Function.prototype.call2 = function (context) {
        var context = context || window;
    context.fn = this;

    let arg = [...arguments].slice(1)
    let result = context.fn(...arg)

    delete context.fn
    return result
}

Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
                result = context.fn(...arr)
    }

    delete context.fn
    return result;
}

Function.prototype.bind2 = function (context) {

    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}

25.  实现一个函数 clone 可以对 Javascript 中的五种主要数据类型（Number、string、 Object、Array、Boolean）进行复制
 ```js
  function clone(obj) {
  var o;
  switch (typeof obj) {
    case 'undefined':
      break;
    case 'string':
    case 'number':
    case 'boolean':
      o = obj;
      break;
    case 'object': // object 分为两种情况 对象（Object）或数组（Array）
      if (obj === null) {
        o = null;
      } else {
        if (Object.prototype.toString.call(obj).slice(8, -1) === 'Array') {
          o = [];
          for (var i = 0; i < obj.length; i++) {
            o.push(clone(obj[i]));
          }
        } else {
          o = {};
          for (var k in obj) {
            o[k] = clone(obj[k]);
          }
        }
      }
      break;
    default:
      o = obj;
      break;
  }
  return o;
}

 ```


 26. 给定两个数组，求交集
   ```js
   ```
27.  防抖与节流
    我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，_onmousemove、resize、onscroll_ 等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和函数节流。

函数防抖(_debounce_)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。

具体实现：

```js
/**
 * 函数防抖
 * @param {function} func 一段时间后，要调用的函数
 * @param {number} wait 等待的时间，单位毫秒
 */
function debounce(func, wait) {
  // 设置变量，记录 setTimeout 得到的 id
  let timerId = null;
  return function (...args) {
    if (timerId) {
      // 如果有值，说明目前正在等待中，清除它
      clearTimeout(timerId);
    }
    // 重新开始计时
    timerId = setTimeout(() = {
      func(...args);
    }, wait);
  };
}
```

函数节流(_throttle_)，指连续触发事件但是在 _n_ 秒中只执行一次函数。即 _2n_ 秒内执行 _2_ 次... 。节流如字面意思，会稀释函数的执行频率。

具体实现：

```js
function throttle(func, wait) {
  let context, args;
  let previous = 0;
  return function () {
    let now = +new Date();
    context = this;
    args = arguments;
    if (now - previous  wait) {
      func.apply(context, args);
      previous = now;
    }
  };
}
```

28.  new 操作符都做了哪些事？如何手写new?
    

29. 实现一个深拷贝


30. 数组去重有哪些方法？


31. 浏览器中DOM Tree 是如何构建的？
1. 转码: 浏览器将接收到的二进制数据按照指定编码格式转化为 HTML 字符串
2. 生成 Tokens: 之后开始 parser，浏览器会将 HTML 字符串解析成 Tokens
3. 构建 Nodes: 对 Node 添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope
4. 生成 DOM Tree: 通过 node 包含的指针确定的关系构建出 DOM Tree

32. 浏览器是如何渲染 UI 的？
    1. 浏览器解析 HTML，形成 DOM Tree
2. 解析 HTML 过程中遇到 CSS，则进行 CSS 解析，生成 Style Rules
3. 将 DOM Tree 与 Style Rules 合成为 Render Tree
4. 进入布局（Layout）阶段，为每个节点分配一个应出现在屏幕上的确切坐标
5. 随后调用 GPU 进行绘制（Paint），遍历 Render Tree 的节点，并将元素呈现出来


33. 如何让(a===1 && a===2 && a === 3)的值为true？
    var value = 0; //window.value
Object.defineProperty(window, 'a', {
    get: function() {
        return this.value += 1;
    }
});


34. 如何实现 a == 1 && a == 2 && a == 3 为 true？
   方法一 ：
const a = {
  value: 1,
  valueOf() {
    return this.value++;
  }
};
方法二：
const a = {
  value: 1,
  toString() {
    return this.value++;
  },
};

方法三：
const a = {
  value: 1,
  [Symbol.toPrimitive]() {
    return this.value++;
  },
}


35.  手写flat
    onst checkType = (arr) => {
  return Object.prototype.toString.call(arr).slice(8, -1);
};
Array.prototype.myFlat = function (num) {
  var type = checkType(this);
  var result = [];
  if (!Object.is(type, 'Array')) {
    return;
  }
  for (var i = 0; i < this.length; i++) {
    var item = this[i];
    var cellType = checkType(item);
    if (Object.is(cellType, 'Array')) {
      num--;
      if (num < 0) {
        var newArr = result.push(item);
        return newArr;
      }
      result.push.apply(result, item.myFlat(num));
    } else {
      result.push(item);
    }
  }
  return result;
};



36. 手写reduce
    

37. 封装一个能够统计重复的字符的函数，例如  *aaabbbdddddfff*  转化为 *3a3b5d3f*
    function compression(str) {
  if (str.length == 0) {
    return 0;
  }
  var len = str.length;
  var str2 = '';
  var i = 0;
  var num = 1;
  while (i < len) {
    if (str.charAt(i) == str.charAt(i + 1)) {
      num++;
    } else {
      str2 += num;
      str2 += str.charAt(i);
      num = 1;
    }
    i++;
  }
  return str2;
}
// 测试：
console.log(compression('aaabbbdddddfff')); // 3a3b5d3f


38.  手写用 ES6 proxy 如何实现 arr[-1] 的访问
   const proxyArray = (arr) => {
  const length = arr.length;
  return new Proxy(arr, {
    get(target, key) {
      key = +key;
      while (key < 0) {
        key += length;
      }
      return target[key];
    },
  });
};
var a = proxyArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
console.log(a[-1]);


39.  
```js
new Promise((resolve, reject) => {
 resolve(2) 
 new Promise((resolve, reject) => {
  resolve(5)
 }).then((v) => {
  console.log(v)
 })
}).then((v) => {
 console.log(v)
})


new Promise((resolve, reject) => {
 setTimeout(() => {
  resolve(2)
  new Promise((resolve, reject) => {
      resolve(5)
    }).then((v) => {
      console.log(v)
    })
 })
}).then((v) => {
 console.log(v)
})

``` 
5
2
2
5
加入微队列的时机有两个点
1.调用 resolve 时，会检查目前注册的thenable(即then 中的回调)，将它们加入到微队列
2.调用 then方法时，会检查当前的 promise状态，如果为 fulfilled则将传递的 thenable加入到微队列

在此题的第一部分，当两个resolve被调用时，均还没有运行then方法，即没有注册任何的thenable，因此，第一部分的thenable执行顺序由 then方法的调用顺序决定。

在此题的第二部分，当第一个resolve执行时，由于此时已经注册了 thenable，因此即刻将其加入到微队列，因此会先输出 2.


40.   
```js
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}
async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(function () {
  console.log('setTimeout');
}, 0);

async1();

new Promise(function (resolve) {
  console.log('promise1');
  resolve();
}).then(function () {
  console.log('promise2');
});
console.log('script end');
```
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout

41.   
  ```js
  var a;
var b = new Promise((resolve, reject) => {
  console.log('promise1');
  setTimeout(() => {
    resolve();
  }, 1000);
})
  .then(() => {
    console.log('promise2');
  })
  .then(() => {
    console.log('promise3');
  })
  .then(() => {
    console.log('promise4');
  });

a = new Promise(async (resolve, reject) => {
  console.log(a);
  await b;
  console.log(a);
  console.log('after1');
  await a;
  resolve(true);
  console.log('after2');
});

console.log('end');

```
promise1
undefined
end
promise2
promise3
promise4
Promise { <pending> }
after1

42.   
```js
async function m1() {
  return 1;
}

async function m2() {
  const n = await m1();
  console.log(n);
  return 2;
}

async function m3() {
  const n = m2();
  console.log(n); 
  return 3;
}

m3().then((n) => {
  console.log(n);
});

m3();

console.log(4);
```

Promise { <pending> }
Promise { <pending> }
4
1
3
1


43.  
Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log);
1
记住一个点，如果then传入的不是函数，那么值直接透传即可

44. 为什么用多个域名存储网站资源更有效？
    主要原因是浏览器对同一个域下的 TCP 连接数是有限制的，这样就导致某个网页如果外部资源多了，比如图片很多的网页，在解析页面时，由于 TCP 连接数受限，就无法同时发起多个下载连接，无法充分利用带宽资源。因此，可以把静态资源放到多个域名下，这样就绕开了连接数的限制，做到了并发下载。

45. 介绍一下 webpack scope hoisting
    scope hoisting 是 webpack 的内置优化，它是针对模块的优化，在生产环境打包时会自动开启。
在未开启scope hoisting时，webpack 会将每个模块的代码放置在一个独立的函数环境中，这样是为了保证模块的作用域互不干扰。
而 scope hoisting 的作用恰恰相反，是把多个模块的代码合并到一个函数环境中执行。在这一过程中，webpack 会按照顺序正确的合并模块代码，同时对涉及的标识符做适当处理以避免重名。
这样做的好处是减少了函数调用，对运行效率有一定提升，同时也降低了打包体积。
但 scope hoisting 的启用是有前提的，如果遇到某些模块多次被其他模块引用，或者使用了动态导入的模块，或者是非 ESM 的模块，都不会有 scope hoisting。

46. 闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？
    闭包是指有权访问另外一个函数作用域中的变量的函数。

因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用，内存泄漏。

如果要销毁一个闭包，可以 把被引用的变量设置为null，即手动清除变量，这样下次 js 垃圾回收机制回收时，就会把设为 null 的量给回收了。

闭包的应用场景：
匿名自执行函数
结果缓存
封装
实现类和继承
防抖
节流
柯里化

47. 什么是作用域链、原型链?
    什么是作用域链?
当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。

什么原型链?
每个对象都可以有一个原型__proto__，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找。这个操作被委托在整个原型链上，这个就是我们说的原型链。

48. 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因
    for 循环按顺序遍历，forEach 使用 iterator 迭代器遍历
量级越大的时候，forEach的性能远远低于for的性能
我们从语法上面来观察：
arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
可以看到 forEach 是有回调的，它会按升序为数组中含有效值的每一项执行一次 callback，且除了抛出异常以外，也没有办法中止或者跳出 forEach 循环。那这样的话执行就会额外的调用栈和函数内的上下文。

而 for 循环则是底层写法，不会产生额外的消耗。

在实际业务中没有很大的数组时，for 和 forEach 的性能差距其实很小，forEach 甚至会优于 for 的时间，且更加简洁，可读性也更高，一般也会优先使用 forEach 方法来进行数组的循环处理。


49. undefined==null 返回的结果是什么？undefined 与 null 的区别在哪？  
这两个值都表示“无”的意思。

通常情况下， 当我们试图访问某个不存在的或者没有赋值的变量时，就会得到一个 undefined 值。Javascript 会自动将声明是没有进行初始化的变量设为 undifined。

而 null 值表示空，null 不能通过 Javascript 来自动赋值，也就是说必须要我们自己手动来给某个变量赋值为 null。

50.  
```js
class Foo {
    constructor(arr) { 
        this.arr = arr; 
    }
    bar(n) {
        return this.arr.slice(0, n);
    }
}
var f = new Foo([0, 1, 2, 3]);
console.log(f.bar(1));//[0]
console.log(f.bar(2).splice(1, 1));//[1]
console.log(f.arr);//[1,2,3,4]
描述下代码的执行结果
```

```js
slice：返回新数组，不改变原数组，第一个参数为起始index，第二个为终止index（不包含）
splice：直接修改原数组，第一个参数为起始index，第二个为截取的数量
所以输出结果:
[0]
[1]
[0,1,2,3]
实例中的arr并没有被修改
```

51.  
```js
new Promise((resolve, reject) => {
    reject(1);
    console.log(2);
    resolve(3);
    console.log(4);
}).then((res) => { console.log(res) })
    .catch(res => { console.log('reject1') })
try {
    new Promise((resolve, reject) => {
        throw 'error'
    }).then((res) => { console.log(res) })
        .catch(res => { console.log('reject2') })
} catch (err) {
    console.log(err)
}

```

```bash
2
4
reject1
reject2
```

52. 怎么添加、移除、复制、创建、和查找节点
1）创建新节点
createDocumentFragment( ) // 创建一个DOM 片段
createElement( ) // 创建一个具体的元素
createTextNode( ) // 创建一个文本节点
2）添加、移除、替换、插入
appendChild( )
removeChild( )
replaceChild( )
insertBefore( ) // 在已有的子节点前插入一个新的子节点
3）查找
getElementsByTagName( ) //通过标签名称
getElementsByName( ) // 通过元素的 Name 属性的值
getElementById( ) // 通过元素 Id，唯一性
querySelector( ) // 用于接收一个 CSS 选择符，返回与该模式匹配的第一个元素
querySelectorAll( ) // 用于选择匹配到的所有元素

53. JavaScript 中的 const 数组可以进行 push 操作吗？为什么？
    可以进行 push 操作。虽然 const 表示常量，但是当我们把一个数组赋值给 const 声明的变量时，实际上是把这个数组的地址赋值给该变量。而 push 操作是在数组地址所指向的堆区添加元素，地址本身并没有发生改变。

54.  
```js
var a = function () { return 5 }
a.toString = function () { return 3 }
console.log(a + 7); //10
```
10
因为会自动调用 a 函数的 toString 方法。


55.    
``` bash
下面的代码打印什么内容？为什么？
var b = 10;
(function b() {
  b = 20;
  console.log(b)
})()
```

``` bash
运行结果：
function b() { b = 20; console.log(b) }
分析：
当 JavaScript 解释器遇到非匿名立即执行函数（题目中的 b）时，会创建一个辅助的特定对象，然后将函数名称当作这个对象的属性，因此函数内部可以访问到 b，但是这个值又是只读的，所以对他的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。
```

56.  
webpack 中的 loader 属性和 plugins 属性的区别是什么？
它们都是 webpack 功能的扩展点。
loader 是加载器，主要用于代码转换，比如 JS 代码降级，CSS 预编译、模块化等
plugins 是插件，webpack 打包流程中每个环节都提供了钩子函数，可以利用这些钩子函数参与到打包生命周期中，更改或增加 webpack 的某些功能，比如生成页面和 css 文件、压缩打包结果等

57.  
说一下 webpack 中的几种 hash 的实现原理是什么？

hash
hash 是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都共用相同的 hash 值
chunkhash
每个打包过程单独的 hash 值，如果一个项目有多个 entry，则每个 entry 维护自己的 chunkhash。
contenthash
每个文件内容单独的 hash 值，它和打包结果文件内容有关，只要文件内容不变，contenthash 不变。


58.  
package.json 文件中的 devDependencies 和 dependencies 对象有什么区别？
前端项目的 package.json 文件中，dependencies 和 devDependencies 对象都用于指定项目所依赖的软件包，但它们在项目的开发和生产环境中的使用有所不同。
1.dependencies：
dependencies 是指定项目在生产环境中运行所需要的依赖项。
这些依赖项通常包括运行时需要的库、框架、工具等。
当你通过 npm install 或 npm ci 安装依赖时，默认会安装 dependencies 中的包。
这些依赖项会被打包和部署到生产环境中，因此它们对于项目的运行是必需的。
2.devDependencies：
devDependencies 是指定在开发过程中所需要的依赖项。
这些依赖项通常包括开发、测试、构建、部署等过程中所需的工具、库等。
例如，测试框架、构建工具、代码检查工具等通常属于 devDependencies。
当你在开发环境中使用 npm install 安装依赖时，只会安装 dependencies 中的包。要安装 devDependencies 中的包，你需要额外使用 npm install --dev 或 npm install --only=dev 等命令。
这些依赖项不会被打包到生产环境中，因为它们只在开发过程中需要，对于实际部署和运行项目并不需要。
总的来说，dependencies 中的依赖项是项目运行所必需的，而 devDependencies 中的依赖项则是在开发过程中需要的辅助工具和库。


59.  
```js
  new Promise((resolve, reject) => {
    console.log(3);
    let p = new Promise((resolve, reject) => {
      console.log(7);
      setTimeout(() => {
        console.log(1);
      }, 0);
      setTimeout(() => {
        console.log(2);
        resolve(3);
      }, 0);
      resolve(4);
    });
    resolve(2);
    p.then((arg) => {
      console.log(arg, 5);
    });
    setTimeout(() => {
      console.log(6);
    }, 0);
  });
first().then((arg) => {
  console.log(arg, 7);
  setTimeout(() => {
    console.log(8);
  }, 0);
});
setTimeout(() => {
  console.log(9);
}, 0);
console.log(10);
```
```js
3
7
10
4 5
2 7
1
2
6
9
8
```

60.   
```js
const async1 = async () => {
  console.log('async1');
  setTimeout(() => {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 end')
  return 'async1 success'
} 
console.log('script start');
async1().then(res => console.log(res));
console.log('script end');
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res => console.log(res))
setTimeout(() => {
  console.log('timer2')
}, 1000)

```

```bash
今日答案：
script start
async1
promise1
script end
1
timer2
timer1
```

61.  
```js
async function testSometing() {
  console.log("执行testSometing");
  return "testSometing";
}

async function testAsync() {
  console.log("执行testAsync");
  return Promise.resolve("hello async");
}

async function test() {
  console.log("test start...");
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
}

test();

var promise = new Promise(resolve => {
  console.log("promise start...");
  resolve("promise");
});
promise.then(val => console.log(val));

console.log("test end...");
```
```bash
test start...
执行testSometing
promise start...
test end...
testSometing
执行testAsync
promise
hello async
testSometing hello async
```

62.  
```
async function async1() {
 console.log("async1 start");
  await async2();
  console.log("async1 end");
}

async function async2() {
  console.log("async2");
}

console.log("script start");

setTimeout(function() {
  console.log("setTimeout");
}, 0);

async1();

new Promise(function(resolve) {
  console.log("promise1");
  resolve();
}).then(function() {
  console.log("promise2");
});
console.log('script end')
```

``` bash
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

63.  

```js
Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log);
```

```bash
1
then接收的如果不是函数那么会透传
```
64.  
```js
var a;
var b = new Promise((resolve, reject) => {
  console.log('promise1');
  setTimeout(() => {
    resolve();
  }, 1000);
})
  .then(() => {
    console.log('promise2');
  })
  .then(() => {
    console.log('promise3');
  })
  .then(() => {
    console.log('promise4');
  });

a = new Promise(async (resolve, reject) => {
  console.log(a);
  await b;
  console.log(a);
  console.log('after1');
  await a;
  resolve(true);
  console.log('after2');
});

console.log('end');
```
```bash
promise1
undefined
end
promise2
promise3
promise4
Promise { <pending> }
after1

```
64.  

```js

```

```bash
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

65. 
介绍下 `http1.0`、`http1.1`、`http2.0` 协议的区别？
http1.0：
它的特点是每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：

1. 无法复用连接 ，每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低
2. 队头阻塞， 如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。

http1.1：

http1.1 是 http1.0 的改进版，它做出了以下改进：

1. 长连接： http1.1 允许在请求时增加请求头connection:keep-alive，这样便允许后续的客户端请求在一段时间内复用之前的 TCP 连接
2. 管道化：基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。
3. 缓存处理：新增响应头 cache-control，用于实现客户端缓存。
4. 断点传输：在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率

http2.0

http2.0 进一步优化了传输效率，它主要有以下改进：

1. 二进制分帧：将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装
2. 多路复用：基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序
3. 头部压缩：http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量
4. 服务器推：http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求

66.  
为什么 HTTP1.1 不能实现多路复用
HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

67.  
简单讲解一下 http2 的多路复用
在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

68. 
  ```js
  new Promise((resolve, reject) => {
 resolve(2) 
 new Promise((resolve, reject) => {
  resolve(5)
 }).then((v) => {
  console.log(v)
 })
}).then((v) => {
 console.log(v)
})


new Promise((resolve, reject) => {
 setTimeout(() => {
  resolve(2)
  new Promise((resolve, reject) => {
      resolve(5)
    }).then((v) => {
      console.log(v)
    })
 })
}).then((v) => {
 console.log(v)
})
  ``` 
```bash
5 2 2 5 
加入微队列的时机有两个点
1.调用 resolve 时，会检查目前注册的thenable(即then 中的回调)，将它们加入到微队列
2.调用 then方法时，会检查当前的 promise状态，如果为 fulfilled则将传递的 thenable加入到微队列

在此题的第一部分，当两个resolve被调用时，均还没有运行then方法，即没有注册任何的thenable，因此，第一部分的thenable执行顺序由 then方法的调用顺序决定。

在此题的第二部分，当第一个resolve执行时，由于此时已经注册了 thenable，因此即刻将其加入到微队列，因此会先输出 2.
``` 

69.  
谈谈你对 TCP 三次握手和四次挥手的理解
TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：

首先服务器进入监听状态，然后即可处理连接

第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。

第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。

第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。

最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成

当需要关闭连接时，需要进行四次挥手才能关闭

1. Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。
2. Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。
3. Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。
4. Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。
5. Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。
6. Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。


70.  
介绍 HTTPS 握手过程
1.客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息
2. 服务器响应公钥和服务器证书
3.客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器
4.服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪
5.客户端使用会话密钥解密消息，知道了服务器已经准备就绪。
6.后续客户端和服务器使用会话密钥加密信息传递消息

71. 
Vue 的 nextTick 是如何实现的？
nextTick 的本质将回调函数包装为一个微任务放入到微任务队列，这样浏览器在完成渲染任务后会优先执行微任务。

nextTick 在 Vue2 和 Vue3 里的实现有一些不同：

1. Vue2 为了兼容旧浏览器，会根据不同的环境选择不同包装策略：
   1. 优先使用 Promise，因为它是现代浏览器中最有效的微任务实现。
   2. 如果不支持 Promise，则使用 MutationObserver，这是另一种微任务机制。
   3. 在 IE 环境下，使用 setImmediate，这是一种表现接近微任务的宏任务。
   4. 最后是 setTimeout(fn, 0) 作为兜底方案，这是一个宏任务，但会在下一个事件循环中尽快执行。

2. Vue3 则是只考虑现代浏览器环境，直接使用 Promise 来实现微任务的包装，这样做的好处在于代码更加简洁，性能更高，因为不需要处理多种环境的兼容性问题。

整体来讲，Vue3 的 nextTick 实现更加简洁和高效，是基于现代浏览器环境的优化版本，而 Vue2 则为了兼容性考虑，实现层面存在更多的兼容性代码。

72.  
Vue 实现双向数据绑定原理是什么？
Vue2.x 采用数据劫持结合发布订阅模式（PubSub 模式）的方式，通过 Object.defineProperty 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

Vue 的数据双向绑定整合了 Observer，Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化->视图更新，视图交互变化（例如 input 操作）->数据 model 变更的双向绑定效果。

Vue3.x 放弃了 Object.defineProperty ，使用 ES6 原生的 Proxy，来解决以前使用 Object.defineProperty 所存在的一些问题。


73.  
vue 的数据为什么频繁变化但只会更新一次？
这是因为 vue 的 DOM 更新是一个异步操作，在数据更新后会首先被 set 钩子监听到，但是不会马上执行 DOM 更新，而是在下一轮循环中执行更新。

具体实现是 vue 中实现了一个 queue 队列用于存放本次事件循环中的所有 watcher 更新，并且同一个 watcher 的更新只会被推入队列一次，并在本轮事件循环的微任务执行结束后执行此更新(UI Render 阶段)，这就是 DOM 只会更新一次的原因。

这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，vue 刷新队列并执行实际 (已去重的) 工作。vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。

74.  
为什么 Vue3 中去掉了 Vue 构造函数？
Vue2 的全局构造函数带来了诸多问题：
1. 调用构造函数的静态方法会对所有vue应用生效，不利于隔离不同应用
2. Vue2 的构造函数集成了太多功能，不利于 tree shaking，Vue3 把这些功能使用普通函数导出，能够充分利用 tree shaking 优化打包体积
3. Vue2 没有把组件实例和 Vue 应用两个概念区分开，在 Vue2 中，通过 new Vue 创建的对象，既是一个 Vue 应用，同时又是一个特殊的 Vue 组件。Vue3 中，把两个概念区别开来，通过 createApp 创建的对象，是一个 Vue 应用，它内部提供的方法是针对整个应用的，而不再是一个特殊的组件。

75. 
介绍一下 Vue3 内部的运行机制是怎样的？

Vue3 是一个声明式的框架。声明式的好处在于，它直接描述结果，用户不需要关注过程。Vue.js 采用模板的方式来描述 UI，但它同样支持使用虚拟 DOM 来描述 UI。虚拟 DOM 要比模板更加灵活，但模板要比虚拟 DOM 更加直观。

当用户使用模板来描述 UI 的时候，内部的 编译器 会将其编译为渲染函数，渲染函数执行后能够确定响应式数据和渲染函数之间的依赖关系，之后响应式数据一变化，渲染函数就会重新执行。

渲染函数执行的结果是得到虚拟 DOM，之后就需要 渲染器 来将虚拟 DOM 对象渲染为真实 DOM 元素。它的工作原理是，递归地遍历虚拟 DOM 对象，并调用原生 DOM API 来完成真实 DOM 的创建。渲染器的精髓在于后续的更新，它会通过 Diff 算法找出变更点，并且只会更新需要更新的内容。

编译器、渲染器、响应式系统都是 Vue 内部的核心模块，它们共同构成一个有机的整体，不同模块之间互相配合，进一步提升框架性能。


76.  
谈谈 computed 的机制，缓存了什么？为什么 computed 不支持异步？

缓存的是上一次 getter 计算出来的值。

为什么 computed 不支持异步？
computed 属性在 Vue 中不支持异步操作的主要原因是设计上的理念和使用场景的考虑。computed 属性的初衷是用于计算并缓存一个基于响应式依赖的同步计算结果，当其依赖的响应式数据发生变化时，Vue 会自动重新计算 computed 的值，并将其缓存，以提高性能。
computed 不支持异步的几个具体原因：
缓存机制与同步计算：computed 属性的一个核心特性是缓存。当依赖的响应式数据没有变化时，computed 的计算结果会被缓存并直接返回，而不会重新执行计算。这种缓存机制是基于同步计算的，假如允许异步计算，那么在异步操作完成之前，computed 属性无法提供有效的返回值，这与它的同步缓存理念相违背。
数据一致性：computed 属性通常用于模板中的绑定，它的计算结果需要在渲染期间是稳定且可用的。如果 computed 支持异步操作，渲染过程中的数据可能不一致，会导致模板渲染时无法确定使用什么数据，从而可能造成视图的闪烁或数据错误。
调试与依赖追踪困难：如果 computed 属性是异步的，那么在调试和依赖追踪时就会变得非常复杂。异步操作的完成时间不确定，会使得依赖追踪的过程变得不直观，也难以预期。
如果需要进行异步操作，通常推荐使用 watch 来实现。


77.   
watch 和 computed 的区别是什么？说一说各自的使用场景？

omputed
作用：用于创建计算属性，依赖于 Vue 的响应式系统来做数据追踪。当依赖的数据发生变化时，会自动重新计算。
无副作用：计算属性内部的计算应当是没有副作用的，也就是说仅仅基于数据做二次计算。
缓存：计算属性具备缓存机制，如果响应式数据没变，每次获取计算属性时，内部直接返回的是上一次计算值。
用处：通常用于模板当中，以便在模板中显示二次计算后的结构。
同步：计算属性的一个核心特性是缓存，而这种缓存机制是基于同步计算的，假如允许异步计算，那么在异步操作完成之前，计算属性无法提供有效的返回值，这与它的缓存设计理念相违背。

watch
作用：用于监听数据的变化，可以监听一个或者多个数据，当数据发生改变时，执行一些用户指定的操作。
副作用：监听器中的回调函数可以执行副作用操作，例如发送网络请求、手动操作 DOM 等。
无缓存：监听器中的回调函数执行结果不会被缓存，也没办法缓存，因为不知道用户究竟要执行什么操作，有可能是包含副作用的操作，有可能是不包含副作用的操作。
用处：常用于响应式数据发生变化后，重新发送网络请求，或者修改 DOM 元素等场景。
支持异步：在监听到响应式数据发生变化后，可以进行同步或者异步的操作。

78.  
讲一讲 Vue3 的 diff 算法做了哪些改变？
Vue2 采用的是双端 diff 算法，而 Vue3 采用的是快速 diff. 这两种 diff 算法前面的步骤都是相同的，先是新旧列表的头节点进行比较，当发现无法复用则进行新旧节点列表的尾节点比较。

一头一尾比较完后，如果旧节点列表有剩余，就将对应的旧 DOM 节点全部删除掉，如果新节点列表有剩余：将新节点列表中剩余的节点创建对应的 DOM，放置于新头节点对应的 DOM 节点后面。

之后两种 diff 算法呈现出不同的操作，双端会进行旧头新尾比较、无法复用则进行旧尾新头比较、再无法复用这是暴力比对，这样的处理会存在多余的移动操作，即便一些新节点的前后顺序和旧节点是一致的，但是还是会产生移动操作。

而 Vue3 快速 diff 则采用了另外一种做法，找到新节点在旧节点中对应的索引列表，然后求出最长递增子序列，凡是位于最长递增子序列里面的索引所对应的元素，是不需要移动位置的，这就做到了只移动需要移动的 DOM 节点，最小化了 DOM 的操作次数，没有任何无意义的移动。可以这么说，Vue3 的 diff 再一次将性能优化到了极致，整套操作下来，没有一次 DOM 操作是多余的，仅仅执行了最必要的 DOM 操作。


79.  
