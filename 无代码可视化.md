无代码可视化核心概念：
物料、编排、出码、渲染引擎等
1. 课程代码
https://github.com/encode-studio-fe/encode-byelide
补课代码（canvas table + vue 组件封装）
暂时无法在飞书文档外展示此内容
补充录播课（纯源码实现）源代码
暂时无法在飞书文档外展示此内容
优化 canvas table 实现源码，同学新提出的问题，换了方式实现
暂时无法在飞书文档外展示此内容
2. 背景介绍
近年来，低代码平台与可视化相关平台⽇益⽕热。 • 低代码允许开发⼈员低成本通过拖拉拽的⽅式快速构建企业内部系统或落地⻚，常 ⻅的低代码平台能⼒包括：审批流、应⽤构建等。其在企业开发提效与运营⽅⾯取得了 不错的成绩。例如国外的：Coda、Airtable、Notion 等产品，例如国内的：明道云、 极简云、ClickPaaS 等产品。构建低代码平台是⼀件有挑战性的事情，这节实战课会从 业务与技术架构⼊⼿，带你彻底弄懂低代码平台研发。   可视化平台允许数据分析⼈员通过拖拉拽的⽅式快速组建仪表盘或数据分析⼤盘， 其在企业运营⽅⾯发挥重要作⽤。例如国外的：PowerBI、Monday、Coda 等产品， 国内的：观远数据、BDP、FineBI 等产品。构建可视化 SaaS 是⼀件⾮常有趣的事情， 这节实战课会从业务与技术架构出发，带你从零完成可视化图表数据协议设计、图表渲 染器开发、图表编排等功能。

• 当低代码遇上可视化，相信会有更多⽕花，没错，我们课程将这两⼤⽕热业务⽅向 进⾏融合，带你真正体验⼤⼚企业级项⽬的设计、开发与流程管控。
• 开发过程中，我们会严格按照⼤⼚开发流程，从项⽬搭建、规范约定、技术选型与 评估、需求分析到开发，每个流程细节我们都不会放过。技术选型⽅⾯，我们会选⽤ Vue3 作为技术栈，状态管理选⽤ Pinia，编辑器开发我们会基于 tiptap 来展开，另外 我们会选⽤ Arco Design 作为 UI 库、Echarts 开发图表相关内容，除此之外，我们会 向⼤家展⽰如何更优雅
3. 学习成果
通过本节课程学习，你会掌握低代码与可视化平台的核⼼业务模型，学会⼤型项⽬的架构分析与技术⽅案选型思路，为⾃⼰的简历添上浓墨重彩的⼀笔。
技术及业务上：
- 制定 blocksuite 方案，实现物料编排与插件化底座设计
- 掌握基于 hook 实现可维护性更高的动态表单及表单设计工具的方案
- 了解支持千万级数据的数据表格渲染方案
学完后对工作/面试的帮助：
1. 面试上：无/低代码、复杂表单、可视化及编辑器相关业务是相对复杂的业务，不仅能帮你提升业务理解力，还能提升技术实力；
2. 后续工作上：大量设计方案及大型项目架构设计思想，有助于你在今后的工作中，多一份思考；
4. 产物
- 源码 github地址：encode-studio-fe/encode-byelide；
案例效果图
- 基础框架
![1280X1280](/Volumes/F/zyl-study/web-zhuawa/无代码可视化/1280X1280.PNG)
- 海量数据（1000W）表格渲染，及数据源
![e9686baf-65ed-4aef-ad0e-422d07dee40e](/Volumes/F/zyl-study/web-zhuawa/无代码可视化/e9686baf-65ed-4aef-ad0e-422d07dee40e.png)
- 流程引擎实现
![18a2ebde-4817-4838-a8c6-f1f153a82e94](/Volumes/F/zyl-study/web-zhuawa/无代码可视化/18a2ebde-4817-4838-a8c6-f1f153a82e94.png)
- 移动端应用构建，富文本插件化机制
![342846e1-5f45-4cbd-8a81-ff39beb53a81](/Volumes/F/zyl-study/web-zhuawa/无代码可视化/342846e1-5f45-4cbd-8a81-ff39beb53a81.png)
- 发布应用，PC & 移动端
![2df353c3-d67e-4907-991d-0fcccadb2fba](/Volumes/F/zyl-study/web-zhuawa/无代码可视化/2df353c3-d67e-4907-991d-0fcccadb2fba.png)
![f351e3f6-05df-4264-91cf-cd2b9d6a26ae](/Volumes/F/zyl-study/web-zhuawa/无代码可视化/f351e3f6-05df-4264-91cf-cd2b9d6a26ae.png)


5. 技术选型
- 包管理：pnpm
- 工程化相关
  - vite
  - lint-staged
  - cspell
  - commitizen
  - cz-git
  - husky
  - zx
  - tsno
- lint规范：
  - commitlint；
  - stylelint；
  - prettier；
  - eslint；
  - editorconfig;
- Vue CLI、Vue3
- Pinia
- Vue-Router
- 拖拽库：基于原生的 smooth-dnd 封装用于 Vue3 的拖拽组件
- 编辑器：tiptap for vue3，https://tiptap.dev/installation/vue3
- 表单校验：vee-validate，https://vee-validate.logaretm.com/v4/
- 流程编排：@vue-flow/core，https://vueflow.dev/
- 图表：echarts
6. 简历描述
6.1 应届
Byelide 低代码平台
6.1.1 技术栈要点
Vue3、Pinia、Vue-Router
6.1.2 项目简介
低代码+可视化搭建平台，涵盖数据源管理与加工、页面组装、流程引擎、低代码编辑器
6.1.3 工作内容与成果
☻ 参与页面组装模块设计，选用通用 blocksuite （block）方案，使页面元素及物料丰富高度可定制
☻ 动态表单开发，借助 Vee-validate（react-hook-form），基于 hook 实现可维护性更高的动态表单及表单设计工具
☻ 低代码物料出码功能，基于 vue-json-pretty 封装物料协议数据预览与编辑
☻ 流程引擎及服务编排等内容实现，基于鼠标 move 事件封装 vue draggable 组件实现组件拖拽与页面内容编排
☻ 数据源支持 1000 万行表格数据渲染与编辑，通过 canvas 技术实现

- 表单（username，password）
  - 校验
  - 密码加密
  - 验证码
- 登录注册真的这么简单吗？
  - authing、auth2
  - 用户中心（登录、鉴权）

6.2 1-3年
Byelide 低代码平台
6.2.1 技术栈要点
Vue3、Pinia、Vue-Router
6.2.2 项目简介
低代码+可视化搭建平台，涵盖数据源管理与加工、页面组装、流程引擎、低代码编辑器
6.2.3 工作内容与成果
☻ 参与页面组装模块设计，选用通用 blocksuite （block）方案，使页面元素及物料丰富高度可定制
☻ 动态表单开发，借助 Vee-validate，基于 hook 实现可维护性更高的动态表单及表单设计工具
☻ 低代码物料出码功能，基于 vue-json-pretty 封装物料协议数据预览与编辑
☻ 基于 monaco-editor 实现低代码编辑器复杂功能，包含自动补全、语法提示等 LSP 服务相关内容
☻ 主导封装 webpack plugin 及 loader 支持静态资源自动上传、源码脱敏防备、构建优化等 
☻ 流程引擎及服务编排等内容实现，基于鼠标 move 事件封装 vue draggable 组件实现组件拖拽与页面内容编排
☻ 数据源支持 1000 万行表格数据渲染与编辑，通过 canvas 技术实现

- 打包构建，影响产物
- 静态资源（font、image）
- 代码
- 稳健性（项目监控）
- 团队沉淀（npm 包的贡献）

6.3 3年+
Byelide 低代码平台
6.3.1 技术栈要点
Vue3、Pinia、Vue-Router
6.3.2 项目简介
AIGC + 低代码，涵盖数据源管理与加工、页面组装、流程引擎、低代码编辑器、AI 辅助数据建模、AI 托管式应用构建 等功能。
6.3.3 工作内容与成果
☻ 负责平台技术选型、基础架构及方案设计，包含:工程化相关方案设计与落地、各模块方案设计与核心实现
☻ 动态表单开发，借助 Vee-validate，基于 hook 实现可维护性更高的动态表单及表单设计工具
☻ 低代码物料出码功能，基于 vue-json-pretty 封装物料协议数据预览与编辑
 ☻ 主导页面组装模块设计，选用通用 blocksuite 方案，使页面元素丰富且高度可定制
☻ AI 数据建模及应用创建模块选用 nodejs 服务，借助 langChainjs 构建端到端语言模型服务
☻ 基于 monaco-editor 实现低代码编辑器复杂功能，包含自动补全、语法提示等 LSP 服务相关内容
☻ 主导封装 webpack plugin 及 loader 支持静态资源自动上传、源码脱敏防备、构建优化等 
☻ 流程引擎及服务编排等内容实现，基于鼠标 move 事件封装 vue draggable 组件实现组件拖拽与页面内容编排
☻ 数据源支持 1000 万行表格数据渲染与编辑，通过 canvas 技术实现
7.  课程安排
7.1 第一部分 
对应代码地址：链接
1. 项目需求分析评审（入料、编排、渲染、出码）
2. Vue 项目基础架构设计，基于 Vite、Vue3、Pinia、Vue-Router
3. 构建基础框架（导航、物料、配置）
4. 编排的选型与实现（流式、画布式、Grid）
7.2 第二部分
对应代码地址：链接
1. 插件化机制实现物料灵活组装
2. 配置面板开发
3. 表单生成器 Form Builder 动态生成表单实现校验与提交
7.3 第三部分
对应代码地址：链接
1. 可视化物料
2. 图表渲染器引擎开发
3. 定制化图表开发（基于 d3/zrender）
7.4 第四部分
对应代码地址：链接
1. 出码功能
2. 预览器开发
3. 性能调优
4. 应用部署与发布

8. 面试问题
8.1 快手当时问我，低代码平台有时候存在一些破坏性的功能和一些阻断性的功能更新，这种怎么办呢？
  - 独立分支，版本系统，但是需要考虑物料和数据的版本统一问题
  - 兼容处理，数据升级或者前端兼容
8.2 脚手架在打包方面，对于公共的依赖，公共的组件怎么处理的？ 
  1. 公共资源上传 CDN
  2. externals
8.3 在低代码平台项目中，既然物料是通过拉取后端接口得到的，那么所有的物料都打包到一个js文件里，这样的话，如果画布中明明只用到了2个组件，却加载了所有的物料，这种性能问题怎么解决？
  1. Split chunk 处理
  2. 异步组件 defineAsyncComponent
8.4 低代码平台项目遇到了哪些性能问题？如何解决的？
  1. 问题
        1. 包体积大
            2. 加载渲染速度慢
                3. 资源处理问题
  2. 方案
        1. 按需加载，适度拆包
            2. 优化代码，分析 rerender 等问题，找到影响性能的点并解决
                3. 资源压缩 gzip
                  8.5 低代码项目一般会遇到哪些兼容性问题，然后是如何解决的吗
  1. 浏览器兼容问题，如果是 js 层面我们通过 babel、core-js 实现，如果是 vite，我们可以使用 vite-plugin-legacy 解决
  2. 浏览器特性兼容问题，我们需要对应 polyfill 解决
8.6 快手面试官问我如何去更新低代码的数据域，假如点击一个按钮，发请求，然后会修改表单的值，这个怎么做？这个功能在合一老师的低代码项目中是缺失的，可以帮我问下实现思路吗？
  1. pubSub
  2. 设计物料的事件与生命周期
  3. 全局事件系统注册物料事件，通过物料在页面中的 id 作为订阅 key
  4. 分发事件与事件触发
8.7 我这边低代码平台有一个按钮，打开一个子编辑器，实现方式是这个子编辑器和原来的那个是一样的，也就是也包含头部插件，左侧物料库，和中间画布，右侧属性配置，现在有个问题是，打开多个子编辑器的话，导致页面非常卡顿，这个有什么解决办法吗？
  1. 减少渲染
8.8 具体blocksuit是什么样的⽅案
Blocksuite⽅式定义了物料与物料编排的基本协议。 最初提出该协议的是notion，notion中所有内容均由block（块）承载，将所有物料block化，设计 通⽤数据协议。 Blocksuite定义物料数据协议，描述block的基础数据、配置数据、动作配置等内容。

8.9 langChainjs是怎样构建端到端的服务的
langChainjs⽤于开发语⾔模型驱动应⽤程序的框架，平台内部分GPT相关内容实现借助langChain 实现，⽬前市⾯上也有不错的集成⽅案，例如nextjs+langChain

8.10 基于monaco-editor实现低代码编辑器复杂功能具体讲讲?
该功能⽤于实现公式编辑器及⾃定义DSL编辑器编辑场景，monaco-editor作为主流强⼤的编辑器库，vscode底层也是使⽤的它。 
最初我们尝试结合Anltr+monaco-editor实现DSL语法⾼亮与⾃动补全，代码⾃动推荐等 ⾃定义语⾔服务，拓展⾃动补全与推荐的能⼒

8.11 封装 webpackplugin 和 loader 怎样封装的 我们知道plugin是基于 class，loader 是基于函数，在整个过程可以拿到 compiler 与 compilation 对象，通过 tappable 提供的系列钩⼦，可以在不同阶段处理⾃定义处理。

class UploadToCDN {
    constructor(options) {
        this.options = options
    }
    apply(compiler) {
        // 因为会有异步操作，所以这⾥⽤tapAsync ， 当逻辑执⾏完成时调⽤
        compiler.hooks.emit.tapAsync(PLUGIN_NAME, (compilation, callback) => {
            // 在资源输出到dist 之前进⾏压缩
        })
        compiler.hooks.afterEmit.tapAsync(PLUGIN_NAME, (compilation, callback) => {
            // 在资源输出后，把 dist 上传到 oss
        })
    }
}

8.12 具体说说流程引擎和服务编排
流程引擎主要包括：⾃动化、审批流、动作等场景。市⾯上有很多通⽤协议，例如：osworkflow、 jbpm、activiti、flowable；但这些在实现如下场景还是⽐较⿇烦：抄送、会签、加签、传阅、跳转、 任意流。
从零实现状态机、⽇志等功能，实现节点拖拉拽与连线

8.13 通过拖拉拽的⽅式拖动之后那些组件（⽐如⽂本框那些）是怎样呈现在 ⻚⾯上的，这⾥具体怎样实现的?
策略模式实现组件渲染，每个组件对应渲染器，在渲染组件时，对应组件渲染器启动绘制渲染。 渲染过程中，如果对应物料组件还存在事件配置，则需要将事件注册进事件系统，以在合适时间调⽤ 执⾏

8.14 ⼏万条数据渲染到⻚⾯怎么处理
  1. 分⻚显⽰
  2. 虚拟滚动
  3. Canvas⽅案，究极⽅案
8.15 发布之后的操作
  1. 不涉及到私有化部署，公有云部署（按量付费）
  2. 主机 ECS、域名、证书
        1. 域名备案跟随公司主体，证书 caddy

---
2024.05.29 补充
8.16 常见问题及解决方案
问题：组件间通信复杂
  - 解决方案：通过事件总线或状态管理工具（如Vuex、Redux）来简化组件间通信，确保数据流的单向性和清晰性。
  - 亮点：提高代码的可维护性和可扩展性。
问题：接口约束和规范化难题
  - 解决方案：定义统一的接口规范和数据格式，使用TypeScript进行类型检查，确保各个组件的接口一致性。
  - 亮点：通过严格的接口约束和类型检查，可以避免运行时错误，提高代码质量。

问题：全局变量和参数传递复杂
  - 解决方案：使用全局状态管理工具（如Vuex、Redux）管理全局变量和传参，确保数据的一致性和可追溯性。
  - 亮点：有效管理复杂的全局状态和参数传递，提高系统的稳定性。

问题：防止注入恶意代码
  - 解决方案：使用iframe隔离和安全沙箱技术来防止恶意代码注入。对用户输入进行严格的校验和过滤，防止XSS攻击。
  - 亮点：提高系统的安全性，保护用户数据和系统稳定性。

问题：设计器和页面渲染的耦合
  - 解决方案：使用JSON描述UI组件，通过解析JSON动态渲染页面。设计区配置的全局样式可以通过CSS Modules或Scoped CSS来防止样式污染。
  - 亮点：设计器与实际渲染解耦，提高了系统的灵活性和可扩展性。

8.17 低代码是for B端还是C端
  - B端（Business）指企业用户，C端（Consumer）指个人用户。低代码平台通常用于企业级应用开发，因此一般针对B端。其主要应用场景包括企业内部系统、管理系统、业务流程自动化等。

8.18 设计的页面是通过链接访问还是下载
  - 低代码平台生成的页面一般通过链接访问。这种方式便于更新和维护，同时也能保证数据安全和实时性。

8.19 低代码不同组件的接口约束和代码规范
  - 定义统一的接口规范和数据格式，使用TypeScript进行类型检查。
  - 制定代码规范文档，采用代码审查机制，确保团队遵循统一的开发标准。

8.20 低代码实现页面传参、组件传参
  - 页面传参可以通过URL参数或全局状态管理工具（如Vuex、Redux）进行传递。
  - 组件传参可以通过props和emit事件进行父子组件间的数据传递。

8.21 低代码全局变量功能
  - 使用全局状态管理工具（如Vuex、Redux）管理全局变量，不可变变量可以使用常量（const）进行定义，存放在单独的配置文件中。

8.22 防止注入恶意代码
  - 使用iframe进行隔离，确保用户输入的数据在安全沙箱中执行。
  - 对用户输入进行严格的校验和过滤，防止XSS和其他注入攻击。

8.23 拖拽方案实现
  - 使用第三方拖拽组件（如vue-draggable），结合Vue的响应式数据绑定，实现拖拽组件在画布上的动态渲染。
  - 画布通过JSON数据描述当前的UI状态，各个组件根据JSON数据进行渲染。

8.24 全局样式防止影响设计器
  - 使用Scoped CSS或CSS Modules来确保样式只作用于特定组件，避免污染其他部分的样式。
  - 可以使用iframe将设计器和实际页面隔离，确保样式互不干扰。

8.25 吸附功能和网格线功能
  - 吸附功能可以通过计算组件位置和网格线位置，自动调整组件的位置来实现。
  - 网格线可以通过CSS背景或绘制Canvas来实现，结合吸附功能提供更好的用户体验。

8.26 组件之间的通信
  - 使用事件总线（event bus）来实现，即在组件内部定义emit和on的事件配置，通过事件驱动实现组件间通信。

8.27 组件实现思路

1. Tab 标签页组件

实现 Tab 标签页组件时，主要需要考虑以下几点：

- 结构：
  - 父组件 <Tabs> 负责管理所有的标签页和内容区。
  - 子组件 <Tab> 表示单个标签页，包含标题和对应的内容。

- 状态管理：
  - 使用状态（如Vue中的 data 或 React中的 state）来管理当前激活的标签索引。
  - 当用户点击某个标签时，更新该状态以显示对应的内容。

- 样式：
  - 使用 CSS 来定义标签页的选中和未选中状态的样式。
  - 可以使用 CSS Modules 或 Scoped CSS 来确保样式的局部性。

- 事件处理：
  - 绑定点击事件，切换当前激活的标签页。
  - 可以通过 emit 事件通知父组件，以便在外部处理逻辑。

示例代码（Vue）：

<template>
  <div class="tabs">
    <div class="tab-titles">
      <div
        v-for="(tab, index) in tabs"
        :key="index"
        :class="{'active': activeTab === index}"
        @click="selectTab(index)"
      >
        {{ tab.title }}
      </div>
    </div>
    <div class="tab-content">
      <slot :name="`tab-${activeTab}`"></slot>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      activeTab: 0,
      tabs: [
        { title: 'Tab 1' },
        { title: 'Tab 2' },
        { title: 'Tab 3' },
      ],
    };
  },
  methods: {
    selectTab(index) {
      this.activeTab = index;
      this.$emit('tab-changed', index);
    },
  },
};
</script>

<style scoped>
.tabs {
  /* 样式代码 */
}
.tab-titles .active {
  /* 选中状态样式 */
}
</style>

2. Popover 弹出框组件

实现 Popover 组件时，需要考虑定位和显示隐藏逻辑：

- 结构：
  - 父组件 <Popover> 包含触发器和弹出内容。

- 定位：
  - 使用相对定位或绝对定位来定位弹出框的位置。
  - 根据触发器的位置动态计算弹出框的位置。

- 显示隐藏：
  - 使用状态管理弹出框的显示和隐藏。
  - 可以通过点击触发器、点击外部区域来控制弹出框的显示隐藏。

示例代码（Vue）：

<template>
  <div class="popover" @click="togglePopover">
    <slot name="trigger"></slot>
    <div v-if="show" class="popover-content">
      <slot name="content"></slot>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      show: false,
    };
  },
  methods: {
    togglePopover() {
      this.show = !this.show;
    },
    closePopover() {
      this.show = false;
    },
  },
};
</script>

<style scoped>
.popover {
  /* 样式代码 */
}
.popover-content {
  /* 弹出框样式 */
}
</style>

8.28 发布到npm

如果你提到你将组件库发布到了npm，你可以补充以下内容：

1. 发布流程：
  - 使用工具（如 npm 或 yarn）进行打包和发布。
  - 确保所有依赖项和配置文件（如 package.json）正确配置。

   示例命令：
npm publish

2. 版本管理：
  - 遵循语义化版本控制（SemVer），分别管理主版本号、次版本号和修订号。
  - 通过Git标签和分支策略管理不同版本的代码。

   示例：
git tag v1.0.0
git push origin v1.0.0

3. 线上问题处理：
  - 监控：使用监控工具（如Sentry、New Relic）实时监控线上问题。
  - 回滚：在发布出现重大问题时，能够快速回滚到稳定版本。
  - 修复：在本地复现并修复问题，确保问题解决后再发布修复版本。

   示例：
npm version patch
npm publish
9. 补充问题
2023.12.02 补充问题
1. 字段联动如何解决，自定义组件如何实现，组件如何请求接口，嵌套组件如何实现
  [图片]
    感觉没啥必要这样写 直接框框两个div完事，主要是不了解为什么要这么做，目前感觉低代码只是一个架子，真要去公司 不可能直接上个架子就用。

  字段联动属于表单操作，我们需要维护表单项状态，控制表单项状态之间的关系来解决表单联动问题；
  自定义组件就像图中：SmoothDndContainer 等的方式封装，先解决一层组件的问题嵌套组件只是组件嵌套写法；
  组件请求接口我们通常会封装一层 services 层用于接口请求，接口数据存放在状态中，在组件中一般只从状态中获取数据，但是也有特例，就是一些类似于省市区数据我们可以在 Select 组件中处理，这是一个不错的解决方案：https://tanstack.com/query/latest/docs/vue/quick-start
  封装的目的是为了复用，老的写法因为封装思路是 Vue2 的思路所以我们废弃了这种写法，进而使用 Vue3 写法进行封装，之所以没有提及详细迁移思路是因为老的写法可以不用深入了解，看最新写法即可
2. 封装的目的是为了复用，老的写法因为封装思路是 Vue2 的思路所以我们废弃了这种写法，进而使用 Vue3 写法进行封装，之所以没有提及详细迁移思路是因为老的写法可以不用深入了解，看最新写法即可
希望录播小课
3. 项目拉下来会报错，是因为依赖或者相关库更新导致项目启动出现问题，也正是带着大家从零排查并解决工程化方面的问题，因为项目依赖和工程化相关的内容非常容易出错
4. 关于 canvas table 这个问题，如果大家目前工作中表格没有达到万级以上，都可以暂时了解一下这个技术，本身 canvas 的开发可能很多同学没有接触，所以 canvas table 整体的开发模式我提供一下资料和课堂上的示例供大家参考学习；如果完全基于 canvas 自研，可选用：https://konvajs.org/，开源社区比较优秀的示例：维格表（https://github.com/apitable/apitable/blob/8202f230578e621b274964e301f4a568319f4368/packages/datasheet/src/pc/components/konva_components/components/transformer.tsx），国外估计超20亿美金的公司 glide（https://github.com/glideapps/glide-data-grid）

---
2024.01.03 补充问题
1、关于低代码平台这个项目，如何结合之前的公司业务去跟面试官说开发这个项目的项目背景
- 上家公司项目概况：上家公司做的项目基本上都是为公司某个部门业务产品线服务的：例如：团险部门是团体意外险，证券部门是股市赢家的产品，希望老师能提供一下思路
- 答：仔细看一下我们课程第一节和实战资料，有详细介绍需求背景和价值

2、该如何向面试官详细介绍低代码平台这个项目
- 自己也看了项目，感觉自己语言组织能力有点差，不知道该从哪里说起，希望老师能写个模板参考一下，让自己思维也发散发散
- 答：就是描述用这个搭建了什么，比如动态表单 Form Builder，可视化图表搭建 bdp，可以直接搜索

3、数据源支持1000万行表格数据渲染与编辑，通过canvas技术实现
- 这个技术和优化知识点都能掌握，但是该怎么去结合实际需求来说呢？这项技术具体的落地需求场景有哪些情况呢？ 
- 答：一般同学用不上，我是因为之前大量云表格开发经验，所以给同学们提供了这个学习方向，除非你去云表格的公司，比如飞书云表格、维格表等

4、主导封装webpack plugin及loader 支持静态资源自动上传、源码脱敏防备，构建优化等
- 问题：这个源码脱敏防备是啥意思?，个人的理解是指的对客户隐私数据加密(例如：手机号，身份证号这种数据),如果是的，那实现的思路是咋样的，我想的是通过babel去游历，但是不太清楚该怎么样定位到这些隐私数据的节点上去替换
- 答：代码丑化压缩，source map上传到指定位置用来服务于异常监控

5、关于跨端应用的开发例如(taro、uni-app)
- 最后针对不同端打包发布的时候，该怎么去做不同端的打包兼容处理，有没有比较好的文章或者项目可以学习借鉴的，自己在网上找了很久，没找到合适的学习资料
- 答：跨端重点在端差异抹平代码上，跟构建关系不太大
2024.04.03 补充问题
为什么同时用 provide 和 globalProperties？
咱们低代码项目里面，通过插件化添加物料的时候，这里为什么要同时用provide和globalProperties注册呢？只用其中一种是不是也可以？
[图片]
答：两种是为了在值获取时不同，组件内可以轻松 inject，在不能使用的场景里，可以使用 globalProperties，请参照 Pinia 等源码
2024.04.07 补充问题
自适应宽高
[图片]
面试问：如何低代码展示时候不同分辨率的适配问题？
我回答的是用transform:scale，可以根据情况横向拉伸和纵向拉伸，但是面试官一直不满意，说有留白怎么办，拉伸之后和原设计有区别怎么办，这种问题有什么好的解决方案吗？
2024.04.14 补充问题
低代码项目中的，封装webpack plugin及loader 支持静态资源自动上传、源码脱敏防备的思路可以再详细解释一下吗
答：
1.封装 plugin 实现静态资源自动上传 oss
2. 代码 terser unlify 实现丑化压缩

10. 补充内容
1. 需求背景、方案设计
2. Canvas Table
3. Vue 组件封装的思想
4. 简历方面准备

5. 源码的学习方法
  1. 分支、commit
  2. 如果你想看完整效果的话，一定一定一定要看 main 分支
  3. 如果你是跟着课程学习，建议你切到对应分支，因为跟着课程的分支（有一些问题，是留给大家探讨解决）
  4. 为什么没有完全敲代码

