

# javascript高级用法(1/2)

https://vgbixa7nr9.feishu.cn/drive/folder/fldcnuszmspfoSJwl5QFtPrsCGg

https://www.yuque.com/lpldplws/atomml/tmbe7ykqmslqszhe?singleDoc# 《JavaScript高级用法(1/2)》 密码：bwxh

## 1.原型&原型链

### 1.1 构造函数创建对象

我们先使用构造函数创建一个对象：

```js
function Person() {

}
var person = new Person();
person.name = 'xianzao';
console.log(person.name) // xianzao
```

在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。

### 1.2 prototype

每个函数都有一个 `prototype` 属性，比如：

```js
function Person() {

}
// 虽然写在注释里，但是你要注意：
// prototype是函数才会有的属性
Person.prototype.name = 'xianzao';

var person1 = new Person();
var person2 = new Person();

console.log(person1.name) // xianzao
console.log(person2.name) // xianzao
```

那这个函数的 `prototype` 属性到底指向的是什么呢？是这个函数的原型吗？

其实，函数的 `prototype` 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 `person1` 和 `person2` 的原型。

那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。

用一张图表示构造函数和实例原型之间的关系：

![构造函数和实例关系](/Volumes/F/zyl-study/web-zhuawa/20221203/构造函数和实例关系.png)

这里用 Object.prototype 表示实例原型。

那么该怎么表示实例与实例原型，也就是 `person` 和 Person.`prototype` 之间的关系呢？

### 1.3  __proto__

原型：每一个js对象(null除外)在创建的时候会关联另一个对象，这个对象就是原型，都会从原型上继承属性

这是每一个JavaScript对象(除了 null )都具有的一个属性，叫`__proto__`，这个属性会指向该对象的原型。

函数 prototype指向的是一个对象，这个对象是调用该构造函数创建的实例的原型

```js
function Person() {

}
var person = new Person();

console.log(person.__proto__ === Person.prototype); // true
```

![_proto_原型指向图](/Volumes/F/zyl-study/web-zhuawa/20221203/_proto_原型指向图.png)

既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？

### 1.4 contructor   

指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数是有的：`constructor`，每个原型都有一个 `constructor` 属性指向关联的构造函数

```js
function Person() {

}
console.log(Person === Person.prototype.constructor); // true
```

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/constructor原型指向图.png" alt="constructor原型指向图" style="zoom:67%;" />

所以，这里可以得到

```js
function Person() {

}

var person = new Person();

console.log(person.__proto__ == Person.prototype) // true

console.log(Person.prototype.constructor == Person) // true

console.log(Object.getPrototypeOf(person) === Person.prototype) // true
```

### 1.5 实例与原型

当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。

举个例子：

```js
function Person() {

}

Person.prototype.name = 'xianzao';

var person = new Person();

person.name = 'zaoxian';
console.log(person.name) // zaoxian

delete person.name;
console.log(person.name) // xianzao
```

在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 `person.name` 的时候，结果自然为 zaoxian。

但是当我们删除了 person 的 name 属性时，读取 `person.name`，从 person 对象中找不到 name 属性就会从 person 的原型也就是 `person.__proto__` ，也就是 `Person.prototype`中查找，结果为 `xianzao`。

### 1.6原型的原型

如果在原型上还没有找到呢？原型的原型又是什么呢？

```js
var obj = new Object();
obj.name = 'xianzao'
console.log(obj.name) // xianzao
```

其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 `__proto__` 指向构造函数的 `prototype` ，所以我们再更新下关系图：

<img src="https://camo.githubusercontent.com/9a69b0f03116884e80cf566f8542cf014a4dd043fce6ce030d615040461f4e5a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67" alt="img" style="zoom:50%;" />

其中，蓝色为原型链

### 1.8其他

#### 1.8.1 constructor

首先是contructor属性

```js
function Person() {

}
var person = new Person();

console.log(person.constructor === Person); // true
```

当获取 `person.constructor` 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 `Person.prototype` 中读取，正好原型中有该属性，所以：

```js
person.constructor === Person.prototype.constructor
```

#### 1.8.2 __proto__

绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 `Person.prototype` 中，实际上，它是来自于 `Object.prototype` ，与其说是一个属性，不如说是一个 `getter/setter`，当使用 `obj.__proto__` 时，可以理解成返回了 `Object.getPrototypeOf(obj)`。

#### 1.8.3 继承

关于继承，前面提到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：

继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。

## 2. 词法作用域和动态作用域

### 2.1 作用域

作用域是指程序源代码中定义变量的区域。

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

JavaScript 采用词法作用域`(lexical scoping`)，也就是静态作用域。

### 2.2 静态作用域和动态作用域

因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。

而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

// 结果是 ???
```

假设JavaScript采用静态作用域，让我们分析下执行过程：

执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。

假设JavaScript采用动态作用域，让我们分析下执行过程：

执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。

前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。

### 2.3 动态作用域

什么语言是动态作用域？

bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。

```js
value=1
function foo () {
    echo $value;
}
function bar () {
    local value=2;
    foo;
}
bar
```

### 2.4 思考

看一下面试题：

```js
// case 1
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();

// case 2
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

两段代码各自的执行结果是多少？

local scope

因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。

而引用《JavaScript权威指南》的回答就是：

JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。

但是在这里真正想让大家思考的是：

虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？

## 3.执行上下文

### 3.1 顺序执行

写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行：

```js
var foo = function () {

    console.log('foo1');

}

foo();  // foo1

var foo = function () {

    console.log('foo2');

}

foo(); // foo2
```

那这段呢？

```js
function foo() {

    console.log('foo1');

}

foo();  // foo2

function foo() {

    console.log('foo2');

}

foo(); // foo2，这里function foo(){
   // console.log('foo2')
//}会将//function foo(){
   // console.log('foo1')
//}覆盖掉

```

打印的结果却是两个 foo2。

这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，那这个“一段一段”中的“段”究竟是怎么划分的呢？

到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？

```js
console.log(add2(1,1)); //输出2
function add2(a,b){
    return a+b;
}
console.log(add1(1,1));  //报错：add1 is not a function
var add1 = function(a,b){
    return a+b;
}

// 用函数语句创建的函数add2，函数名称和函数体均被提前，在声明它之前就使用它。
// 但是使用var表达式定义函数add1，只有变量声明提前了，变量初始化代码仍然在原来的位置，没法提前执行。
```

### 2.2  可执行代码

这就要说到 JavaScript 的可执行代码(`executable code`)的类型有哪些了？

其实很简单，就三种，全局代码、函数代码、eval代码。

举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做"执行上下文(`execution context`)"。

### 2.3 执行上下文栈

JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文

为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：

```js
ECStack = [];
```

试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 `globalContext` 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 `globalContext`：

```js
ECStack = [
    globalContext
];
```

 当JavaScript 遇到下面的这段代码了：

```js
function fun3() {
    console.log('fun3')
}

function fun2() {
    fun3();
}

function fun1() {
    fun2();
}

fun1();
```

当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：

```js
// 伪代码

// fun1()
ECStack.push(<fun1> functionContext);

// fun1中竟然调用了fun2，还要创建fun2的执行上下文
ECStack.push(<fun2> functionContext);

// 擦，fun2还调用了fun3！
ECStack.push(<fun3> functionContext);

// fun3执行完毕
ECStack.pop();

// fun2执行完毕
ECStack.pop();

// fun1执行完毕
ECStack.pop();

// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
```

### 2.4 回顾上文

```js
// case 1
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();

// case 2
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？

答案就是执行上下文栈的变化不一样。

模拟第一段代码：

```js
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```

模拟第二段

```js
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```

这就是上文说到的区别。

## 4. 变量对象

### 4.1 基础

当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

对于每个执行上下文，都有三个重要属性：

- 变量对象(`Variable object`，VO)；
- 作用域链(`Scope chain`)；
- this；

这里着重讲变量对象的内容

### 4.2 变量对象

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。

### 4.3 全局上下文

1. 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。
2. 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。
3. 例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。

简单点说：

1. 可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。

```js
console.log(this);
```

2. 全局对象是由 Object 构造函数实例化的一个对象。

```js
console.log(this instanceof Object);
```

3. 预定义的属性是否可用

```js
console.log(Math.random());
console.log(this.Math.random());
```

4. 作为全局变量的宿主

```js
var a = 1;
console.log(this.a);
```

5. 客户端 JavaScript 中，全局对象有 window 属性指向自身

```js
var a = 1;
console.log(window.a);

this.window.b = 2;
console.log(this.b);
```

综上，对JS而言，全局上下文中的变量对象就是全局对象。

### 4.4 函数上下文

在函数上下文中，我们用活动对象(`activation object`, AO)来表示变量对象。

活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。

活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。

### 4.5 执行过程

执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：

1. 进入执行上下文；
2. 代码执行；

#### 4.5.1 进入执行上下文

当进入执行上下文时，这时候还没有执行代码，
变量对象会包括：

1. 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建；
   - 没有实参，属性值设为 undefined；

2. 函数声明
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性；

3. 变量声明
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性；

举个例子：

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

在进入执行上下文后，这时候的 AO 是：

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```

#### 4.5.2 代码执行

在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值

还是上面的例子，当代码执行完后，这时候的 AO 是：

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```

到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：

1. 全局上下文的变量对象初始化是全局对象；
2. 函数上下文的变量对象初始化只包括 Arguments 对象；
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值；
4. 在代码执行阶段，会再次修改变量对象的属性值；

#### 4.5.3 思考题

```js
function foo() {
    console.log(a);
    a = 1;
}

foo(); // ???

function bar() {
    a = 1;
    console.log(a);
}
bar(); // ???
```

第一段会报错：`Uncaught ReferenceError: a is not defined`。

第二段会打印：1。

这是因为函数中的 "a" 并没有通过 var 关键字声明，所有不会被存放在 AO 中。

第一段执行 console 的时候， AO 的值是：

```js
AO = {
    arguments: {
        length: 0
    }
}
```

没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。

当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。

```js
console.log(foo);

function foo(){
    console.log("foo");
}

var foo = 1;
```

会打印函数，而不是 undefined 。

这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。

## 5. 作用域链

上文讲到，当JavaScript代码执行一段可执行代码(`executable code`)时，会创建对应的执行上下文(`execution context`)。

对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this

本节讲作用域链。

### 5.1 作用域链

当查找变量的时候，会先从当前上下⽂的变量对象中查找，如果没有找到，就会从⽗级(词法层⾯上的⽗级)执⾏上下⽂的变量对象中查找，⼀直找到全局上下⽂的变量对象，也就是全局对象。这样由多个执⾏上下⽂的变量对象构成的链表就叫做作⽤域链。

### 5.2 函数创建

上文的词法作用域与动态作用域中讲到，函数的作用域在函数定义的时候就决定了。

这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！

举个例子：

```js
function foo() {
    function bar() {
        ...
    }
}
```

函数创建时，各自的[[scope]]为：

```js
foo.[[scope]]=[
    globalContext.AO
]

bar.[[scope]]=[
    fooContext.AO
    globalContext.VO
]
```

### 5.3 函数激活

当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。
这时候执行上下文的作用域链，我们命名为 Scope：

```js
Scope = [AO].concat([[Scope]]);
```

至此，作用域链创建完毕。

### 5.4 总结

结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：

```js
var scope = "global scope";
function checkscope(){
    var scope2 = 'local scope';
    return scope2;
}
checkscope();
```

执行过程如下：

1. checkscope 函数被创建，保存作用域链到 内部属性[[scope]]

```js
checkscope.[[scope]] = [
    globalContext.VO
];
```

2. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈

```js
ECStack = [
    checkscopeContext,
    globalContext
];
```

3. checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链

```js
checkscopeContext = {
    Scope: checkscope.[[scope]],
}
```

4. 第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }，
    Scope: checkscope.[[scope]],
}
```

5. 第三步： 将活动对象压入 checkscope 作用域链顶端

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
```

6. 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
```

7. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出

```js
ECStack = [
  globalContext
];
```

## 6. this

对于每个执行上下文，都有三个重要属性

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this

本节主要讲this

1.在浏览器下，全局this是window

2.函数this,例如show();//window如果是use strict,则为undefined

3.对象this：

- 作为普通函数调用，指向全局对象
- 作为构造函数调用时，this指向new出来的对象
- 作为对象方法调用时，this指向上级对象
- apply,call,bind调用this指向其绑定的对象

箭头函数this的指向是定义该函数时所在作用域指向的对象

### 6.1 Types

Types are further subclassified into ECMAScript language types and specification types.

An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.

A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record.

我们简单的翻译一下：

ECMAScript 的类型分为语言类型和规范类型。

ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。

而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。

我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。

这里要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。

### 6.2 Reference

那什么又是 Reference ？

The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators.

所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。

这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。

再看接下来的这段具体介绍 Reference 的内容

A Reference is a resolved name binding.
A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.
The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).
A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.

这段讲述了 Reference 的构成，由三个组成部分，分别是：

- base value；

- referenced name；

- strict reference；

可是这些到底是什么呢？

我们简单的理解的话：

base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。

referenced name 就是属性的名称。

举个例子：

```js
var foo = 1;

// 对应的Reference是：
var fooReference = {
    base: EnvironmentRecord,
    name: 'foo',
    strict: false
};
```

```js
var foo = {
    bar: function () {
        return this;
    }
};
 
foo.bar(); // foo

// bar对应的Reference是：
var BarReference = {
    base: foo,
    propertyName: 'bar',
    strict: false
};
```

而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。

#### 6.2.1 GetBase

GetBase(V). Returns the base value component of the reference V.

返回 reference 的 base value。

```js
var foo = 1;

var fooReference = {
    base: EnvironmentRecord,
    name: 'foo',
    strict: false
};

GetValue(fooReference) // 1;
```

GetValue 返回对象属性真正的值，但是，调用 GetValue，返回的将是具体的值，而不再是一个 Reference

#### 6.2.2 IsPropertyReference

IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.

如果 base value 是一个对象，就返回true。

### 6.3 如何确定this的值

关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？

- Let ref be the result of evaluating MemberExpression；
- if Type(ref) is Reference, then

- - If IsPropertyReference(ref) is true, then 
  - Let thisValue be GetBase(ref). 

- Else, the base of ref is an Environment Record 

- - Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). 

- Else, Type(ref) is not Reference.
- Let thisValue be undefined. 

让我们描述一下：

1. 计算 MemberExpression 的结果赋值给 ref；
2. 判断 ref 是不是一个 Reference 类型；

1. 1. 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 
   2. 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) 
   3. 如果 ref 不是 Reference，那么 this 的值为 undefined；

### 6.4 具体分析

 

#### 6.4.1 计算 MemberExpression 的结果赋值给 ref 

什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions：

MemberExpression :

- PrimaryExpression // 原始表达式

- FunctionExpression // 函数定义表达式

- MemberExpression [ Expression ] // 属性访问表达式

- MemberExpression . IdentifierName // 属性访问表达式

- new MemberExpression Arguments // 对象创建表达式

举个例子：

```js
function foo() {
    console.log(this)
}

foo(); // MemberExpression 是 foo

function foo() {
    return function() {
        console.log(this)
    }
}

foo()(); // MemberExpression 是 foo()

var foo = {
    bar: function () {
        return this;
    }
}

foo.bar(); // MemberExpression 是 foo.bar
```

所以简单理解 `MemberExpression` 其实就是()左边的部分。

#### 6.4.2 判断 ref 是不是一个 Reference 类型

关键就在于看规范是如何处理各种 `MemberExpression`，返回的结果是不是一个`Reference`类型。

```js
var value = 1;

var foo = {
  value: 2,
  bar: function () {
    return this.value;
  }
}

//示例1
console.log(foo.bar());
//示例2
console.log((foo.bar)());
//示例3
console.log((foo.bar = foo.bar)());
//示例4
console.log((false || foo.bar)());
//示例5
console.log((foo.bar, foo.bar)());
```

#### 6.4.3 foo.bar()

上面的demo种，`MemberExpression` 计算的结果是 `foo.bar`，那么 `foo.bar` 是不是一个 Reference 呢？

根据规范，这里展示了一个计算的过程，什么都不管了，就看最后一步：

Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict.

我们得知该表达式返回了一个 Reference 类型

根据之前的内容，我们知道该值为：

```js
var Reference = {   base: foo,   name: 'bar',   strict: false };
```

接下来按照流程：

1. 如果 ref 是 Reference，并且 `IsPropertyReference(ref)` 是 true, 那么 this 的值为` GetBase(ref)`

该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？

前面我们说了IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。

base value 为 foo，是一个对象，所以 `IsPropertyReference(ref)` 结果为 true。

这个时候我们就可以确定 this 的值

```js
this = GetBase(ref)，
```

GetBase 也已经铺垫了，获得 base value 值，这个例子中就是fo，所以 this 的值就是 foo ，示例1的结果就是 2。

#### 6.4.4 (foo.bar)()

```js
console.log((foo.bar)());
```

foo.bar 被 () 包住

Return the result of evaluating Expression. This may be of type Reference.

NOTE This algorithm does not apply GetValue to the result of evaluating Expression.

实际上 () 并没有对 `MemberExpression` 进行计算，所以其实跟示例 1 的结果是一样的。

#### 6.4.5 (foo.bar=foo.bar)()

看示例3，有赋值操作符，

因为使用了 GetValue，所以返回的值不是 Reference 类型，

按照之前讲的判断逻辑，如果 ref 不是Reference，那么 this 的值为 undefined

this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。

#### 6.4.6 (false||foo.bar)()

示例4，因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined。

#### 6.4.7 (foo.bar，foo.bar)()

看示例5，因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined。

#### 6.4.8 总结

```js

var value = 1;

var foo = {
  value: 2,
  bar: function () {
    return this.value;
  }
}

//示例1
console.log(foo.bar()); // 2
//示例2
console.log((foo.bar)()); // 2
//示例3
console.log((foo.bar = foo.bar)()); // 1
//示例4
console.log((false || foo.bar)()); // 1
//示例5
console.log((foo.bar, foo.bar)()); // 1

```

注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。

## 7.执行上下文

### 7.1 思考题

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

两段代码都会打印'local scope'，在上文讲到了两者的区别在于执行上下文栈的变化不一样，本节会在此基础上，详细的解析执行上下文栈和执行上下文的具体变化过程。

### 7.2 具体执行分析

我们分析第一段代码：

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

执行过程如下：

1. 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈

```js
 ECStack = [
      globalContext
  ];
```

2. 全局上下文初始化

```js
  globalContext = {
      VO: [global],
      Scope: [globalContext.VO],
      this: globalContext.VO
  }
```

3. 初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]

```js
  checkscope.[[scope]] = [
    globalContext.VO
  ];
```

4. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈

```js
ECStack = [
    checkscopeContext,
    globalContext
];
```

5. checkscope 函数执行上下文初始化：
   - 复制函数 [[scope]] 属性创建作用域链；
   - 用 arguments 创建活动对象；
   - 初始化活动对象，即加入形参、函数声明、变量声明；
   - 将活动对象压入 checkscope 作用域链顶端；

同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope: undefined,
        f: reference to function f(){}
    },
    Scope: [AO, globalContext.VO],
    this: undefined
}
```

6. f 函数执行，沿着作用域链查找 scope 值，返回 scope 值；

7. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出；

```js
ECStack = [
    checkscopeContext,
    globalContext
];
```

8. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出

```js
ECStack = [
    globalContext
];
```

## 8.闭包

MDN 对闭包的定义为：

闭包是指那些能够访问自由变量的函数。

那什么是自由变量呢？

自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。

由此，我们可以看出闭包共有两部分组成：

闭包 = 函数 + 函数能够访问的自由变量

```js
var a = 1;

function foo() {
    console.log(a);
}

foo();
```

foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。

所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。

但是，这是理论上的闭包，其实还有一个实践角度上的闭包。

ECMAScript中，闭包指的是：

1. 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域；
2. 从实践角度：以下函数才算是闭包：

1. 1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）；
   2. 在代码中引用了自由变量；

接下来就来讲讲实践上的闭包

### 8.1 分析

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();
```

先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。

这里直接给出简要的执行过程：

1. 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈；
2. 全局执行上下文初始化；
3. 执行 `checkscope` 函数，创建 `checkscope` 函数执行上下文，`checkscope` 执行上下文被压入执行上下文栈；
4. `checkscope` 执行上下文初始化，创建变量对象、作用域链、this等；
5. `checkscope` 函数执行完毕，`checkscope` 执行上下文从执行上下文栈中弹出；
6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈；
7. f 执行上下文初始化，创建变量对象、作用域链、this等；
8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出；

了解到这个过程，我们应该思考一个问题：

1. 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？

当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：

```js
fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}
```

因为这个作用域链，f 函数依然可以读取到 `checkscopeContext.AO` 的值，说明当 f 函数引用了 `checkscopeContext.AO` 中的值的时候，即使 `checkscopeContext` 被销毁了，但是 JavaScript 依然会让 `checkscopeContext.AO` 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。

所以，让我们再看一遍实践角度上闭包的定义：

1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）；
2. 在代码中引用了自由变量；

### 8.2 思考题

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

答案是都是 3，让我们分析一下原因：
当执行到 data[0] 函数之前，此时全局上下文的 VO 为：

```js
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```

当执行 data[0] 函数的时候，data[0] 函数的作用域链为：

```js
data[0]Context = {
    Scope: [AO, globalContext.VO]
}
```

data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。
data[1] 和 data[2] 是一样的道理。
所以改成闭包：

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
        return function(){
            console.log(i);
        }
  })(i);
}

data[0]();
data[1]();
data[2]();
```

当执行到 data[0] 函数之前，此时全局上下文的 VO 为：

```js
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```

跟没改之前一模一样。

当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：

```js
data[0]Context = {
    Scope: [AO, 匿名函数Context.AO globalContext.VO]
}
```

匿名函数执行上下文的AO为

```js
匿名函数Context = {
    AO: {
        arguments: {
            0: 0,
            length: 1
        },
        i: 0
    }
}
```

data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。

data[1] 和 data[2] 是一样的道理。

# javascript高级用法(2/2)

函数变量提升

https://www.yuque.com/lpldplws/atomml/os260aysmxgeyhhm?singleDoc# 《JavaScript高级用法(2/2)》 密码：ih4c

## 1. 参数按值传递

ECMAscript的所有函数的参数都是按值传递

function foo(a){}

把函数外部的值赋值给函数内部的参数，把值从一个变量赋值到另一个变量一样

### 1.1.按值传递

```js
var val=1;
function foo(v){
     v=2;
    console.log(v);//2
}
foo(val);//传递的是赋值后val的结果,_val
console.log(val)//1
```

很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，函数中修改的都是 _value 的值，而不会影响原来的 value 值。

### 1.2. 共享传递

拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝会产生性能上的问题。

这里提及一种：按引用传递。

所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。

举个例子

```js
var obj={val:1};
function foo(o){
    o.val=2;//这里没有改变o的地址，只是改变了val的值
    console.log(o.val)//2，
}
foo(obj)
console.log(obj.val);//2，因为地址并没有改变，obj的引用地址没有变化
```

为什么《JavaScript高级程序设计》都说了 ECMAScript 中所有函数的参数都是按值传递的，那为什么能按"引用传递"成功呢？

```js
var obj={val:1};
function foo(o){
    o=2;//把o的地址直接变成了值
    console.log(o)//2
}
foo(obj)
console.log(obj.val);//1，obj的引用地址没有变化，变的只是o的东西
```

如果 JavaScript 采用的是引用传递，外层的值也会被修改，那这里如何解释？

这就要讲到第二种传递方式，叫按共享传递。

而共享传递是指，在传递对象的时候，传递的是地址索引。

所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。

最后，你可以这样理解：

参数如果是基本类型是按值传递，如果是引用类型按共享传递。

但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。

换句话说，函数传递参数 ，传递的是参数的拷贝：

1. 指针拷贝，拷贝的是地址索引；
2. 常规类型拷贝，拷贝的是值 ；

所以，一共是两种传递方式，按值传递和按共享传递。

### 1.3 总结

javascript中数据类型分为基本类型与引用类型：

1. 基本类型值存储于栈内存中，传递的就是当前值，修改不会影响原有变量的值；
2. 引用类型值其实也存于栈内存中，只是它的值是指向堆内存当中实际值的一个地址；索引引用传递传的值是栈内存当中的引用地址，当改变时，改变了堆内存当中的实际值；

所以针对上述的内容：

```js
var value = 1;
function foo(v) {
    v = 2;
    console.log(v); //2
}
foo(value);
console.log(value) // 1
```

内存分布：

改变前：

| 栈内存 |      | 堆内存 |
| ------ | ---- | ------ |
| value  | 1    |        |
| v      | 1    |        |

改变后：

| 栈内存 |      | 堆内存 |
| ------ | ---- | ------ |
| value  | 1    |        |
| v      | 2    |        |

```js
var obj = {
value: 1
};
function foo(o) {
    o.value = 2;
    console.log(o.value); //2
}
foo(obj);
console.log(obj.value) // 2
```

改变前：

| 栈内存 |          | 堆内存     |
| ------ | -------- | ---------- |
| obj    | 指针地址 | {value: 1} |
| o      | 指针地址 | {value: 1} |

改变后：

| 栈内存 |          | 堆内存     |
| ------ | -------- | ---------- |
| obj    | 指针地址 | {value: 2} |
| o      | 指针地址 | {value: 2} |

```js
var obj = {
value: 1
};
function foo(o) {
    o = 2;
    console.log(o); //2
}
foo(obj);
console.log(obj.value) // 1
```

改变前：

| 栈内存 |          | 堆内存     |
| ------ | -------- | ---------- |
| obj    | 指针地址 | {value: 1} |
| o      | 指针地址 | {value: 1} |

改变后：

| 栈内存 |          | 堆内存     |
| ------ | -------- | ---------- |
| obj    | 指针地址 | {value: 1} |
| o      | 2        |            |

## 2. 手写call和apply

### 2.1 手写call

call() ：在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。

```js
let foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
```

注意两点：

1. call 改变了 this 的指向，指向到 foo；
2. bar 函数执行了；

#### 2.1.1 第一步

上述方式等同于：

```js
let foo = {
    value: 1,
    bar: function() {
        console.log(this.value)
    }
};

foo.bar(); // 1
```

这个时候 this 就指向了 foo，但是这样却给 foo 对象本身添加了一个属性，所以们用 delete 再删除它即可。
所以我们模拟的步骤可以分为：

1. 将函数设为对象的属性；
2. 执行该函数；
3. 删除该函数；
   以上个例子为例，就是：

```js
// 第一步
// fn 是对象的属性名，反正最后也要删除它，所以起什么都可以。
foo.fn = bar
// 第二步
foo.fn()
// 第三步
delete foo.fn
```

根据上述思路，提供一版：

```js
// 第一版
Function.prototype.call2 = function(context) {
    // 首先要获取调用call的函数，用this可以获取
    context.fn = this;
    context.fn();
    delete context.fn;
}

// 测试一下
 let foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call2(foo); // 1
```

#### 2.1.2 第二步

call除了可以指定this，还可以指定参数

```js
var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call(foo, 'kevin', 18);
// kevin
// 18
// 1

```

可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。

上述代码的Arguments中取第二个到最后一个的参数

```js
// 以上个例子为例，此时的arguments为：
// arguments = {
//      0: foo,
//      1: 'kevin',
//      2: 18,
//      length: 3
// }
// 因为arguments是类数组对象，所以可以用for循环
var args = [];
for(var i = 1, len = arguments.length; i < len; i++) {
    args.push('arguments[' + i + ']');
}

// 执行后 args为 ["arguments[1]", "arguments[2]", "arguments[3]"]
```

接下来使用eval拼接成一个函数

```js
eval('context.fn(' + args +')')
```

考虑到目前大部分浏览器在console中限制eval的执行，也可以使用rest

此处代码为：

```js
// 第二版
Function.prototype.call2 = function(context) {
    context.fn = this;
    let arg = [...arguments].slice(1)
    context.fn(...arg)
    delete context.fn;
}

// 测试一下
var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call2(foo, 'kevin', 18); 
// kevin
// 18
// 1
```

#### 2.1.3 第三步

1. this 参数可以传 null，当为 null 的时候，视为指向 window

举个例子:

```js
var value = 1;

function bar() {
    console.log(this.value);
}

bar.call(null); // 1
```

2. 针对函数，可以实现返回值

```js
var obj = {
    value: 1
}

function bar(name, age) {
    return {
        value: this.value,
        name: name,
        age: age
    }
}

console.log(bar.call(obj, 'kevin', 18));
// Object {
//    value: 1,
//    name: 'kevin',
//    age: 18
// }
```

这里

```js
// 第三版
Function.prototype.call2 = function (context) {
		var context = context || window;
    context.fn = this;

    let arg = [...arguments].slice(1)
    let result = context.fn(...arg)

    delete context.fn
  	return result
}

// 测试一下
var value = 2;

var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.call2(null); // 2

console.log(bar.call2(obj, 'kevin', 18));
// 1
// Object {
//    value: 1,
//    name: 'kevin',
//    age: 18
// }
```

这边给出最简化的写法：

```js
Function.prototype.call2 = function(context, ...args) {
  // 判断是否是undefined和null
  if (typeof context === 'undefined' || context === null) {
    context = window
  }
  let fnSymbol = Symbol()
  context[fnSymbol] = this
  let fn = context[fnSymbol](...args)
  delete context[fnSymbol] 
  return fn
}
```

### 2.2	手写apply

apply 的实现跟 call 类似，只是入参不一样，apply为数组

```js
Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
				result = context.fn(...arr)
    }

    delete context.fn
    return result;
}
```

最简化版方式

```js
Function.prototype.apply2 = function(context, args) {
  // 判断是否是undefined和null
  if (typeof context === 'undefined' || context === null) {
    context = window
  }
  let fnSymbol = Symbol()
  context[fnSymbol] = this
  let fn = context[fnSymbol](...args)
  delete context[fnSymbol] 
  return fn
}
```

## 3.手写bind

bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。

由此我们可以首先得出 bind 函数的两个特点：

1. 返回一个函数；
2. 可以传入参数；

### 3.1 返回函数的模拟实现

```js
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

// 返回了一个函数
var bindFoo = bar.bind(foo); 

bindFoo(); // 1
```

关于指定 this 的指向，我们可以使用 call 或者 apply 实现

```js
// 第一版
Function.prototype.bind2 = function (context) {
    var self = this;

    // 虑到绑定函数可能是有返回值的，加上return
    return function () {
        return self.apply(context);
    }

}
```

### 3.2 传参的模拟实现

接下来，关于参数的传递：

```js
var foo = {
    value: 1
};

function bar(name, age) {
    console.log(this.value);
    console.log(name);
    console.log(age);

}

var bindFoo = bar.bind(foo, 'daisy');
bindFoo('18');
// 1
// daisy
// 18
```

当需要传 name 和 age 两个参数时，可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age。
这里如果不适用rest，使用arguments进行处理：

```js
// 第二版
Function.prototype.bind2 = function (context) {

    var self = this;
    // 获取bind2函数从第二个参数到最后一个参数
    var args = Array.prototype.slice.call(arguments, 1);

    return function () {
        // 这个时候的arguments是指bind返回的函数传入的参数
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(context, args.concat(bindArgs));
    }
}
```

### 3.3 构造函数效果的模拟实现

bind 还有一个特点，就是

一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：

```js
var value = 2;

var foo = {
    value: 1
};

function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}

bar.prototype.friend = 'kevin';

var bindFoo = bar.bind(foo, 'daisy');

var obj = new bindFoo('18');
// undefined
// daisy
// 18
console.log(obj.habit);
console.log(obj.friend);
// shopping
// kevin
```

尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了
后文中new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。

```js
// 第三版
Function.prototype.bind2 = function (context) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
        // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
        // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
    }
    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
    fBound.prototype = this.prototype;
    return fBound;
}

```

### 3.4 构造函数效果的优化实现

但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：

```js
// 第四版
Function.prototype.bind2 = function (context) {

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```

### 3.5 最终版

调用 bind 的不是函数时，提示错误：

```js
if (typeof this !== "function") {
  throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
}
```

最终代码为：

```js
Function.prototype.bind2 = function (context) {

    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```

最简化版：

```js
Function.prototype.myBind = function(context) {
// 判断是否是undefined 和 null
    if (typeof context === "undefined" || context === null) {
    	context = window;
    }
    self = this;
    return function(...args) {
    	return self.apply(context, args);
    }
}
```

## 4.手写模拟new

new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一

先看看 new 实现了哪些功能。

```js
function Person (name, age) {
    this.name = name;
    this.age = age;

    this.habit = 'Games';
}

Person.prototype.strength = 80;

Person.prototype.sayYourName = function () {
    console.log('I am ' + this.name);
}

var person = new Person('Kevin', '18');

console.log(person.name) // Kevin
console.log(person.habit) // Games
console.log(person.strength) // 60

person.sayYourName(); // I am Kevin
```

我们可以看到，实例 person 可以：

1. 访问到 Otaku 构造函数里的属性；
2. 访问到 Otaku.prototype 中的属性；

接下来，我们可以尝试着模拟一下了。

因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的：

```js
function Person () {
    ……
}

// 使用 new
var person = new Person(……);
// 使用 objectFactory
var person = objectFactory(Person, ……)
```

### 4.1 初步实现

因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Person 构造函数里的属性，我们可以使用 `Person.apply(obj, arguments)`来给 obj 添加新的属性。

然后，实例的 __proto__ 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性

```js
// 第一版代码
function objectFactory() {
    var obj = new Object(),
    Constructor = [].shift.call(arguments);
    obj.__proto__ = Constructor.prototype;
    Constructor.apply(obj, arguments);

    return obj;

};
```

在这一版中，我们：

1. 用new Object() 的方式新建了一个对象 obj；
2. 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数；
3. 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性；
4. 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性；
5. 返回 obj；

测试一下：

```js
function Person (name, age) {
    this.name = name;
    this.age = age;

    this.habit = 'Games';
}

Person.prototype.strength = 60;

Person.prototype.sayYourName = function () {
    console.log('I am ' + this.name);
}

function objectFactory() {
    var obj = new Object(),
    Constructor = [].shift.call(arguments);
    obj.__proto__ = Constructor.prototype;
    Constructor.apply(obj, arguments);
    return obj;
};

var person = objectFactory(Person, 'Kevin', '18')

console.log(person.name) // Kevin
console.log(person.habit) // Games
console.log(person.strength) // 60

person.sayYourName(); // I am Kevin
```

### 4.2 最终实现

假如构造函数有返回值

```js
function Person (name, age) {
    this.strength = 60;
    this.age = age;

    return {
        name: name,
        habit: 'Games'
    }
}

var person = new Person('Kevin', '18');

console.log(person.name) // Kevin
console.log(person.habit) // Games
console.log(person.strength) // undefined
console.log(person.age) // undefined

```

在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。
而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？
再举个例子：

```js
function Person (name, age) {
    this.strength = 60;
    this.age = age;

    return 'handsome boy';
}

var person = new Otaku('Kevin', '18');

console.log(person.name) // undefined
console.log(person.habit) // undefined
console.log(person.strength) // 60
console.log(person.age) // 18
```

这次尽管有返回值，但是相当于没有返回值进行处理。

所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。

```js
// 最终版的代码
function objectFactory() {
    var obj = new Object(),
    Constructor = [].shift.call(arguments);
    obj.__proto__ = Constructor.prototype;
    var ret = Constructor.apply(obj, arguments);
    return typeof ret === 'object' ? ret : obj;

};
```

## 5.类数组对象与arguments

### 5.1类数组对象

所谓的类数组对象:

拥有一个 length 属性和若干索引属性的对象

举个例子：

```js
var array = ['name', 'age', 'sex'];

var arrayLike = {
    0: 'name',
    1: 'age',
    2: 'sex',
    length: 3
}
```

#### 5.1.1 读写

```js
console.log(array[0]); // name
console.log(arrayLike[0]); // name

array[0] = 'new name';
arrayLike[0] = 'new name';
```

#### 5.1.2 长度

```js
console.log(array.length); // 3
console.log(arrayLike.length); // 3
```

#### 5.1.3 遍历

```js
for(var i = 0, len = array.length; i < len; i++) {
   ……
}
for(var i = 0, len = arrayLike.length; i < len; i++) {
    ……
}
```

但是调用原生的数组方法会报错，如push

```js
arrayLike.push is not a function
```

#### 5.1.4 调用数组方法

只能通过 Function.call 间接调用

```js
var arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }

Array.prototype.join.call(arrayLike, '&'); // name&age&sex

Array.prototype.slice.call(arrayLike, 0); // ["name", "age", "sex"] 
// slice可以做到类数组转数组

Array.prototype.map.call(arrayLike, function(item){
    return item.toUpperCase();
}); 
// ["NAME", "AGE", "SEX"]
```

### 5.2 Arguments对象

Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。

举个例子:

```js
function foo(name, age, sex) {
    console.log(arguments);
}

foo('name', 'age', 'sex')
```

打印结果：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1669796564922-3f9b7f45-48af-4f09-a288-c99f27c48d7f.png)

可以看到除了类数组的索引属性和length属性之外，还有一个callee属性

#### 5.2.1 length属性

Arguments对象的length属性，表示实参的长度，举个例子：

```js
function foo(b, c, d){
    console.log("实参的长度为：" + arguments.length)
}

console.log("形参的长度为：" + foo.length)

foo(1)

// 形参的长度为：3
// 实参的长度为：1
```

#### 5.2.2. callee属性

Arguments 对象的 callee 属性，通过它可以调用函数自身。

讲个闭包经典面试题使用 callee 的解决方法：

```js
var data = [];

for (var i = 0; i < 3; i++) {
    (data[i] = function () {
       console.log(arguments.callee.i) 
    }).i = i;
}

data[0]();
data[1]();
data[2]();

// 0
// 1
// 2
```

#### 5.2.3 arguments和对应参数的绑定

```js
function foo(name, age, sex, hobbit) {

    console.log(name, arguments[0]); // name name

    // 改变形参
    name = 'new name';

    console.log(name, arguments[0]); // new name new name

    // 改变arguments
    arguments[1] = 'new age';

    console.log(age, arguments[1]); // new age new age

    // 测试未传入的是否会绑定
    console.log(sex); // undefined

    sex = 'new sex';

    console.log(sex, arguments[2]); // new sex undefined

    arguments[3] = 'new hobbit';

    console.log(hobbit, arguments[3]); // undefined new hobbit

}

foo('name', 'age')
```

传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享

#### 5.2.4. 传递参数

将参数从一个函数传递到另一个函数

```js
// 使用 apply 将 foo 的参数传递给 bar
function foo() {
    bar.apply(this, arguments);
}
function bar(a, b, c) {
   console.log(a, b, c);
}

foo(1, 2, 3)
```

#### 5.2.5 es6

使用ES6的 ... 运算符，我们可以轻松转成数组。

```js
function func(...arguments) {
    console.log(arguments); // [1, 2, 3]
}

func(1, 2, 3);
```

#### 5.2.6 应用

arguments的应用其实很多，像参数不定长、函数柯里化等等都有涉及。

## 6. 创建对象的多种方式&优缺点

### 6.1 工厂模式

```js
function createPerson(name) {
    var o = new Object();
    o.name = name;
    o.getName = function () {
        console.log(this.name);
    };

    return o;
}

var person1 = createPerson('kevin');
```

优点：简单；

缺点：对象无法识别，因为所有的实例都指向一个原型；

### 6.2 构造函数模式

```js
function Person(name) {
    this.name = name;
    this.getName = function () {
        console.log(this.name);
    };
}

var person1 = new Person('kevin');
```

优点：实例可以识别为一个特定的类型；

缺点：每次创建实例时，每个方法都要被创建一次；

#### 6.2.1 构造函数优化

```js
function Person(name) {
    this.name = name;
    this.getName = getName;
}

function getName() {
    console.log(this.name);
}

var person1 = new Person('kevin');
```

解决了每个方法都要重新创建的问题

### 6.3 原型模式

```js
function Person(name) {

}

Person.prototype.name = 'xianzao';
Person.prototype.getName = function () {
    console.log(this.name);
};

var person1 = new Person();
```

优点：方法不会重新创建；

缺点：

1. 所有的属性和方法都共享；
2. 不能初始化参数；

#### 6.3.1 原型模式优化

```js
function Person(name) {

}

Person.prototype = {
    name: 'xianzao',
    getName: function () {
        console.log(this.name);
    }
};

var person1 = new Person();
```

优点：封装清晰点；

缺点：重写了原型，丢失了constructor属性；

#### 6.3.2 原型模式优化2

```js
function Person(name) {

}

Person.prototype = {
    constructor: Person,
    name: 'kevin',
    getName: function () {
        console.log(this.name);
    }
};

var person1 = new Person();
```

优点：实例可以通过constructor属性找到所属构造函数；

缺点：

1. 所有的属性和方法都共享；
2. 不能初始化参数；

### 6.4 组合模式

```js
function Person(name) {
    this.name = name;
}

Person.prototype = {
    constructor: Person,
    getName: function () {
        console.log(this.name);
    }
};

var person1 = new Person();
```

优点：该共享的共享，该私有的私有，使用最广泛的方式；

缺点：希望写在一个地方，即更好的封装性；

#### 6.4.1 动态原型模式

```js
function Person(name) {
    this.name = name;
    if (typeof this.getName != "function") {
        Person.prototype.getName = function () {
            console.log(this.name);
        }
    }
}

var person1 = new Person();
```

注意：使用动态原型模式时，不能用对象字面量重写原型

```js
function Person(name) {
    this.name = name;
    if (typeof this.getName != "function") {
        Person.prototype = {
            constructor: Person,
            getName: function () {
                console.log(this.name);
            }
        }
    }
}

var person1 = new Person('xianzao');
var person2 = new Person('zaoxian');

// 报错 并没有该方法
person1.getName();

// 注释掉上面的代码，这句是可以执行的。
person2.getName();
```

开始执行`var person1 = new Person('xianzao')`

我们回顾下 new 的实现步骤：

1. 首先新建一个对象；
2. 然后将对象的原型指向 `Person.prototype`；
3. 然后 `Person.apply(obj)`；
4. 返回这个对象；

注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 `Person.prototype`，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 `Person.prototype`。而之前的原型是没有 getName 方法的，所以就报错了。

如果你就是想用字面量方式写代码，可以尝试下这种:

```js
function Person(name) {
    this.name = name;
    if (typeof this.getName != "function") {
        Person.prototype = {
            constructor: Person,
            getName: function () {
                console.log(this.name);
            }
        }

        return new Person(name);
    }
}

var person1 = new Person('xianzao');
var person2 = new Person('zaoxian');

person1.getName(); // xianzao
person2.getName();  // zaoxian

```

## 7.继承的多种方式&优缺点

### 7.1 原型链继承

```js
function Parent () {
    this.name = 'xianzao';
}

Parent.prototype.getName = function () {
    console.log(this.name);
}

function Child () {

}

Child.prototype = new Parent();

var child1 = new Child();

console.log(child1.getName()) // xianzao
```

问题：引用类型的属性被所有实例共享，举个例子：

```js
function Parent () {
    this.names = ['xianzao', 'zaoxian'];
}

function Child () {

}

Child.prototype = new Parent();

var child1 = new Child();

child1.names.push('test');

console.log(child1.names); // ["xianzao", "zaoxian", "test"]

var child2 = new Child();

console.log(child2.names); // ["xianzao", "zaoxian", "test"]
```

### 7.2 借用构造函数

```js
function Parent () {
    this.names = ['xianzao', 'zaoxian'];
}

function Child () {
    Parent.call(this);
}

var child1 = new Child();

child1.names.push('test');

console.log(child1.names); // ["xianzao", "zaoxian", "test"]

var child2 = new Child();

console.log(child2.names); // ["xianzao", "zaoxian"]
```

优点：

1. 避免了引用类型的属性被所有实例共享；

2. 可以在 Child 中向 Parent 传参；

```js
function Parent (name) {
    this.name = name;
}

function Child (name) {
    Parent.call(this, name);
}

var child1 = new Child('xianzao');

console.log(child1.name); // xianzao

var child2 = new Child('zaoxian');

console.log(child2.name); // zaoxian
```

缺点：

方法都在构造函数中定义，每次创建实例都会创建一遍方法。

### 7.3 组合继承

```js
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {

    Parent.call(this, name);
    
    this.age = age;

}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');

child1.colors.push('black');

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');

console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```

优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。

### 7.4 原型继承

```js
function createObj(o) {
    function F(){}
    F.prototype = o;
    return new F();
}
```

缺点：
包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

```js
var person = {
    name: 'kevin',
    friends: ['daisy', 'kelly']
}

var person1 = createObj(person);
var person2 = createObj(person);

person1.name = 'person1';
console.log(person2.name); // kevin

person1.friends.push('taylor');
console.log(person2.friends); // ["daisy", "kelly", "taylor"]
```

### 7.5 寄生式继承

创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

```js
function createObj (o) {
    var clone = Object.create(o);
    clone.sayName = function () {
        console.log('hi');
    }
    return clone;
}
```

# 浏览器事件模型

https://www.yuque.com/lpldplws/atomml/dh5rlaq0xygdkok5?singleDoc# 《浏览器事件模型&请求》 密码：qnyz

## 1. 课程目标

1. 掌握浏览器的事件捕获、冒泡等常见的事件模型；
2. 掌握ajax、fetch、axios的基础使用；

## 2. 课程大纲

1. 浏览器事件模型；
2. 浏览器请求；

## 3. 浏览器事件模型

### 3.1. DOM事件

DOM`(Document Object Model`，文档对象模型)是针对HTML文档和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、移出和修改页面的某一部分，DOM 脱胎于Netscape 及微软公司创始的 DHTML（动态HTML）。但现在它已经成为表现和操作页面标记的真正跨平台、语言中立的方式。

`Netscape Navigator 4` 和 `IE4` 分别发布于 1997 年的 6 月和 10 月发布的 DHTML，由于 `IE4` 和 `Netscape Navigator4` 分别支持不同的 DHTML，为了统一标准，W3C开始制定 DOM。1998 年10 月 W3C 总结了 IE 和 Navigator4 的规范，制定了 DOMLevel 1即 DOM1，之前 IE 与 Netscape 的规范则被称为 DOMLevel 0 即 DOM0 。

#### 3.1.1 DOM0级事件

假设页面中存在一个 btn 的按钮，并且给 btn 添加一个点击事件：

```js
btn.onclick = function(){
   console.log('this is a click event')
}
```

事件就是用户或浏览器自身执行的某种操作，如click、load、mouseover等，都是事件的名字，而响应某个事件的函数就被称为事件处理程序。

##### 3.1.1.1 click事件过程

在上述的例子中，click 事件并没有像其他函数一样，必须要调用才可以执行，click 事件并不确定什么时候发生，而当浏览器发现用户点击该按钮时，浏览器就检测btn.onclick是否有值，如果有，就会执行btn.onclick.call(btn,event)，此时函数执行，call() 方法接收两个参数，第一个指向调用当前方法的对象，也就是this。
需要注意的是，指定的 this 值并不一定是该函数执行时真正的this值，如果这个函数处于[非严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)下，则指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象。
另一个参数则是事件对象 event，该对象也可以通过 arguments[0] 来访问，它包含了事件相关的所有信息，如本例子中，则包含了点击事件的全部信息。可以通过给函数传参来获取事件信息。

```js
btn.onclick = function(e){
   console.log('this is a click event');
   console.log(e);  //  事件对象
    
}
```

但是在 IE 中，在使用 DOM0 级方法添加事件处理程序时，event 是作 window 对象的一个属性而存在的。此时访问事件对象需要通过 window.event。

```js
btn.onclick = function(){
   console.log(window.event);  //  IE中事件对象    
}
```

在 DOM0级中，如果想要实现一个对象绑定多个函数，可以这样实现：

```js
function fn1(){
    // do something
}
function fn2(){
    // do something
}
btn.onclick = function(e){
  fn1.call(this.xxx);
  fn2.call(this.yyy);
}
```

#### 3.1.2. DOM1级事件

DOM级别1于1998年10月1日成为W3C推荐标准。1级DOM标准中并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。在2级DOM中除了定义了一些DOM相关的操作之外还定义了一个事件模型 ，这个标准下的事件模型就是我们所说的2级DOM事件模型。

#### 3.1.3 DOM2级事件

W3C 后来将 DOM1 升级为 DOM2，DOM2级规范开始尝试以一种符合逻辑的方式来标准化 DOM事件。DOM0级 可以认为 onclick 是 btn 的一个属性，DOM2级 则将属性升级为队列。

DOM2级 事件定义了两个方法，用于处理指定和删除事件处理程序的操作，`addEventListener()`和`removeEventListener()`，所有的 DOM 节点中都包含这两个方法，它们都接收 3 个参数。

1. 要处理的事件名；
2. 作为事件处理程序的函数；
3. 布尔值，true 代表在捕获阶段调用事件处理程序，false 表示在冒泡阶段调用事件处理程序，默认为 false；

```js
btn.addEventListener('click',function(){
  //  do something
})
btn.addEventListener('click',function(){
  //  do something else
})
```

`addEventListener()`将事件加入到监听队列中，当浏览器发现用户点击按钮时，click 队列中依次执行匿名函数1、匿名函数2。

```js
function fn1(){
  //  do something
}
function fn1(){
  //  do something else
}
btn.addEventListener('click',fn1)
btn.addEventListener('click',fn2)
```

如果这样写，click 队列中依次`fn1.call(btn,event)`，`fn2.call(btn,event)`。

通过`addEventListener()`添加的事件只能由`removeEventListener()`来移除，并且`removeEventListener()`只能移除具名函数，不能移除匿名函数。

课后作业：必须通读[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model)上关于DOM的内容；

#### 3.1.4 IE中DOM2级事件

IE8 及之前，实现类似`addEventListener()`和`removeEventListener()`的两个方法是`attachEvent()`和`detachEvent()`，这两个方法接受相同的两个参数。

1. 要处理的事件名；
2. 作为事件处理程序的函数；

IE8 之前的只支持事件冒泡，所以通过`attachEvent()`添加的事件处理程序只能添加到冒泡阶段。

```js
btn.attachEvent('click',fn1)
btn.attachEvent('click',fn2)
```

当用户点击时，click 队列依次`fn1.call(undefined,undefined)`，`fn2.call(undefined,undefined)`。

类似的`detachEvent()`也只能移除具名函数，不能移除匿名函数。

```js
function eventHandler() {
  console.log('xianzao);
}

btn.attachEvent('onClick', eventHandler);
btn.detachEvent('onClick, eventHandler);
```

#### 3.1.5 兼容处理

```js
if(typeof btn.addEventListener === 'function'){
  btn.addEventListener('click',fn);
}else if(typeof btn.attachEvent === 'function'){
  btn.attachEvent('onclick',fn)
}else{
  btn.onclick=function(){
    // do something
  }
}
```

#### 3.1.6 总结

```js
var btn = document.getElementById('btn');

btn.onClick = () => {
  console.log('我是DOM0级事件处理程序');
}
btn.onClick = null;

btn.addEventListener('click', () => {
  console.log('我是DOM2级事件处理程序');
}, false);
btn.removeEventListener('click', handler, false)

btn.attachEvent('onclick', () => {
  console.log('我是IE事件处理程序')
})
btn.detachEvent('onclicn', handler);
```

1. DOM2级的好处是可以添加多个事件处理程序；DOM0对每个事件只支持一个事件处理程序；

2. 通过DOM2添加的匿名函数无法移除，上面写的例子就移除不了，addEventListener和removeEventListener的handler必须同名；

3. 作用域：DOM0的handler会在所属元素的作用域内运行，IE的handler会在全局作用域运行，this === window；

4. 触发顺序：添加多个事件时，DOM2会按照添加顺序执行，IE会以相反的顺序执行；

5. 跨浏览器的事件处理程序

```js
var EventUtil = {
  // element是当前元素，可以通过getElementById(id)获取
  // type 是事件类型，一般是click ,也有可能是鼠标、焦点、滚轮事件等等
  // handle 事件处理函数
  addHandler: (element, type, handler) => {
    // 先检测是否存在DOM2级方法,再检测IE的方法，最后是DOM0级方法（一般不会到这）
    if (element.addEventListener) {
      // 第三个参数false表示冒泡阶段
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element.attachEvent(`on${type}`, handler)
    } else {
      element[`on${type}`] = handler;
    }
  },

  removeHandler: (element, type, handler) => {
    if (element.removeEventListener) {
      // 第三个参数false表示冒泡阶段
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent(`on${type}`, handler)
    } else {
      element[`on${type}`] = null;
    }
  }
}

// 获取元素
var btn = document.getElementById('btn');
// 定义handler
var handler = function(e) {
  console.log('我被点击了');
}
// 监听事件
EventUtil.addHandler(btn, 'click', handler);
// 移除事件监听
// EventUtil.removeHandler(button1, 'click', clickEvent);
```

### 3.2 事件捕获&事件冒泡

事件流描述的是从页面中接收事件的顺序
IE 的事件流是事件冒泡流
而 `Netscape Communicator` 的事件流是事件捕获流

DOM2级事件规定的事件流包括三个阶段：

- 事件捕获阶段；
- 处于目标阶段；
- 事件冒泡阶段；

首先发生的是事件捕获，为截获事件提供了机会。
然后是实际的目标接收到事件。
最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应

![38007715-4cc457d0-327d-11e8-9fb3-667fa75fc38c.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671033844027-574f28ec-feaa-47d5-9d06-cce699bd2bc2.png)

1、当处于目标阶段，没有捕获与冒泡之分，执行顺序会按照`addEventListener`的添加顺序决定，先添加先执行；

2、使用`stopPropagation()`取消事件传播时，事件不会被传播给下一个节点，但是，同一节点上的其他listener还是会被执行；如果想要同一层级的listener也不执行，可以使用`stopImmediatePropagation()`；

```js
// list 的捕获
$list.addEventListener('click', (e) => {
  console.log('list capturing');
  e.stopPropagation();
}, true)
  
// list 捕获 2
$list.addEventListener('click', (e) => {
  console.log('list capturing2');
}, true)

// list capturing
// list capturing2
```

3、`preventDefault()`只是阻止默认行为，跟JS的事件传播一点关系都没有；

4、一旦发起了`preventDefault()`，在之后传递下去的事件里面也会有效果；

#### 3.2.1 测试

如果有以下例子：

```js
<!DOCTYPE html> 
<html> 
<head> 
 <title>Event Bubbling Example</title> 
</head> 
<body> 
 <div id="myDiv">Click Me</div> 
</body> 
</html>
```

1. 事件捕获

最不具体的节点最先收到事件，而最具体的节点最后收到事件。事件捕获实际上是为了在事件到达最终目标
前拦截事件。

如果前面的例子使用事件捕获，则点击<div>元素会以下列顺序触发 click 事件：

- document； 
- <html>；
- <body>；
- <div>；

1. 事件冒泡

在点击页面中的<div>元素后，click 事件会以如下顺序发生：

- <div>；
- <body>；
- <html>；
- document； 

<div>元素，即被点击的元素，最先触发 click 事件。然后，click 事件沿 DOM 树一路向上，在经过的每个节点上依次触发，直至到达 document 对象。

### 3.3 事件对象

DOM0和DOM2的事件处理程序都会自动传入event对象

IE中的event对象取决于指定的事件处理程序的方法。

IE的handler会在全局作用域运行，`this === window`，所以在IE中会有`window.event`、`event`两种情况，只有在事件处理程序期间，event对象才会存在，一旦事件处理程序执行完成，event对象就会被销毁

event对象里需要关心的两个属性：

1. target：target永远是被添加了事件的那个元素；
2. eventPhase：调用事件处理程序的阶段，有三个值
   1：捕获阶段；
   2：处于目标；
   3：冒泡阶段；

#### 3.3.1 preventDefault与stopPropagation

preventDefault：比如链接被点击会导航到其href指定的URL，这个就是默认行为；
stopPropagation：立即停止事件在DOM层次中的传播，包括捕获和冒泡事件；
IE中对应的属性：

- srcElement => target
- returnValue => preventDefaukt()
- cancelBubble => stopPropagation()

IE 不支持事件捕获，因而只能取消事件冒泡，但stopPropagation可以同时取消事件捕获和冒泡。
再针对上面不同类型的事件及属性进行区分：

```js
var EventUtil = {
  // element是当前元素，可以通过getElementById(id)获取
  // type 是事件类型，一般是click ,也有可能是鼠标、焦点、滚轮事件等等
  // handle 事件处理函数
  addHandler: (element, type, handler) => {
    // 先检测是否存在DOM2级方法,再检测IE的方法，最后是DOM0级方法（一般不会到这）
    if (element.addEventListener) {
      // 第三个参数false表示冒泡阶段
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element.attachEvent(`on${type}`, handler)
    } else {
      element[`on${type}`] = handler;
    }
  },

  removeHandler: (element, type, handler) => {
    if (element.removeEventListener) {
      // 第三个参数false表示冒泡阶段
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent(`on${type}`, handler)
    } else {
      element[`on${type}`] = null;
    }
  },
  // 获取event对象
  getEvent: (event) => {
    return event ? event : window.event
  },
  // 获取当前目标
  getTarget: (event) => {
    return event.target ? event.target : event.srcElement
  },
  // 阻止默认行为
  preventDefault: (event) => {
    if (event.preventDefault) {
      event.preventDefault()
    } else {
      event.returnValue = false
    }
  },
  // 停止传播事件
  stopPropagation: (event) => {
    if (event,stopPropagation) {
      event.stopPropagation()
    } else {
      event.cancelBubble = true
    }
  }
}
```

### 3.4. 事件委托

事件委托：用来解决事件处理程序过多的问题
页面结构如下

```js
<ul id="myLinks">
  <li id="goSomewhere">Go somewhere</li>
  <li id="doSomething">Do something</li>
  <li id="sayHi">Say hi</li>
</ul>
```

按照传统的做法，需要像下面这样为它们添加 3 个事 件处理程序。

```js
var item1 = document.getElementById("goSomewhere");
var item2 = document.getElementById("doSomething");
var item3 = document.getElementById("sayHi");
EventUtil.addHandler(item1, "click", function(event){
    location.href = "http://www.xianzao.com";
});
EventUtil.addHandler(item2, "click", function(event){
    document.title = "I changed the document's title";
});
EventUtil.addHandler(item3, "click", function(event){
    alert("hi");
});
```

如果在一个复杂的 Web 应用程序中，对所有可单击的元素都采用这种方式，那么结果就会有数不 清的代码用于添加事件处理程序。此时，可以利用事件委托技术解决这个问题。使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序，如下面的例子所示

```js
var list = document.getElementById("myLinks");
EventUtil.addHandler(list, "click", function(event) {
  event = EventUtil.getEvent(event);
  var target = EventUtil.getTarget(event);
  switch(target.id) {
  case "doSomething":
      document.title = "I changed the document's title";
      break;
  case "goSomewhere":
      location.href = "http://www.wrox.com";
      break;
  case "sayHi": 9 alert("hi");
    break; 
  }
}
```

子节点的点击事件会冒泡到父节点，并被这个注册事件处理

最适合采用事件委托技术的事件包括 `click`、`mousedown`、`mouseup`、`keydown`、`keyup` 和 `keypress`。 虽然 `mouseover` 和 `mouseout` 事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。

可以考虑为 document 对象添加一个事件处理程序，用以处理页面上发生的某种特定类型的事件，需要跟踪的事件处理程序越少，移除它们就越容易（移除事件处理程序关乎内存和性能）。
只要是通过 `onload` 事件处理程序添加的东西，最后都要通过 `onunload` 事件处理程序将它们移除。

## 4.浏览器请求

在浏览器端发送网络请求的常见方式：

1. ajax；
2. fetch；
3. axios；

### 4.1 ajax

Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”。

ajax是js异步技术的术语，早起相关的api是XHR。

Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。

特点：

- 局部刷新页面，无需重载整个页面。

简单来说，Ajax 是一种思想，`XMLHttpRequest` 只是实现 Ajax 的一种方式。其中 `XMLHttpRequest` 模块就是实现 Ajax 的一种很好的方式。

#### 4.1.1. 手写ajax

建议先阅读[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)

利用 `XMLHttpRequest` 模块实现 Ajax。

##### 4.1.1.1. 创建异步对象

```javascript
let xmlHttp;
if (window.XMLHttpRequest) {
  // code for IE7+, Firefox, Chrome, Opera, Safari
  xmlHttp = new XMLHttpRequest();
} else {
  // code for IE6, IE5
  xmlHttp = new ActiveXObject('Microsoft.XMLHTTP');
}
```

通过`XMLHttpRequest`构造函数创建一个异步对象`xmlhttp`, IE6, IE5 使用ActiveXObject创建，创建的这个异步对象上有很多属性和方法，常用的有：

1. `onreadystatechange`：监听异步对象请求状态码`readyState`的改变，每当`readyState`改变时，就会触发`onreadystatechange`事件；
2. `readyState`：请求状态码

`readyState`表示异步对象目前的状态，状态码从0到4

0: 表示请求未初始化，还没有调用 `open()`；

1: 服务器连接已建立，但是还没有调用 `send()`；

2: 请求已接收，正在处理中（通常现在可以从响应中获取内容头）；

3: 请求处理中，通常响应中已有部分数据可用了，没有全部完成；

4: 当`readyState`状态码为4时，表示请求已完成；此阶段确认全部数据都已经解析完毕，可以通过异步对象的属性获取对应数据；

3. status：http状态码

http状态码表示成功的http状态码有

```
xmlHttp.status >= 200 && xmlHttp.status < 300 || xmlHttp.status == 304
```

4. responseText：后台返回的字符串形式的响应数据；

5. responseXML：后台返回的XML形式的响应数据；

##### 4.1.1.2. 设置请求方式和请求地址

创建异步对象之后，通过`open()`方法设置ajax请求方式和请求地址 格式：

```
xmlHttp.open("GET/POST","ajax-get.txt",true)
```

第一个参数：请求的类型；GET 还是 POST；

第二个参数：表示请求的文件的地址url；

第三个参数：设置请求方法是不是异步async，true为异步， false为同步。AJAX存在的意义就是发异步请求，所以第三个参数永远传true；

注意：有个问题，就是IE中的缓存问题

在IE浏览器中，如果通过Ajax发送GET请求，那么IE浏览器认为，同一个URL只有一个结果，如果地址没有发生变化，它就会把上一次返回的结果，直接返回。这样我们不能实时的拿到变化后的数据。如果要想我们拿到实时数据，必须保证每次的URL都是不一样的，有两种方式：

1. Math.random()；
2. new Date().getTime()；

即在请求地址后面拼接上?t=随机数或者1970.01.01至当前的毫秒数 所以在IE中通过ajax发送get请求时，可以设置请求地址为：

```js
xmlHttp.open("GET","ajax-get.txt?t=" + (new Date().getTime()),true);
//或
xmlHttp.open("GET","ajax-get.txt?t=" + Math.random(),true);
```

##### 4.1.1.3. 发送请求

直接通过异步对象的send()发送请求

```javascript
xmlHttp.send();
```

特别注意的是： 如果发送POST请求，使用`setRequestHeader()`来添加 HTTP请求头，并在send()方法中传递要发送的数据：

```javascript
xmlHttp.open("POST","ajax_test.html",true); 
xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); 
xmlHttp.send("fname=Henry&lname=Ford");
```

##### 4.1.1.4. 通过onreadystatechange监听状态变化

当异步对象的readyState发生改变，会触发`onreadystatechange`函数，当readyState变成为4时，表示当前状态是请求完毕的状态，同时当http的响应码status为200到300之间（包括200和300）或为304时，表示ajax请求成功;当http状态码不是200到300之间的数也不是304时，表示请求不成功

```js
//4.监听状态变化
xmlHttp.onreadystatechange = () => {
 // 判断当前状态改变是请求完毕的状态吗
 if (xmlHttp.readyState === 4) {
    if (xmlHttp.status >= 200 && xmlHttp.status < 300 || xmlHttp.status == 304) {
        console.log("成功的接收到服务器返回的数据");
    }else{
        console.log("不成功！");
    }   
 }
}  
```

##### 4.1.1.5 处理返回的结果

如果成功，可通过异步对象的`responseText`属性来获取服务器返回的字符串

接下来，我们来封装一个方法ajax()用于发送请求

封装的时候，需要注意：

1. URL当中只能出现字母 数字 下划线和ASCII码，不能出现中文，可以使用encodeURIComponent()转码；
2. 当我们利用我们的ajax放的发送一个请求到远处服务器时，我们需要等待远程服务器去响应我们的请求，等待远程服务器将响应的结果返回给我们，但是这个响应的速度是不确定的，因为响应的速度是由本地网络和远程服务器的网速等共同决定的，所以我们不可能一直等待服务器的响应。这里需要设置超时时间；

```js
ajax({
  type: 'GET',
  url: 'http://localhost:3000/posts',
  timeout: 1000,
  success: data => {
    console.log('success', data);
  },
  error: err => {
    console.log('error', err);
  },
});

```

##### 4.1.1.6 其他

至此，jQuery官方的ajax还是有一定的差异，所以还需要进一步完善

1. 传递多个参数，需要保持传递顺序。解决方案是可以改写成传递的是一个对象；因为对象里面的值，传递的是一个对象就不用考虑先后顺序，里面用的参数通过对象名.属性名的形式获取；
2. 传递请求类型的区分大小写，jQuery官方的是大小写都可以；解决方案是可以使用`toLowerCase`()或者`toUpperCase`()将类型转成大写或小写再对比；
3. 我们传递的数据用的名字是obj，jQuery官方用的是data；

```js
const ajax = option => {
  //type, url, data, timeout, success, error将所有参数换成一个对象{}

  //  0.将对象转换成字符串

  //处理obj
  const objToString = data => {
    data.t = new Date().getTime();
    let res = [];
    for (let key in data) {
      //需要将key和value转成非中文的形式，因为url不能有中文。使用encodeURIComponent();
      res.push(encodeURIComponent(key) + ' = ' + encodeURIComponent(data[key]));
    }
    return res.join('&');
  };

  let str = objToString(option.data || {});

  //  1.创建一个异步对象xmlHttp；
  var xmlHttp, timer;
  if (window.XMLHttpRequest) {
    xmlHttp = new XMLHttpRequest();
  } else if (xmlHttp) {
    // code for IE6, IE5
    xmlHttp = new ActiveXObject('Microsoft.xmlHttp');
  }

  //  2.设置请求方式和请求地址；
  // 判断请求的类型是POST还是GET
  if (option.type.toLowerCase() === 'get') {
    xmlHttp.open(option.type, option.url + '?t=' + str, true);
    //  3.发送请求；
    xmlHttp.send();
  } else {
    xmlHttp.open(option.type, option.url, true);
    // 注意：在post请求中，必须在open和send之间添加HTTP请求头：setRequestHeader(header,value);
    xmlHttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    //  3.发送请求；
    xmlHttp.send(str);
  }

  //  4.监听状态的变化；
  xmlHttp.onreadystatechange = function () {
    clearInterval(timer);
    debugger;
    if (xmlHttp.readyState === 4) {
      if ((xmlHttp.status >= 200 && xmlHttp.status < 300) || xmlHttp.status == 304) {
        //  5.处理返回的结果；
        option.success(xmlHttp.responseText); //成功后回调；
      } else {
        option.error(xmlHttp.responseText); //失败后回调；
      }
    }
  };

  //判断外界是否传入了超时时间
  if (option.timeout) {
    timer = setInterval(function () {
      xmlHttp.abort(); //中断请求
      clearInterval(timer);
    }, option.timeout);
  }
};
```

#### 4.1.2 测试

选择`json-server`启动本地服务，mock数据：

```js
{
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "author": "xianzao"
    }
  ],
  "comments": [
    {
      "id": 1,
      "body": "some comment",
      "postId": 1
    }
  ],
  "profile": {
    "name": "xianzao"
  }
}
```

执行代码：

```js
ajax({
  type: 'GET',
  url: 'http://localhost:3000/posts',
  timeout: 1000,
  success: data => {
    console.log('success', data);
  },
  error: err => {
    console.log('error', err);
  },
});

```

#### 4.1.3. 总结 

 

我们可以发现，ajax只是一种异步请求的方式，并不特指某一种具体的实现方式，但随着使用这种方式实现网络请求时内部又包含请求的情况，就会出现回调地狱，这也是XHR的诟病之一，因此，后来才催生了更加优雅的请求方式。

### 4.2 fetch

 

Fetch 是在 ES6 出现的，它使用了 ES6 提出的 Promise 对象。它是 XMLHttpRequest 的替代品。

有人把它与 Ajax 作比较，其实这是不对的，我们通常所说的 Ajax 是指使用 XMLHttpRequest 实现的 Ajax，所以真正应该和 XMLHttpRequest 作比较。

Fetch 是一个 API，它是真实存在的，它是基于 Promise 的。
建议阅读：[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)
以下内容摘选自：[fetch教学](https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html)

fetch()的功能与 XMLHttpRequest 基本相同，但有三个差异：

1. fetch使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁；

2. fetch采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码；

3. fetch通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来；

在用法上，fetch()接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象。它的基本用法如下。

```js
fetch(url)
  .then(...)
  .catch(...)
```

下面是一个demo，从服务器获取 JSON 数据。

```js
fetch('https://api.github.com/users/ruanyf')
  .then(response => response.json())
  .then(json => console.log(json))
  .catch(err => console.log('Request Failed', err)); 
```

fetch()接收到的response是一个 [Stream 对象](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API)，response.json()是一个异步操作，取出所有内容，并将其转为 JSON 对象。

Promise 可以使用 await 语法改写，使得语义更清晰。

```js
async function getJSON() {
  let url = 'https://api.github.com/users/ruanyf';
  try {
    let response = await fetch(url);
    return await response.json();
  } catch (error) {
    console.log('Request Failed', error);
  }
}
```

上面示例中，await语句必须放在try...catch里面，这样才能捕捉异步操作中可能发生的错误。

#### 4.2.1 Response

1. Response 对象的同步属性

fetch()请求成功以后，得到的是一个 [Response 对象](https://developer.mozilla.org/en-US/docs/Web/API/Response)。它对应服务器的 HTTP 回应。

```js
const response = await fetch(url);
```

Response 包含的数据通过 Stream 接口异步读取，但是它还包含一些同步属性，对应 HTTP 回应的标头信息（Headers），可以立即读取。

```js

async function fetchText() {
  let response = await fetch('/readme.txt');
  console.log(response.status); 
  console.log(response.statusText);
}
```

response.status和response.statusText就是 Response 的同步属性，可以立即读取。

##### 4.2.1.1 标头信息

1. Response.ok

Response.ok属性返回一个布尔值，表示请求是否成功，true对应 HTTP 请求的状态码 200 到 299，false对应其他的状态码；

2. Response.status

Response.status属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）；

3. Response.statusText

Response.statusText属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回"OK"）；

4. Response.url

Response.url属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL；

5. Response.type

Response.type属性返回请求的类型。可能的值如下：

- basic：普通请求，即同源请求；

- cors：跨域请求；

- error：网络错误，主要用于 Service Worker；

- opaque：如果fetch()请求的type属性设为no-cors，就会返回这个值。表示发出的是简单的跨域请求，类似<form>表单的那种跨域请求；

- opaqueredirect：如果fetch()请求的redirect属性设为manual，就会返回这个值；

6. Response.redirected

Response.redirected属性返回一个布尔值，表示请求是否发生过跳转。

##### 4.2.1.2 判断请求是否成功

fetch()发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，fetch()才会报错，其他情况都不会报错，而是认为请求成功。

这就是说，即使服务器返回的状态码是 4xx 或 5xx，fetch()也不会报错（即 Promise 不会变为 rejected状态）。

1. Response.status

Response.status属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。

```js
async function fetchText() {
  let response = await fetch('/readme.txt');
  if (response.status >= 200 && response.status < 300) {
    return await response.text();
  } else {
    throw new Error(response.statusText);
  }
}
```

response.status属性只有等于 2xx （200~299），才能认定请求成功。这里不用考虑网址跳转（状态码为 3xx），因为fetch()会将跳转的状态码自动转为 200。

2. response.ok是否为true

```js
if (response.ok) {
  // 请求成功
} else {
  // 请求失败
}
```

##### 4.2.1.3 Response.headers

Response 对象还有一个Response.headers属性，指向一个 [Headers 对象](https://developer.mozilla.org/en-US/docs/Web/API/Headers)，对应 HTTP 回应的所有标头。

Headers 对象可以使用for...of循环进行遍历。

```js
const response = await fetch(url);

for (let [key, value] of response.headers) { 
  console.log(`${key} : ${value}`);  
}

// 或者
for (let [key, value] of response.headers.entries()) { 
  console.log(`${key} : ${value}`);  
}
```

Headers 对象提供了以下方法，用来操作标头。

```js
Headers.get()：根据指定的键名，返回键值。
Headers.has()： 返回一个布尔值，表示是否包含某个标头。
Headers.set()：将指定的键名设置为新的键值，如果该键名不存在则会添加。
Headers.append()：添加标头。
Headers.delete()：删除标头。
Headers.keys()：返回一个遍历器，可以依次遍历所有键名。
Headers.values()：返回一个遍历器，可以依次遍历所有键值。
Headers.entries()：返回一个遍历器，可以依次遍历所有键值对（[key, value]）。
Headers.forEach()：依次遍历标头，每个标头都会执行一次参数函数。
```

这些方法中，最常用的是`response.headers.get()`，用于读取某个标头的值。

```js
let response =  await  fetch(url);  
response.headers.get('Content-Type')
// application/json; charset=utf-8
```

`Headers.keys()`和`Headers.values()`方法用来分别遍历标头的键名和键值

```js
// 键名
for(let key of myHeaders.keys()) {
  console.log(key);
}

// 键值
for(let value of myHeaders.values()) {
  console.log(value);
}
```

Headers.forEach()方法也可以遍历所有的键值和键名。

```js
let response = await fetch(url);
response.headers.forEach(
  (value, key) => console.log(key, ':', value)
);
```

##### 4.2.1.4. 读取内容的方法

Response对象根据服务器返回的不同类型的数据，提供了不同的读取方法。

- response.text()：得到文本字符串；
- response.json()：得到 JSON 对象；
- response.blob()：得到二进制 Blob 对象；
- response.formData()：得到 FormData 表单对象；
- response.arrayBuffer()：得到二进制 ArrayBuffer 对象；

这5个读取方法都是异步的，返回的都是 Promise 对象。必须等到异步操作结束，才能得到服务器返回的完整数据。

1. response.text()

`response.text()`可以用于获取文本数据，比如 HTML 文件。

```js
const response = await fetch('/users.html');
const body = await response.text();
document.body.innerHTML = body
```

2. response.json()

`response.json()`主要用于获取服务器返回的 JSON 数据。

3. response.formData()

`response.formData()`主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。

4. response.blob()

`response.blob()`用于获取二进制文件。

```js
const response = await fetch('flower.jpg');
const myBlob = await response.blob();
const objectURL = URL.createObjectURL(myBlob);

const myImage = document.querySelector('img');
myImage.src = objectURL;
```

上面示例读取图片文件flower.jpg，显示在网页上。

5. response.arrayBuffer()

`response.arrayBuffer()`主要用于获取流媒体文件。

```js
const audioCtx = new window.AudioContext();
const source = audioCtx.createBufferSource();

const response = await fetch('song.ogg');
const buffer = await response.arrayBuffer();

const decodeData = await audioCtx.decodeAudioData(buffer);
source.buffer = buffer;
source.connect(audioCtx.destination);
source.loop = true;
```

上面示例是response.arrayBuffer()获取音频文件song.ogg，然后在线播放的例子。

##### 4.2.1.5 Response.clone

Stream 对象只能读取一次，读取完就没了。这意味着，前一节的五个读取方法，只能使用一个，否则会报错。

```js
let text =  await response.text();
let json =  await response.json();  // 报错
```

上面示例先使用了`response.text()`，就把 Stream 读完了。后面再调用`response.json()`，就没有内容可读了，所以报错。

Response 对象提供`Response.clone()`方法，创建Response对象的副本，实现多次读取。

```js
const response1 = await fetch('flowers.jpg');
const response2 = response1.clone();

const myBlob1 = await response1.blob();
const myBlob2 = await response2.blob();

image1.src = URL.createObjectURL(myBlob1);
image2.src = URL.createObjectURL(myBlob2);
```

上面示例中，`response.clone()`复制了一份 Response 对象，然后将同一张图片读取了两次。

##### 4.2.1.6 Response.body

Response.body属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作。
它可以用来分块读取内容，应用之一就是显示下载的进度。

```js
const response = await fetch('flower.jpg');
const reader = response.body.getReader();

while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Received ${value.length} bytes`)
}
```

`response.body.getReader()`方法返回一个遍历器。这个遍历器的read()方法每次返回一个对象，表示本次读取的内容块。

这个对象的done属性是一个布尔值，用来判断有没有读完；value属性是一个 arrayBuffer 数组，表示内容块的内容，而value.length属性是当前块的大小。

#### 4.2.2 定制HTTP请求

fetch()的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求

```js
fetch(url, optionObj)
```

HTTP 请求的方法、标头、数据体都在这个对象里面设置。

##### 4.2.2.1 POST请求

```js
const response = await fetch(url, {
  method: 'POST',
  headers: {
    "Content-type": "application/x-www-form-urlencoded; charset=UTF-8",
  },
  body: 'foo=bar&lorem=ipsum',
});

const json = await response.json();
```

配置对象用到了三个属性。

```js
method：HTTP 请求的方法，POST、DELETE、PUT都在这个属性设置。
headers：一个对象，用来定制 HTTP 请求的标头。
body：POST 请求的数据体。
```

注意，有些标头不能通过headers属性设置，比如`Content-Length`、Cookie、Host等等。它们是由浏览器自动生成，无法修改。

##### 4.2.2.2 提交JSON数据

```js
const user =  { name:  'John', surname:  'Smith'  };
const response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
   'Content-Type': 'application/json;charset=utf-8'
  }, 
  body: JSON.stringify(user) 
});
```

标头`Content-Type`要设成`'application/json;charset=utf-8'`。因为默认发送的是纯文本，`Content-Type`的默认值是`'text/plain;charset=UTF-8'`。

##### 4.2.2.3 提交表单

```js
const form = document.querySelector('form');

const response = await fetch('/users', {
  method: 'POST',
  body: new FormData(form)
})
```

##### 4.2.2.4. 文件上传

如果表单里面有文件选择器，可以用前一个例子的写法，上传的文件包含在整个表单里面，一起提交。

另一种方法是用脚本添加文件，构造出一个表单，进行上传，请看下面的例子。

```js
const input = document.querySelector('input[type="file"]');

const data = new FormData();
data.append('file', input.files[0]);
data.append('user', 'foo');

fetch('/avatars', {
  method: 'POST',
  body: data
});
```

##### 4.2.2.5 直接上传二进制数据

fetch()也可以直接上传二进制数据，将 Blob 或 arrayBuffer 数据放在body属性里面。

```js
let blob = await new Promise(resolve =>   
  canvasElem.toBlob(resolve,  'image/png')
);

let response = await fetch('/article/fetch/post/image', {
  method:  'POST',
  body: blob
});
```

#### 4.2.3 option API

fetch()第二个参数的完整 API 如下：

```js
const response = fetch(url, {
  method: "GET",
  headers: {
    "Content-Type": "text/plain;charset=UTF-8"
  },
  body: undefined,
  referrer: "about:client",
  referrerPolicy: "no-referrer-when-downgrade",
  mode: "cors", 
  credentials: "same-origin",
  cache: "default",
  redirect: "follow",
  integrity: "",
  keepalive: false,
  signal: undefined
});
```

fetch()请求的底层用的是 [Request() 对象](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request)的接口，参数完全一样，因此上面的 API 也是Request()的 API。

##### 4.2.3.1 cache

cache属性指定如何处理缓存。可能的取值如下：

- default：默认值，先在缓存里面寻找匹配的请求；
- no-store：直接请求远程服务器，并且不更新缓存；
- reload：直接请求远程服务器，并且更新缓存；
- no-cache：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存；
- force-cache：缓存优先，只有不存在缓存的情况下，才请求远程服务器；
- only-if-cached：只检查缓存，如果缓存里面不存在，将返回504错误；

##### 4.2.3.2 mode

mode属性指定请求的模式。可能的取值如下：

- cors：默认值，允许跨域请求；
- same-origin：只允许同源请求；
- no-cors：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单所能发出的请求；

##### 4.2.3.3. credentials

credentials属性指定是否发送 Cookie。可能的取值如下：

- same-origin：默认值，同源请求时发送 Cookie，跨域请求时不发送；
- include：不管同源请求，还是跨域请求，一律发送 Cookie；
- omit：一律不发送；

跨域请求发送 Cookie，需要将credentials属性设为include。

```js
fetch('http://another.com', {
  credentials: "include"
});
```

##### 4.2.3.4 signal

signal属性指定一个 `AbortSignal` 实例，用于取消fetch()请求。

##### 4.2.3.5 keepalive

keepalive属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。

一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用keepalive属性，数据可能无法发送，因为浏览器已经把页面卸载了。

```js
window.onunload = function() {
  fetch('/analytics', {
    method: 'POST',
    body: "statistics",
    keepalive: true
  });
};
```

##### 4.2.3.6. redirect

redirect属性指定 HTTP 跳转的处理方法。可能的取值如下：

- follow：默认值，fetch()跟随 HTTP 跳转；
- error：如果发生跳转，fetch()就报错；
- manual：fetch()不跟随 HTTP 跳转，但是response.url属性会指向新的 URL，response.redirected属性会变为true，由开发者自己决定后续如何处理跳转；

##### 4.2.3.7. integrity

integrity属性指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。

比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。

```js
fetch('http://site.com/file', {
  integrity: 'sha256-abcdef'
});
```

##### 4.2.3.8. referrer

referrer属性用于设定fetch()请求的referer标头。

这个属性可以为任意字符串，也可以设为空字符串（即不发送referer标头）。

```js
fetch('/page', {
  referrer: ''
});
```

##### 4.2.3.9. referrerPolicy

referrerPolicy属性用于设定Referer标头的规则。可能的取值如下：

- `no-referrer-when-downgrade`：默认值，总是发送Referer标头，除非从 HTTPS 页面请求 HTTP 资源时不发送；
- `no-referrer`：不发送Referer标头；
- `origin`：Referer标头只包含域名，不包含完整的路径；
- `origin-when-cross-origin`：同源请求Referer标头包含完整的路径，跨域请求只包含域名；
- `same-origin`：跨域请求不发送Referer，同源请求发送；
- `strict-origin`：Referer标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送Referer标头；
- `strict-origin-when-cross-origin`：同源请求时Referer标头包含完整路径，跨域请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头；
- `unsafe-url`：不管什么情况，总是发送Referer标头；

#### 4.2.4. fetch cancel

fetch()请求发送以后，如果中途想要取消，需要使用`AbortController`对象。

```js

let controller = new AbortController();
let signal = controller.signal;

fetch(url, {
  signal: controller.signal
});

signal.addEventListener('abort',
  () => console.log('abort!')
);

controller.abort(); // 取消

console.log(signal.aborted); // true
```

上面示例中，首先新建 AbortController 实例，然后发送fetch()请求，配置对象的signal属性必须指定接收 `AbortController` 实例发送的信号`controller.signal`。

`controller.abort()`方法用于发出取消信号。这时会触发abort事件，这个事件可以监听，也可以通过`controller.signal.aborted`属性判断取消信号是否已经发出。

下面是一个1秒后自动取消请求的例子。

```js
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);

try {
  let response = await fetch('/long-operation', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') {
    console.log('Aborted!');
  } else {
    throw err;
  }
}
```

#### 4.2.5 测试

针对json-server服务，只需要执行：

```js
fetch('http://localhost:3000/posts')
  .then(res => res.json())
  .then(data => {
    console.log(data);
  })
  .catch(err => {
    console.log(err);
  });
```

有兴趣的同学可以参考：[fetch polyfill](https://github.com/github/fetch)

### 4.3 axios

[github地址](https://github.com/axios/axios)

[官网地址](https://axios-http.com/)

axios是一个用于网络请求的第三方库，是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：

- 从浏览器中创建 `XMLHttpRequest`；
- 从 node.js 发出 http 请求；
- 支持 Promise API；
- 拦截请求和响应；
- 转换请求和响应数据；
- 取消请求；
- 自动转换JSON数据；
- 客户端支持防止CSRF/XSRF；

#### 4.3.1 基础使用

Axios 提供了两种不同的形式来发送 HTTP 请求：

##### 4.3.1.1. 方法

`axios(config)` 方法接收一个对象，这个对象包含了一些对请求的配置， axios 会根据这些配置来发送对应的 HTTP 请求

最基本的配置项应该包括：

1. method 请求的方法（可选值： get , post 等）；
2. url 请求的地址 （必须项）；
3. data 请求发送的数据（post等请求需要）；

默认的请求方法是get所以如果是get请求可以不设置method

```js
// 发送 POST 请求
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
});
```

请求响应的处理在 then 和 catch 回调中，请求正常会进入 then ，请求异常则会进 catch

```js
// 发送 POST 请求
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
}).then(res => {
    consloe.log(res)
}).catch(err => {
    console.log(err)
})

// 发送 GET 请求（默认的方法）
axios('/user/12345');
```

##### 4.3.1.2 请求别名

```js
// 发送GET请求
axios.get('/user?ID=12345').then(function (response) {
  console.log(response);
}).catch(function (error) {
  console.log(error);
});

// 发送POST请求
发送post请求
axios.post('/user', {
  firstName: 'Fred',
  lastName: 'Flintstone'
}).then(function (response) {
  console.log(response);
}).catch(function (error) {
  console.log(error);
});
```

#### 4.3.2 响应数据

其中的 data 是后端返回的数据，一般只需要关注 `response` 中的 `data` 字段就行

```js
{
  // `data` 由服务器提供的响应
  data: {},
  // `status` 来自服务器响应的 HTTP 状态码
  status: 200,
  // `statusText` 来自服务器响应的 HTTP 状态信息
  statusText: 'OK',
  // `headers` 服务器响应的头
  headers: {},
   // `config` 是为请求提供的配置信息
  config: {},
 // 'request'
  // `request` is the request that generated this response
  // It is the last ClientRequest instance in node.js (in redirects)
  // and an XMLHttpRequest instance the browser
  request: {}
}
```

#### 4.3.3 创建实例

可以使用自定义配置新建一个 axios 实例 `axios.create([config])`：

```js
const instance = axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});

```

创建的实例中的 axios() api 改为了 request() api，使用方式是一样的，其他如请求别名等函数，都没有改变

以下是实例所拥有的方法

- request(config)；
- get(url[, config])；
- delete(url[, config])；
- head(url[, config])；
- options(url[, config])；
- post(url[, data[, config]])；
- put(url[, data[, config]])；
- patch(url[, data[, config]])；

axios会把这些 方法中的config 会和创建实例时指定的 config 合并到一起使用

#### 4.3.4 拦截器

- `axios.interceptors.request` 请求拦截器
- `axios.interceptors.response` 响应拦截器

```js

// 添加请求拦截器
axios.interceptors.request.use(function (config) {
  // 在发送请求之前做些什么
  config.header["Token"] = "xxxx"
  return config;
}, function (error) {
  // 对请求错误做些什么
  return Promise.reject(error);
});

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
  // 对响应数据做点什么
  if (response.status === 200){
    return response.data
  } else {
    return Promise.reject(new Error('error'))
  }
}, function (error) {
  // 对响应错误做点什么
  return Promise.reject(error);
});
```

如果想要取消拦截器，可以通过使用一个变量来接收设置拦截器时返回的实例，然后使用 eject 来取消拦截器

```js
const myInterceptor = axios.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);
```

#### 4.3.5 完整的请求配置

```js
{
   // `url` 是用于请求的服务器 URL
  url: '/user',
  // `method` 是创建请求时使用的方法
  method: 'get', // default
  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。
  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL
  baseURL: 'https://some-domain.com/api/',
  // `transformRequest` 允许在向服务器发送前，修改请求数据
  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法
  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream
  transformRequest: [function (data, headers) {
    // 对 data 进行任意转换处理
    return data;
  }],
  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据
  transformResponse: [function (data) {
    // 对 data 进行任意转换处理
    return data;
  }],
  // `headers` 是即将被发送的自定义请求头
  headers: {'X-Requested-With': 'XMLHttpRequest'},
  // `params` 是即将与请求一起发送的 URL 参数
  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象
  params: {
    ID: 12345
  },
   // `paramsSerializer` 是一个负责 `params` 序列化的函数
  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
  paramsSerializer: function(params) {
    return Qs.stringify(params, {arrayFormat: 'brackets'})
  },
  // `data` 是作为请求主体被发送的数据
  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'
  // 在没有设置 `transformRequest` 时，必须是以下类型之一：
  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - 浏览器专属：FormData, File, Blob
  // - Node 专属： Stream
  data: {
    firstName: 'Fred'
  },
  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)
  // 如果请求话费了超过 `timeout` 的时间，请求将被中断
  timeout: 1000,
   // `withCredentials` 表示跨域请求时是否需要使用凭证
  withCredentials: false, // default
  // `adapter` 允许自定义处理请求，以使测试更轻松
  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).
  adapter: function (config) {
    /* ... */
  },
 // `auth` 表示应该使用 HTTP 基础验证，并提供凭据
  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },
   // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'
  responseType: 'json', // default
  // `responseEncoding` indicates encoding to use for decoding responses
  // Note: Ignored for `responseType` of 'stream' or client-side requests
  responseEncoding: 'utf8', // default
   // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称
  xsrfCookieName: 'XSRF-TOKEN', // default
  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value
  xsrfHeaderName: 'X-XSRF-TOKEN', // default
   // `onUploadProgress` 允许为上传处理进度事件
  onUploadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },
  // `onDownloadProgress` 允许为下载处理进度事件
  onDownloadProgress: function (progressEvent) {
    // 对原生进度事件的处理
  },
   // `maxContentLength` 定义允许的响应内容的最大尺寸
  maxContentLength: 2000,
  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte
  validateStatus: function (status) {
    return status >= 200 && status < 300; // default
  },
  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目
  // 如果设置为0，将不会 follow 任何重定向
  maxRedirects: 5, // default
  // `socketPath` defines a UNIX Socket to be used in node.js.
  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.
  // Only either `socketPath` or `proxy` can be specified.
  // If both are specified, `socketPath` is used.
  socketPath: null, // default
  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：
  // `keepAlive` 默认没有启用
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),
  // 'proxy' 定义代理服务器的主机名称和端口
  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据
  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。
  proxy: {
    host: '127.0.0.1',
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },
  // `cancelToken` 指定用于取消请求的 cancel token
  // （查看后面的 Cancellation 这节了解更多）
  cancelToken: new CancelToken(function (cancel) {
  })
}

```

#### 4.3.6 测试

针对`json-server`服务，只需要执行：

```js
const axios = require('axios');

axios
  .get('http://localhost:3000/posts')
  .then(function (response) {
    // handle success
    console.log(response);
  })
  .catch(function (error) {
    // handle error
    console.log(error);
  })
  .then(function () {
    // always executed
  });

```

### 4.4. 总结

1. Ajax 是`Async Javascript And Xml`的简称，它是原生JavaScript的一种请求方案，利用 XMLHttpRequest 进行异步请求数据，实现无感刷新数据；
2. Fetch 是 ES6 新推出的一套异步请求方案，它天生自带 Promise，同时也是原生的，如果在较小项目中为了项目大小着想和兼容性不是那么高的前提下不妨可以用它来进行异步请求也是不错的；
3. Axios 是基于 Ajax 和 Promise 封装的一个库，可以利用Promise来更好的管控请求回调嵌套造成的回调地狱；

# **JavaScript的垃圾回收和内存泄漏**

https://www.yuque.com/lpldplws/atomml/my01zht47ol0dh2u?singleDoc# 《JavaScript的垃圾回收和内存泄漏》 密码：kb86

## 1. 课程目标

1. 掌握JavaScript和V8中的垃圾回收机制；
2. 掌握常见的内存泄漏事件及排查方法；

## 2. 课程大纲

1. JavaScript的垃圾回收机制；
2. JavaScript的内存泄漏；

## 3. JavaScript的垃圾回收机制

### 3.1. 什么是GC

GC 即 `Garbage Collection` ，程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 GC 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，GC 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 `垃圾回收机制`。

当然也不是所有语言都有 GC，一般的高级语言里面会自带 GC，比如 Java、Python、JavaScript 等，也有无 GC 的语言，比如 C、C++ 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦。

### 3.2. 垃圾产生&为何回收

我们知道写代码时创建一个基本类型、对象、函数等时都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显式手动的去分配内存
我们举个简单的例子：

```js
let test = {
  name: "xianzao"
};
test = [1,2,3,4,5]
```

假设它是一个完整的程序代码

我们知道 JavaScript 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，所以，JavaScript 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的。

那上面代码首先我们声明了一个变量 test，它引用了对象 {name: 'xianzao'}，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，如下图

```js
堆     	      栈
test   ->    {name: "xianzao"}
test   ->    [1,2,3,4,5]
```

没有了引用关系后，这部分内存就不会被使用了，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）。

程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃。

### 3.3. 垃圾回收策略

在 JavaScript 内存管理中有一个概念叫做 `可达性`，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收。

至于如何回收，其实就是怎样发现这些不可达的对象（垃圾）它并给予清理的问题， JavaScript 垃圾回收机制的原理就是定期找出那些不再用到的内存（变量），然后释放其内存。（不是实时的找出无用内存并释放的原因：实时开销太大了）。

#### 3.3.1. 标记清除法

##### 3.3.1.1. 策略

标记清除（`Mark-Sweep`），目前在 JavaScript引擎 里这种算法是最常用的，到目前为止的大多数浏览器的 JavaScript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript引擎 在运行垃圾回收的频率上有所差异。

此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。

你可能会疑惑怎么给变量加标记？

1. 当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记）；
2. 维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表；

其实，怎样标记对我们来说并不重要，重要的是策略。

引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 全局Window对象、文档DOM树 等。

整个标记清除算法大致过程就像下面这样：

1. 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0；
2. 然后从各个根对象开始遍历，把不是垃圾的节点改成1；
3. 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间；
4. 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收；

##### 3.3.1.2. 优点

实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单

##### 3.3.1.3. 缺点

在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092420475-d1abba3c-6ec4-40a5-92c4-1da4e53c8dfe.png)

假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配:

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092419187-0ff8a6ee-85c1-4a9c-8bc0-745843ebfd04.png)

常见包括三种分配策略找到合适的块内存：

1. `First-fit`，找到大于等于 size 的块立即返回；
2. `Best-fit`，遍历整个空闲列表，返回大于等于 size 的最小分块；
3. `Worst-fit`，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回

这三种策略里面 `Worst-fit` 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于` First-fit` 和 `Best-fit`来说，考虑到分配的速度和效率 First-fit 是更为明智的选择

综上所述，标记清除算法或者说策略就有两个很明显的缺点：

1. 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块；
2. 分配速度慢，因为即便是使用 `First-fit` 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢；

归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了

而 标记整理（Mark-Compact）算法 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092423372-e0a9490e-095c-4340-b713-b0edd65a9c65.png)

#### 3.3.2. 引用计数算法

##### 3.3.2.1. 策略

引用计数（`Reference Counting`），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，但因为它的问题很多，目前很少使用这种算法了。

它的策略是跟踪记录每个变量值被使用的次数

1. 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1；
2. 如果同一个值又被赋给另一个变量，那么引用数加 1；
3. 如果该变量的值被其他的值覆盖了，则引用次数减 1；
4. 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存；

```js
let a = new Object() 	// 此对象的引用计数为 1（a引用）
let b = a 		// 此对象的引用计数是 2（a,b引用）
a = null  		// 此对象的引用计数为 1（b引用）
b = null 	 	// 此对象的引用计数为 0（无引用）
...			// GC 回收此对象
```

虽然这种方式很简单，但是在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A：

```js
function test(){
  let A = new Object()
  let B = new Object()
  
  A.b = B
  B.a = A
}
```

对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 test 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放。

我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一。

在 IE8 以及更早版本的 IE 中，BOM 和 DOM 对象并非是原生 JavaScript 对象，它是由 C++ 实现的 组件对象模型对象（COM，Component Object Model），而 COM 对象使用 引用计数算法来实现垃圾回收，所以即使浏览器使用的是标记清除算法，只要涉及到  COM 对象的循环引用，就还是无法被回收掉，就比如两个互相引用的 DOM 对象等等，而想要解决循环引用，需要将引用地址置为 null 来切断变量与之前引用值的关系：

不过在 IE9 及以后的 BOM 与 DOM 对象都改成了 JavaScript 对象，也就避免了上面的问题。

```js
// COM对象 
let ele = document.getElementById("xxx")
let obj = new Object() 

// 造成循环引用 
obj.ele = ele 
ele.obj = obj

// 切断引用关系 
obj.ele = null 
ele.obj = null
```

##### 3.3.2.2. 优点

1. 引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾；
2. 标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了；

##### 3.3.2.3. 缺点

1. 需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限；
2. 无法解决循环引用无法回收的问题；

### 3.4 V8对GC的优化

#### 3.4.1. 分代式垃圾回收

上文所说的垃圾回收策略在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说，同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，这也是分代式的原则。

##### 3.4.1.1. 新老生代

V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。

新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大

V8 整个堆内存的大小就等于新生代加上老生代的内存：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092423162-0bd1d171-318b-425c-b623-3a1295c3d72a.png)

对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器。

##### 3.4.1.2. 新生代垃圾回收

新生代对象是通过一个名为 `Scavenge` 的算法进行垃圾回收，在 `Scavenge`算法 的具体实现中，主要采用了一种复制式的方法即 `Cheney`算法：

`Cheney`算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092423947-e7c13bc1-b9f4-431a-bc36-4b56d8bd67af.png)

新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。

当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。

当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理。

另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。

##### 3.4.1.3. 老生代垃圾回收

相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是标记清除了。

首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。

清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。

前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了上文中说的标记整理算法来解决这一问题来优化空间。

分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率。

#### 3.4.2. 并行回收(Parallel)

先了解一个概念：全停顿（`Stop-The-World`），我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 全停顿。

比如一次 GC 需要 60ms ，那我们的应用逻辑就得暂停 60ms ，假如一次 GC 的时间过长，对用户来说就可能造成页面卡顿等问题。这里，引入多个辅助线程来同时处理，以此加速垃圾回收的执行速度，因此 V8 团队引入了并行回收机制。

所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作。

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092421822-e71467b9-bb01-4bc6-a8ca-a9cb4d8c53a1.png)

简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了。

新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，这就是并行回收。

#### 3.4.3. 增量标记与懒性清理

并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然可能会消耗大量时间。

所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记。

##### 3.4.3.1. 什么是增量

增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 GC 标记：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092423467-06f47b6e-c3d5-4366-a8a4-0a7e71c66097.png)将一次完整的 GC 标记分次执行，那在每一小次 GC 标记执行完之后如何暂停下来去执行任务程序，而后又怎么恢复呢？那假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢？

##### 3.4.3.2. 三色标记法(暂停与恢复)

我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法之前，单纯使用黑色和白色来标记数据就可以了，其标记流程即在执行一次完整的 GC 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在会从一组跟对象出发，将所有能访问到的数据标记为黑色，遍历结束之后，标记为黑色的数据对象就是活动对象，剩余的白色数据对象也就是待清理的垃圾对象。

如果采用非黑即白的标记策略，那在垃圾回收器执行了一段增量回收后，暂停后启用主线程去执行了应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了

为了解决这个问题，V8 团队采用了一种特殊方式： 三色标记法

三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑

1. 白色指的是未被标记的对象；
2. 灰色指自身被标记，成员变量（该对象的引用对象）未被标记；
3. 黑色指自身和成员变量皆被标记；

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092424752-ed9ce30f-d088-48f5-97ff-10bf496e4652.png)

如上图所示，我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色；

就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 C、E 将要等待回收）。

采用三色标记法后我们在恢复执行时就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以。

三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 全停顿 的时间。

##### 3.4.3.3. 写屏障(增量中修改引用)

一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了，增量中修改引用，可能不太好理解，我们举个例子：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092425720-52f7efe6-6ccb-4e17-a1f0-d4190d4f8c9e.png)

假如我们有 A、B、C 三个对象依次引用，在第一次增量分段中全部标记为黑色（活动对象），而后暂停开始执行应用程序也就是 JavaScript 脚本，在脚本中我们将对象 B 的指向由对象 C 改为了对象 D ，接着恢复执行下一次增量分段。

这时其实对象 C 已经无引用关系了，但是目前它是黑色（代表活动对象）此一整轮 GC 是不会清理 C 的，不过我们可以不考虑这个，因为就算此轮不清理等下一轮 GC 也会清理，这对我们程序运行并没有太大影响。

我们再看新的对象 D 是初始的白色，按照我们上面所说，已经没有灰色对象了，也就是全部标记完毕接下来要进行清理了，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收，还有引用关系就被回收，后面我们程序里可能还会用到对象 D 呢，这肯定是不对的。

为了解决这个问题，V8 增量回收使用 写屏障 (`Write-barrier`) 机制，即一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 GC 标记阶段可以正确标记，这个机制也被称作 强三色不变性。

那在我们上图的例子中，将对象 B 的指向由对象 C 改为对象 D 后，白色对象 D 会被强制改为灰色。

##### 3.4.3.4. 懒性清理

增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理(`Lazy Sweeping`)

增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记。

##### 3.4.3.5. 增量标记与惰性清理的优缺？

增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：

1. 并没有减少主线程的总暂停的时间，甚至会略微增加；
2. 由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量；

#### 3.4.4. 并发回收(Concurrent)

前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量两个缺点，那么怎么才能在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢？

这就要说到并发回收了，它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092425501-75560169-0fc6-4607-9d9a-cd96a03db8fe.png)

辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 JavaScript  时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点。

#### 3.4.4. 总结

V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，上述的这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的：

1. 老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）；
2. 标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）；
3. 清理的任务会采用增量的方式分批在各个 JavaScript 任务之间执行；

## 4. JavaScript的内存泄漏

### 4.1. 什么是内存泄漏

引擎中有垃圾回收机制，它主要针对一些程序中不再使用的对象，对其清理回收释放掉内存。

那么垃圾回收机制会把不再使用的对象（垃圾）全都回收掉吗？

其实引擎虽然针对垃圾回收做了各种优化从而尽可能的确保垃圾得以回收，但并不是说我们就可以完全不用关心这块了，我们代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的对象内存，没有及时被回收时，这种场景称之为内存泄漏（`Memory leak`）。

### 4.2. 常见的内存泄漏

#### 4.2.1. 不正当的闭包

闭包是指有权访问另一个函数作用域中的变量的函数

```javascript
function fn1(){
  let test = new Array(1000).fill('xianzao')
  return function(){
    console.log('zaoxian')
  }
}
let fn1Child = fn1()
fn1Child()
```

Q：上例是闭包吗？它造成内存泄漏了吗？

显然它是一个典型闭包，但是它并没有造成内存泄漏，因为返回的函数中并没有对 fn1 函数内部的引用，也就是说，函数 fn1 内部的 test 变量完全是可以被回收的，再来看：

```javascript
function fn2(){
  let test = new Array(1000).fill('xianzao')
  return function(){
    console.log(test)
    return test
  }
}
let fn2Child = fn2()
fn2Child()
```

Q：上例是闭包吗？它造成内存泄漏了吗？

显然它也是闭包，并且因为 return 的函数中存在函数 fn2 中的 test 变量引用，所以 test 并不会被回收，也就造成了内存泄漏。

那么怎样解决呢？

其实在函数调用后，把外部的引用关系置空就好了，如下：

```js
function fn2(){
  let test = new Array(1000).fill('xianzao')
  return function(){
    console.log(test)
    return test
  }
}
let fn2Child = fn2()
fn2Child()
fn2Child = null
```

#### 4.2.2. 隐式全局变量

JavaScript 的垃圾回收是自动执行的，垃圾回收器每隔一段时间就会找出那些不再使用的数据，并释放其所占用的内存空间。

再来看全局变量和局部变量，函数中的局部变量在函数执行结束后这些变量已经不再被需要，所以垃圾回收器会识别并释放它们。但是对于全局变量，垃圾回收器很难判断这些变量什么时候才不被需要，所以全局变量通常不会被回收，我们使用全局变量是 OK 的，但同时我们要避免一些额外的全局变量产生，如下：

```javascript
function fn(){
  // 没有声明从而制造了隐式全局变量test1
  test1 = new Array(1000).fill('xianzao')
  
  // 函数内部this指向window，制造了隐式全局变量test2
  this.test2 = new Array(1000).fill('xianzao')
}
fn()
```

调用函数 fn ，因为 没有声明 和 函数中this 的问题造成了两个额外的隐式全局变量，这两个变量不会被回收，这种情况我们要尽可能的避免，在开发中我们可以使用严格模式或者通过 lint 检查来避免这些情况的发生，从而降低内存成本。

除此之外，我们在程序中也会不可避免的使用全局变量，这些全局变量除非被取消或者重新分配之外也是无法回收的，这也就需要我们额外的关注，也就是说当我们在使用全局变量存储数据时，要确保使用后将其置空或者重新分配，当然也很简单，在使用完将其置为 null 即可，特别是在使用全局变量做持续存储大量数据的缓存时，我们一定要记得设置存储上限并及时清理，不然的话数据量越来越大，内存压力也会随之增高。

```javascript
var test = new Array(10000)

// do something

test = null
```

#### 4.2.3. 游离DOM引用

考虑到性能或代码简洁方面，我们代码中进行 DOM 时会使用变量缓存 DOM 节点的引用，但移除节点的时候，我们应该同步释放缓存的引用，否则游离的子树无法释放：

```javascript
<div id="root">
  <ul id="ul">
    <li></li>
    <li></li>
    <li id="li3"></li>
    <li></li>
  </ul>
</div>
<script>
  let root = document.querySelector('#root')
  let ul = document.querySelector('#ul')
  let li3 = document.querySelector('#li3')
  
  // 由于ul变量存在，整个ul及其子元素都不能GC
  root.removeChild(ul)
  
  // 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC
  ul = null
  
  // 已无变量引用，此时可以GC
  li3 = null
</script>
```

如上所示，当我们使用变量缓存 DOM 节点引用后删除了节点，如果不将缓存引用的变量置空，依然进行不了 GC，也就会出现内存泄漏。

假如我们将父节点置空，但是被删除的父节点其子节点引用也缓存在变量里，那么就会导致整个父 DOM 节点树下整个游离节点树均无法清理，还是会出现内存泄漏，解决办法就是将引用子节点的变量也置空，如下图：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092426328-6cbba7d6-1fe6-4fc9-87ea-8bb56cc29bb7.png)

#### 4.2.4. 定时器

开发时我们经常会用到计时器，也就是 `setTimeout` 和 `setInterval`，先来看一个例子：

```javascript
// 获取数据
let someResource = getData()
setInterval(() => {
  const node = document.getElementById('Node')
	if(node) {
    node.innerHTML = JSON.stringify(someResource))
	}
}, 1000)
```

代码中每隔一秒就将得到的数据放入到 Node 节点中去，但是在 `setInterval` 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。

什么才叫结束呢？也就是调用了 `clearInterval`。如果没有被 clear 掉的话，就会造成内存泄漏。不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。所以在上例中，`someResource` 就没法被回收。

同样，`setTiemout` 也会有同样的问题，所以，当不需要 interval 或者 timeout 时，最好调用 `clearInterval` 或者 `clearTimeout`来清除，另外，浏览器中的 `requestAnimationFrame` 也存在这个问题，我们需要在不需要的时候用 `cancelAnimationFrame` API 来取消使用。

#### 4.2.5. 事件监听器

当事件监听器在组件内挂载相关的事件处理函数，而在组件销毁时不主动将其清除时，其中引用的变量或者函数都被认为是需要的而不会进行回收，如果内部引用的变量存储了大量数据，可能会引起页面占用内存过高，这样就造成意外的内存泄漏。

我们就拿 Vue 组件来举例子，React 里也是一样的：

```javascript
<template>
  <div></div>
</template>

<script>
export default {
  created() {
    window.addEventListener("resize", this.doSomething)
  },
  beforeDestroy(){
    window.removeEventListener("resize", this.doSomething)
  },
  methods: {
    doSomething() {
      // do something
    }
  }
}
</script>
```

#### 4.2.6. Map、Set对象

当使用 Map 或 Set 存储对象时，同 Object 一致都是强引用，如果不将其主动清除引用，其同样会造成内存不自动进行回收。

如果使用 Map ，对于键为对象的情况，可以采用 WeakMap，WeakMap 对象同样用来保存键值对，对于键是弱引用（注：WeakMap 只对于键是弱引用），且必须为一个对象，而值可以是任意的对象或者原始值，由于是对于对象的弱引用，不会干扰 Js 的垃圾回收。

如果需要使用 Set 引用对象，可以采用 WeakSet，WeakSet 对象允许存储对象弱引用的唯一值，WeakSet 对象中的值同样不会重复，且只能保存对象的弱引用，同样由于是对于对象的弱引用，不会干扰 Js 的垃圾回收。

这里可能需要简单介绍下，谈弱引用，我们先来说强引用，之前我们说 JS 的垃圾回收机制是如果我们持有对一个对象的引用，那么这个对象就不会被垃圾回收，这里的引用，指的就是 强引用 ，而弱引用就是一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，因此可能在任何时刻被回收。

```javascript
// obj是一个强引用，对象存于内存，可用
let obj = {id: 1}

// 重写obj引用
obj = null 
// 对象从内存移除，回收 {id: 1} 对象
```

这是一个简单的通过重写引用来清除对象引用，使其可回收。

再看下面这个：

```javascript
let obj = {id: 1}
let user = {info: obj}
let set = new Set([obj])
let map = new Map([[obj, 'xianzao']])

// 重写obj
obj = null 

console.log(user.info) // {id: 1}
console.log(set)
console.log(map)
```

这里重写了 obj 以后，`{id: 1}` 依然会存在于内存中，因为 user 对象以及后面的 set/map 都强引用了它，Set/Map、对象、数组对象等都是强引用，所以我们仍然可以获取到` {id: 1}` ，我们想要清除那就只能重写所有引用将其置空了。

接下来我们看 WeakMap 以及 WeakSet：

```js
let obj = {id: 1}
let weakSet = new WeakSet([obj])
let weakMap = new WeakMap([[obj, 'xianzao']])

// 重写obj引用
obj = null

// {id: 1} 将在下一次 GC 中从内存中删除
```

使用了 WeakMap 以及 WeakSet 即为弱引用，将 obj 引用置为 null 后，对象 {id: 1} 将在下一次 GC 中被清理出内存。

#### 4.2.7 console 

在一些小团队中可能项目上线也不清理这些 console，殊不知这些 console 也是隐患，同时也是容易被忽略的，我们之所以在控制台能看到数据输出，是因为浏览器保存了我们输出对象的信息数据引用，也正是因此未清理的 console 如果输出了对象也会造成内存泄漏。

所以，开发环境下我们可以使用控制台输出来便于我们调试，但是在生产环境下，一定要及时清理掉输出。

### 4.3  内存泄漏排查、定位与修复 

 

首先来看个例子：

```js
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>test</title>
  </head>

  <body>
    <button id="click">click</button>
    <h1 id="content"></h1>

    <script>
      let click = document.querySelector('#click');
      let content = document.querySelector('#content');
      let arr = [];

      function closures() {
        let test = new Array(10000).fill('xianzao');

        return function () {
          return test;
        };
      }

      click.addEventListener('click', function () {
        arr.push(closures());
        arr.push(closures());
        arr.push(closures());
        arr.push(closures());
        arr.push(closures());
        arr.push(closures());
        arr.push(closures());
        arr.push(closures());
        arr.push(closures());
        arr.push(closures());

        content.innerHTML = arr.length;
      });
    </script>
  </body>
</html>
```

这是一个由不正当使用闭包构成的内存泄漏例子。

有一个 closures 函数，这是一个闭包函数，我们为页面中的 button 元素绑定了一个点击事件，每次点击都将执行 10 次闭包函数并将其执行结果 push 到全局数组 arr 中，由于闭包函数执行结果也是一个函数并且存在对原闭包函数内部数组 test 的引用，所以 arr 数组中每一项元素都使得其引用的闭包内部 test 数组对象无法回收，arr 数组有多少元素，也就代表着我们存在多少次闭包引用，所以此程序点击次数越多，push 的越多，内存消耗越大，页面也会越来越卡。

#### 4.3.1排查问题

 

一般我们会使用Chrome的 devTool来排查问题，通过它可以帮助我们分析程序中像性能、安全、网络等各种东西，也可以让我们快速定位到问题源。

找到 Performance 这一面板，它可以记录并分析在网站的生命周期内所发生的各类事件，我们就可以通过它监控我们程序中的各种性能情况并分析，其中就包括内存，如下图：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092426387-fd13498f-8da2-4571-938c-2212da73322f.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

先清理一下GC，点击开始录制进入录制状态，接着疯狂点击页面中 click 按钮 20 次，这时页面上的数值应该是 200，我们再点击一下小垃圾桶，手动触发一次 GC。

再次疯狂点击页面中 click 按钮 20 次，这时页面上的数值应该是 400，然后停止录制。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092427189-ee30fdbb-8922-4b70-8b1b-e3141f05e2b4.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

这时候我们可以发现：尽管我们在点击10次后执行GC，但heap并没有清空，这就是内存泄漏。

#### 4.3.2 分析定位

Chrome Devtool 还为我们提供了 Memory 面板，它可以为我们提供更多详细信息，比如记录 JS CPU 执行时间细节、显示 JS 对象和相关的DOM节点的内存消耗、记录内存的分配细节等。

其中的 Heap Profiling 可以记录当前的堆内存 heap 的快照，并生成对象的描述文件，该描述文件给出了当下 JS 运行所用的所有对象，以及这些对象所占用的内存大小、引用的层级关系等等，用它就可以定位出引起问题的具体原因以及位置。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092428730-e717c302-254c-44d6-9024-af74d36d2124.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

重新刷新下页面，清除GC，生成第一次快照：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092429079-dade0e22-6bda-48c1-bc40-4f128f5267b7.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

左侧列表中的 Snapshot 1 代表了我们生成的快照1，也就是刚刚那一刻的内存状态。

选中 Snapshot 1 后就是右侧视图表格了，表格左上方有一个下拉框，它有四个值：

1. Summary：按照构造函数进行分组，捕获对象和其使用内存的情况，可理解为一个内存摘要，用于跟踪定位DOM节点的内存泄漏；

2. Comparison：对比某个操作前后的内存快照区别，分析操作前后内存释放情况等，便于确认内存是否存在泄漏及造成原因；

3. Containment：探测堆的具体内容，提供一个视图来查看对象结构，有助分析对象引用情况，可分析闭包及更深层次的对象分析；

4. Statistics：统计视图；

该下拉默认会为我们选择 Summary ，所以下方表格展示的就是快照1中数据的内存摘要，简单理解就是快照1生成的那一刻，内存中都存了什么，包括占用内存的信息等等。

接下来来简单了解下 Summary 选项数据表格的列都表示什么

1. Constructor：显示所有的构造函数，点击每一个构造函数可以查看由该构造函数创建的所有对象；

2. Distance：显示通过最短的节点路径到根节点的距离，引用层级；

3. Shallow Size：显示对象所占内存，不包含内部引用的其他对象所占的内存；

4. Retained Size：显示对象所占的总内存，包含内部引用的其他对象所占的内存；

然后同上述操作一样，清除GC，点击一次click，再生成快照，总共生成四次快照。

接下来可以比较第三次和第四次快照中的数据对比：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092429499-bde63d56-38d2-432c-be35-a5b34d58b8e0.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

这样可以过滤很多没有变化的数据，方便对比。

其中，Constructor列是构造函数，每一个构造函数点击都可以查看由该构造函数创建的所有对象，还是要先介绍下此列中常见的构造函数大致代表什么：

1. system、system/Context 表示引擎自己创建的以及上下文创建的一些引用，这些不用太关注，不重要；

2. closure 表示一些函数闭包中的对象引用；

3. array、string、number、regexp 这一系列也能看出，就是引用了数组、字符串、数字或正则表达式的对象类型；

4. HTMLDivElement、HTMLAnchorElement、DocumentFragment等等这些其实就是你的代码中对元素的引用或者指定的 DOM 对象引用；

##### 4.3.2.1 closure

 

首先看闭包，可以发现有10次闭包，指向第20行：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092429886-64ba3fb1-39e1-4562-a406-10dda257f282.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092429470-ecf45278-6285-4c23-bb21-bec636191efd.png?x-oss-process=image%2Fresize%2Cw_1314%2Climit_0)

说明哪怕清除GC后，还是有闭包数据导致占用内存。

##### 4.3.2.2 array

 

这里array可以发现，是由于每次执行10次arr.push(closures())导致的，数量也是10，且在GC清除后，数据内容都为上次基础之上添加的"xianzao"。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671092432872-13612ff8-d60d-4099-8321-bede17c697ed.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

##### 4.3.2.3 总结

 

至此，可以确认，错误有两点：

1. 20行的闭包引用数组造成的内存泄漏；

2. 全局变量 arr 的元素不断增多造成的内存泄漏；

#### 4.3.3 修复验证

 

在实际项目中，比如全局对象一直增大这个问题，全局对象我们无法避免，但是可以限制一下全局对象的大小，根据场景可以超出就清理一部分。

比如闭包引用的问题，不让它引用，或者执行完置空。

总之，一切都需要根据具体场景选择解决方案，解决之后重复上面排查流程看内存即可。

### 4.4 常见的前端内存问题 

 

1. 内存泄漏：主要注意上述问题；

2. 内存膨胀：即在短时间内内存占用极速上升到达一个峰值，想要避免需要使用技术手段减少对内存的占用；

3. 频繁 GC：GC 执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 GC，频繁 GC 同样会导致页面卡顿，想要避免的话就不要搞太多的临时变量，因为临时变量不用了就会被回收；

# 前端异步处理规范及应用

https://www.yuque.com/lpldplws/atomml/gtn6hvlf3fh1gl6e?singleDoc# 《前端异步处理规范及应用》 密码：cdik

## 1.课程目标

 

1. 掌握Promise、async/await及generator的定义及用法；

2. 手动实现Promise和async/await；

## 2.课程大纲

1. 简版Promise；

2. Promise/A+规范解读；

3. async/await介绍；

4. generator介绍；

 

## 3.简版Promise

### 3.1 reolve和reject

```js
let p1=new Promise((resolve,reject)=>{
    resolve('success');
    reject('fail');
});
console.log('p1',p1);
let p2=new Promise((resolve,reject)=>{
    reject('success');
    resolve('fail');
})
console.log('p2',p2);
let p3=new Promise((resolve,reject)=>{
    throw 'error';
})

console.log('p3',p3);

//p1 Promise{<fulfilled>:'success'}
//p2 Promise{<rejected>:'success'}
//p3 Promise{<rejected>:'error'}
```

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1670244647596-10c599c5-b64e-46a3-99e0-31e55de924b5.png)

这里说明了Promise的四个特点：

1. 执行了resolve，Promise状态会变成fulfilled；
2. 执行了reject，Promise状态会变成rejected；
3. Promise状态不可逆，第一次成功就永久为fulfilled，第一次失败就永远状态为rejected；
4. Promise中有throw的话，就相当于执行了reject；

#### 3.1.1实现resolve reject

1. Promise的初始化状态是pending
2. 需要对resolve和reject绑定this：确定resolve和reject的this指向永远指向当前的MyPromise实例，防止随着函数执行环境的改变而改变

```js
class MyPromise{
     constructor(executor){
         //初始状态
         this.initValue();
         //初始化this指向
         this.initBind();
         //执行传入的函数
         try{
             executor(this.resolve,this.reject); 
         }catch(e){
             this.reject(e)
         }
        
     }
    
    initValue(){
        this.PromiseResult=null;
        this.PromiseState='pending';
    }
    
    initBind(){
        this.reolve=this.resolve.bind(this);
        this.reject=this.reject.bind(this); //绑定MyPromise的实例
    }
    
    resolve(val){
        if(this.PromiseState!=='pending'){ return}
        this.PromiseResult=value;
        this.PomiseState='fullfilled'
    }
    
    reject(reason){
         if(this.PromiseState!=='pending'){ return}
         this.PromiseResult=reason;
        this.PomiseState='rejected'
    }
    
}
```

测试如下：

```js
const test1 = new MyPromise((resolve, reject) => {
    resolve('success')
})
console.log(test1) // MyPromise { PromiseState: 'fulfilled', PromiseResult: 'success' }

const test2 = new MyPromise((resolve, reject) => {
    reject('fail')
})
console.log(test2) // MyPromise { PromiseState: 'rejected', PromiseResult: 'fail' }
```

#### 3.1.2 状态不可变

```js
const test1 = new MyPromise((resolve, reject) => {
    resolve('success')
    reject('fail')
})
console.log(test1) // MyPromise { PromiseState: 'rejected', PromiseResult: 'fail' }
```

正确的应该是状态为fulfilled，但这里状态又变成了rejected。

Promise有三种状态：

- pending：等待中，是初始状态；
- fulfilled：成功状态；
- rejected：失败状态；

一旦状态从pending变为fulfilled或者rejected，那么此Promise实例的状态就不可以改变了。

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1670244647795-2efa2831-a1d5-4849-af3a-107ea7c701fc.png)

这步只需要:

```js
    resolve(value) {
        // state是不可变的
+        if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
    }

    reject(reason) {
        // state是不可变的
+        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
    }
```

也就是：

```js
class MyPromise {
    // 构造方法
    constructor(executor) {
        // 初始化值
        this.initValue()
        // 初始化this指向
        this.initBind()
        // 执行传进来的函数
        executor(this.resolve, this.reject)
    }

    initBind() {
        // 初始化this
        this.resolve = this.resolve.bind(this)
        this.reject = this.reject.bind(this)
    }

    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态
    }

    resolve(value) {
        // state是不可变的
      	if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
    }

    reject(reason) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
    }
}
```

结果如下：

```js
const test1 = new MyPromise((resolve, reject) => {
    // 只以第一次为准
    resolve('success')
    reject('fail')
})
console.log(test1) // MyPromise { PromiseState: 'fulfilled', PromiseResult: 'success' }
```

#### 3.1.3 throw

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1670244647961-dd8a421b-4cb2-45fd-a20c-b7ce03f338b2.png)

Promise中有throw的话，就相当于执行了reject。这就要使用try catch了

```js
+        try {
            // 执行传进来的函数
            executor(this.resolve, this.reject)
+        } catch (e) {
            // 捕捉到错误直接执行reject
+            this.reject(e)
+        }
```

完整代码为：

```js
class MyPromise {
    // 构造方法
    constructor(executor) {

        // 初始化值
        this.initValue()
        // 初始化this指向
        this.initBind()
      	try {
            // 执行传进来的函数
            executor(this.resolve, this.reject)
        } catch (e) {
            // 捕捉到错误直接执行reject
            this.reject(e)
        }
    }

    initBind() {
        // 初始化this
        this.resolve = this.resolve.bind(this)
        this.reject = this.reject.bind(this)
    }

    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态
    }

    resolve(value) {
        // state是不可变的
      	if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
    }

    reject(reason) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
    }
}
```

测试代码:

```js
const test3 = new MyPromise((resolve, reject) => {
    throw('fail')
})
console.log(test3) // MyPromise { PromiseState: 'rejected', PromiseResult: 'fail' }
```

### 3.2 then

平时业务中then的使用一般如下：

```js
// 马上输出 ”success“
const p1 = new Promise((resolve, reject) => {
    resolve('success')
}).then(res => console.log(res), err => console.log(err))

// 1秒后输出 ”fail“
const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('fail')
    }, 1000)
}).then(res => console.log(res), err => console.log(err))

// 链式调用 输出 200
const p3 = new Promise((resolve, reject) => {
    resolve(100)
}).then(res => 2 * res, err => console.log(err))
  .then(res => console.log(res), err => console.log(err))
```

根据上述代码可以确定：

1. then接收两个回调，一个是成功回调，一个是失败回调；
2. 当Promise状态为fulfilled执行成功回调，为rejected执行失败回调；
3. 如resolve或reject在定时器里，则定时器结束后再执行then；
4. then支持链式调用，下一次then执行受上一次then返回值的影响；

#### 3.2.1 实现then源码实现

```js
  then(onFulfilled,onRejected){
    //参数校验，确保一定是函数
    onFulfilled=typeof onFulfilled==='function'?onFulfilled:val=>val;
    onRejected=typeof onRejected==='function'?onRejected:reason=>{throw reason};     
if(this.PromiseState==='fulfilled'){
        //如果当前为成功状态，执行第一个回调
        onFulfilled(this.PromiseResult);
    }else if(this.PromiseState==='rejected'){
        //如果当前为失败状态，执行第二个回调
        onRejected(this.PromiseResult)
    }
  }
```

完整代码为：

```js
class MyPromise {
    // 构造方法
    constructor(executor) {

        // 初始化值
        this.initValue()
        // 初始化this指向
        this.initBind()
      	try {
            // 执行传进来的函数
            executor(this.resolve, this.reject)
        } catch (e) {
            // 捕捉到错误直接执行reject
            this.reject(e)
        }
    }

    initBind() {
        // 初始化this
        this.resolve = this.resolve.bind(this)
        this.reject = this.reject.bind(this)
    }

    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态
    }

    resolve(value) {
        // state是不可变的
      	if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
    }

    reject(reason) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
    }

    then(onFulfilled, onRejected) {
      // 接收两个回调 onFulfilled, onRejected
      
      // 参数校验，确保一定是函数
      onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
      onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }

      if (this.PromiseState === 'fulfilled') {
          // 如果当前为成功状态，执行第一个回调
          onFulfilled(this.PromiseResult)
      } else if (this.PromiseState === 'rejected') {
          // 如果当前为失败状态，执行第二哥回调
          onRejected(this.PromiseResult)
      }

    }
}
```

测试then的结果为：

```js
// 输出 ”success“
const test = new MyPromise((resolve, reject) => {
    resolve('success')
}).then(res => console.log(res), err => console.log(err))
```

#### 3.2.2 定时器

如何保证下述代码能够在1s后执行then的回调？

```js
// 1秒后输出 ”fail“
const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('fail')
    }, 1000)
}).then(res => console.log(res), err => console.log(err))
```

我们不能确保1秒后才执行then函数，但是我们可以保证1秒后再执行then里的回调（后续课程的事件循环会讲到）

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1670244647986-826eb3a0-2e61-4f55-9289-f5e335a3a16b.png)

在这1秒时间内，我们可以先把then里的两个回调保存起来，然后等到1秒过后，执行了resolve或者reject，咱们再去判断状态，并且判断要去执行刚刚保存的两个回调中的哪一个回调。

那么问题来了，我们怎么知道当前1秒还没走完甚至还没开始走呢？其实很好判断，只要状态是pending，那就证明定时器还没跑完，因为如果定时器跑完的话，那状态肯定就不是pending，而是fulfilled或者rejected

那是用什么来保存这些回调呢？建议使用数组，因为一个promise实例可能会多次then，用数组就一个一个保存了

```js
    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态
+        this.onFulfilledCallbacks = [] // 保存成功回调
+        this.onRejectedCallbacks = [] // 保存失败回调
    }

    resolve(value) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
        // 执行保存的成功回调
+        while (this.onFulfilledCallbacks.length) {
+            this.onFulfilledCallbacks.shift()(this.PromiseResult)
+        }
    }

    reject(reason) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
        // 执行保存的失败回调
+        while (this.onRejectedCallbacks.length) {
+            this.onRejectedCallbacks.shift()(this.PromiseResult)
+        }
    }
    
    then(onFulfilled, onRejected) {
        // 接收两个回调 onFulfilled, onRejected

        // 参数校验，确保一定是函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }

        if (this.PromiseState === 'fulfilled') {
            // 如果当前为成功状态，执行第一个回调
            onFulfilled(this.PromiseResult)
        } else if (this.PromiseState === 'rejected') {
            // 如果当前为失败状态，执行第二哥回调
            onRejected(this.PromiseResult)
+        } else if (this.PromiseState === 'pending') {
+            // 如果状态为待定状态，暂时保存两个回调
+            this.onFulfilledCallbacks.push(onFulfilled.bind(this))
+            this.onRejectedCallbacks.push(onRejected.bind(this))
+        }

    }

```

完整代码为：

```js
class MyPromise {
    // 构造方法
    constructor(executor) {

        // 初始化值
        this.initValue()
        // 初始化this指向
        this.initBind()
      	try {
            // 执行传进来的函数
            executor(this.resolve, this.reject)
        } catch (e) {
            // 捕捉到错误直接执行reject
            this.reject(e)
        }
    }

    initBind() {
        // 初始化this
        this.resolve = this.resolve.bind(this)
        this.reject = this.reject.bind(this)
    }

    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态
      	this.onFulfilledCallbacks = [] // 保存成功回调
        this.onRejectedCallbacks = [] // 保存失败回调
    }

    resolve(value) {
        // state是不可变的
      	if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
      	// 执行保存的成功回调
      	while (this.onFulfilledCallbacks.length) {
            this.onFulfilledCallbacks.shift()(this.PromiseResult)
        }
    }

    reject(reason) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
        // 执行保存的失败回调
	      while (this.onRejectedCallbacks.length) {
            this.onRejectedCallbacks.shift()(this.PromiseResult)
        }
    }

    then(onFulfilled, onRejected) {
      // 接收两个回调 onFulfilled, onRejected
      
      // 参数校验，确保一定是函数
      onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
      onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }

      if (this.PromiseState === 'fulfilled') {
          // 如果当前为成功状态，执行第一个回调
          onFulfilled(this.PromiseResult)
      } else if (this.PromiseState === 'rejected') {
          // 如果当前为失败状态，执行第二哥回调
          onRejected(this.PromiseResult)
      } else if (this.PromiseState === 'pending') {
    			// 如果状态为待定状态，暂时保存两个回调
          this.onFulfilledCallbacks.push(onFulfilled.bind(this))
          this.onRejectedCallbacks.push(onRejected.bind(this))
      }
    }
}
```

看下是否能够实现定时器的功能：

```js
const test2 = new MyPromise((resolve, reject) => {
    setTimeout(() => {
        resolve('success') // 1秒后输出 success
    }, 1000)
}).then(res => console.log(res), err => console.log(err))
```

#### 3.3.3 链式调用

then支持链式调用，下一次then执行受上一次then返回值的影响，给大家举个例子：

```js
// 链式调用 输出 200
const p3 = new Promise((resolve, reject) => {
  resolve(100)
}).then(res => 2 * res, err => console.log(err))
  .then(res => console.log(res), err => console.log(err))

// 链式调用 输出300
const p4 = new Promise((resolve, reject) => {
  resolve(100)
}).then(res => new Promise((resolve, reject) => resolve(3 * res)), err => console.log(err))
  .then(res => console.log(res), err => console.log(err))
```

根据上文，可以得到：

1. then方法本身会返回一个新的Promise对象；

2. 如果返回值是promise对象，返回值为成功，新promise就是成功；

3. 如果返回值是promise对象，返回值为失败，新promise就是失败；

4. 如果返回值非promise对象，新promise对象就是成功，值为此返回值；

then是Promise上的方法，那如何实现then完还能再then呢？

then执行后返回一个Promise对象就行了，就能保证then完还能继续执行then；

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1670244647813-454dcadd-6378-4854-9831-22bb463de24e.png?x-oss-process=image%2Fresize%2Cw_556%2Climit_0)



```js
    then(onFulfilled, onRejected) {
        // 接收两个回调 onFulfilled, onRejected

        // 参数校验，确保一定是函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }


        var thenPromise = new MyPromise((resolve, reject) => {

            const resolvePromise = cb => {
                try {
                    const x = cb(this.PromiseResult)
                    if (x === thenPromise && x) {
                        // 不能返回自身哦
                        throw new Error('不能返回自身。。。')
                    }
                    if (x instanceof MyPromise) {
                        // 如果返回值是Promise
                        // 如果返回值是promise对象，返回值为成功，新promise就是成功
                        // 如果返回值是promise对象，返回值为失败，新promise就是失败
                        // 谁知道返回的promise是失败成功？只有then知道
                        x.then(resolve, reject)
                    } else {
                        // 非Promise就直接成功
                        resolve(x)
                    }
                } catch (err) {
                    // 处理报错
                    reject(err)
                    throw new Error(err)
                }
            }

            if (this.PromiseState === 'fulfilled') {
                // 如果当前为成功状态，执行第一个回调
                resolvePromise(onFulfilled)
            } else if (this.PromiseState === 'rejected') {
                // 如果当前为失败状态，执行第二个回调
                resolvePromise(onRejected)
            } else if (this.PromiseState === 'pending') {
                // 如果状态为待定状态，暂时保存两个回调
                // 如果状态为待定状态，暂时保存两个回调
                this.onFulfilledCallbacks.push(resolvePromise.bind(this, onFulfilled))
                this.onRejectedCallbacks.push(resolvePromise.bind(this, onRejected))
            }
        })

        // 返回这个包装的Promise
        return thenPromise

    }
```

完整代码为：

```js
class MyPromise {
    // 构造方法
    constructor(executor) {

        // 初始化值
        this.initValue()
        // 初始化this指向
        this.initBind()
      	try {
            // 执行传进来的函数
            executor(this.resolve, this.reject)
        } catch (e) {
            // 捕捉到错误直接执行reject
            this.reject(e)
        }
    }

    initBind() {
        // 初始化this
        this.resolve = this.resolve.bind(this)
        this.reject = this.reject.bind(this)
    }

    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态
      	this.onFulfilledCallbacks = [] // 保存成功回调
        this.onRejectedCallbacks = [] // 保存失败回调
    }

    resolve(value) {
        // state是不可变的
      	if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
      	// 执行保存的成功回调
      	while (this.onFulfilledCallbacks.length) {
            this.onFulfilledCallbacks.shift()(this.PromiseResult)
        }
    }

    reject(reason) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
        // 执行保存的失败回调
	      while (this.onRejectedCallbacks.length) {
            this.onRejectedCallbacks.shift()(this.PromiseResult)
        }
    }

    then(onFulfilled, onRejected) {
        // 接收两个回调 onFulfilled, onRejected

        // 参数校验，确保一定是函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }


        var thenPromise = new MyPromise((resolve, reject) => {

            const resolvePromise = cb => {
                try {
                    const x = cb(this.PromiseResult)
                    if (x === thenPromise) {
                        // 不能返回自身哦
                        throw new Error('不能返回自身。。。')
                    }
                    if (x instanceof MyPromise) {
                        // 如果返回值是Promise
                        // 如果返回值是promise对象，返回值为成功，新promise就是成功
                        // 如果返回值是promise对象，返回值为失败，新promise就是失败
                        // 谁知道返回的promise是失败成功？只有then知道
                        x.then(resolve, reject)
                    } else {
                        // 非Promise就直接成功
                        resolve(x)
                    }
                } catch (err) {
                    // 处理报错
                    reject(err)
                    throw new Error(err)
                }
            }

            if (this.PromiseState === 'fulfilled') {
                // 如果当前为成功状态，执行第一个回调
                resolvePromise(onFulfilled)
            } else if (this.PromiseState === 'rejected') {
                // 如果当前为失败状态，执行第二个回调
                resolvePromise(onRejected)
            } else if (this.PromiseState === 'pending') {
                // 如果状态为待定状态，暂时保存两个回调
                // 如果状态为待定状态，暂时保存两个回调
                this.onFulfilledCallbacks.push(resolvePromise.bind(this, onFulfilled))
                this.onRejectedCallbacks.push(resolvePromise.bind(this, onRejected))
            }
        })

        // 返回这个包装的Promise
        return thenPromise

    }
}
```

测试一下：

```js
const test3 = new MyPromise((resolve, reject) => {
  resolve(100) // 输出 状态：success 值： 200
}).then(res => 2 * res, err => 3 * err)
  .then(res => console.log('success', res), err => console.log('fail', err))


const test4 = new MyPromise((resolve, reject) => {
  resolve(100) // 输出 状态：fail 值：200
  }).then(res => new MyPromise((resolve, reject) => reject(2 * res)), err => new Promise((resolve, reject) => resolve(3 * err)))
    .then(res => console.log('success', res), err => console.log('fail', err))
```

#### 3.3.4 执行顺序

这里需要了解，then方法是微任务（后续课程会讲）

```js
const p = new Promise((resolve, reject) => {
    resolve(1)
}).then(res => console.log(res), err => console.log(err))

console.log(2)

输出顺序是 2 1
```

这里为了实现类似的功能，使用setTimeout代替（setTimeout为宏任务，此处主要跟在全局上的console对比）

```js
const resolvePromise = cb => {
  setTimeout(() => {
    try {
      const x = cb(this.PromiseResult)
      if (x === thenPromise) {
        // 不能返回自身哦
        throw new Error('不能返回自身。。。')
      }
      if (x instanceof MyPromise) {
        // 如果返回值是Promise
        // 如果返回值是promise对象，返回值为成功，新promise就是成功
        // 如果返回值是promise对象，返回值为失败，新promise就是失败
        // 谁知道返回的promise是失败成功？只有then知道
        x.then(resolve, reject)
      } else {
        // 非Promise就直接成功
        resolve(x)
      }
    } catch (err) {
      // 处理报错
      reject(err)
      throw new Error(err)
    }
  })
}
```

至此，完整的代码为：

```js
class MyPromise {
    // 构造方法
    constructor(executor) {

        // 初始化值
        this.initValue()
        // 初始化this指向
        this.initBind()
      	try {
            // 执行传进来的函数
            executor(this.resolve, this.reject)
        } catch (e) {
            // 捕捉到错误直接执行reject
            this.reject(e)
        }
    }

    initBind() {
        // 初始化this
        this.resolve = this.resolve.bind(this)
        this.reject = this.reject.bind(this)
    }

    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态
      	this.onFulfilledCallbacks = [] // 保存成功回调
        this.onRejectedCallbacks = [] // 保存失败回调
    }

    resolve(value) {
        // state是不可变的
      	if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
      	// 执行保存的成功回调
      	while (this.onFulfilledCallbacks.length) {
            this.onFulfilledCallbacks.shift()(this.PromiseResult)
        }
    }

    reject(reason) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
        // 执行保存的失败回调
	      while (this.onRejectedCallbacks.length) {
            this.onRejectedCallbacks.shift()(this.PromiseResult)
        }
    }

    then(onFulfilled, onRejected) {
        // 接收两个回调 onFulfilled, onRejected

        // 参数校验，确保一定是函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }


        var thenPromise = new MyPromise((resolve, reject) => {

            const resolvePromise = cb => {
              setTimeout(() => {
                try {
                  const x = cb(this.PromiseResult)
                  if (x === thenPromise) {
                    // 不能返回自身哦
                    throw new Error('不能返回自身。。。')
                  }
                  if (x instanceof MyPromise) {
                    // 如果返回值是Promise
                    // 如果返回值是promise对象，返回值为成功，新promise就是成功
                    // 如果返回值是promise对象，返回值为失败，新promise就是失败
                    // 谁知道返回的promise是失败成功？只有then知道
                    x.then(resolve, reject)
                  } else {
                    // 非Promise就直接成功
                    resolve(x)
                  }
                } catch (err) {
                  // 处理报错
                  reject(err)
                  throw new Error(err)
                }
              })
            }

            if (this.PromiseState === 'fulfilled') {
                // 如果当前为成功状态，执行第一个回调
                resolvePromise(onFulfilled)
            } else if (this.PromiseState === 'rejected') {
                // 如果当前为失败状态，执行第二个回调
                resolvePromise(onRejected)
            } else if (this.PromiseState === 'pending') {
                // 如果状态为待定状态，暂时保存两个回调
                // 如果状态为待定状态，暂时保存两个回调
                this.onFulfilledCallbacks.push(resolvePromise.bind(this, onFulfilled))
                this.onRejectedCallbacks.push(resolvePromise.bind(this, onRejected))
            }
        })

        // 返回这个包装的Promise
        return thenPromise

    }
}
```

测试一下：

```js
const test4 = new MyPromise((resolve, reject) => {
    resolve(1)
}).then(res => console.log(res), err => console.log(err))

console.log(2)
```

### 3.3 其他方法

#### 3.3.1 all

1. 接收一个Promise数组，数组中如有非Promise项，则此项当做成功；
2. 如果所有Promise都成功，则返回成功结果数组；
3. 如果有一个Promise失败，则返回这个失败结果；

```js
static all(promises) {
    const result = []
    let count = 0
    return new MyPromise((resolve, reject) => {
        const addData = (index, value) => {
            result[index] = value
            count++
            if (count === promises.length) resolve(result)
        }
        promises.forEach((promise, index) => {
            if (promise instanceof MyPromise) {
                promise.then(res => {
                    addData(index, res)
                }, err => reject(err))
            } else {
                addData(index, promise)
            }
        })
    })
}
```

#### 3.3.2 race

1. 接收一个Promise数组，数组中如有非Promise项，则此项当做成功；
2. 哪个Promise最快得到结果，就返回那个结果，无论成功失败；

```js
static race(promises) {
    return new MyPromise((resolve, reject) => {
        promises.forEach(promise => {
            if (promise instanceof MyPromise) {
                promise.then(res => {
                    resolve(res)
                }, err => {
                    reject(err)
                })
            } else {
                resolve(promise)
            }
        })
    })
}
```

#### 3.3.3 allSettled

1. 接收一个Promise数组，数组中如有非Promise项，则此项当做成功；
2. 把每一个Promise的结果，集合成数组后返回；

```js
static allSettled(promises) {
    return new Promise((resolve, reject) => {
        const res = []
        let count = 0
        const addData = (status, value, i) => {
            res[i] = {
                status,
                value
            }
            count++
            if (count === promises.length) {
                resolve(res)
            }
        }
        promises.forEach((promise, i) => {
            if (promise instanceof MyPromise) {
                promise.then(res => {
                    addData('fulfilled', res, i)
                }, err => {
                    addData('rejected', err, i)
                })
            } else {
                addData('fulfilled', promise, i)
            }
        })
    })
}
```

#### 3.3.4 any

与all相反

1. 接收一个Promise数组，数组中如有非Promise项，则此项当做成功；
2. 如果有一个Promise成功，则返回这个成功结果；
3. 如果所有Promise都失败，则报错；

```js
static any(promises) {
    return new Promise((resolve, reject) => {
        let count = 0
        promises.forEach((promise) => {
            promise.then(val => {
                resolve(val)
            }, err => {
                count++
                if (count === promises.length) {
                    reject(new AggregateError('All promises were rejected'))
                }
            })
        })
    })
}
}
```

### 3.4 scheduler

实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有N个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出：

```js
class Scheduler {
  add(promiseCreator) { ... }
  // ...
}

const timeout = (time) => new Promise(resolve => {
  setTimeout(resolve, time)
})

const scheduler = new Scheduler(n)
const addTask = (time, order) => {
  scheduler.add(() => timeout(time)).then(() => console.log(order))
}

addTask(1000, '1')
addTask(500, '2')
addTask(300, '3')
addTask(400, '4')

// 打印顺序是：2 3 1 4
```

流程分析：

整个的完整执行流程：

1. 起始1、2两个任务开始执行；
2. 500ms时，2任务执行完毕，输出2，任务3开始执行；
3. 800ms时，3任务执行完毕，输出3，任务4开始执行；
4. 1000ms时，1任务执行完毕，输出1，此时只剩下4任务在执行；
5. 1200ms时，4任务执行完毕，输出4；

当资源不足时将任务加入等待队列，当资源足够时，将等待队列中的任务取出执行

在调度器中一般会有一个等待队列queue，存放当资源不够时等待执行的任务
具有并发数据限制，假设通过max设置允许同时运行的任务，还需要count表示当前正在执行的任务数量
当需要执行一个任务A时，先判断count==max 如果相等说明任务A不能执行，应该被阻塞，阻塞的任务放进queue中，等待任务调度器管理
如果count<max说明正在执行的任务数没有达到最大容量，那么count++执行任务A,执行完毕后count--
此时如果queue中有值，说明之前有任务因为并发数量限制而被阻塞，现在count<max，任务调度器会将对头的任务弹出执行

```js
class Scheduler {
  constructor(max) {
    this.max = max;
    this.count = 0; // 用来记录当前正在执行的异步函数
    this.queue = new Array(); // 表示等待队列
  }
  async add(promiseCreator) {
    /*
        此时count已经满了，不能执行本次add需要阻塞在这里，将resolve放入队列中等待唤醒,
        等到count<max时，从队列中取出执行resolve,执行，await执行完毕，本次add继续
        */
    if (this.count >= this.max) {
      await new Promise((resolve, reject) => this.queue.push(resolve));
    }

    this.count++;
    let res = await promiseCreator();
    this.count--;
    if (this.queue.length) {
      // 依次唤醒add
      // 若队列中有值，将其resolve弹出，并执行
      // 以便阻塞的任务，可以正常执行
      this.queue.shift()();
    }
    return res;
  }
}

const timeout = time =>
  new Promise(resolve => {
    setTimeout(resolve, time);
  });

const scheduler = new Scheduler(2);

const addTask = (time, order) => {
  //add返回一个promise，参数也是一个promise
  scheduler.add(() => timeout(time)).then(() => console.log(order));
};
  
  addTask(1000, '1');
  addTask(500, '2');
  addTask(300, '3');
  addTask(400, '4');
  
// output: 2 3 1 4
```

## 4. Promise A+规范

上文我们实现了简版的Promise，接下来看下标准的Promise/A+的规范

- [官方地址](https://promisesaplus.com/)；
- [github地址](https://github.com/promises-aplus)；

对照的翻译如下：

一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。

一个 promise 表示异步操作的最终结果。与 promise 进行交互的主要方式是通过它的方法 then。该方法通过注册回调来得到这个 promise 的最终 value ，或者为什么这个 promise 不能被 fulfilled 的 reason 。

该规范详细说明了 then 方法的行为，提供了一个可互操作的基础，因此所有符合 `Promises/A+` 的 promise 实现都可以依赖该基础。尽管 `Promises/A+` 组织可能偶尔会通过向后兼容的微小更改来修改此规范，以解决新发现的情况，但我们只有在仔细考虑、讨论和测试后才会进行大的或向后不兼容的更改。因此, 该规范应该被认为是十分稳定的 。·

从历史上看, Promises/A+ 阐明了早期 [Promises/A proposal](https://wiki.commonjs.org/wiki/Promises/A) 的条款，并将部分事实上已经实现的拓展涵盖其中，以及对某些未指定或者有问题的部分省略。

最后，`Promises/A+` 规范的核心不包括：如何 create 、fulfill 或 reject promises。而是选择专注于提供可互操作的 then 方法。不过伴随规范的未来工作可能会涉及这些主题。

这里可以看到，`Promises/A+` 规范目前的核心是规范 then 方法，并没有对如何实现 promise 以及如何改变 promise 的状态进行限制。

### 4.1 术语

1. "prmoise" 是一个拥有符合本规范的 then 方法的对象或者函数；
2. "thenable" 是一个定义了 then 方法的对象或者函数；
3. "value" 是 JavaScript 的任意合法值(包括 undefined, thenable, promise)；
4. "exception" 是一个用 throw 语句抛出的 value ；
5. "reason" 是一个表示 promise 被 rejected 的 value ；

### 4.2 要求

#### 4.2.1. promise 的状态

pormise 必须是以下三个状态之一: pending, fulfilled, rejected。

- 当 promise 处于 pending 状态时：

- - 可以转换到 fulfilled 或 rejected 状态；

- 当 promise 处于 fulfilled 状态时：

- - 不能转换到其他状态；
  - 必须有一个 value ，并且不能改变；

- 当 promise 处于 rejected 状态时：

- - 不能转换到其他状态；
  - 必须有 reason ，并且不能改变；

#### 4.2.2. then方法

promise 必须提供一个 then 方法，能由此去访问当前或最终的 value 或者 reason 。pormise 的 then 方法， 接受两个参数

```js
promise.then(onFulfilled, onRejected)
```

- onFulfilled 和 onRejected 都是可选参数：
  ○ 如果 onFulfilled 不是函数，则忽略；
  ○ 如果 onRejected 不是函数，则忽略；

- 如果 onFulfilled 是一个函数:
  ○ 它必须在 promise 被 fulfilled 后，以 promise 的 value 作为第一个参数调用；
  ○ 它不能在 promise 被 fulfilled 之前调用；
  ○ 它不能被调用多次；

- 如果 onRejected 是一个函数：
  ○ 它必须在 promise 被 rejected 后，以 promise 的 reason 作为第一个参数调用；
  ○ 它不能能在 promise 被 rejected 之前调用；
  ○ 它不能被调用多次；
  ○ 在 [execution context](https://es5.github.io/#x10.3) 栈（执行上下文栈）只包含平台代码之前， onFulfilled 或者 onRejected 不能被调用 (译者注: 异步执行回调)；

- onFulfilled 或者 onRejected 必须以函数形式调用（即不能有this值）
- then 方法可以被同一个 promise 调用多次
  ○ 如果或者当 promise 处于 fulfilled 状态， 所有自己的 onFulfilled 回调函数，必须要按照 then 注册的顺序被调用；
  ○ 如果或者当 promise 处于 rejected 状态， 所有自己的 onRejected 回调函数，必须要按照 then 注册的顺序被调用；
- then 方法必须要返回 promise

```js
promise2 = promise1.then(onFulfilled, onRejected);
```

- - 如果 onFulfilled 或者 onRejected 返回一个值 x ，则执行 Promise Resolution Procedure：`[[Resolve]](promise2, x)`；
  - 如果 onFulfilled 或者 onRejected 抛出异常 e ， promise2 必须以 e 作为 reason ，转到 rejected 状态；
  - 如果 onFulfilled 不是函数，并且 promise1 处于 fulfilled 状态 ，则 promise2 必须以与 promise1 同样的 value 被 fulfilled；
  - 如果 onRejected 不是函数，并且 promise1 处于 rejected 状态 ，则 promise2 必须以与 promise1 同样的 reason 被 rejected

#### 4.2.3 Promise Resolution Procedure

Promise Resolution Procedure 是一个抽象操作。它以一个 promise 和一个 value 作为输入，记作：`[[Resolve]](promise, x) `。 如果 x 是一个 thenable , 它会尝试让 promise 变成与 x 的一样状态 ，前提 x 是一个类似的 promise 对象。否则，它会让 promise 以 x 作为 value 转为 fulfilled 状态。

这种对 thenables 的处理允许不同的 promise 进行互操作，只要它们暴露一个符合 Promises/A+ 的 then 方法。它还允许 Promises/A+ 实现使用合理的 then 方法“同化”不一致的实现。

`[[Resolve]](promise, x)` 执行以下步骤：

- 如果 promise 和 x 引用的是同一个对象，则以一个 TypeError 作为 reason 让 promise 转为 rejeted 状态；
- 如果 x 也是一个 promise ，则让 promise 接受它的状态：

- - 如果 x 处于 pending 状态，promise 必须保持 pending 状态，直到 x 变成 fulfilled 或者 rejected 状态，promise 才同步改变；
  - 如果或者当 x 处于 fulfilled 状态， 以同样的 value 让 promise 也变成 fulfilled 状态；
  - 如果或者当 x 处于 rejected 状态， 以同样的 reason 让 promise 也变成 rejected 状态；

- 如果 x 是一个对象或者函数：

- - 令 then 等于 x.then；
  - 如果读取 x.then 抛出异常 e ， 以 e 作为 reason 让 promise 变成 rejected 状态；
  - 如果 then 是一个函数，以 x 作为 this 调用它，传入第一个参数 resolvePromise ， 第二个参数 rejectPromise ：

- - - 如果 resolvePromise 被传入 y 调用， 则执行 `[[Resolve]](promise, y)`；
    - 如果 rejectedPromise 被传入 r 调用，则用，r 作为 reason 让 promise 变成 rejected 状态；
    - 如果 resolvePromise 和 rejectPromise 都被调用了，或者被调用多次了。只有第一次调用生效，其余会被忽略；
    - 如果调用 then 抛出异常 e：

- - - - 如果 resolvepromise 或 rejectPromise 已经被调用过了，则忽略它；
      - 否则, 以 e 作为 reason 让 promise 变成 rejected 状态；

- - - 如果 then 不是一个函数，以 x 作为 value 让 promise 变成 fulfilled 状态；

- 如果 x 不是对象或函数， 以 x 作为 value 让 promise 变成 fulfilled 状态；

如果一个 promise 被一个循环的 thenable 链中的对象 resolved，而 `[[Resolve]](promise, thenable) `的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励实现者检测这样的递归是否存在，并且以 TypeError 作为 reason 拒绝 promise；

## 5. async/await

[caniuse支撑程度](https://caniuse.com/?search=async await)

### 5.1. 介绍

async/await的用处：用同步方式，执行异步操作

```js
function request(num) { // 模拟接口请求
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(num * 2)
    }, 1000)
  })
}

request(1).then(res1 => {
  console.log(res1) // 1秒后 输出 2

  request(2).then(res2 => {
    console.log(res2) // 2秒后 输出 4
  })
})
```

现在有一个新的要求：先请求完接口1，再拿接口1返回的数据，去当做接口2的请求参数，那我们也可以这么做：

```js
request(5).then(res1 => {
  console.log(res1) // 1秒后 输出 10

  request(res1).then(res2 => {
    console.log(res2) // 2秒后 输出 20
  })
})
```

如果嵌套的多了，这个时候就可以用async/await来解决了：

```js
async function fn () {
  const res1 = await request(5)
  const res2 = await request(res1)
  console.log(res2) // 2秒后输出 20
}
fn()
```

使用async/await代替上述的内容：

```js
async function fn () {
  await request(1)
  await request(2)
  // 2秒后执行完
}
fn()
```

```js
async function fn () {
  const res1 = await request(5)
  const res2 = await request(res1)
  console.log(res2) // 2秒后输出 20
}
fn()
```

在async函数中，await规定了异步操作只能一个一个排队执行，从而达到用同步方式，执行异步操作的效果。

注意：await只能在async函数中使用

刚刚上面的例子await后面都是跟着异步操作Promise，那如果不接Promise？

```js
function request(num) { // 去掉Promise
  setTimeout(() => {
    console.log(num * 2)
  }, 1000)
}

async function fn() {
  await request(1) // 2
  await request(2) // 4
  // 1秒后执行完  同时输出
}
fn()
```

可以看出，如果await后面接的不是Promise的话，其实是达不到类似同步的效果的

Q：什么是async？async是一个位于function之前的前缀，只有async函数中，才能使用await。那async执行完是返回是什么？

```js
async function fn () {}
console.log(fn) // [AsyncFunction: fn]
console.log(fn()) // Promise {<fulfilled>: undefined}
```

可以看出，async函数执行完会自动返回一个状态为fulfilled的Promise，也就是成功状态，但是值却是undefined，那要怎么才能使值不是undefined呢？只要函数有return返回值就行了。

```js
async function fn (num) {
  return num
}
console.log(fn) // [AsyncFunction: fn]
console.log(fn(10)) // Promise {<fulfilled>: 10}
fn(10).then(res => console.log(res)) // 10
```

#### 5.1.1 总结

1. await只能在async函数中使用，不然会报错；
2. async函数返回的是一个Promise对象，有无值看有无return值；
3. await后面最好是接Promise，虽然接其他值也能达到排队效；
4. async/await作用是用同步方式，执行异步操作

#### 5.1.2 语法糖

Q：async/await是一种语法糖，那么什么是语法糖呢？

A：语法糖是简化代码的一种方式，用其他方式也能达到同样的效果，但写法可能没有这么便利。

ES6的class也是语法糖，因为其实用普通function也能实现同样效果

回归正题，async/await是一种语法糖，用到的是ES6里的迭代函数——generator函数

## 6. generator

 

### 6.1 介绍

generator函数跟普通函数在写法上的区别就是，多了一个星号*，并且只有在generator函数中才能使用yield，而yield相当于generator函数执行的中途暂停点，比如下方有3个暂停点。而怎么才能暂停后继续走呢？那就得使用到next方法，next方法执行后会返回一个对象，对象中有value 和 done两个属性

- value：暂停点后面接的值，也就是yield后面接的值；

- done：是否generator函数已走完，没走完为false，走完为true；

```js
function* gen() {
  yield 1
  yield 2
  yield 3
}
const g = gen()
console.log(g.next()) // { value: 1, done: false }
console.log(g.next()) // { value: 2, done: false }
console.log(g.next()) // { value: 3, done: false }
console.log(g.next()) // { value: undefined, done: true }
```

可以看到最后一个是undefined，这取决于你generator函数有无返回值

```js
function* gen() {
  yield 1
  yield 2
  yield 3
  return 4
}
const g = gen()
console.log(g.next()) // { value: 1, done: false }
console.log(g.next()) // { value: 2, done: false }
console.log(g.next()) // { value: 3, done: false }
console.log(g.next()) // { value: 4, done: true }
```

#### 6.1.1. yield后接函数

yield后面接函数的话，到了对应暂停点yield，会马上执行此函数，并且该函数的执行返回值，会被当做此暂停点对象的value

```js
function fn(num) {
  console.log(num)
  return num
}
function* gen() {
  yield fn(1)
  yield fn(2)
  return 3
}
const g = gen()
console.log(g.next()) 
// 1
// { value: 1, done: false }
console.log(g.next())
// 2
//  { value: 2, done: false }
console.log(g.next()) 
// { value: 3, done: true }
```

#### 6.1.2 yield后接promise

```js
function fn(num) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(num)
    }, 1000)
  })
}
function* gen() {
  yield fn(1)
  yield fn(2)
  return 3
}
const g = gen()
console.log(g.next()) // { value: Promise { <pending> }, done: false }
console.log(g.next()) // { value: Promise { <pending> }, done: false }
console.log(g.next()) // { value: 3, done: true }
```

如果想获取的是两个Promise的结果1 和 2，可以使用Promise的then

```js
const g = gen()
const next1 = g.next()
next1.value.then(res1 => {
  console.log(next1) // 1秒后输出 { value: Promise { 1 }, done: false }
  console.log(res1) // 1秒后输出 1

  const next2 = g.next()
  next2.value.then(res2 => {
    console.log(next2) // 2秒后输出 { value: Promise { 2 }, done: false }
    console.log(res2) // 2秒后输出 2
    console.log(g.next()) // 2秒后输出 { value: 3, done: true }
  })
})
```

#### 6.1.3 next函数传参

generator函数可以用next方法来传参，并且可以通过yield来接收这个参数，注意两点

1. 第一次next传参是没用的，只有从第二次开始next传参才有用；
2. next传值时，要记住顺序是，先右边yield，后左边接收参数；

```js
function* gen() {
  const num1 = yield 1
  console.log(num1)
  const num2 = yield 2
  console.log(num2)
  return 3
}
const g = gen()
console.log(g.next()) // { value: 1, done: false }
console.log(g.next(11111))
// 11111
//  { value: 2, done: false }
console.log(g.next(22222)) 
// 22222
// { value: 3, done: true }
```

#### 6.1.4 Promise&next传参

根据上文可以知道：

1. yield后面接Promise；
2. next函数传参；

所以一起使用时的效果为：

```js
function fn(nums) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(nums * 2)
    }, 1000)
  })
}
function* gen() {
  const num1 = yield fn(1)
  const num2 = yield fn(num1)
  const num3 = yield fn(num2)
  return num3
}
const g = gen()
const next1 = g.next()
next1.value.then(res1 => {
  console.log(next1) // 1秒后同时输出 { value: Promise { 2 }, done: false }
  console.log(res1) // 1秒后同时输出 2

  const next2 = g.next(res1) // 传入上次的res1
  next2.value.then(res2 => {
    console.log(next2) // 2秒后同时输出 { value: Promise { 4 }, done: false }
    console.log(res2) // 2秒后同时输出 4

    const next3 = g.next(res2) // 传入上次的res2
    next3.value.then(res3 => {
      console.log(next3) // 3秒后同时输出 { value: Promise { 8 }, done: false }
      console.log(res3) // 3秒后同时输出 8

       // 传入上次的res3
      console.log(g.next(res3)) // 3秒后同时输出 { value: 8, done: true }
    })
  })
})
```

### 6.2 实现async/await

上方的generator函数的Promise&next传参，就很像async/await了，区别在于

1. gen函数执行返回值不是Promise，asyncFn执行返回值是Promise；
2. gen函数需要执行相应的操作，才能等同于asyncFn的排队效果；
3. gen函数执行的操作是不完善的，因为并不确定有几个yield，不确定会嵌套几次；

针对这种情况，可以通过高阶函数（HOC）封装：

高阶函数：参数是函数，返回值也可以是函数。

```js
function highorderFn(函数) {
    // 一系列处理
    return 函数
}
```

根据上述代码，可以封装一个高阶函数，接收一个generator函数，并经过处理，返回一个具有async函数功能的函数：

```js
function generatorToAsync(generatorFn) {
  // 经过一系列处理
  
  return 具有async函数功能的函数
}
```

#### 6.2.1 返回值promise

```js
function* gen() {

}

const asyncFn = generatorToAsync(gen)

console.log(asyncFn()) // 期望这里输出 Promise
```

这里需要针对`generatorToAsync`进行处理：

```js
function* gen() {

}
function generatorToAsync (generatorFn) {
  return function () {
    return new Promise((resolve, reject) => {

    })
  }
}

const asyncFn = generatorToAsync(gen)

console.log(asyncFn()) // Promise
```

#### 6.2.2. 结合上述代码

把之前的处理代码，加入generatorToAsync函数中

```js
function fn(nums) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(nums * 2)
    }, 1000)
  })
}
function* gen() {
  const num1 = yield fn(1)
  const num2 = yield fn(num1)
  const num3 = yield fn(num2)
  return num3
}
function generatorToAsync(generatorFn) {
  return function () {
    return new Promise((resolve, reject) => {
      const g = generatorFn()
      const next1 = g.next()
      next1.value.then(res1 => {

        const next2 = g.next(res1) // 传入上次的res1
        next2.value.then(res2 => {

          const next3 = g.next(res2) // 传入上次的res2
          next3.value.then(res3 => {

            // 传入上次的res3
            resolve(g.next(res3).value)
          })
        })
      })
    })
  }
}

const asyncFn = generatorToAsync(gen)

asyncFn().then(res => console.log(res)) // 3秒后输出 8
```

到这里，就已经实现了async/await的初始功能了

```js
async function asyncFn() {
  const num1 = await fn(1)
  const num2 = await fn(num1)
  const num3 = await fn(num2)
  return num3
}
asyncFn().then(res => console.log(res)) // 3秒后输出 8
```

#### 6.2.3. 结合多个await方法

因为async中可以支持若干个await，await的个数是不确定的。同样类比，generator函数中，也可能有2个yield，3个yield，5个yield，所以需要对上述代码进行改造

```js
function generatorToAsync(generatorFn) {
  return function() {
    const gen = generatorFn.apply(this, arguments) // gen有可能传参

    // 返回一个Promise
    return new Promise((resolve, reject) => {

      function go(key, arg) {
        let res
        try {
          res = gen[key](arg) // 这里有可能会执行返回reject状态的Promise
        } catch (error) {
          return reject(error) // 报错的话会走catch，直接reject
        }

        // 解构获得value和done
        const { value, done } = res
        if (done) {
          // 如果done为true，说明走完了，进行resolve(value)
          return resolve(value)
        } else {
          // 如果done为false，说明没走完，还得继续走

          // value有可能是：常量，Promise，Promise有可能是成功或者失败
          return Promise.resolve(value).then(val => go('next', val), err => go('throw', err))
        }
      }

      go("next") // 第一次执行
    })
  }
}

const asyncFn = generatorToAsync(gen)

asyncFn().then(res => console.log(res))
```

#### 6.2.4 测试结果

- async/await

```js
async function asyncFn() {
  const num1 = await fn(1)
  console.log(num1) // 2
  const num2 = await fn(num1)
  console.log(num2) // 4
  const num3 = await fn(num2)
  console.log(num3) // 8
  return num3
}
const asyncRes = asyncFn()
console.log(asyncRes) // Promise
asyncRes.then(res => console.log(res)) // 8
```

- generatorToAsync

```js
function* gen() {
  const num1 = yield fn(1)
  console.log(num1) // 2
  const num2 = yield fn(num1)
  console.log(num2) // 4
  const num3 = yield fn(num2)
  console.log(num3) // 8
  return num3
}

const genToAsync = generatorToAsync(gen)
const asyncRes = genToAsync()
console.log(asyncRes) // Promise
asyncRes.then(res => console.log(res)) // 8
```

# 前端模块化

https://www.yuque.com/lpldplws/web/xhqomd?singleDoc# 《前端模块化》 密码：xnou

## 1. 课程目标

1. 学习前端模块化发展历程；
2. 掌握现代前端开发模块化的实现及实战；

## 2. 课程大纲

- 模块化理解；
- 模块化规范及总结；

## 3. 模块化的理解

在JavaScript发展初期就是为了实现简单的页面交互逻辑，而如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。模块化已经发展了有十余年了，不同的工具和轮子层出不穷，但总结起来，它们解决的问题主要有三个：

1. 外部模块的管理；
2. 内部模块的组织；
3. 模块源码到目标代码的编译和转换；

以下为各个工具或者框架的诞生时间，先了解下时间节奏，方便对内容有所了解：

```js
 生态             诞生时间
 Node.js          2009年   
 NPM              2010年   
 requireJS(AMD)   2010年
 seaJS(CMD)       2011年
 broswerify       2011年
 webpack          2012年
 grunt            2012年 
 gulp             2013年
 react            2013年 
 vue              2014年
 angular          2016年
 redux            2015年 
 vite             2020年
 snowpack         2020年  
```

### 3.1 什么是模块？

- 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件)，并进行组合在一起；
- 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信；

### 3.2 模块化的进化过程

#### 3.2.1. 全局function模式

将不同的功能封装成不同的全局函数

- 编码：将不同的功能封装成不同的全局函数
- 问题：污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系

```js
function m1(){
  //...
}
function m2(){
  //...
}
```

#### 3.2.2 namespace模式

简单对象封装

- 作用：减少了全局变量，解决命名冲突
- 问题：数据不安全(外部可以直接修改模块内部的数据)

```js
let myModule = {
  data: 'www.baidu.com',
  foo() {
    console.log(`foo() ${this.data}`)
  },
  bar() {
    console.log(`bar() ${this.data}`)
  }
}
myModule.data = 'other data' //能直接修改模块内部的数据
myModule.foo() // foo() other data
```

这样的写法会暴露所有模块成员，内部状态可以被外部改写。

#### 3.3.3. IIFE模式

匿名函数自调用(闭包)

- 作用：数据是私有的, 外部只能通过暴露的方法操作
- 编码：将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
- 问题：如果当前这个模块依赖另一个模块怎么办?

```js
// index.html文件
<script type="text/javascript" src="module.js"></script>
<script type="text/javascript">
    myModule.foo()
    myModule.bar()
    console.log(myModule.data) //undefined 不能访问模块内部数据
    myModule.data = 'xxxx' //不是修改的模块内部的data
    myModule.foo() //没有改变
</script>

// module.js文件
(function(window) {
  let data = 'www.xianzao.com'
  //操作数据的函数
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
  }
  function bar() {
    //用于暴露有函数
    console.log(`bar() ${data}`)
    otherFun() //内部调用
  }
  function otherFun() {
    //内部私有的函数
    console.log('otherFun()')
  }
  //暴露行为
  window.myModule = { foo, bar } //ES6写法
})(window)
```

最后得到的结果：

```js
foo() www.xianzao.com
bar() www.xianzao.com
otehrFun()
undefined
foo() www.xianzao.com
```

#### 3.3.4 IIFE模式增强

这就是现代模块实现的基石

```js
// module.js文件
(function(window, $) {
  let data = 'www.baidu.com'
  //操作数据的函数
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
    $('body').css('background', 'red')
  }
  function bar() {
    //用于暴露有函数
    console.log(`bar() ${data}`)
    otherFun() //内部调用
  }
  function otherFun() {
    //内部私有的函数
    console.log('otherFun()')
  }
  //暴露行为
  window.myModule = { foo, bar }
})(window, jQuery)

 // index.html文件
<!-- 引入的js必须有一定顺序 -->
<script type="text/javascript" src="jquery-1.10.1.js"></script>
<script type="text/javascript" src="module.js"></script>
<script type="text/javascript">
  myModule.foo()
</script>
```

上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。

### 3.3 模块化的好处

- 避免命名冲突(减少命名空间污染)；
- 更好的分离, 按需加载；
- 更高复用性；
- 高可维护性；

### 3.4. 引入多个<script>后出现出现问题

- 请求过多

首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多；

- 依赖模糊

我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错；

- 难以维护

以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。
模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，因此才有了后续的commonjs, AMD, ES6, CMD规范。

## 4. 模块化规范

### 4.1. CommonJS

#### 4.1.1. 概念

Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。

#### 4.1.2. 特点

- 所有代码都运行在模块作用域，不会污染全局作用域；
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存；
- 模块加载的顺序，按照其在代码中出现的顺序；

#### 4.1.3. 基本语法

- 暴露模块：`module.exports = value`或`exports.xxx = value`
- 引入模块：`require(xxx)`,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径

此处我们有个疑问：CommonJS暴露的模块到底是什么? CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。

```javascript
// example.js
var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;
```

上面代码通过module.exports输出变量x和函数addX。

```javascript
var example = require('./example.js');//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径
console.log(example.x); // 5
console.log(example.addX(1)); // 6
```

require命令用于加载模块文件。require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。

#### 4.1.4. 模块的加载机制

CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：

```js
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};
```

上面代码输出内部变量counter和改写这个变量的内部方法incCounter。

```js
// main.js
var counter = require('./lib').counter;
var incCounter = require('./lib').incCounter;

console.log(counter);  // 3
incCounter();
console.log(counter); // 3
```

上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。

#### 4.1.5 服务器端实现

1. 安装node
2. npm init

```js
|-modules
  |-module1.js
  |-module2.js
  |-module3.js
|-app.js
|-package.json
  {
    "name": "commonJS-node",
    "version": "1.0.0"
  }

```

3. 下载第三方模块

```js
npm install uniq --save // 用于数组去重
```

4. 定义模块代码

```js
//module1.js
module.exports = {
  msg: 'module1',
  foo() {
    console.log(this.msg)
  }
}

//module2.js
module.exports = function() {
  console.log('module2')
}

//module3.js
exports.foo = function() {
  console.log('foo() module3')
}
exports.arr = [1, 2, 3, 3, 2]

// app.js文件
// 引入第三方库，应该放置在最前面
let uniq = require('uniq')
let module1 = require('./modules/module1')
let module2 = require('./modules/module2')
let module3 = require('./modules/module3')

module1.foo() //module1
module2() //module2
module3.foo() //foo() module3
console.log(uniq(module3.arr)) //[ 1, 2, 3 ]
```

5. node app.js

#### 4.1.6. 浏览器端实现

使用Browserify：Browserify 会对代码进行解析，整理出代码中的所有模块依赖关系，然后把相关的模块代码都打包在一起，形成一个完整的JS文件，这个文件中不会存在 require 这类的模块化语法，变成可以在浏览器中运行的普通JS

1. 创建项目结构

```js
|-js
  |-dist //打包生成文件的目录
  |-src //源码所在的目录
    |-module1.js
    |-module2.js
    |-module3.js
    |-app.js //应用主源文件
|-index.html //运行于浏览器上
|-package.json
  {
    "name": "browserify-test",
    "version": "1.0.0"
  }
```

2. 下载browserify

- 全局: `npm install browserify -g`
- 局部: `npm install browserify --save-dev`

3. 定义模块代码

注意：index.html文件要运行在浏览器上，需要借助browserify将app.js文件打包编译，如果直接在index.html引入app.js就会报错！

4. 打包处理js

根目录下运行

```js
browserify js/src/app.js -o js/dist/bundle.js
```

5. 页面使用引入

在index.html文件中引入

```js
<script type="text/javascript" src="js/dist/bundle.js"></script>
```

### 4.2  AMD（Asynchronous Module Definition）

#### 4.2.1 概念

CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。此外AMD规范比CommonJS规范在浏览器端实现要来着早。

#### 4.2.2 基本语法

定义暴露模块

```js
//定义没有依赖的模块
define(function(){
   return 模块
})

//定义有依赖的模块
define(['module1', 'module2'], function(m1, m2){
   return 模块
})
```

引用使用模块：

```js
require(['module1', 'module2'], function(m1, m2){
   使用m1/m2
})
```

#### 4.2.3 AMD实现

通过比较是否实用AMD，来说明使用AMD实际使用的效果。

##### 4.2.3.1. 未使用AMD规范

```js
// dataService.js文件
(function (window) {
  let msg = 'www.xianzao.com'
  function getMsg() {
    return msg.toUpperCase()
  }
  window.dataService = {getMsg}
})(window)

// alerter.js文件
(function (window, dataService) {
  let name = 'xianzao'
  function showMsg() {
    alert(dataService.getMsg() + ', ' + name)
  }
  window.alerter = {showMsg}
})(window, dataService)

// main.js文件
(function (alerter) {
  alerter.showMsg()
})(alerter)

// index.html文件
<div><h1>Modular Demo 1: 未使用AMD(require.js)</h1></div>
<script type="text/javascript" src="js/modules/dataService.js"></script>
<script type="text/javascript" src="js/modules/alerter.js"></script>
<script type="text/javascript" src="js/main.js"></script>
```

最后得到的如下结果：

```js
'WWW.XIANZAO.COM', 'xianzao'
```

这种方式缺点很明显：首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错

##### 4.2.3.2. 使用require.js

RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。


接下来介绍AMD规范在浏览器实现的步骤：

1. 下载require.js, 并引入

- 官网: http://www.requirejs.cn/
- github : https://github.com/requirejs/requirejs

然后将require.js导入项目: `js/libs/require.js`

2. 创建项目结构

```js
|-js
  |-libs
    |-require.js
  |-modules
    |-alerter.js
    |-dataService.js
  |-main.js
|-index.html
```

3. 定义require.js的模块化代码

```js
// dataService.js文件
// 定义没有依赖的模块
define(function() {
  let msg = 'www.xianzao.com'
  function getMsg() {
    return msg.toUpperCase()
  }
  return { getMsg } // 暴露模块
})

//alerter.js文件
// 定义有依赖的模块
define(['dataService'], function(dataService) {
  let name = 'xianzao'
  function showMsg() {
    alert(dataService.getMsg() + ', ' + name)
  }
  // 暴露模块
  return { showMsg }
})

// main.js文件
(function() {
  require.config({
    baseUrl: 'js/', //基本路径 出发点在根目录下
    paths: {
      //映射: 模块标识名: 路径
      alerter: './modules/alerter', //此处不能写成alerter.js,会报错
      dataService: './modules/dataService'
    }
  })
  require(['alerter'], function(alerter) {
    alerter.showMsg()
  })
})()

// index.html文件
<!DOCTYPE html>
<html>
  <head>
    <title>Modular Demo</title>
  </head>
  <body>
    <!-- 引入require.js并指定js主文件的入口 -->
    <script data-main="js/main" src="js/libs/require.js"></script>
  </body>
</html>
```

4. 页面引入require.js模块

在index.html引入

```js
<script data-main="js/main" src="js/libs/require.js"></script>
```

5. 引入第三方库

```js
// alerter.js文件
define(['dataService', 'jquery'], function(dataService, $) {
  let name = 'Tom'
  function showMsg() {
    alert(dataService.getMsg() + ', ' + name)
  }
  $('body').css('background', 'green')
  // 暴露模块
  return { showMsg }
})
```

```js
// main.js文件
(function() {
  require.config({
    baseUrl: 'js/', //基本路径 出发点在根目录下
    paths: {
      //自定义模块
      alerter: './modules/alerter', //此处不能写成alerter.js,会报错
      dataService: './modules/dataService',
      // 第三方库模块
      jquery: './libs/jquery-1.10.1' //注意：写成jQuery会报错
    }
  })
  require(['alerter'], function(alerter) {
    alerter.showMsg()
  })
})()
```

上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。

##### 4.2.3.3. 总结

 通过两者的比较，可以得出AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块

### 4.3 CMD(Common Module Definition)

#### 4.3.1概念

CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。

#### 4.3.2 基本语法 

```js
//定义没有依赖的模块
define(function(require, exports, module){
  exports.xxx = value
  module.exports = value
})
```

```js
//定义有依赖的模块
define(function(require, exports, module){
  //引入依赖模块(同步)
  var module2 = require('./module2')
  //引入依赖模块(异步)
    require.async('./module3', function (m3) {
    })
  //暴露模块
  exports.xxx = value
})
```

```js
// 引入使用的模块
define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
```

#### 4.3.3. CMD实现

1. 下载sea.js, 并引入

- 官网: http://seajs.org/
- github : https://github.com/seajs/seajs

然后将sea.js导入项目：`js/libs/sea.js`

2. 创建项目结构

```js
|-js
  |-libs
    |-sea.js
  |-modules
    |-module1.js
    |-module2.js
    |-module3.js
    |-module4.js
    |-main.js
|-index.html
```

3. 定义sea.js的模块化代码

```js
// module1.js文件
define(function (require, exports, module) {
  //内部变量数据
  var data = 'xianzao.com'
  //内部函数
  function show() {
    console.log('module1 show() ' + data)
  }
  //向外暴露
  exports.show = show
})

// module2.js文件
define(function (require, exports, module) {
  module.exports = {
    msg: 'I am xianzao'
  }
})

// module3.js文件
define(function(require, exports, module) {
  const API_KEY = 'abc123'
  exports.API_KEY = API_KEY
})

// module4.js文件
define(function (require, exports, module) {
  //引入依赖模块(同步)
  var module2 = require('./module2')
  function show() {
    console.log('module4 show() ' + module2.msg)
  }
  exports.show = show
  //引入依赖模块(异步)
  require.async('./module3', function (m3) {
    console.log('异步引入依赖模块3  ' + m3.API_KEY)
  })
})

// main.js文件
define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
```

4. 在index.html中引入

```js
<script type="text/javascript" src="js/libs/sea.js"></script>
<script type="text/javascript">
  seajs.use('./js/modules/main')
</script>
```

最后得到结果如下：

```js
module1 show(), xianzao
module4 show() I am xianzao
异步引入依赖模块3 abc123
```

#### 4.3.4cmd和amd的区别

```js
// CMD
define(function (requie, exports, module) {
    //依赖就近书写
    var module1 = require('Module1');
    var result1 = module1.exec();
    module.exports = {
      result1: result1,
    }
});

// AMD
define(['Module1'], function (module1) {
    var result1 = module1.exec();
    return {
      result1: result1,
    }
});
```

从上面的代码比较中我们可以得出AMD规范和CMD规范的区别

1. 对依赖的处理：

- AMD推崇依赖前置，即通过依赖数组的方式提前声明当前模块的依赖；
- CMD推崇依赖就近，在编程需要用到的时候通过调用require方法动态引入；

2. 在本模块的对外输出：

- AMD推崇通过返回值的方式对外输出；
- CMD推崇通过给module.exports赋值的方式对外输出

### 4.4 ES6模块化

#### 4.4.1 概念

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。`CommonJS` 和 `AMD` 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。

#### 4.4.2 基本使用

export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。

```js
/** 定义模块 math.js **/
var basicNum = 0;
var add = function (a, b) {
    return a + b;
};
export { basicNum, add };
/** 引用模块 **/
import { basicNum, add } from './math';
function test(ele) {
    ele.textContent = add(99 + basicNum);
}
```

如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。

```js
// export-default.js
export default function () {
  console.log('foo');
}

// import-default.js
import customName from './export-default';
customName(); // 'foo'
```

模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。

ES6 模块与 CommonJS 模块的差异

1. CommonJS,可以动态加载语句，代码发生在运行时, 模块输出的是一个值的拷贝,可以修改导出的值,一旦内部再修改这个值，则不会同步到外部。ES6 模块输出的是值的引用,内部修改可以同步到外部，而且导入的值，不能进行修改，也就是只读
2. Common JS 模块是运行时加载，ES6 模块是静态编译期间就确定模块的依赖，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时编译时输出接口；

第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:

```js
// lib.js
export let counter = 3;
export function incCounter() {
  counter++;
}
// main.js
import { counter, incCounter } from './lib';
console.log(counter); // 3
incCounter();
console.log(counter); // 4

//lib.js
export let cnt=3;
export function intCnt(){
    cnt++;
}

import {cnt,intCnt} from './lib';
console.log(cnt);//3
intCnt();
console.log(cnt);//4
cnt=10;//抛出错误

//lib.js
//commonjs环境
module.exports={
     cnt:3,
     intCnt:(){
     cnt++;
 }
}
let {cnt,intCnt}=require('./lib.js');
console.log(cnt);//3
intCnt();
console.log(cnt);//3
cnt=10;//不会报错
```



#### 4.4.3 ES6实现

简单来说就一句话：使用Babel将ES6编译为ES5代码，使用Browserify编译打包js。

1. 定义package.json文件

```js
 {
   "name" : "es6-babel-browserify",
   "version" : "1.0.0"
 }
```

2. 安装babel-cli, babel-preset-es2015和browserify

```bash
npm install babel-cli browserify -g
npm install babel-preset-es2015 --save-dev
```

3. 定义.babelrc文件

```js
  {
    "presets": ["es2015"]
  }
```

4. 定义模块代码

```js
//module1.js文件
// 分别暴露
export function foo() {
  console.log('foo() module1')
}
export function bar() {
  console.log('bar() module1')
}

//module2.js文件
// 统一暴露
function fun1() {
  console.log('fun1() module2')
}
function fun2() {
  console.log('fun2() module2')
}
export { fun1, fun2 }

//module3.js文件
// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据
export default () => {
  console.log('默认暴露')
}

// app.js文件
import { foo, bar } from './module1'
import { fun1, fun2 } from './module2'
import module3 from './module3'
foo()
bar()
fun1()
fun2()
module3()
```

5. 编译并在index.html中引入

- 使用Babel将ES6编译为ES5代码(但包含CommonJS语法) :` babel js/src -d js/lib`
- 使用Browserify编译js : `browserify js/lib/app.js -o js/lib/bundle.js`

然后在index.html文件中引入

```js
 <script type="text/javascript" src="js/lib/bundle.js"></script> 
```

最后得到如下结果：

```js
foo() module1
bar() module1
fun1() module2
fun2() module2
默认暴露
```

6. 引入第三方库

首先安装依赖`npm install jquery@1`，然后在app.js文件中引入

```js
//app.js文件
import { foo, bar } from './module1'
import { fun1, fun2 } from './module2'
import module3 from './module3'
import $ from 'jquery'

foo()
bar()
fun1()
fun2()
module3()
$('body').css('background', 'green')
```

### 4.5 UMD(Universal Module Defintion)

是一种javascript通用模块定义规范，让你的模块能在javascript所有运行环境中发挥作用。

意味着要同时满足CommonJS, AMD, CMD的标准，以下为实现：

```js
(function(root, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        console.log('是commonjs模块规范，nodejs环境')
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        console.log('是AMD模块规范，如require.js')
        define(factory)
    } else if (typeof define === 'function' && define.cmd) {
        console.log('是CMD模块规范，如sea.js')
        define(function(require, exports, module) {
            module.exports = factory()
        })
    } else {
        console.log('没有模块环境，直接挂载在全局对象上')
        root.umdModule = factory();
    }
}(this, function() {
    return {
        name: '我是一个umd模块'
    }
}))
```

## 5. 总结

1. CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案；
2. AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；
3. CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行；
4. ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案；
5. UMD为同时满足CommonJS, AMD, CMD标准的实现

### 5.1 commonjs和esm的区别？

首先，本身宿主环境是什么，如果不管构建环境的话，一般情况下commonjs的宿主是nodejs中使用的，是值的拷贝,而es的规范的最初提出是在浏览器中使用的，代表着可以异步的去下载。在webpack中import和require是没有区别的，唯一的区别是会打个标记esm为true还是false，其他没有什么区别

本质上都只是一个规范而已，如果传统上nodejs解析commonjs，只是一个值的拷贝，里面的require相当于去读这个文件，对于esm看谁来解析，如果是浏览器解析，本身就是下载这个文件，然后拿这个文件的引用

# **阿里前端面试官带你深度模拟前端专家面试**

https://www.yuque.com/lpldplws/atomml/wa93b6?singleDoc# 《阿里前端面试官带你深度模拟前端专家面试》 密码：xord

## 1. 模拟面试环节

### 1.1. 常见的简历内容

- 熟练使用Antd UI库构建项目 ；
- 熟练使用ajax、axios等技术；
- 熟练使用各种前端库，如Bootstrap，jQuery等 ；
- 熟练使用Charles对App页面进行调试；
- 熟悉ES6，掌握Promise、async、await的使用；
- 熟悉Vue的使用，掌握vue-router、vue cli等；
- 熟悉React的使用，掌握Redux、Mobx、React-Router的使用；
- 掌握前端开发工具，如webpack ；
- 了解MVC，MVVM设计模式 ；
- 对原型链、闭包、面向对象有一定认识 ；了解Node.js，可配合后端开发人员进行开发；
- 关注前端发展趋势；

### 1.2 建立内容

 

目标：P7

技术栈：

- 熟练：JS、CSS、TS；

- 熟练：Vue2/3、Vue-SSR、React

- 熟练：跨端（Uni-app）；

- 熟悉：Node、网络；

- 了解：Vue、React技术栈原理、RN；

- 了解：跨端小程序原理；

- 了解：linux、docker、sql；

项目：

1. 项目1：RN

2. 项目2：C端

- 封装CLI，基于Vue-cli4，支持CDN、ajax、hybrid；

- IM SDK开发；

- 技术栈：Vue3、TS、Rollup、Babel、Vite、websocket；

3. 项目3：跨端

- uni-app开发；

- 项目性能优化；

- 技术栈：Vue、Uni-app、Webpack、TS；

4. 项目4：B端

- 规范组件；

## 2.面试问题

 

### 2.1面试问题

 

1. 基础：

- 从用户输入网址到客户端展现，中间发生了什么过程？

2. 框架：

- Vue、React实现diff的区别？

- Vue 和 Uni-app在生成多端代码时的异同点？

- 组件库的设计思路？

- 跨端小程序的实现思路？

3. 项目问题：

- 项目1：
  - RN遇到最难的问题是什么？
  - 如何针对RN进行性能优化？
  - 为什么不用flutter？
  - 既然有跨端应用，为什么不转uni-app?

- 项目2：
  - CLI实现的功能？
  - 详细介绍一下IM-SDK？

- 项目3：
  - uni-app项目优化方案？

- 项目4：
  - 如何规范组件？
  - 组内如何推动？

4. 常见问题：

- 做过技术复杂度最高的项目是什么；

- 前端前沿知识有哪些了解；

 

## 3.面试常见问题&面试注意事项

### 3.1 面试常见问题

 

#### 3.1.1 从用户输入网址到客户端展现，中间发生了什么过程？ 

目的在于是否有对性能优化的实践

1. 输入网址 --- 告诉浏览器你要去哪里

2. 浏览器查找DNS --- 网络世界是IP地址的世界，DNS就是ip地址的别名。从本地DNS到最顶级DNS一步一步的网上爬，直到命中需要访问的IP地址

- DNS预解析 --- 使用CDN缓存，加快解析CDN寻找到目标地址（dns-prefetch）；

3. 客户端和服务器建立连接 --- 建立TCP的安全通道，3次握手

- CDN加速 --- 使用内容分发网络，让用户更快的获取到所要内容；

- 启用压缩 --- 在http协议中，使用类似Gzip压缩的方案（对服务器资源不足的时候进行权衡）；

- 使用HTTP/2协议 --- http2.0针对1.0优化了很多东西，包括异步连接复用，头压缩等等，使传输更快；

4. 浏览器发送http请求 --- 默认长连接（复用一个tcp通道，短连接：每次连接完就销毁）

- 减少http请求 --- 每个请求从创建到销毁都会消耗很多资源和时间，减少请求就可以相对来说更快展示内容；
  - 压缩合并js文件以及css文件
  - 针对图片，可将图片进行合并然后下载，通过css Sprites切割展示（控制大小，太大的话反而适得其反）

- 使用http缓存 --- 缓存原则：越多越好，越久越好。让客户端发送更少请求，直接从本地获取，加快性能；

- 减少cookie请求 --- 针对非必要数据（静态资源）请求，进行跨域隔离，减少传输内容大小；

- 预加载请求 --- 针对一些业务中场景可预加载的内容，提前加载，在之后的用户操作中更少的请求，更快的响应；

- 选择get和post --- 在http定义的时候，get本质上就是获取数据，post是发送数据的。get可以在一个TCP报文完成请求，但是post先发header，再发送数据。so，考虑好请求选型；

- 缓存方案选型 --- 递进式缓存更新（防止一次性丢失大量缓存，导致负载骤多）；

5. 服务器响应请求 --- tomcat、IIS等服务器通过本地映射文件关系找到地址或者通过数据库查找到数据，处理完成返回给浏览器

- 后端框架选型 --- 更快的响应，前端更快的操作；

- 数据库选型和优化 --- 更快的响应，前端更快的操作；

6. 浏览器接受响应 --- 浏览器根据报文头里面的数据进行不同的响应处理

- 解耦第三方依赖 --- 越多的第三方的不确定因素，会导致web的不稳定性和不确定性；

- 避免404资源 --- 请求资源不到浪费了从请求到接受的所有资源；

7. 浏览器渲染顺序

- HTML解析开始构建dom树；

- 外部脚本和样式表加载完毕
  - 尽快加载css，首先将CSSOM对象渲染出来，然后进行页面渲染，否则导致页面闪屏，用户体验差
  - css选择器是从右往左解析的，so类似#test a {color: #444},css解析器会查找所有a标签的祖先节点，所以效率不是那么高；
  - 在css的媒介查询中，最好不要直接和任何css规则直接相关。最好写到link标签中，告诉浏览器，只有在这个媒介下，加载指定这个css；

- 脚本在文档内解析并执行
  - 按需加载脚本，例如现在的webpack就可以打包和按需加载js脚本；
  - 将脚本标记为异步，不阻塞页面渲染，获得最佳启动，保证无关主要的脚本不会阻塞页；
  - 慎重选型框架和类库，避免只是用类库和框架的一个功能或者函数，而引用整个文件；

- HTML DOM完全构造起来
  - DOM 的多个读操作（或多个写操作），应该放在一起。原则：统一读、统一写；

- 图片和外部内容加载
  - 对多媒体内容进行适当优化，包括恰当使用文件格式，文件处理、渐进式渲染等；
  - 避免空的src，空的src仍然会发送请求到服务器；
  - 避免在html内容中缩放图片，如果你需要使用小图，则直接使用小图；

-  网页完成加载
  - 服务端渲染，特别针对首屏加载很重要的网站，可以考虑这个方案。后端渲染结束，前端接管展示；

总结一下可以做到性能优化的点：

![img](https://camo.githubusercontent.com/5956b4f3cdd26e099f73ec3bdbe73020b43224326bf1d7c6a3aff81abb996afb/68747470733a2f2f70392d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f64363137353866356630336334616231623539653635646464373264326136667e74706c762d6b3375316662706663702d77617465726d61726b2e696d6167653f)



 

#### 3.1.2 前端工程化有哪些实践？ 

1. 技术选型：主要指基于什么原因，选择哪种前端框架：React、Vue、Angular（对微应用的理解）；

2. 规范统一：

- git hooks、git commit配置；

- eslint配置；

- 项目结构规范：CLI；

- UI规范：组件库的选择、开发与使用；

3. 测试：Jest的使用，与其他框架的对比；

4. 构建工具：webpack、rollup、vite的选择；

5. 部署：

- 使用Jenkins构建前端项目并部署到服务器；

- 如何使用github action 或者gitLab action关联项目；

6. 性能监控：

- 前端监控的理解与实践，performance的使用；

- 数据上报的方式；

- 如何上传错误的sourcemap；

- 无埋点；

7. 性能优化:

- 加载时性能优化：lighthouse、HTTP、CDN缓存、SSR；

- 运行时性能优化：重绘重排、长列表渲染；

8. 重构：为什么要重构，如何重构，重构的思想；

9. 微前端：针对巨石项目如何支持；

10. serverless：什么时候使用serverless；

#### 3.1.3 前端前沿知识有哪些了解？ 

 

1. 微前端；

2. low code、no code；

3. 前端工程化搭建；

4. 自动化部署；

5. 前端性能检测；

6. 跨端；

7. 前端组件化；

8. 前端稳定性建设；

9. 在线文档；

### 3.2面试注意事项

#### 3.2.1面试类型

1. 中小厂 / 国企：八股文 + 项目

- 直接是八股文的原题，最多变式（手写防抖、节流；手写call、apply；手写Promise.all、Promise.allSettled）；

- 对项目经验要求度不高，对具体实现细节考察比较少，主要考察对基础的理解程度；

2. 大厂：技术深度广度挖掘：八股文 + 项目 + 算法

- 以八股文作为切入点，扩展至类似技术栈的具体实现，可能会涉及到框架的具体实现，看候选人对技术基础的理解程度：P6居多；

- 以项目具体经验作为切入点，根据项目经验延伸至前端项目的具体落地，结合市场上比较优秀的框架对比，主要考察技术面的广度和深度，以及是否能够解决行业内某一具体细分的问题，如工程化，脚手架，CI/CD等：P7居多；

#### 3.2.2 面试流程

 

- 中小厂：一般为3轮：技术面2轮+HR面1轮；

- 国企：一般为4轮：线上笔试1轮+技术面2轮+HR面1轮；

- 大厂：一般为4~5轮：技术面3轮+（交叉面1轮）+HR面1轮；

#### 3.2.3 技术深度广度拓展 

 

![img](https://risingstars.js.org/favicon.ico)

[2021 年 JavaScript 明星项目](https://risingstars.js.org/2021/zh)



- 前端框架：React、Vue、Svelte、Angular；

- Node框架：Next、Nest、Nuxt；

- 构建工具：Vite、esbuild、webpack、rollup；

- CSS in JavaScript：Styled component、twind、CSS module；

- 测试框架：Storybook、Jest；

- 移动端开发：React Native；

- 状态管理：Zustand、Redux、Vuex、MobX；

#### 3.2.4. 大厂职级详解 

 

| 要求\级别 | 主要目标                 | 核心能力                 | 要求                                                         |
| --------- | ------------------------ | ------------------------ | ------------------------------------------------------------ |
| P5        | 从学生转变为“打工人”     | 在别人知道下完成任务     | 技术：岗位基本技术&团队常用技术 业务：熟悉业务功能的处理逻辑 管理：熟悉项目流程 |
| P6        | 成为独立自主的“项目能手” | 独立负责端到端的项目任务 | 技术：熟练掌握端到端的工作流技术 业务：熟悉某业务的所有功能 管理：项目子任务推进 |
| P7        | 成为让人信服的“团队专家” | 指挥单个团队达到目标     | 技术：精通团队相关技术 业务：关注业务的整体情况 管理：指挥10人以内的小团队 |
| P8        | 成为“跨团队指挥”         | 指挥多个团队达成目标     | 技术：精通领域相关技术 业务：熟悉多个业务或精通端到端业务 管理：核心是抓重点 |

 

#### 3.2.5. 前端Job Model 

| 类型                 | 体系职能                                                     |
| -------------------- | ------------------------------------------------------------ |
| 技术-前端-开发       | 负责人机交互层的界面开发，实现交互功能                       |
| 技术-前端-架构       | 熟悉业务领域与前端技术发展，负责前端类库框架、研发流程等基础体系的设计并推动实现，负责业务领域的前端技术选型并推动落地 |
| 技术-前端-数据可视化 | 负责常规统计图表、业务洞察分析、地理空间数据分析等相关引擎、服务、产品及生态建设 |
| 技术-前端-Node       | 基于Node进行web服务开发或工具开发                            |
| 技术-前端-图像互动   | 负责互动/游戏化业务，2D&3D图像渲染等研发工作                 |
| 前端体验             | 1. 体验度量：通过设计体验模型来度量产品体验功能 2. 体验优化：体验分析，如核心链路分析、体验验收&用户反馈等 |
| 前端工程化           | 1. 基础前端工程服务平台、前端上层链路研发平台、开发支撑平台 2. 前端研发工具，如WebIDE etc |
| 跨端技术             | 1. 跨软硬件设备，IoT、跨操作系统、跨App、跨渲染容器（最常见，如webView，weex，rn etc） 2. 跨端生态 |
| 中后台技术           | 1. 基础UI组件，研发工具 2. low Code、no Code逻辑编排 etc     |
| 前端智能化           | 1. D2C（Design to Code 设计稿转代码） 2. 分析用户特征，推荐UI排版，千人千面 |
| Serverless           | 1. 含义：Serverless = Server + less = 少/无服务器 2. FaaS：Function as a service 代码+相关依赖+配置 |
| 数据可视化           | 1. 基础前端工程服务平台、前端上层链路研发平台、开发支撑平台 2. 前端研发工具，如WebIDE etc |
| 多媒体技术           | 1. 音视频基础、流媒体播放、视频剪辑等 2. 多端（web、Hybrid、小程序）直播间 |

[2022-爪哇前端大厂工程师训练营.pdf(4.1 MB)](https://www.yuque.com/office/yuque/0/2022/pdf/2340337/1665577595901-fd8baad9-7274-4d85-b51f-21ff5c973357.pdf?from=https%3A%2F%2Fwww.yuque.com%2Flpldplws%2Fweb%2Fwa93b6%3FsingleDoc)

# js运行机制

https://www.yuque.com/lpldplws/atomml/xnudhigbps5in504?singleDoc# 《JavaScript的运行机制》 密码：zglx

## 1. 课程目标

1. 了解进程与线程的基础概念，明确在浏览器中的进程与线程机制；
2. 了解浏览器与Node中的事件循环；

## 2. 课程大纲

1. 进程与线程；
2. 事件循环；

## 3. 进程与线程

### 3.1. 什么是进程

CPU是计算机的核心，承担所有的计算任务。

官网说法，进程是CPU资源分配的最小单位。

字面意思就是进行中的程序，我将它理解为一个可以独立运行且拥有自己的资源空间的任务程序，进程包括运行中的程序和程序所使用到的内存和系统资源。

CPU可以有很多进程，我们的电脑每打开一个软件就会产生一个或多个进程，为什么电脑运行的软件多就会卡，是因为CPU给每个进程分配资源空间，但是一个CPU一共就那么多资源，分出去越多，越卡，每个进程之间是相互独立的，CPU在运行一个进程时，其他的进程处于非运行状态，CPU使用 时间片轮转调度算法 来实现同时运行多个进程。

### 3.2. 什么是线程

线程是CPU调度的最小单位。

线程是建立在进程的基础上的一次程序运行单位，通俗点解释线程就是程序中的一个执行流，一个进程可以有多个线程。

一个进程中只有一个执行流称作单线程，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。

一个进程中有多个执行流称作多线程，即在一个程序中可以同时运行多个不同的线程来执行不同的任务， 也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

### 3.3. 进程和线程的区别

进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。

一个进程由一个或多个线程组成，线程可以理解为是一个进程中代码的不同执行路线。

进程之间相互独立，但同一进程下的各个线程间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。

调度和切换：线程上下文切换比进程上下文切换要快得多。

### 3.4. 多进程和多线程

- 多进程：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰；
- 多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务；

### 3.5. JS为什么是单线程

JS的单线程，与它的用途有关。

作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

还有人说js还有Worker线程，对的，为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作DOM。

所以，这个标准并没有改变JavaScript是单线程的本质。

### 3.6. 浏览器

拿Chrome来说，我们每打开一个Tab页就会产生一个进程。

#### 3.6.1. 浏览器包含哪些进程

1. Browser进程

1. - 浏览器的主进程(负责协调、主控)，该进程只有一个；

2. - 负责浏览器界面显示，与用户交互。如前进，后退等；

3. - 负责各个页面的管理，创建和销毁其他进程；

4. - 将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上；

5. - 网络资源的管理，下载等；

2. 第三方插件进程

1. - 每种类型的插件对应一个进程，当使用该插件时才创建；

3. GPU进程

1. - 该进程也只有一个，用于3D绘制等等；

4. 渲染进程

1. - 即通常所说的浏览器内核(Renderer进程，内部是多线程)；

2. - 每个Tab页面都有一个渲染进程，互不影响；

3. - 主要作用为页面渲染，脚本执行，事件处理等；

#### 3.6.2. 为什么浏览器要多进程

假设浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差？同理如果插件崩溃了也会影响整个浏览器。

浏览器进程有很多，每个进程又有很多线程，都会占用内存

#### 3.6.3. 渲染进程

页面的渲染，JS的执行，事件的循环，都在渲染进程内执行，所以我们要重点了解渲染进程

渲染进程是多线程的，看渲染进程的一些常用较为主要的线程：

##### 3.6.3.1. GUI渲染线程

1. 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等；

1. - 解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree；

2. - 解析css，生成CSSOM(CSS规则树)；

3. - 把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)；

2. 当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)；

3. 当我们修改元素的尺寸，页面就会回流(Reflow)；

4. 当页面需要Repaing和Reflow时GUI线程执行，绘制页面；
5. 回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免Reflow和Repaint；
6. GUI渲染线程与JS引擎线程是互斥的：

1. - 当JS引擎执行时GUI线程会被挂起(相当于被冻结了)；

2. - GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行；

##### 3.6.3.2. JS引擎线程

1. JS引擎线程就是JS内核，负责处理Javascript脚本程序(例如V8引擎)；
2. JS引擎线程负责解析Javascript脚本，运行代码；
3. JS引擎一直等待着任务队列中任务的到来，然后加以处理：

1. - 浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的；

2. - 一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序；

4. GUI渲染线程与JS引擎线程是互斥的，js引擎线程会阻塞GUI渲染线程 

1. - 就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)；

2. - 例如浏览器渲染的时候遇到<script>标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况；（所以有了`defer` 和 `async`标签）

##### 3.6.3.3. 事件触发线程

1. 属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue)；
2. 当js执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理；
3. 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；
4. 因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理；

##### 3.6.3.4. 定时触发器线程

1. setInterval与setTimeout所在线程；
2. 浏览器定时计数器并不是由JavaScript引擎计数的(因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)；
3. 通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程；
4. W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms；

#### 3.6.3.5. 异步http请求线程

1. 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求；
2. 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行；
3. 简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行；

## 4. 事件循环(Event Loop)基础

JS分为同步任务和异步任务。同步任务都在主线程(这里的主线程就是JS引擎线程)上执行，会形成一个执行栈。

主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放一个事件回调。一旦执行栈中的所有同步任务执行完毕(也就是JS引擎线程空闲了)，系统就会读取任务队列，将可运行的异步任务(任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中，开始执行

我们来看一段简单的代码：

```javascript
let setTimeoutCallBack = function() {
  console.log('我是定时器回调');
};
let httpCallback = function() {
  console.log('我是http请求回调');
}

// 同步任务
console.log('我是同步任务1');

// 异步定时任务
setTimeout(setTimeoutCallBack,1000);

// 异步http请求任务
ajax.get('/info',httpCallback);

// 同步任务
console.log('我是同步任务2');
```

以上代码的执行过程：

1. JS是按照顺序从上往下依次执行的，可以先理解为这段代码时的执行环境就是主线程，也就是也就是当前执行栈；
2. 首先，执行`console.log('我是同步任务1')`；
3. 接着，执行到`setTimeout`时，会移交给定时器线程，通知定时器线程 1s 后将 `setTimeoutCallBack` 这个回调交给事件触发线程处理，在 1s 后事件触发线程会收到 `setTimeoutCallBack` 这个回调并把它加入到事件触发线程所管理的事件队列中等待执行；
4. 接着，执行http请求，会移交给异步http请求线程发送网络请求，请求成功后将 `httpCallback` 这个回调交由事件触发线程处理，事件触发线程收到 httpCallback 这个回调后把它加入到事件触发线程所管理的事件队列中等待执行；
5. 再接着执行`console.log('我是同步任务2')`；
6. 至此主线程执行栈中执行完毕，JS引擎线程已经空闲，开始向事件触发线程发起询问，询问事件触发线程的事件队列中是否有需要执行的回调函数，如果有将事件队列中的回调事件加入执行栈中，开始执行回调，如果事件队列中没有回调，JS引擎线程会一直发起询问，直到有为止；

可以发现：

1. 定时触发线程只管理定时器且只关注定时不关心结果，定时结束就把回调扔给事件触发线程；
2. 异步http请求线程只管理http请求同样不关心结果，请求结束把回调扔给事件触发线程；
3. 事件触发线程只关心异步回调入事件队列；
4. JS引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行；
5. 反复执行，就是我们所谓的事件循环(Event Loop)；

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671096823790-ac382b71-e3e7-4796-9e30-903d7ff8662e.png)

1. 执行栈开始顺序执行；
2. 判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行；
3. 执行栈空，询问任务队列中是否有事件回调；
4. 任务队列中有事件回调则把回调加入执行栈末尾继续从第一步开始执行；
5. 任务队列中没有事件回调则不停发起询问；

# 5. 宏任务& 微任务

宏任务 -> GUI渲染 -> 宏任务 -> ... 复制代码

## 5.1. 宏任务(`macrotask`)

在ECMAScript中，`macrotask`也被称为task。

我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他、

由于JS引擎线程和GUI渲染线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，GUI渲染线程开始工作，对页面进行渲染：

```javascript
宏任务 -> GUI渲染 -> 宏任务 -> ...
```

常见的宏任务：

1. 主代码块；
2. setTimeout；
3. setInterval；
4. setImmediate ()  -Node；
5. requestAnimationFrame () -浏览器

### 5.2. 微任务(`microtask`)

ES6新引入了Promise标准，同时浏览器实现上多了一个`microtask`微任务概念，在ECMAScript中，`microtask`也被称为jobs。

我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务。

当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完：

```javascript
宏任务 -> 微任务 -> GUI渲染 -> 宏任务 -> ...
```

常见微任务

1. process.nextTick () -Node；
2. Promise.then()；
3. catch；
4. finally；
5. Object.observe；
6. MutationObserver；

### 5.3. 区分宏任务&微任务

打开新的空白窗口，在console中输入以下代码

```javascript
window.open();

document.body.style = 'background:black';
document.body.style = 'background:red';
document.body.style = 'background:blue';
document.body.style = 'background:pink';
```

背景直接渲染了粉红色，根据上文里讲浏览器会先执行完一个宏任务，再执行当前执行栈的所有微任务，然后移交GUI渲染，上面四行代码均属于同一次宏任务，全部执行完才会执行渲染，渲染时GUI线程会将所有UI改动优化合并，所以视觉上，只会看到页面变成粉红色。

```javascript
document.body.style = 'background:blue';
setTimeout(()=>{
    document.body.style = 'background:black'
},200)
```

页面会先卡一下蓝色，再变成黑色背景。之所以会卡一下蓝色，是因为以上代码属于两次宏任务，第一次宏任务执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色。

```javascript
document.body.style = 'background:blue'
console.log(1);
Promise.resolve().then(()=>{
    console.log(2);
    document.body.style = 'background:pink'
});
console.log(3);
```

输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出

页面的背景色直接变成粉色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了粉色，然后才执行的渲染。

### 5.4. 注意点

1. 浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务；
2. 微任务和宏任务不在一个任务队列，不在一个任务队列：

1. - `setTimeout`是一个宏任务，它的事件回调在宏任务队列，`Promise.then()`是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列；
   - 以Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM树构建，js解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务；
   - 微任务是如何产生的呢？当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的API，所以定时器是宏任务，在js中遇到定时器会也是放入到浏览器的队列中）；

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671096823921-6ff3ee75-9409-4152-9337-de64a59d5493.png)

1. 首先执行一个宏任务，执行结束后判断是否存在微任务；
2. 有微任务先执行所有的微任务，再渲染，没有微任务则直接渲染；
3. 然后再接着执行下一个宏任务；

## 6. 完整的Event Loop

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671096824044-e65976eb-709e-4f37-aaf9-2c498e89fae5.png)

1. 整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为同步任务、异步任务两部分，同步任务会直接进入主线程依次执行，异步任务会再分为宏任务和微任务；
2. 宏任务进入到`Event Table`中，并在里面注册回调函数，每当指定的事件完成时，`Event Table`会将这个函数移到`Event Queue`中；
3. 微任务也会进入到另一个`Event Table`中，并在里面注册回调函数，每当指定的事件完成时，`Event Table`会将这个函数移到`Event Queue`中；
4. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的`Event Queue`，如果有任务，就全部执行，如果没有就执行下一个宏任务；
5. 上述过程会不断重复，这就是Event Loop；

## 7. Promise&async/aweait

### 7.1. Promise

`new Promise(() => {}).then() `中，前面的 new Promise() 这一部分是一个构造函数，这是一个同步任务，后面的 .then() 才是一个异步微任务：

```javascript
new Promise((resolve) => {
	console.log(1)
  resolve()
}).then(()=>{
	console.log(2)
})
console.log(3)
// 上面代码输出1 3 2
```

### 7.2. async/await 函数

async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种

所以在使用await关键字与Promise.then效果类似，await 以前的代码，相当于与 new Promise 的同步代码，await 以后的代码相当于 Promise.then的异步

```javascript
setTimeout(() => console.log(4))

async function test() {
  console.log(1)
  await Promise.resolve()
  console.log(3)
}

test()

console.log(2)
// 输出1 2 3 4
```

### 7.3. demo

```javascript
function test() {
  console.log(1)
  setTimeout(function () { 	// timer1
    console.log(2)
  }, 1000)
}

test();

setTimeout(function () { 		// timer2
  console.log(3)
})

new Promise(function (resolve) {
  console.log(4)
  setTimeout(function () { 	// timer3
    console.log(5)
  }, 100)
  resolve()
}).then(function () {
  setTimeout(function () { 	// timer4
    console.log(6)
  }, 0)
  console.log(7)
})

console.log(8)

// 输出1，4，8，7，3，6，5，2
```

1. JS是顺序从上而下执行；
2. 执行到test()，test方法为同步，直接执行`console.log(1)`打印1；
3. test方法中`setTimeout`为异步宏任务，回调我们把它记做timer1放入宏任务队列；
4. test方法下面有一个`setTimeout`为异步宏任务，回调我们把它记做timer2放入宏任务队列；
5. 执行promise，`new Promise`是同步任务，直接执行，打印4；
6. `new Promise`里面的`setTimeout`是异步宏任务，回调我们记做timer3放到宏任务队列；
7. `Promise.then`是微任务，放到微任务队列；
8. console.log(8)是同步任务，直接执行，打印8；
9. 主线程任务执行完毕，检查微任务队列中有`Promise.then`；
10. 开始执行微任务，发现有`setTimeout`是异步宏任务，记做timer4放到宏任务队列；
11. 微任务队列中的`console.log(7)`是同步任务，直接执行，打印7；
12. 微任务执行完毕，第一次循环结束；
13. 检查宏任务队列，里面有timer1、timer2、timer3、timer4，四个定时器宏任务，按照定时器延迟时间得到可以执行的顺序，即Event Queue：timer2、timer4、timer3、timer1，依次拿出放入执行栈末尾执行；
14. 执行timer2，`console.log(3)`为同步任务，直接执行，打印3；
15. 检查没有微任务，第二次Event Loop结束；
16. 执行timer4，`console.log(6)`为同步任务，直接执行，打印6；
17. 检查没有微任务，第三次Event Loop结束；
18. 执行timer3，`console.log(5)`同步任务，直接执行，打印5；
19. 检查没有微任务，第四次Event Loop结束；
20. 执行timer1，`console.log(2)`同步任务，直接执行，打印2；
21. 检查没有微任务，也没有宏任务，第五次Event Loop结束；

## 8. NodeJS中的运行机制

虽然NodeJS中的JavaScript运行环境也是V8，也是单线程，但是，还是有一些与浏览器中的表现是不一样的。

其实nodejs与浏览器的区别，就是nodejs的宏任务分好几种类型，而这好几种又有不同的任务队列，而不同的任务队列又有顺序区别，而微任务是穿插在每一种宏任务之间的。

在node环境下，process.nextTick的优先级高于Promise，可以简单理解为在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1671096823466-47c77129-f237-4e37-aaa2-429adc11f6d4.png)

NodeJS的Event Loop：

1. Node会先执行所有类型为 timers 的 `MacroTask`，然后执行所有的 `MicroTask`(`NextTick`例外)；
2. 进入 poll 阶段，执行几乎所有 `MacroTask`，然后执行所有的 `MicroTask`；
3. 再执行所有类型为 check 的 `MacroTask`，然后执行所有的 `MicroTask`；
4. 再执行所有类型为 `close callbacks` 的 `MacroTask`，然后执行所有的 `MicroTask`；
5. 至此，完成一个 Tick，回到 timers 阶段，重复执行；

## 9.async和defer的区别？

- defer属性告诉浏览器不要等待脚本，浏览器回继续处理HTML,构建DOM。该脚本‘在后台’加载，然后在DOM完全构建完成后再运行。defer脚本总是在DOM准备好时执行，但在DOMContentLoaded事件之前。

```js
<p>...content before scripts...</p>

<script>
  document.addEventListener('DOMContentLoaded', () => alert("DOM fully loaded and parsed after defer!"));
</script>

<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<p>...content after scripts...</p>


1.页面内容立即显示。
2.DOMContentLoaded事件处理程序等待defer脚本执行完之后执行
```

补充：当纯 HTML 被完全加载以及解析时，**`DOMContentLoaded`** 事件会被触发，而不必等待样式表，图片或者子框架完成加载。

- defer脚本保持相对顺序来执行，就像常规脚本一样

  ```js
  <script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
  <script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
  
  //这两个脚本会并行下载，small.js 可能会比long.js先下载完成，但是执行的时候依然会先执行 long.js
  ```

所以defer可用于对脚本执行顺序有严格要求的情况

- async

  - async属性意味着该脚本是完全独立的：

  - 浏览器不会阻止async脚本,async脚本不会等待其他脚本

  - DOMContentLoaded和async脚本不会互相等待

    - DOMContentLoaded可能在async脚本执行之前触发(如果async脚本在页面解析完成后完成加载)

    - 或在async脚本执行之后触发(如果async脚本很快加载完成或在HTTP缓存中)

```js
<p>...content before scripts...</p>

<script>
  document.addEventListener('DOMContentLoaded', () => alert("DOM 完全加载以及解析"));
</script>

<script async src="https://javascript.info/article/script-async-defer/long.js"></script>
<script async src="https://javascript.info/article/script-async-defer/small.js"></script>

<p>...content after scripts...</p>


//页面内容立即显示：async不阻塞
//DOMContentLoaded可能发生在async之前或之后
//small.js先加载完就会在long.js之前执行，但如果long.js在之前有缓存，那么long.js先执行。
```

应用场景：将独立的第三方脚本集成到页面中时，不如及时器，广告等

总结:script是会阻碍HTML解析的，只有下载好并执行完脚本才会继续解析HTML

defer和async有一个共同点：下载此类脚本都不会阻止页面呈现(异步加载),区别在于：

- async执行与文档顺序无关，先加载哪个就先执行哪个；defer会按按照文档的中的顺序执行
- async脚本加载完成后立即执行，可以在DOM尚未完全下载完成就加载和执行；而defer脚本需要等到文档所有元素解析完成之后才执行

1. 事件的触发线程

- setTimeout ajax ->回调事件

2. 定时器的线程

- setTimeout setInterval

3. 异步http请求的线程

## 10. event loop

1.同步任务： js引擎的线程中，执行栈

2.异步任务：可以执行的异步任务 事件的触发线程 任务队列

## 11.宏任务和微任务

### 宏任务

1.正常代码块

2.setTimeout

3.setInterval

4.setImmediate Node

5.requestAnimationIframe 浏览器

### 微任务

在宏任务执行后立即执行的任务

macrotask ->microtask ->GUI ->macrotask

- promise.then()
- catch
- finally
- Object.observe
- MutationObserver
- process.nextTick()



# ts

对比原理：

它是javascript的一个超集，在原有的语法基础上，添加了可选的静态类型和基于类的面向对象编程

- 面向项目：

​    TS:面向于解决大型复杂项目中，架构以及代码维护复杂场景

​    JS:脚本化语言，用于面向单一简单场景

- 自主检测

  TS：编译期间，主动发现并纠正错误

  JS：运行时报错

- 类型检测

  TS:弱类型，支持对于动态和静态类型的检测

  JS:弱类型，无静态类型选项

- 运行流程

  TS:依赖编译，依赖工程化体系

  JS：直接在浏览器中运行

- 复杂特性

  TS:模块化、泛型、接口

所有类型检测和语法检测都是在编译的时候报错

```ts
enum Score{
    BAD,
    NG,
    GOOD,
    PERFECT
}

let scoNAme=Score[0]//BAD
let scoVal=Score['BAD']//0

//异构
enum Enum{
    A,//0
    B,//1
    C='C',
    D='D',
    E=6,
    F,//7
}
//指出异构的枚举值
//手写将其转化成js实现
let Enum;
function Enum;
(function(Enum){
    //正向
    Enum['A']=0;
    Enum['B']=1;
    Enum['C']='C';
    Enum['D']='D';
    Enum['E']=6;
    Enum['F']=7;
    
    //反向
    Enum[0]='A';
    Enum[1]='B';
    Enum[6]='E';
    Enum[7]='F';
})(Enum||(Enum={}))
```

## any-绕过所有类型检查=>类型检查和变异检查全部失效

```ts
let anyValue:any=123;
anyValue='anyVal';
anyValue=false;
let value1:boolean=anyValue;
```

## unkown-绕过了赋值检查=>禁止更改传递

```ts
let unknownValue:unknown;
unknownValue=true;
unknownValue=123;
unknownValue='unknwonValue';
let value1:unknown=unknownValue;//ok
let value1:any=unknownValue;
let value1:boolean=unknownValue;//报错
```

## void-声明函数的返回值

```js
function voidFunction():void{
   console.log('void function')
  }
```

## never -函数永不返回

```tsx
function error(msg:string):never{
    throw new Error(msg)
}

function longlongLoop():never{
     while(true){}
}
```

## object/{} -对象

```ts
//ts将js的object分为两个接口来定义
interface ObjectConstructor{
    create(o:object|null):any
}

const proto={};
Object.create(proto);
Object.create(null);
Object.create(undefined)//报错


//Object.prototype上属性
interface Object{
    constructor:Function'
    toString():string;
    toLocaleString():string;
    valueof():Object;
    hasOwnProperty(v:PropertyKey):boolean;
    isPrototypeOf(v:Object):boolean;
}
```

## {} -空对象定义空属性

```tsx
const obj={};
obj.prop='zyl';//报错
//可以使用Object上所有方法
obj.toString();//不会报错
```

## interface

对行为的一种抽象，具体行为由类实现

只读和js的引用是不同的

const只是地址不能改变，readonly是内容和地址都不能发生改变

因为接口的只读是编译的时候执行的，而js是运行的时候执行的

```ts
let arr:number[]=[1,2,3];
let r0:ReadonlyArray<number> =arr;

ro[0]=12;//报错
ro.push(5);//报错
ro.length=100;//报错
arr=ro;//报错
```

```tsx
interface Class{
    readOnly name:string;
    time:number;
    [propName:string]:any;
}

const c1={name:'js',time:1};
const c2={name:'browser',time:3}
const c3={name:'ts',level:1,time:2}
```

## 交叉类型

```ts
//合并冲突
interface A{
     c:string,
    d:string,
}

interface B{
    c:number,
    e:string
}

type Ab=A&B；//会把c过滤掉
let ab:AB={
    d:'class',
    e:'class'
}
```

## 断言-类型声明、转换

### 编译状态在产生作用

```ts
//尖括号形式声明
let anyValue:any='hi zyl';
let anyLength:number=(<string>anyValue).length;

//as声明
let anyValue:any='hi zyl';
let anyLength:number=(anyValue as string).length;

//非空-判断是否为空
type ClassTime=()=>number;
const start=(classTime:ClassTime|undefined)=>{
    let number=classTime?();
}
```

### 多态 - 多重状态类型

```ts
interface Teacher{
     name:string,
     courses:string[],
     score:number
}

interface Student{
    name:string,
    startTime:Date,
    score:string
}

type Class=Teacher|Student;

//in-是否包含某种属性
function startCourse(cls:Class){
    if('courses' in cls ){
        //老师
    }
    
    if('startTime' in cls){
        //学生
    }
}


//typeof /instanceof -类型分类场景下的身份确认
function startCourse(cls:Class){
    if(typeof cls.score==='number'){
        //老师
    }
    
    if(typeof cls.score==='string'){
        //学生
    }
}

function startCourse(cls:Class){
    if(cls instanceof Teacher){
        //老师
    }
    
    if(cls instanceof Student){
        //学生
    }
}

```

## 函数重载

```ts
class Class{
    start(name:number,score:number):number;
    start(name:string,score:number):string;
    start(name:string,score:number):number;
    start(name:Comnbinable,score:Comnbinable){
        if(typeof name==='number'||typeof score==='number'){
            //
        }
           if(typeof name==='string'||typeof score==='string'){
            //
        }
           if(typeof name==='string'||typeof score==='number'){
            //
        }
    }
}
```

## 泛型 -重用

```tsx
function startClass<T,U>(name:T,score:U):T{
    
}

function startClass<T,U>(name:T,score:U):string{
    
}

function startClass<T,U>(name:T,score:U):T{
    return (name+String(score)) as any as T;
}
```

## 装饰器-decorator

```ts
function ZhaoWa(target:Function):void{
    target.prototype.startClass=function():void{
        
    }
}


@ZhaoWa
class Course{
    contructor(){
        
    }
}
```

## ts实战

### webpack打包配置=>vue-cli=>webpack配置=>编译时

- entry - 入口
- extensions加上ts - 用于处理尝试的数据尾缀列表 =>面试题：如何webpack新增一种处理类型文件
- Loaders - ts-loader,增加对于ts的工具处理 =>工程化

### ts配置文件

tsconfig.json

### Vue/vuex+ts

```vue
<template>
<div>
     <vueComponent></vueComponent>
    </div>
</template>

<script lang="ts">
   //1.定义组件的方式上:形式上-extends
    //申明当前组件模块 Vue.component or Vue.extends
    import Vue from 'vue';
    const Component=Vue.extend({
        //类型推断
    })
    //2.全面拥抱面向对象 - 官方vue-class-component
    import Component from 'vue-class-component'
    //@Component本质 -类装饰器=>利用类装饰器，统一进行描述vue模版等概念
    @Component({
        components:{
            vueComponent:vueComponent
        }
    })
    export default Class myComponent extends Vue{
         message:string='Hello'
         onclick():void{
             console.log(this.message)
         }
    }
    //3.申明 - 利用ts的额外补充模块declare =>实现独立模块的声明，使之可以被独立引用
    declare module '*.vue'{
        import Vue from 'vue'
        export default Vue
    }
    declare module '/typings/vuePlugin.d.ts'{
        interface Vue{
            myProps:string
        }
    }
    
    //实例中使用
    let vm=new Vue();
    console.log(vm.myProps)
    
    //4.props 提供propType原地声明联合变量
    import {propType} from 'vue'
    interface customPayload{
        str:string,
        number:number,
        name:string
    }
    const Component=Vue.extend({
        props:{
            name:String,
            success:{
                type:string
            },
            payload:{
                type:Object as propType<customPayload>
            },
            callback:{
                type:Function as propType<()=>void>
            }
        }
    })
    
    //5.computed以及method
    computed:{
        getMsg():string{
            return this.click()+'!'
        }
    },
   methods:{
     click():string{
       return this.message+'zyl'
     }
   }
    
    //6.vuex的接入ts -声明使用
    //vue.d.ts声明模块-ComponentCustomProperties
    import {ComponentCustomProperties} from 'vue';
    declare module '@vue/runtion-core'{
        interface State{
            count:number
        }
        
        interface ComponentCustomProperties{
            $store:Store<State>
        }
    }
        
    //7.api形式编码实现-官方
      //store.ts
      import {InjectionKey} from 'vue'  
        import {createStore,Store} from 'vuex'
        export interface State{
            count:number
        }
        
        export const key:InjectionKey<Store<State>>=Symbol()
        export const store=createStore<State>({
            state:{
                count:0
            }
        })
        
        //main.ts
        import {createApp} from 'vue'
        import {store,key} from './store'
        const app=createApp({
            //传入参数
        })
        //利用provider&inject依赖注入
        app.use(store,key)//=>出入injection key
        app.mount('#app')
        //消费方
        import {useStore} from 'vuex'
        import {key} from './store'
        export default {
            const store=useStore(key);
           //store.state.count
        }
       
    //8.vuex面向对象 - 使用vuex-class工具
    import {State,Action,Getter} from 'vuex-class';
    export default class App extends Vue{
        //利用属性装饰器整合store的状态
        @State login:boolean;
        
        //利用时间装饰器，整合store方法
        @Action setInit:()=>void
        
        get isLogin:boolean;
        mounted(){
            this.setInit();
            this.isLogin=this.login;
        }
    }
</script>
```

# Esnext规范详解

const不在window中，因为const是块级作用域。而var是挂载到window中，故是全局作用域

## 死锁 -dead zone

```js
if(true){
    console.log(arg1);
    var arg1='zyl'
}
```

## let or const

```js
const obj={
    teacher:'zyl',
    leader:'zyl11'
}

obj.teacher='hhh';

//const 是常量，锁定的是栈内存
//引用类型的原理-指向地址
Obejct.freeze(obj)
//freeze的局限性=>只能冻结单层根层
function deepFreeze(obj){
    Object.freeze(obj);
    (Object.keys(obj)||[]).forEach(key=>{
         if(typeof obj[key]==='object'){
             deepFreeze(obj[key])
         }
    })
}
```

## 上下文

## 箭头函数

1.dom操作的cb

```js
const btn=document.querySelector('#btn');
btn.addEventListener('click',function(){
    this.style.color='#fff'
})
```

2.类操作，箭头函数无法构造类

3.箭头函数无法构造原型上的方法

4.箭头函数没有arguments属性

## class

class 的类型是Function

如何建立一个私有属性-闭包

```js
class Course{
     constructor(teacher,course){
         this._teacher=teacher;
         let _course='es6';
         this.getCourse=()=>{
             return _course
         }
     }
}
```

适配器模式

```js
class utils{
    constuctor(core){
        this._main=core;
        this._name='zyl'
    }
    
    get name(){
        return {
             ...this._main.name,
            name:${this._name}
        }
    }
   set  name(val){
       this._name=val;
   }
}
```

# Vue基础用法

https://www.yuque.com/lpldplws/web/dn72m7?singleDoc# 《Vue基础用法》 密码：xrw9

面试题：

## 简单聊聊对于MVVM的了解？

- 发展史以及旁支

  - 语义话模版
  - MVC - model view controller
  - MVVM -  Model-view-ViewModel(vue和react)
    - 数据会绑定在viewModel层，并自动将数据渲染到页面中
    - 视图变化的时候，会通知viewModel层去更新数据

  - mvc更关注元素本身；mvvm关注整体数据层统一

## vue是如何利用mvvm思想来进行书写？

模板式渲染+数据双向绑定

- 利用花括号，构筑了数据与视图的双向绑定=>学习曲线更加平滑
- 通过视图绑定事件，来处理数据

## 生命周期

vue生命周期

beforeCreate=>created=>beforeMount=>mounted=>beforeUpdate=>updated=>beforeDestory=>destoryed

bC：new Vue() - 实例初始化挂载功能

c: data、props、methods、computed - 数据操作，不涉及到vdom和dom

bM: vDom已经更新了的，但不涉及dom

m: dom进行任何获取或者操作

bU :vDom更新了的，dom未更新

u: dom已经更新了 - 谨慎操作数据

bD: 实例vm尚未被销毁 - 清空events,reset,store,clear

d：实例vm已经被销毁 - 首尾

react是mvvm，都是操作虚拟dom

## 条件

v-if & v-show & v-else & v-else-if

v-if 无dom,不会渲染实际节点及其子节点

v-show 存在实际节点及其子节点，只是不展示

## 循环

v-for和v-if循环优先级

在vue 2.x, 在同一个元素上同时使用v-if和v-for时候，v-for会优先作用

在vue3.x, v-if总是优先于v-for生效

## key的作用

- 模板编译原理 - template=>dom

  template => 正则匹配语法 -生成AST: 静态、动态 =>转换AST为可执行方法 =>render() => dom

- dom diff

  1 2 3 4 5 6

  6 5 7 3 2 1

  层级上: 只考虑单层复用，多层级的遍历实现

  顺序上：双向指针，首尾向中间移动

  替换上：移动、新增、删除；优先复用 - key =>快速识别顺序

- key的选取 - 尽可能地复用节点

  使用index id 随机数 

  使用index ：

  节点 1 2 3 4 5 6

  key  0 1 2 3 4 5

  节点 6 5 7 3 2 1

  key  0 1 2 3 4 5

  =>当节点顺序发生改变，或者插入元素导致index顺延的情况下

## 指令

v-once -只渲染一次

v-text -渲染字符串

v-html - 渲染html

v-bind - 绑定赋值

v-on - @监听

v-model -双向绑定 -语法糖： value + @input

## 面试题

{{}}的计算类型

- 绑定数据计算可以写在花括号里

  {{number+1}}

- 截断

  {{msg.slice(0,-1)}}

- 浮点数

  {{number.toFixed(2)}}

- 转整型

  {{parseInt(number,10)}}

- 函数加工

  {{calcNumber(number)}}

-  三元运算

  {{100>99?'yes':'no'}}

- 逻辑运算

  {{100>99&&100>98}}

- 取反

  {{!number}}

## 版本差异

### 数据上

对象响应式是否可以传递影响

2.x对象响应式可以被传递

3 响应式对象始终通过挂载实例获取（this）

### 模板上

2.x统一根模版

3.x支持碎片化模版

### 接口方法上

2.x 收敛到固定语法接口

3.x平铺方法，对齐js

### 生命周期

setup=>bc+c

onBeforeMount()=>bM

onMounted=>m

onBeforeUpdate=>bU

onUpdated()=>u

onBeforeUnMount()=>bD

onUnMount()=>d

## 1. 课程目标

1. 入门Vue，了解常见的用法；
2. 掌握面试中Vue的基础问题；
3. 掌握Vue学习路线；

## 2. 课程大纲

1. Vue.js简介
2. Vue.js模板及指令
3. 生命周期
4. Vue.js computed 和 watch

## 3. 主要内容

注意：主要以Vue2为主，Vue3的内容后续讲解

课程时间安排：

- 前四节课：课程内容+Vue2核心源码解析
- 后续课：课程+Vue3核心源码解析

官网地址：https://v2.cn.vuejs.org/

### 3.1. Vue.js简介

Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://v2.cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。

- 语义化模板

- - header
  - footer
  - template

- MVC

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1647071835190-02b721bb-406d-452f-adb9-3a1af1daf22e.png)

```javascript
// model
var myapp = {}; // 创建这个应用对象

myapp.Model = function() {
  var val = 0;

  this.add = function(v) {
    if (val < 100) val += v;
  };

  this.sub = function(v) {
    if (val > 0) val -= v;
  };

  this.getVal = function() {
    return val;
  };

  ／* 观察者模式 *／
  var self = this, 
      views = [];

  this.register = function(view) {
    views.push(view);
  };

  this.notify = function() {
    for(var i = 0; i < views.length; i++) {
        views[i].render(self);
    }
  };
};

// view
myapp.View = function(controller) {
  var $num = $('#num'),
      $incBtn = $('#increase'),
      $decBtn = $('#decrease');

  this.render = function(model) {
      $num.text(model.getVal() + 'rmb');
  };

  /*  绑定事件  */
  $incBtn.click(controller.increase);
  $decBtn.click(controller.decrease);
};

// controller
myapp.Controller = function() {
  var model = null,
      view = null;

  this.init = function() {
    /* 初始化Model和View */
    model = new myapp.Model();
    view = new myapp.View(this);

    /* View向Model注册，当Model更新就会去通知View啦 */
    model.register(view);
    model.notify();
  };

  /* 让Model更新数值并通知View更新视图 */
  this.increase = function() {
    model.add(1);
    model.notify();
  };

  this.decrease = function() {
    model.sub(1);
    model.notify();
  };
};

// init
(function() {
  var controller = new myapp.Controller();
  controller.init();
})();
```

- MVVM

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1647072104508-55c6d7e4-d8c5-4f39-afab-def587496cae.png)

```javascript
// model
var data = {
    val: 0
};

// view
<div id="myapp">
    <div>
        <span>{{ val }}rmb</span>
    </div>
    <div>
        <button v-on:click="sub(1)">-</button>
        <button v-on:click="add(1)">+</button>
    </div>
</div>

// controller
new Vue({
  el: '#myapp',
  data: data,
  methods: {
    add(v) {
        if(this.val < 100) {
            this.val += v;
        }
    },
    sub(v) {
        if(this.val > 0) {
            this.val -= v;
        }
    }
  }
});

// MVVM
// 1. 数据会绑定在viewModel层并自动将数据渲染到页面中
// 2. 视图变化时，会通知viewModel层更新数据

// Vue是不是MVVM？React呢？
// 严格来讲都不是
// React：ui = render (data) 单向数据流
// Vue:   ref 直接操作DOM，跳过了ViewModel
```

### 3.2. Vue.js模板及指令

#### 3.2.1. Vue.js实例

每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：

```js
var vm = new Vue({
  // 选项
})
```

在Vue2里，虽然没有完全遵循 MVVM，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例。

当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。

```js
// 我们的数据对象
var data = { a: 1 }

// 该对象被加入到一个 Vue 实例中
var vm = new Vue({
  data: data
})

// 获得这个实例上的 property
// 返回源数据中对应的字段
vm.a == data.a // => true

// 设置 property 也会影响到原始数据
vm.a = 2
data.a // => 2

// ……反之亦然
data.a = 3
vm.a // => 3
```

当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，比如：

```
vm.b = 'hi'
```

那么对 b 的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如：

```js
data: {
  newTodoText: '',
  visitCount: 0,
  hideCompletedTodos: false,
  todos: [],
  error: null
}
```

这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。

```js
var obj = {
  foo: 'bar'
}

Object.freeze(obj)

new Vue({
  el: '#app',
  data: obj
})
```

除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。例如：

```j s
var data = { a: 1 }
var vm = new Vue({
  el: '#example',
  data: data
})

vm.$data === data // => true
vm.$el === document.getElementById('example') // => true

// $watch 是一个实例方法
vm.$watch('a', function (newValue, oldValue) {
  // 这个回调将在 `vm.a` 改变后调用
})
```

注意：具体的监听派发更新过程后续源码解析时讲解，此处会用即可

#### 3.2.2. Vue.js模板

模板引擎编译源码部分讲解，此处需要理解会用即可

Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。

在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。

##### 3.2.2.1. 文本

数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：

```
<span>Message: {{ msg }}</span>
```

Mustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。

通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：

```
<span v-once>这个将不会改变: {{ msg }}</span>
```

##### 3.2.2.2. 原始HTML

双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html指令：

```j s
<p>Using mustaches: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

Using mustaches: <span style="color: red">This should be red.</span>

Using v-html directive: This should be red.

这个 span 的内容将会被替换成为 property 值 rawHtml，直接作为 HTML——会忽略解析 property 值中的数据绑定。

注意：动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。

##### 3.2.2.3. 属性

Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind指令：

```
<div v-bind:id="dynamicId"></div>
```

##### 3.2.2.4. 使用 JavaScript 表达式

迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。

```j s
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div v-bind:id="'list-' + id"></div>
```

这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。

```js
<!-- 这是语句，不是表达式 -->
{{ var a = 1 }}

<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

#### 3.2.3. Vue.js指令

指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。

```
<p v-if="seen">现在你看到我了</p>
```

这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 <p> 元素。

##### 3.2.3.1. 参数

一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML attribute：

```
<a v-bind:href="url">...</a>
```

在这里 href 是参数，告知 v-bind 指令将该元素的 href attribute 与表达式 url 的值绑定。

另一个例子是 v-on 指令，它用于监听 DOM 事件：

```
<a v-on:click="doSomething">...</a>
```

##### 3.2.3.2. 动态参数

从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：

```js
<!--
注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。
-->
<a v-bind:[attributeName]="url"> ... </a>
```

这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data property attributeName，其值为 "href"，那么这个绑定将等价于 v-bind:href。

同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：

```
<a v-on:[eventName]="doSomething"> ... </a>
```

在这个示例中，当 eventName 的值为 "focus" 时，v-on:[eventName] 将等价于 v-on:focus。

对动态参数的值的约束

动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。

对动态参数表达式的约束

动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：

```js
<!-- 这会触发一个编译警告 -->
<a v-bind:['foo' + bar]="value"> ... </a>
```

##### 3.2.3.3. [修饰符](https://v2.cn.vuejs.org/v2/api/#v-on)

修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：

```
<form v-on:submit.prevent="onSubmit">...</form>
```

##### 3.2.3.4. 缩写

v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。

- v-bind缩写

```js
<!-- 完整语法 --> 
<a v-bind:href="url">...</a> 

<!-- 缩写 -->
<a :href="url">...</a> 

<!-- 动态参数的缩写 (2.6.0+) --> 
<a :[key]="url"> ... </a>
```

- v-on缩写

```j s
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a @[event]="doSomething"> ... </a>
```

##### 3.2.3.5. 自定义指令

除了核心功能默认内置的指令 ( v-model 和 v-show )，Vue 也允许注册自定义指令。在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。

Vue 自定义指令有全局注册和局部注册两种方式。全局注册指令的方式，通过 `Vue.directive( id, [definition] )` 方式注册全局指令。如果想注册局部指令，组件中也接受一个directives的选项。

```javascript
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})

// 注册一个局部自定义指令 `v-focus`
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
```

然后我们可以在模板中任何元素上使用`v-focus` property，如下：

```javascript
<input v-focus>
```

当我们需要批量注册自定义指令时，写很多个``Vue.directive( id, [definition] ) 会导致代码冗余，所以我们可以利用Vue.use()` 的特性，完成批量注册。

批量注册指令，新建 `directives/directive.js` 文件

```javascript
// 导入指令定义文件
import debounce from './debounce'
import throttle from './throttle'
// 集成一起
const directives = {
  debounce,
  throttle,
}
//批量注册
export default {
  install(Vue) {
    Object.keys(directives).forEach((key) => {
      Vue.directive(key, directives[key])
    })
  },
}
```

在 main.js 引入，并Vue.use() 调用完成批量注册。

```javascript
import Vue from 'vue'
import Directives from './directives/directive.js'
Vue.use(Directives)
```

一个指令定义对象可以提供如下几个钩子函数 (均为可选)：

- bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作，此时获取父节点为null。
- inserted: 被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中），此时可以获取到父节点。
- update: 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新
- componentUpdated: 指令所在组件的 VNode 及其子 VNode 全部更新后调用。
- unbind: 只调用一次， 指令与元素解绑时调用。

接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。

指令钩子函数会被传入以下参数：

- el：指令所绑定的元素，可以用来直接操作 DOM。
- binding：一个对象，包含以下 property： 

- - name：指令名，不包括 v- 前缀。
  - value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
  - oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
  - expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。
  - arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。
  - modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。

- vnode：Vue 编译生成的虚拟节点。
- oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。

###### 3.2.3.5.1. v-longpress

```javascript
// directive
const longpress = {
  bind: function (el, {value:{fn,time}}) {
    //没绑定函数直接返回
    if (typeof fn !== 'function') return
    // 定义定时器变量
    el._timer = null
    // 创建计时器（ n秒后执行函数 ）
    el._start = (e) => {
      //e.type表示触发的事件类型如mousedown,touchstart等
      //pc端: e.button表示是哪个键按下0为鼠标左键，1为中键，2为右键
      //移动端: e.touches表示同时按下的键为个数
      if (  (e.type === 'mousedown' && e.button && e.button !== 0) || 
            (e.type === 'touchstart' && e.touches && e.touches.length > 1)
      ) return;
      //定时长按n秒后执行事件
      if (el._timer === null) {
        el._timer = setTimeout(() => {
          fn()
        }, time)
        //取消浏览器默认事件，如右键弹窗
        el.addEventListener('contextmenu', function(e) {
          e.preventDefault();
        })
      }
    }
    // 如果两秒内松手，则取消计时器
    el._cancel = (e) => {
      if (el._timer !== null) {
        clearTimeout(el._timer)
        el._timer = null
      }
    }
    // 添加计时监听
    el.addEventListener('mousedown', el._start)
    el.addEventListener('touchstart', el._start)
    // 添加取消监听
    el.addEventListener('click', el._cancel)
    el.addEventListener('mouseout', el._cancel)
    el.addEventListener('touchend', el._cancel)
    el.addEventListener('touchcancel', el._cancel)
  },
  // 指令与元素解绑时，移除事件绑定
  unbind(el) {
    // 移除计时监听
    el.removeEventListener('mousedown', el._start)
    el.removeEventListener('touchstart', el._start)
    // 移除取消监听
    el.removeEventListener('click', el._cancel)
    el.removeEventListener('mouseout', el._cancel)
    el.removeEventListener('touchend', el._cancel)
    el.removeEventListener('touchcancel', el._cancel)
  },
}

export default longpress

// 引用
<template>
  <button v-longpress="{fn: longpress,time:2000}">长按</button>
</template>

<script>
export default {
  methods: {
    longpress () {
      console.log('长按指令生效')
    }
  }
}
</script>
```

###### 3.2.3.5.2. v-debounce

```javascript
const debounce = {
  inserted: function (el, {value:{fn, event, time}}) {
    //没绑定函数直接返回
    if (typeof fn !== 'function') return
    el._timer = null
    //监听点击事件，限定事件内如果再次点击则清空定时器并重新定时
    el.addEventListener(event, () => {
      if (el._timer !== null) {
        clearTimeout(el._timer)
        el._timer = null
      }
      el._timer = setTimeout(() => {
        fn()
      }, time)
    })
  },
}

export default debounce

// 引用
<template>
  <input v-debounce="{fn: debounce, event: 'input', time: 5000}" />
</template>

<script>
export default {
  methods: {
    debounce(){
      console.log('debounce 防抖')
    },
  }
}
</script>
```

###### 3.2.3.5.3. v-throttle

```javascript
const throttle = {
    bind:function (el,{value:{fn,time}}) {
        if (typeof fn !== 'function') return
        el._flag = true;//开关默认为开
        el._timer = null
        el.handler = function () {
            if (!el._flag) return;
            //执行之后开关关闭
            el._flag && fn()
            el._flag = false
            if (el._timer !== null) {
                clearTimeout(el._timer)
                el._timer = null
            }
            el._timer = setTimeout(() => {
                el._flag = true;//三秒后开关开启
            }, time);
        }
        el.addEventListener('click',el.handler)
    },
    unbind:function (el,binding) {
        el.removeEventListener('click',el.handler)
    }
}

export default throttle

// 引用
<template>
 <button v-throttle="{fn: throttle,time:3000}">throttle节流</button>
</template>

<script>
export default {
  methods: {
    throttle () {
      console.log('throttle 节流 只触发一次')
    }
  }
}
</script>
```

### 3.3. Vue.js生命周期

#### 3.3.1. 生命周期内容

| 生命周期      | 描述                               |
| ------------- | ---------------------------------- |
| beforeCreate  | 组件实例被创建之初                 |
| created       | 组件实例已经完全创建               |
| beforeMount   | 组件挂载之前                       |
| mounted       | 组件挂载到实例上去之后             |
| beforeUpdate  | 组件数据发生变化，更新之前         |
| updated       | 组件数据更新之后                   |
| beforeDestroy | 组件实例销毁之前                   |
| destroyed     | 组件实例销毁之后                   |
| activated     | keep-alive 缓存的组件激活时        |
| deactivated   | keep-alive 缓存的组件停用时调用    |
| errorCaptured | 捕获一个来自子孙组件的错误时被调用 |

#### 3.3.2. 生命周期功能

后续源码课程会讲解生命周期的实现

1. beforeCreate -> created

- - 初始化vue实例，进行数据观测

2. created

- - 完成数据观测，属性与方法的运算，watch、event事件回调的配置
  - 可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算
  - 此时vm.$el 并没有被创建

3. created -> beforeMount

- - 判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译
  - vm.el获取到的是挂载DOM的

4. beforeMount

- - 在此阶段可获取到vm.el
  - 此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上

5. beforeMount -> mounted

- - 此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM

6. mounted

- - vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM

7. beforeUpdate

- - 更新的数据必须是被渲染在模板上的（el、template、render之一）
  - 此时view层还未更新
  - 若在beforeUpdate中再次修改数据，不会再次触发更新方法

8. updated

- - 完成view层的更新
  - 若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated）

9. beforeDestroy

- - 实例被销毁前调用，此时实例属性与方法仍可访问

10. destroyed

- - 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器
  - 并不能清除DOM，仅仅销毁实例

使用场景分析

| 生命周期      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| beforeCreate  | 执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务 |
| created       | 组件初始化完毕，各种数据可以使用，常用于异步数据获取         |
| beforeMount   | 未执行渲染、更新，dom未创建                                  |
| mounted       | 初始化结束，dom已创建，可用于获取访问数据和dom元素           |
| beforeUpdate  | 更新前，可用于获取更新前各种状态                             |
| updated       | 更新后，所有状态已是最新                                     |
| beforeDestroy | 销毁前，可用于一些定时器或订阅的取消                         |
| destroyed     | 组件已销毁，作用同上                                         |

### 3.4. Vue.js computed 和 watch

#### 3.4.1. computed

```js
<div id="example">
  {{ message.split('').reverse().join('') }}
</div>
```

在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。

所以，对于任何复杂逻辑，你都应当使用计算属性。

```j s
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
```

```js
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

结果：

- Original message: "Hello"
- Computed reversed message: "olleH"

##### 3.4.1.1. computed 和 method

你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：

```js
<p>Reversed message: "{{ reversedMessage() }}"</p>
```

```js
// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```

我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。

不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。

这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：

```js
computed: {
  now: function () {
    return Date.now()
  }
}
```

相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。

我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。

##### 3.4.1.2. computed vs watch

Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子：

```js
<div id="demo">{{ fullName }}</div>
```

```
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})
```

上面代码是命令式且重复的。将它与计算属性的版本进行比较：

```js
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

##### 3.4.1.3. computed的 setter

计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：

```js
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
```

现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。

#### 3.4.2. watch

虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。

```j s
<div id="watch-example">
  <p>
    Ask a yes/no question:
  	<input v-model="question">
  </p>
  <p>{{ answer }}</p>
</div>
```

```js
<!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 -->
<!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 -->
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
<script>
  
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    }
  },
  created: function () {
    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
    // 请参考：https://lodash.com/docs#debounce
    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
  },
  methods: {
    getAnswer: function () {
      if (this.question.indexOf('?') === -1) {
        this.answer = 'Questions usually contain a question mark. ;-)'
        return
      }
      this.answer = 'Thinking...'
      var vm = this
      axios.get('https://yesno.wtf/api')
        .then(function (response) {
          vm.answer = _.capitalize(response.data.answer)
        })
        .catch(function (error) {
          vm.answer = 'Error! Could not reach the API. ' + error
        })
    }
  }
})
  </script>
```

在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

#### 3.4.3. 异同点

##### 3.4.3.1. 相同点

1. 基于vue的依赖收集机制；

2. 都是被依赖的变化触发，进行改变进而进行处理计算；

##### 3.4.3.2. 不同点

1. 入和出

computed：多入单出 —— 多个值变化，组成一个值的变化；

watch：单入多出 —— 单个值的变化，进而影响一系列的状态变更；

2. 性能

computed：会自动diff依赖，若依赖没有变化，会改从缓存中读取当前计算值；

watch：无论监听值变化与否，都会执行回调；

3. 写法上

computed: 必须有return返回值；

watch: 不一定；

4. 时机上

computed：从首次生成赋值，就开始计算运行了；

watch: 首次不会运行，除非——immediate：true；

# vue高级用法

https://www.yuque.com/lpldplws/web/ck0csfxciuzol315?singleDoc# 《Vue高级用法》 密码：tczl

## 1. 课程目标

1. 深入学习Vue mixin、插件及过滤器；
2. 简单掌握Vue的设计思路，为后续Vue源码作铺垫；

## 2. 课程大纲

1. Vue mixin；
2. Vue 插件；
3. Vue过滤器；
4. Vue的设计思路；

## 3. Vue mixin

官方给出了解释：

混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。

这段话在理解上很简单，无非就是将每个组件中共同功能抽离出来，而所有共同功能所有组成的一个对象就会被作为一个 Mixin 处理。

通俗点将，就是将组件的公共逻辑或者配置提取出来，哪个组件需要用到时，直接将提取的这部分混入到组件内部即可。这样既可以减少代码冗余度，也可以让后期维护起来更加容易。

这里需要注意的是：提取的是逻辑或配置，而不是HTML代码和CSS代码。其实大家也可以换一种想法，mixin就是组件中的组件，Vue组件化让我们的代码复用性更高，那么组件与组件之间还有重复部分，我们使用Mixin在抽离一遍。

### 3.1. Vue mixin 和 Vuex的区别

上文中提到，Mixin就是一个抽离公共部分的作用。在Vue中，Vuex状态管理似乎也是做的这一件事，它也是将组件之间可能共享的数据抽离出来。两者看似一样，实则还是有细微的区别，区别如下：

1. Vuex公共状态管理，如果在一个组件中更改了Vuex中的某个数据，那么其它所有引用了Vuex中该数据的组件也会跟着变化；
2. Mixin中的数据和方法都是独立的，组件之间使用后是互相不影响的；

### 3.2. mixin的使用

初始化vite模板后，在src下创建一个mixin的文件夹，初始化代码。

```javascript
export const mixins = {
	data() {
		return {};
	},
	computed: {},
	created() {},
	mounted() {},
	methods: {},
};
```

我们可以看到，mixin此时包含了组件的基础逻辑。然后进行更新。

```javascript
export const mixins = {
	data() {
		return {
			msg: 'xianzao',
		};
	},
	computed: {},
	created() {
		console.log('我是mixin中的created生命周期函数');
	},
	mounted() {
		console.log('我是mixin中的mounted生命周期函数');
	},
	methods: {
		clickMe() {
			console.log('我是mixin中的点击事件');
		},
	},
};
```

#### 3.2.1. 局部混入

根据不同的业务场景，我们将mixin可以分为两种：局部混入和全局混入。顾名思义，局部混入和组件的按需加载有点类似，就是需要用到mixin中的代码时，我们再在组件章引入它。全局混入的话，则代表我在项目的任何组件中都可以使用mixin。

组件中引入mixin也非常简单，我们稍微改造下`App.vue`组件。

```javascript
<template>
	<div id="app">
		<img alt="Vue logo" src="./assets/vue.svg" />
		<button @click="clickMe">点击我</button>
	</div>
</template>

<script>
import { mixins } from './mixin/index';
export default {
	name: 'App',
	mixins: [mixins],
	components: {},
	created() {
		console.log('组件调用mixin数据', this.msg);
	},
	mounted() {
		console.log('我是组件的mounted生命周期函数');
	},
};
</script>
```

上段代码中引入mixin的方法也非常简单，直接使用vue提供给我们的mixins属性：mixins:[mixins]。

通过上面的代码和效果我们可以得出以下几点：

1. mixin中的生命周期函数会和组件的生命周期函数一起合并执行；
2. mixin中的data数据在组件中也可以使用；
3. mixin中的方法在组件内部可以直接调用；
4. 生命周期函数合并后执行顺序：先执行mixin中的，后执行组件的；

Q：如果一个组件中改动了mixin中的数据，另一个引用了mixin的组件会受影响吗？

A：答案是不会的。

在component中新建Demo组件

```javascript
// src/components/demo.vue
<template>
  <div>mixin中的数据：{{ msg }}</div>
</template>
<script>
import { mixins } from "../mixin/index";
export default {
  mixins: [mixins],
};
</script>
```

在App中引入，发现：

```javascript
<template>
	<div id="app">
		<img alt="Vue logo" src="./assets/vue.svg" />
		<button @click="clickMe">点击我</button>
		<button @click="changeMsg">更改mixin数据</button>
		<Demo></Demo>
	</div>
</template>

<script>
import { mixins } from './mixin/index';
import Demo from './components/Demo.vue';
export default {
	name: 'App',
	mixins: [mixins],
	components: { Demo },
	created() {
		console.log('组件调用minxi数据', this.msg);
	},
	mounted() {
		console.log('我是组件的mounted生命周期函数');
	},
	methods: {
		changeMsg() {
			this.msg = 'updated xianzao';
			console.log('更改后的msg:', this.msg);
		},
	},
};
</script>
```

1. 我们在demo组件中引入了mixin，且使用了mixin中的msg数据；
2. 在App.vue中同样引入了mixin，且设置了点击事件更改msg；
3. 点击按钮，更改msg，查看demo组件中显示是否有变化；

可以看到我们在App.vue组件中更改了msg后，demo组件显示没有任何变化，所以不同组件中的mixin是相互独立的。

#### 3.2.2. 全局混入

修改main

```javascript
import { createApp } from 'vue';
import './style.css';
import App from './App.vue';
import { mixins } from './mixin/index';

const app = createApp(App);

app.mixin(mixins);

app.mount('#app');
```

在App.js中去掉mixin部分：

```javascript
<template>
	<div id="app">
		<img alt="Vue logo" src="./assets/vue.svg" />
		<button @click="clickMe">点击我</button>
		<button @click="changeMsg">更改mixin数据</button>
		<Demo></Demo>
	</div>
</template>

<script>
import Demo from './components/Demo.vue';
export default {
	name: 'App',
	components: { Demo },
	created() {
		console.log('组件调用minxi数据', this.msg);
	},
	mounted() {
		console.log('我是组件的mounted生命周期函数');
	},
	methods: {
		changeMsg() {
			this.msg = 'updated xianzao';
			console.log('更改后的msg:', this.msg);
		},
	},
};
</script>
```

可以发现效果上和局部混入没有任何区别，这就是全局混入的特点。

请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。

#### 3.2.3. 选项合并

如果mixin中定义的属性或方法的名称与组件中定义的名称有冲突，怎么办？

这里的冲突主要分为以下几种情况：

1. 生命周期函数：先执行mixin中生命周期函数中的代码，然后在执行组件内部的代码；
2. data数据冲突：组件中的data数据会覆盖mixin中数据

```javascript
var mixin = {
  data: function () {
    return {
      message: 'hello',
      foo: 'abc'
    }
  }
}

new Vue({
  mixins: [mixin],
  data: function () {
    return {
      message: 'goodbye',
      bar: 'def'
    }
  },
  created: function () {
    console.log(this.$data)
    // => { message: "goodbye", foo: "abc", bar: "def" }
  }
})
```

1. 方法冲突：选择组件本身的方法

```javascript
var mixin = {
  methods: {
    foo: function () {
      console.log('foo')
    },
    conflicting: function () {
      console.log('from mixin')
    }
  }
}

var vm = new Vue({
  mixins: [mixin],
  methods: {
    bar: function () {
      console.log('bar')
    },
    conflicting: function () {
      console.log('from self')
    }
  }
})

vm.foo() // => "foo"
vm.bar() // => "bar"
vm.conflicting() // => "from self"
```

### 3.3. mixin优缺点

优点：

1. 提高代码复用；
2. 无需传递状态；
3. 维护方便，只需要修改一个地方即可；

缺点：

1. 命名冲突；
2. 滥用的话后期很难维护；
3. 不好追溯源，排查问题稍显麻烦；
4. 不能轻易的重复代码；

### 3.4. Vue中的选项式合并策略

在Vue的初始化过程中，最开始的阶段就是选项合并阶段。它通过调用mergeOptions函数将两个选项配置合并成一个选项配置。这里的选项options的形式实际上就是我们平时开发时在Vue中写的对象配置，形式如下：

```javascript
 { 
   components: {}, 
   filters: {},
   data() { return {} }, 
   computed: {}, 
   created: {}, 
   methods: {},
   ... 
 }
```

因此，选项合并实际可以简单的看作是两个上面的对象合并成一个对象。

由于`mergeOptions`是实现实例化(`new Vue(options)`)、继承(`Vue.extend`)和混入(`Vue.mixin`)三大功能的核心函数，所以分析它的实现是理解Vue实例化过程和继承的必经之路。 下面我们将从以下几个方面来全面了解Vue中的选项合并：

1. 实例化过程中的选项，了解我们需要合并的选项是怎样的；
2. `mergeOptions`的实现，了解各个合并策略；
3. 继承(`Vue.extend`和`extends`:{})的选项合并；
4. 混入(`Vue.mixin`和`mixins`:[])的选项合并；
5. 为什么实例化过程中有时用`initInternalComponent`而不是`mergeOptions`；

#### 3.4.1. 实例化过程中的选项

Vue的实例化过程调用的是`core/instance/init.js`文件中的`_init`方法。（先了解，后面源码课会讲）

```javascript
 Vue.prototype._init = function (options?: Object) {
   const vm: Component = this
 
   ...
 
   vm.$options = mergeOptions(
     resolveConstructorOptions(vm.constructor),
     options || {},
     vm
   )
 
   ...
 }
```

实例化的过程中第一个重要的处理就是选项的合并，这里第二个参数比较容易理解，就是我们平时写的Vue的配置项。第一个参数则是通过`resolveConstructorOptions(vm.constructor)`生成，找到`resolveConstructorOptions`方法，代码如下：

```javascript
 // * 返回构造函数的 options
 export function resolveConstructorOptions (Ctor: Class<Component>) {
   // * 如果不是继承，options 就是原构造函数的 options
   // * 如果是继承时，options 为合并 superOptions 和 extendOptions 的 options
   // * 此外，这里的 options 还包含了全局注册的 组件/指令/过滤器
   let options = Ctor.options
   // * Ctor.super 存在说明是调用了 extend 方法进行继承生成的构造函数
   // * 详见 /src/core/global-api/extend.js 文件
   // * - superOptions 是父类 options
   // * - extendOptions 是当前类传入的 options (如果与 sealedOptions不同，需要合并)
   // * - options = mergeOptions(superOptions, extendOptions)
   // * - sealedOptions 保存的是当前类继承时 合并后的 options(是extend的时候赋值的)
   if (Ctor.super) {
     const superOptions = resolveConstructorOptions(Ctor.super)
     const cachedSuperOptions = Ctor.superOptions
     // * 如果 superOptions 变动了，需要处理新的 options
     if (superOptions !== cachedSuperOptions) {
       Ctor.superOptions = superOptions
       // * sealedOptions 是 seal 的时候赋值的，
       // * 这里的变动可能是 options 在 extend 后继续被赋值
       // * 复现：https://jsfiddle.net/vvxLyLvq/2/
       // * 所以需要找出变动了的属性，然后更新到 extendOptions 上
       // * 这里的 extend 只是对象的合并
       const modifiedOptions = resolveModifiedOptions(Ctor)
       if (modifiedOptions) {
         extend(Ctor.extendOptions, modifiedOptions)
       }
       // * 由于 options 变化了，重新合并一次
       options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
       if (options.name) {
         // * 将自身的构造函数也存到了 components 对象中
         options.components[options.name] = Ctor
       }
     }
   }
   return options
 }
```

这里传入的是当前构造函数，那么`Ctor.options`指的是Vue构造函数的`options`。这里我们先了解，Vue。options的内容大致如下：

```javascript
 // Vue.options 内容
 {
   components: {
     KeepAlive,
     Transition,
     TransitionGroup
   },
   filters: {},
   directives: {
     model,
     show
   },
   _base: Vue
 }
```

再看下一句`Ctor.super`的判断，super这个字段是在`core/global-api/extend.js`文件中的extend方法调用时添加的。如果`Ctor.super`存在，说明Ctor是通过继承而来的子构造函数。但是，如果在extend后，我们又在父构造函数的options上添加新的属性，这个时候子构造函数是无法继承新的属性的。因此，这里需要通过`Ctor.super`向上寻找，找出所有父构造函数更新的options属性，并更新到子构造函数上，这样就能解决`Vue.options`被更改的问题了。 有兴趣的话，可以看一下Vue的[issues#4976](https://github.com/vuejs/vue/issues/4976)。

最后，经过`resolveConstructorOptions`处理后，最终得到的同样是一个Vue的配置选项，下一步则是需要将这两个配置选项进行合并了。

#### 3.4.2. mergeOptions的实现

##### 3.4.2.1. 选项校验和规范化

`mergeOptions`函数的定义是在`/src/core/util/options.js`文件当中，部分代码如下：

```javascript
 export function mergeOptions (
   parent: Object,// 选项
   child: Object, // 选项
   vm?: Component // Vue 实例
 ): Object {
   // * 1. 校验选项中的 components 里的名称是否合法。
   if (process.env.NODE_ENV !== 'production') {
     checkComponents(child)
   }
   
   // * ['type1'], { type2: { type: String, default: '' } } 两种形式
   // * 2. 都转换成后一种形式
   normalizeProps(child, vm)
   
   // * ['injectKey1'], { injectKey2: { from: 'xxx', default: 'yyy' } } 两种形式
   // * 3. 都转换成后一种形式
   normalizeInject(child, vm)
   
   // * directive 有两种形式 function() {} 或者是 { bind, update, ... }
   // * 4. 都转换成后一种形式
   normalizeDirectives(child)
 
   // * 合并策略
   ...
 }
```

在正式合并之前，会优先校验components里的组件名称是否合法，如果不合法会进行提示。

```javascript
function checkComponents (options: Object) {
   for (const key in options.components) {
     validateComponentName(key)
   }
 }
 
 // 校验组件名称是否合法
 export function validateComponentName (name: string) {
   // 1. 判断组件名是否合法，如数字开头的则不合法
   if (!new RegExp(`^[a-zA-Z][\-\.0-9_${unicodeRegExp.source}]*$`).test(name)) {
     warn(
       'Invalid component name: "' + name + '". Component names ' +
       'should conform to valid custom element name in html5 specification.'
     )
   }
   // 2. 判断组件是否是自身定义的组件名，如 slot 等。
   // 3. 判断组件是否是 html 中的标签名，如 div 等
   if (isBuiltInTag(name) || config.isReservedTag(name)) {
     warn(
       'Do not use built-in or reserved HTML elements as component ' +
       'id: ' + name
     )
   }
 }
```

除此之外， Vue还做了以下几点处理。通过选项形式的转换，将多种写法的选项转换成统一形式：

1. `normalizeProps`方法：处理props，将数组形式定义的props转换成对象形式。
2. `normalizeInject`方法：处理inject，将数组形式定义的inject转换成对象形式。
3. `normalizeDirectives`方法：处理directives，将指令数组里函数形式定义的directive转换成对象形式。

处理前和处理后对比结果如下：

```javascript
 // ===> 处理前 <===
 {
   props: ['user-name'],
   inject: ['id'],
   directives: [function add() {}]
 }
 
 // ===> 处理后 <====
 {
   // 对象形式
   props: {
     userName: { // 转换成驼峰命名
       type: null
     }
   },
   // 对象形式
   inject: {
     id: {
       from: 'id'
     }
   },
   directives: [{
     // 对象形式
     bind: function add() {}
     update: function add() {}
   }]
 }
```

在校验完成之后，接下里就是正式的合并流程了，Vue针对每个规定的配置选项都有定义好的合并策略，例如`data`,`component`,`mounted`,`methods`等。如果Vue父子选项配置具有相应的选项，那么直接按照相应的合并策略进行合并。合并的入口如下：

```javascript
 export function mergeOptions (
   parent: Object,
   child: Object,
   vm?: Component
 ): Object {
   ...
   // * 合并策略
   const options = {}
   let key
   for (key in parent) {
     mergeField(key)
   }
   for (key in child) {
     if (!hasOwn(parent, key)) {
       mergeField(key)
     }
   }
   function mergeField (key) {
     // 根据 key 获取相应的合并策略
     const strat = strats[key] || defaultStrat
     // 用相应的合并策略进行合并
     options[key] = strat(parent[key], child[key], vm, key)
   }
   return options
 }
```

以上通过两个for循环，遍历`parent`和`child`的key（key这里指的是`data`/`methods`/`created`等），然后依次调用`mergeField`方法。`mergeField`则是通过key在strats中找到对应的合并策略，然后用该合并策略进行相应合并。如果找不到合并策略，则使用默认合并策略`defaultStrat`。

这里的strats已经在该文件中定义，现在重点来看一下Vue中strats是如何定义合并策略的。

##### 3.4.2.2. data合并

```javascript
 strats.data = function (
   parentVal: any,
   childVal: any,
   vm?: Component
 ): ?Function {
   if (!vm) {
     if (childVal && typeof childVal !== 'function') {
       process.env.NODE_ENV !== 'production' && warn(
         'The "data" option should be a function ' +
         'that returns a per-instance value in component ' +
         'definitions.',
         vm
       )
       return parentVal
     }
     return mergeDataOrFn(parentVal, childVal)
   }
 
   return mergeDataOrFn(parentVal, childVal, vm)
 }
```

可以看出当vm不存在时，如果`childVal`即`data`不为函数形式，那么在非开发环境下就会报错，这也是为什么我们平时在写组件data时需要写成函数形式的原因。

但是这里的vm在什么情况下不存在呢？我们可以全局搜索一下`mergeOptions(`，看看哪些位置调用了该方法：

![img](https://cdn.nlark.com/yuque/0/2023/png/2340337/1673512997783-64242c76-aff2-45de-95aa-eaec810cb022.png)



 可以看出，在`extend`，`mixin`中，由于处理构造函数阶段时，是没有实例的，所以也就不会传vm。这里我们主要讨论`extend`。

接下来我们全局搜索一下`extend`在哪些地方被调用了。

![img](https://cdn.nlark.com/yuque/0/2023/png/2340337/1673513049847-5d0ef41c-d979-4ba4-b307-c5a92ccddeef.png)

可以看到，extend方法主要在两个位置被调用。

第一个位置在 `src/core/global-api/assets.js`文件。

```javascript
 ASSET_TYPES.forEach(type => {
   Vue[type] = function (
     id: string,
     definition: Function | Object
   ): Function | Object | void {
       ...
       if (type === 'component' && isPlainObject(definition)) {
         definition.name = definition.name || id
         // * 通过继承，返回新的构造函数（相当于 子组件 的构造函数）
         definition = this.options._base.extend(definition)
       }
       ...
       // * component / directive / filter 
       // * 将注册的内容全部添加到 Vue 构造函数的 options 上
       this.options[type + 's'][id] = definition
       return definition
   }
 })
```

通过遍历`ASSET_TYPES`，在Vue构造函数上添加了component静态属性，即当我们使用`Vue.component`的时候，实际上会执行这里的`this.options._base.extend(definition)`，即调用了extend方法来将传入的组件选项合并后返回新的构造函数。

第二个位置在`src/core/vdom/create-component.js`文件：

```javascript
 export function createComponent (
   Ctor: Class<Component> | Function | Object | void,
   data: ?VNodeData,
   context: Component,
   children: ?Array<VNode>,
   tag?: string
 ): VNode | Array<VNode> | void {
   ...
   // * 这里的 Ctor 有几种形式
   // * 1. 全局形式定义的 component，那么 Ctor 是构造函数形式
   // * 2. 局部定义的 component，那么是 对象形式。会对对象形式进行 extend 处理
   const baseCtor = context.$options._base
 
   // 对象形式。会对对象形式进行 extend 处理
   if (isObject(Ctor)) {
     Ctor = baseCtor.extend(Ctor)
   }
   ...
   return vnode
 }
```

传入的Ctor一种情况是全局定义的组件，此时Ctor通过extend创建，传入的是构造函数形式。另外一种情况则是局部注册的组件，传入的是选项配置形式，此时会执行`baseCtor.extend(Ctor)`，同样会通过extend来创建构造函数。

因此，无论是全局注册的组件还是局部组件，最终都会调用extend方法，而extend方法在合并选项的时候会校验传入的data是否是函数形式，这也就是为什么在定义组件时data必须是以函数形式定义。

好了，了解完了data在组件中为什么要为函数形式后，我们继续看data的后续合并过程。`mergeDataOrFn`函数执行时最终调用的都是`mergeData`函数：

```javascript
 function mergeData (to: Object, from: ?Object): Object {
   if (!from) return to
   let key, toVal, fromVal
 
   const keys = hasSymbol
     ? Reflect.ownKeys(from)
     : Object.keys(from)
 
   for (let i = 0; i < keys.length; i++) {
     key = keys[i]
     // key 为 __ob__ 则跳过 
     if (key === '__ob__') continue
     toVal = to[key]
     fromVal = from[key]
     // * 自身不存在这个key，那么使用将 from 的 key 和 value 添加到 to 上
     // * 如果 to 原本是响应式的，那么新增的 key 值也需要是响应式的
     if (!hasOwn(to, key)) {
       set(to, key, fromVal)
     } else if (
       toVal !== fromVal &&
       isPlainObject(toVal) &&
       isPlainObject(fromVal)
     ) {
       // * 如果都是对象，继续合并
       mergeData(toVal, fromVal)
     }
   }
   return to
 }
```

这里的`mergeData`比较简单，实际上就是递归将两个对象合并。需要注意的是，在合并的过程中，如果data是响应式的，那么合并后添加的属性也需要是响应式的。

##### 3.4.2.3. 生命周期合并

生命周期的钩子是在`src/shared/constant.js`中定义：

```javascript
 export const LIFECYCLE_HOOKS = [
 'beforeCreate',
 'created',
 'beforeMount',
 'mounted',
 'beforeUpdate',
 'updated',
 'beforeDestroy',
 'destroyed',
 'activated',
 'deactivated',
 'errorCaptured',
 'serverPrefetch'
]
```

`mergeHook`是生命周期钩子合并的策略，其核心是将父选项和子选项的对应生命周期合并成数组形式，如果存在相同的生命周期执行函数，那么会进行去重处理。

```javascript
function mergeHook (
   parentVal: ?Array<Function>,
   childVal: ?Function | ?Array<Function>
 ): ?Array<Function> {
   const res = childVal
     ? parentVal
       // 都存在时，拼接数组
       ? parentVal.concat(childVal)
       : Array.isArray(childVal)
         // parent 不存在时
         ? childVal
         : [childVal]
     // child 不存在，使用 parent
     : parentVal
   return res
     ? dedupeHooks(res)
     : res
 }
 
 // hooks 去重
 function dedupeHooks (hooks) {
   const res = []
   for (let i = 0; i < hooks.length; i++) {
     if (res.indexOf(hooks[i]) === -1) {
       res.push(hooks[i])
     }
   }
   return res
 }
 
 LIFECYCLE_HOOKS.forEach(hook => {
   strats[hook] = mergeHook
 })
```

结合具体例子看看实际合并的结果：

```javascript
 const extend = {
     created() {
       console.log('extends')
     }
   }
   const mixins = {
     created() {
       console.log('mixins')
     }
   }
 
   // 父构造函数
   const Parent = Vue.extend({
     created() {
       console.log('parent created')
     },
     mixins: [mixins],
     extends: extend,
   })

   // 子构造函数
   const Child = Parent.extend({
     created() {
       console.log('child')
     },
     mixins: [mixins],
     extends: {
       created() {
         console.log('child extends')
       }
     }
   })

   new Child()
   // extends
   // mixins
   // parent created
   // child extends
   // child
```

由于mixins里的created在合并时去重了，所以只会打印一遍mixins。另外可以看出，生命周期在执行时，`parent`和`extends/mixins`里的生命周期都是优先于child生命周期执行的。 

##### 3.4.2.4. components/filters/directives合并

```javascript
 function mergeAssets (
   parentVal: ?Object,
   childVal: ?Object,
   vm?: Component,
   key: string
 ): Object {
   const res = Object.create(parentVal || null)
   if (childVal) {
     process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm)
     return extend(res, childVal)
   } else {
     return res
   }
 }
 
 ASSET_TYPES.forEach(function (type) {
   strats[type + 's'] = mergeAssets
 })
```

`Object.create()`方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。

这合并资源选项的时候，首先会创建一个原型指向父选项的空对象，再将子选项赋值给空对象。注意这里的父选项是通过原型链访问，而子选项是直接添加到对象上的。例如:

```javascript
Vue.component('test', {})
 const vm = new Vue({
   components: {
     test: 'test'
   }
 })
console.log('vm.$options ==> ', vm.$options);
// 合并后，父类的 options 通过 __proto__ 访问
{ 
 components: {
   test: "test",
   __proto__: {
     KeepAlive: { ... },
     Transition: { ... },
     TransitionGroup: { ... },
     test: ...
   }
 },
 directives: {},
 filters: {},
 _base: ...
}
```

这里的__proto__指向的就是选项的components。

##### 3.4.2.5. watch合并

watch的策略是：

1. 当子选项不存在时，使用父选项；
2. 当父选项不存在时，使用子选项；
3. 当父选项和子选项都存在时，如果他们具有相同的观测字段，那么将其合并成数组形式；

```javascript
strats.watch = function (
 parentVal: ?Object,
 childVal: ?Object,
 vm?: Component,
 key: string
): ?Object {
 ...
 // 子类不存在，使用父类
 if (!childVal) return Object.create(parentVal || null)
 ...
 // 父类不存在，使用子类
 if (!parentVal) return childVal
 const ret = {}
 extend(ret, parentVal)
 for (const key in childVal) {
   let parent = ret[key]
   const child = childVal[key]
   // 如果父类存在，改写成数组形式
   if (parent && !Array.isArray(parent)) {
     parent = [parent]
   }
   // 拼接父类和子类
   ret[key] = parent
     ? parent.concat(child)
     : Array.isArray(child) ? child : [child]
 }
 return ret
}
```

##### 3.4.2.6. props,methods,inject,computed合并

这一类的选项合并比较简单：

- 当父选项不存在时，使用子选项；
- 当子选项不存在时，使用父选项；
- 当两者都存在时，使用子选项覆盖父选项。

```javascript
strats.props =
 strats.methods =
 strats.inject =
 strats.computed = function (
   parentVal: ?Object,
   childVal: ?Object,
   vm?: Component,
   key: string
 ): ?Object {
   if (childVal && process.env.NODE_ENV !== 'production') {
     assertObjectType(key, childVal, vm)
   }
   if (!parentVal) return childVal
   // 创建空对象
   const ret = Object.create(null)
   extend(ret, parentVal)
   if (childVal) extend(ret, childVal)
   return ret
 }
```

##### 3.4.2.7. 总结

到这里我们就已经对所有的合并策略都有所了解了。总结一下就是

1. `data`、`provide`、`props`、`methods`、`inject`、`computed`、`components`、`filters`、`directives`基本都是在父子选项同时存在的情况下，子覆盖父；
2. 生命周期在父子选项同时存在的情况下，会合并成数组形式，且去重；
3. watch在父子选项同时存在的情况下，会合并成数组形式，不去重；

#### 3.4.3. Vue.extend的实现

`Vue.extend`的定义是在`core/gloabl-api/extend.js`文件里面，主要用于通过选项配参数生成新的构造函数。这里的参数`extendOptions`就是我们在定义组件时传入的配置选项。

```javascript
 Vue.extend = function (extendOptions: Object): Function {
   extendOptions = extendOptions || {}
   const Super = this
   const SuperId = Super.cid
   const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
   // * 1. 查看配置选项中是否缓存有构造函数
   if (cachedCtors[SuperId]) {
     return cachedCtors[SuperId]
   }

   // * 2. 校验组件名称
   const name = extendOptions.name || Super.options.name
   if (process.env.NODE_ENV !== 'production' && name) {
     validateComponentName(name)
   }

   // * 3. 继承
   const Sub = function VueComponent (options) {
     this._init(options)
   }
   Sub.prototype = Object.create(Super.prototype)
   Sub.prototype.constructor = Sub
   Sub.cid = cid++
 
   ...
 }
```

前半段主要做了三件事：

1. 检验是否通过该选项配置生成过相应构造函数，如果生成过，那么直接使用生成的构造函数即可。这里相当于做了一层优化；
2. 校验组件名称是否合法；
3. 通过原型实现继承，生成新的构造函数

接下来就是选项合并：

```javascript
 // * 4. 合并选项
 Sub.options = mergeOptions(
   Super.options,
   extendOptions
 )
```

参数`Super.options`就是`Vue.options`，前面已经提过两次，这里不再赘述了。这里合并后相当于将`Vue.options`扩充了，并将扩充后的结果保存到`Sub.options`上（即新的构造函数options上），所以在通过该构造函数实例化的时候，拥有`extendOptions`配置的相关功能。

最后，会在新生成的构造函数上添加一些静态方法和属性。注意这里的`superOptioins`/`extendOptions`/`sealedOptioins`都在`resolveConstructorOptions`方法寻找options中使用到。

```javascript
 // * 5. 添加 super
 Sub['super'] = Super
   
 ...

 // * 6. 添加一些方法
 // allow further extension/mixin/plugin usage
 Sub.extend = Super.extend
 Sub.mixin = Super.mixin
 Sub.use = Super.use
 ASSET_TYPES.forEach(function (type) {
   Sub[type] = Super[type]
 })
 if (name) {
   Sub.options.components[name] = Sub
 }

 // * 7. 添加一些属性
 // * 父选项
 Sub.superOptions = Super.options
 // * 传入的配置选项
 Sub.extendOptions = extendOptions
 // * 合并后的配置相许那个
 Sub.sealedOptions = extend({}, Sub.options)
```

最后总结来讲，`Vue.extend`方法实际上就是通过原型继承，并将`Vue.options`与`extendOptions`合并，从而实现一个新的构造函数。

#### 3.4.4. Vue.mixin的实现

Vue.mixin方法的实现更是简单，打开`core/global-api/mixin.js`

```javascript
Vue.mixin = function (mixin: Object) {
 this.options = mergeOptions(this.options, mixin)
 return this
}
```

实际上就是将两个选项配置进行合并。

## 4. Vue插件

### 4.1. 官方介绍

官网中提到，插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：

1. 添加全局方法或者 property。如：[vue-custom-element](https://github.com/karol-f/vue-custom-element)；
2. 添加全局资源：指令/过滤器/过渡等。如 [vue-touch](https://github.com/vuejs/vue-touch)；
3. 通过全局混入来添加一些组件选项。如 [vue-router](https://github.com/vuejs/vue-router)；
4. 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现；
5. 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 [vue-router](https://github.com/vuejs/vue-router)；

通过全局方法 `Vue.use()` 使用插件。它需要在你调用 `new Vue()` 启动应用之前完成：

```javascript
// 调用 `MyPlugin.install(Vue)`
Vue.use(MyPlugin)

new Vue({
  // ...组件选项
})
```

也可以传入一个可选的选项对象：

```javascript
Vue.use(MyPlugin, { someOption: true })
```

Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。

Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 `Vue.use()`。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 `Vue.use()`：

```javascript
var Vue = require('vue')
var VueRouter = require('vue-router')

// 不要忘了调用此方法
Vue.use(VueRouter)
```

开发插件

Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：

```javascript
MyPlugin.install = function (Vue, options) {
  // 1. 添加全局方法或 property
  Vue.myGlobalMethod = function () {
    // 逻辑...
  }

  // 2. 添加全局资源
  Vue.directive('my-directive', {
    bind (el, binding, vnode, oldVnode) {
      // 逻辑...
    }
    ...
  })

  // 3. 注入组件选项
  Vue.mixin({
    created: function () {
      // 逻辑...
    }
    ...
  })

  // 4. 添加实例方法
  Vue.prototype.$myMethod = function (methodOptions) {
    // 逻辑...
  }
}
```

### 4.2. 原理解析

Vue插件概括出来就是

1. 通过`Vue.use(MyPlugin)`使用，本质上是调用`MyPlugin.install(Vue)`；
2. 使用插件必须在new Vue()启动应用之前完成，实例化之前就要配置好；
3. 如果使用Vue.use多次注册相同插件，那只会注册成功一次；



`Vue.use`定义在`src/core/global-api`中，源码如下：

```javascript
Vue.use = function (plugin) {   
  // 忽略已注册插件
  if (plugin.installed) {
    return
  }
  
  // 集合转数组，并去除第一个参数
  var args = toArray(arguments, 1);
  
  // 把this（即Vue）添加到数组的第一个参数中
  args.unshift(this);
  
  // 调用install方法
  if (typeof plugin.install === 'function') {
    plugin.install.apply(plugin, args);
  } else if (typeof plugin === 'function') {
    plugin.apply(null, args);
  }
  
  // 注册成功
  plugin.installed = true;
  return this;
};
```

Vue.use接受一个对象参数plugin，首先判断是否已注册，如果多次注册相同插件那么只会注册成功一次，在注册成功后设置`plugin.installed = true`。

然后执行`toArray(arguments, 1)`方法，arguments是一个表示所有参数的类数组对象，需要转换成数组之后才能使用数组的方法。

```javascript
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  // 循环去除 前start元素
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}
```

上面进行了一次转换，假设list是[1, 2, 3, 4]，start是1，首先创建一个包含3个元素的数组，依次执行`ret[2] = list[ 2 + 1]`、`ret[1] = list[ 1 + 1]`、`ret[0] = list[ 0 + 1]`，实际上就是去除arguments的第一个参数然后把剩余的类数组赋值给新的数组，其实就是去除plugin参数，因为调用plugin.install的时候不需要这个参数。

转换成数组之后调用`args.unshift(this)`，把Vue对象添加到args的第一个参数中，这样就可以在调用`plugin.install`方法的时候把Vue对象传递过去。

### 4.3. 实现一个插件

要求创建一个告诉Vue组件处理自定义rules规则选项的插件，这个rules需要一个对象，该对象指定组件中的数据的验证规则。

```javascript
const vm = new Vue({
  data: { foo: 10 },
  rules: {
    foo: {
      validate: value => value > 1,
      message: 'foo must be greater than one'
    }
  }
})

vm.foo = 0 // 输出 foo must be greater than one
```

1. 先不考虑插件，在已有的VueAPI中是没有rules这个公共方法的，如果要简单实现的话可以通过钩子函数来，即在`created`里面验证逻辑。

```javascript
const vm = new Vue({
    data: { foo: 10 },
    rules: {
        foo: {
          validate: value => value > 1,
          message: 'foo must be greater than one'
        }
    },
    created: function () {
      
        // 验证逻辑
        const rules = this.$options.rules
        if (rules) {
          Object.keys(rules).forEach(key => {
          
            // 取得所有规则
            const { validate, message } = rules[key]
            
            // 监听，键是变量，值是函数
            this.$watch(key, newValue => {
            
              // 验证规则
              const valid = validate(newValue)
              if (!valid) {
                console.log(message)
              }
            })
          })
        }
      }
    
})
```

可以通过`this.$options.rules`获取到自定义的rules对象，然后对所有规则遍历，使用自定义的`validate(newValue)`验证规则。

2. 实现这个rules插件，为了在Vue中直接使用，可以通过`Vue.mixin`注入到Vue组件中，这样所有的Vue实例都可以使用。

按照插件的开发流程，应该有一个公开方法`install`，在`install`里面使用全局的mixin方法添加一些组件选项，`mixin`方法包含一个`created`钩子函数，在钩子函数中验证`this.$options.rules`。

```javascript
import Vue from 'vue'

// 定义插件
const RulesPlugin = {

  // 插件应该有一个公开方法install
  // 第一个参数是Vue 构造器
  // 第二个参数是一个可选的选项对象
  install (Vue) {
  
    // 注入组件
    Vue.mixin({
    
      // 钩子函数
      created: function () {
      
        // 验证逻辑
        const rules = this.$options.rules
        if (rules) {
          Object.keys(rules).forEach(key => {
          
            // 取得所有规则
            const { validate, message } = rules[key]
            
            // 监听，键是变量，值是函数
            this.$watch(key, newValue => {
            
              // 验证规则
              const valid = validate(newValue)
              if (!valid) {
                console.log(message)
              }
            })
          })
        }
      }
    })
  }
}

// 调用插件，实际上就是调用插件的install方法
// 即RulesPlugin.install(Vue)
Vue.use(RulesPlugin)
```

## 5. Vue过滤器

### 5.1. filter介绍

过滤器（filter）实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数。

Vue 允许你自定义过滤器，可被用于一些常见的文本格式化。

在Vue3中已经废弃filter

### 5.2. 如何使用？

vue中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，过滤器应该被添加在 JavaScript表达式的尾部，由“管道”符号指示：

```javascript
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

### 5.3. 定义filter

在组件的选项中定义本地的过滤器：

```javascript
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
```

定义全局过滤器

```vue
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})
```

注意： 当全局过滤器和局部过滤器重名时，会采用局部过滤器

过滤器可以串联：

```javascript
{{ message | filterA | filterB }}
```

在这个例子中，filterA被定义为接收单个参数的过滤器函数，表达式message的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数filterB，将filterA的结果传递到filterB中。

过滤器是JavaScript函数，因此可以接收参数：

```javascript
{{ message | filterA('arg1', arg2) }}
```

其中message的值作为第一个参数，普通字符串'arg1'作为第二个参数，表达式arg2的值作为第三个参数

```javascript
<div id="app">
    <p>{{ msg | msgFormat('xianzao','--')}}</p>
</div>

<script>
    // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat
    Vue.filter('msgFormat', function(msg, arg, arg2) {
        // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则
        return msg.replace(/单纯/g, arg+arg2)
    })
</script>
```

### 5.4. 使用场景

平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等

比如我们要实现将30000 => 30,000，这时候我们就需要使用过滤器。

```javascript
Vue.filter('toThousandFilter', function (value) {
     if (!value) return ''
     value = value.toString()
     return replace(str.indexOf('.') > -1 ? /(\d)(?=(\d{3})+\.)/g : /(\d)(?=(?:\d{3})+$)/g, '$1,')
})
```

### 5.5. filter原理

使用过滤器

```javascript
{{ message | capitalize }}
```

在模板编译阶段过滤器表达式将会被编译为过滤器函数，主要是用过`parseFilters`，我们放到最后讲

```javascript
_s(_f('filterFormat')(message))
```

首先分析一下`_f`：

_f 函数全名是：`resolveFilter`，这个函数的作用是从`this.$options.filters`中找出注册的过滤器并返回

```javascript
// 变为
this.$options.filters['filterFormat'](message) // message为参数
```

关于`resolveFilter`

```javascript
import { indentity,resolveAsset } from 'core/util/index' 

export function resolveFilter(id){
    return resolveAsset(this.$options,'filters',id,true) || identity
}
```

内部直接调用`resolveAsset`，将`option`对象，类型，过滤器id，以及一个触发警告的标志作为参数传递，如果找到，则返回过滤器；

`resolveAsset`的代码如下：

```javascript
export function resolveAsset(options,type,id,warnMissing){ // 因为我们找的是过滤器，所以在 resolveFilter函数中调用时 type 的值直接给的 'filters',实际这个函数还可以拿到其他很多东西
    if(typeof id !== 'string'){ // 判断传递的过滤器id 是不是字符串，不是则直接返回
        return 
    }
    const assets = options[type]  // 将我们注册的所有过滤器保存在变量中
    // 接下来的逻辑便是判断id是否在assets中存在，即进行匹配
    if(hasOwn(assets,id)) return assets[id] // 如找到，直接返回过滤器
    // 没有找到，代码继续执行
    const camelizedId  = camelize(id) // 万一你是驼峰的呢
    if(hasOwn(assets,camelizedId)) return assets[camelizedId]
    // 没找到，继续执行
    const PascalCaseId = capitalize(camelizedId) // 万一你是首字母大写的驼峰呢
    if(hasOwn(assets,PascalCaseId)) return assets[PascalCaseId]
    // 如果还是没找到，则检查原型链(即访问属性)
    const result = assets[id] || assets[camelizedId] || assets[PascalCaseId]
    // 如果依然没找到，则在非生产环境的控制台打印警告
    if(process.env.NODE_ENV !== 'production' && warnMissing && !result){
        warn('Failed to resolve ' + type.slice(0,-1) + ': ' + id, options)
    }
    // 无论是否找到，都返回查找结果
    return result
}
```

下面再来分析一下`_s`：

`_s` 函数的全称是 `toString`,过滤器处理后的结果会当作参数传递给 `toString`函数，最终 toString函数执行后的结果会保存到`Vnode`中的text属性中，渲染到视图中

```javascript
function toString(value){
    return value == null
    ? ''
    : typeof value === 'object'
      ? JSON.stringify(value,null,2)// JSON.stringify()第三个参数可用来控制字符串里面的间距
      : String(value)
}
```

最后，在分析下`parseFilters`，在模板编译阶段使用该函数阶段将模板过滤器解析为过滤器函数调用表达式

```javascript
function parseFilters (filter) {
    let filters = filter.split('|')
    let expression = filters.shift().trim() // shift()删除数组第一个元素并将其返回，该方法会更改原数组
    let i
    if (filters) {
        for(i = 0;i < filters.length;i++){
            experssion = warpFilter(expression,filters[i].trim()) // 这里传进去的expression实际上是管道符号前面的字符串，即过滤器的第一个参数
        }
    }
    return expression
}
// warpFilter函数实现
function warpFilter(exp,filter){
    // 首先判断过滤器是否有其他参数
    const i = filter.indexof('(')
    if(i<0){ // 不含其他参数，直接进行过滤器表达式字符串的拼接
        return `_f("${filter}")(${exp})`
    }else{
        const name = filter.slice(0,i) // 过滤器名称
        const args = filter.slice(i+1) // 参数，但还多了 ‘)’
        return `_f('${name}')(${exp},${args}` // 注意这一步少给了一个 ')'
    }
}
```

总结一下：

1. 在编译阶段通过parseFilters将过滤器编译成函数调用（串联过滤器则是一个嵌套的函数调用，前一个过滤器执行的结果是后一个过滤器函数的参数）；
2. 编译后通过调用resolveFilter函数找到对应过滤器并返回结果；
3. 执行结果作为参数传递给toString函数，而toString执行后，其结果会保存在Vnode的text属性中，渲染到视图；

## 6. Vue的设计思路

在Vue项目中，所有核心的代码都是在src目录下完成，为了更好的了解Vue的底层实现，我们首先来了解一下src目录下代码的组织情况，从全局入手，在脑海里留下简单的印象，方便后续的学习。

```javascript
 .
 ├── compiler  // 编译模块：将 template 编译成为可以生成 vnode 的 render 函数
 │   ├── codeframe.js
 │   ├── codegen             // 代码生成文件：根据 ast 树可生成 vnode 的 render代码
 │   ├── create-compiler.js  // 创建编译器的工厂函数
 │   ├── directives          // 指令解析：v-on, v-bind, v-model
 │   ├── error-detector.js   
 │   ├── helpers.js          // 编译相关方法，如属性获取等方法
 │   ├── index.js            // 入口文件
 │   ├── optimizer.js        // 编译优化：将 ast 树进行优化
 │   ├── parser                      // html 解析文件：将 template 解析成 ast 树🌲
 │   └── to-function.js      // 创建编译器的工厂函数
 ├── core     // 构造函数核心模块：构建Vue构造函数，添加原型方法，实现完成渲染流程的_init方法
 │   ├── components  // 自带的全局组件，如 keep-alive
 │   ├── config.js   // 配置相关
 │   ├── global-api  // 全局api，如 Vue.use, extend, mixin, component等方法
 │   ├── index.js    // 入口文件，在 Vue 上挂载全局方法并导出 Vue
 │   ├── instance    // 构造函数起始位置
 │   ├── observer    // 响应式原理
 │   ├── util        // 一些工具方法，包含 mergeOptions, nextTick 等方法的实现
 │   └── vdom        // 虚拟 dom
 ├── platforms // 平台相关，包含不同平台的不同构建入口，这里主要研究web端
 │   ├── weex
 │   └── web
 │       ├── compiler   // 与平台相关的编译
 │       ├── entry-compiler.js // vue-template-compiler 包的入口文件
 │       ├── entry-runtime-with-compiler.js // 构建入口，包含编译器
 │       ├── entry-runtime.js  // 构建入口，不包含编译器，不支持 template 转换 render
 │       ├── entry-server-basic-renderer.js
 │       ├── entry-server-renderer.js
 │       ├── runtime   // 与平台相关的构建
 │       ├── server
 │       └── util
 │
 ├── server    // 服务端渲染相关
 ├── sfc       // 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包
 └── shared    // 代码库通用代码
     ├── constants.js
     └── util.js
```

### 6.1. Vue的真实面目

要想真正的了解Vue是怎样的，首先我们需要找到Vue是咋哪里被定义的。我们先找到package.json文件下的scripts配置。scripts里存放的都是运行命令的别名形式，通过命令可以轻松找到对应命令执行文件的路径。

```json
 "scripts": {
     "dev": "rollup -w -c scripts/config.js --environment TARGET:full-dev"
  }
```

这里当运行dev命令实际上是运行`scripts/config.js`文件，让我们找到`scripts/config.js`文件。

通过运行命令参数我们可以知道`process.env.TARGET`的值为`full-dev`，因此可以在builds里找到对应的配置文件，如下：

```javascript
 const builds = {
   'full-dev': {
       entry: resolve('web/entry-runtime-with-compiler.js'),
       dest: resolve('dist/vue.js'),
       format: 'umd',
       env: 'development',
       alias: { he: './entity-decoder' },
       banner
    }
   ...
 }
 
 module.exports = genConfig(process.env.TARGET)
```

通过entry，我们找到`web/entry-runtime-with-compiler.js`文件：

```javascript
import Vue from './runtime/index'

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  ...
}
Vue.compile = compileToFunctions

export default Vue
```

这是Vue的起始入口。接着根据Vue的引入路径，找到`./runtime/index`文件：

```javascript
 import Vue from 'core/index'
 ...
 Vue.prototype.__patch__ = inBrowser ? patch : noop
 Vue.prototype.$mount = function (
   el?: string | Element,
   hydrating?: boolean
 ): Component {
   ...
 }
 export default Vue
```

这里还不是Vue真正的起始点，继续查找`core/index`文件：

```javascript
 import Vue from './instance/index'
 initGlobalAPI(Vue)
 ...
 Vue.version = '__VERSION__'
 export default Vue
```

继续查找`./instance/index`文件：

```javascript
 import { initMixin } from './init'
 import { stateMixin } from './state'
 import { renderMixin } from './render'
 import { eventsMixin } from './events'
 import { lifecycleMixin } from './lifecycle'
 import { warn } from '../util/index'
 
 // Vue 构造函数
 function Vue (options) {
   if (process.env.NODE_ENV !== 'production' &&
     !(this instanceof Vue)
   ) {
     warn('Vue is a constructor and should be called with the `new` keyword')
   }
   this._init(options)
 }
 
 // 向原型上添加方法属性
 initMixin(Vue)
 stateMixin(Vue)
 eventsMixin(Vue)
 lifecycleMixin(Vue)
 renderMixin(Vue)
 
 export default Vue
```

到这里就找到了Vue的真正定义的位置！

可以看出Vue其实就是一个构造函数：

1. 原型方法属性：通过 5 个 init 方法，向Vue的原型上添加方法；
2. 静态方法属性：在导入Vue构造函数的过程中，向Vue构造函数上添加静态方法，也有向原型上添加方法；
3. 实例化：在实例化的过程中，执行_init方法，完成整个Vue初始化到渲染的逻辑；

Vue的原型方法（通过5个init方法添加）：

#### 6.1.1. initMixin

```javascript
 export function initMixin (Vue: Class<Component>) {
   Vue.prototype._init = function (options?: Object) {
     // init 实现内容，由于这里仅做概览，所以具体实现均已省略
     ... 
   }
 }
```

从上面Vue构造函数我们可以知道，这个方法在实例化时有被调用，它主要的作用是实现：选项的合并，数据初始化（如响应式处理），以及触发编译和渲染的流程，所以十分重要。这里也只是先做一个了解，后续源码课讲解。

#### 6.1.2. stateMixin

stateMixin主要实现了`data`,`props`的代理功能，即当我们访问$data时，实际访问的是`_data`。另外在非生产环境下，会对`$data`,`$props`进行 set处理，每次设置新的值时都会打印提示，所以实际上`$data`,`$props`都是只读属性。

```javascript
 export function stateMixin (Vue: Class<Component>) {
   const dataDef = {}
   dataDef.get = function () { return this._data }
   const propsDef = {}
   propsDef.get = function () { return this._props }
   // 只读属性
   if (process.env.NODE_ENV !== 'production') {
     dataDef.set = function () {
       warn(
         'Avoid replacing instance root $data. ' +
         'Use nested data properties instead.',
         this
       )
     }
     propsDef.set = function () {
       warn(`$props is readonly.`, this)
     }
   }
   Object.defineProperty(Vue.prototype, '$data', dataDef)
   Object.defineProperty(Vue.prototype, '$props', propsDef)
   Vue.prototype.$set = set
   Vue.prototype.$delete = del
   Vue.prototype.$watch = function () { ... }
 }
```

#### 6.1.3. eventsMixin

和node里EventEmitter类似，eventsMixin实现了四个方法：`$on`,`$off`,`$once`,`$emit`，用于监听，触发，销毁事件：

```javascript
 export function eventsMixin (Vue: Class<Component>) {
   const hookRE = /^hook:/
   Vue.prototype.$on = function () { ... }
   Vue.prototype.$once = function () { ... }
   Vue.prototype.$off = function () { ... }
   Vue.prototype.$emit = function () { ... }
 }
```

#### 6.1.4. lifecycleMixin

lifecycleMixin实现了三个方法：`_update`方法非常重要，它主要负责将`vnode`生成真实节点。

```plain
 export function lifecycleMixin (Vue: Class<Component>) {
   // 更新，将 vnode 生成 真实节点
   Vue.prototype._update = function () { ... }
   // 强制刷新
   Vue.prototype.$forceUpdate = function () { ... }
   // 销毁
   Vue.prototype.$destroy = function () { ... }
 }
```

#### 6.1.5. renderMixin

```javascript
 export function renderMixin (Vue: Class<Component>) {
   installRenderHelpers(Vue.prototype)
 
   Vue.prototype.$nextTick = function (fn: Function) {
     return nextTick(fn, this)
   }
   
   Vue.prototype._render = function (): VNode {
     return vnode
   }
 }
```

1. `installRenderHelpers`函数用于添加render相关方法，在编译环节最后生成的代码，都是由这些方法拼接而成的代码，相当于AST中最后生成代码的阶段；
2. `$nextTick`方法，在下一次事件循环触发，涉及到事件循环机制；
3. `_render`方法，用于生成`vnode`；

### 6.2. Vue的静态方法属性

通过上面5个init方法我们已经了解了许多原型方法的添加过程，但是在Vue中还有很多全局方法，比如`Vue.component``,Vue.use`等方法，它们都是构造函数的静态属性，下面我们看看这些静态属性是如何添加的。与寻找Vue的起始位置过程恰恰相反，这次我们从Vue的起始文件出发，看看最后导出的Vue是怎样的。

#### 6.2.1. src/core/index.js文件

```javascript
 import { initGlobalAPI } from './global-api/index'
 
 initGlobalAPI(Vue)
 
 // ... 中间省略
 
 Vue.version = '__VERSION__'
```

这里我们看一下`initGlobalAPI`方法，打开`core/global-api/index.js`文件

```javascript
export function initGlobalAPI (Vue: GlobalAPI) {
  Vue.util = {
    warn,
    extend,
    mergeOptions,
    defineReactive
  }

  Vue.set = set
  Vue.delete = del
  Vue.nextTick = nextTick

  // 2.6 explicit observable API
  Vue.observable = <T>(obj: T): T => {
    observe(obj)
    return obj
  }

  Vue.options = Object.create(null)
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  Vue.options._base = Vue

  extend(Vue.options.components, builtInComponents)

  initUse(Vue)
  initMixin(Vue)
  initExtend(Vue)
  initAssetRegisters(Vue)
}
```

这里挂载了很多静态方法，Vue中大多数的全局方法都在这个位置添加的，这里我们着重分析一下`options`：

```javascript
import builtInComponents from '../components/index'  

 Vue.options = Object.create(null)
 ASSET_TYPES.forEach(type => {
   Vue.options[type + 's'] = Object.create(null)
 })

 Vue.options._base = Vue

 extend(Vue.options.components, builtInComponents)  
 // Vue.options 内容
 {
   components: {
     KeepAlive
   },
   filters: {},
   directives: {},
   _base: Vue
 }
```

#### 6.2.2. /src/platforms/web/runtime/index.js文件

这里是第二层引入Vue的文件，主要给Vue处理平台相关的一些方法

```javascript
 import Vue from 'core/index'
 import config from 'core/config'
 import { extend, noop } from 'shared/util'
 import { mountComponent } from 'core/instance/lifecycle'
 import { devtools, inBrowser } from 'core/util/index'
 
 import {
   query,
   mustUseProp,
   isReservedTag,
   isReservedAttr,
   getTagNamespace,
   isUnknownElement
 } from 'web/util/index'
 
 import { patch } from './patch'
 import platformDirectives from './directives/index'
 import platformComponents from './components/index'
 
 // install platform specific utils
 Vue.config.mustUseProp = mustUseProp
 Vue.config.isReservedTag = isReservedTag
 Vue.config.isReservedAttr = isReservedAttr
 Vue.config.getTagNamespace = getTagNamespace
 Vue.config.isUnknownElement = isUnknownElement
 
 // install platform runtime directives & components
 extend(Vue.options.directives, platformDirectives)
 extend(Vue.options.components, platformComponents)
 
 Vue.prototype.__patch__ = inBrowser ? patch : noop
 Vue.prototype.$mount = function () { ... }
 
 export default Vue
```

这里首先给Vue.config添加了一系列方法，注意，这些方法之所以在这里添加而不是在`core/index.js`文件里添加，是因为这里的方法都与平台相关，不同的平台的方法实现也会不一样。

```javascript
extend(Vue.options.directives, platformDirectives)
extend(Vue.options.components, platformComponents)
```

这两个extend实际上进一步扩充了`Vue.options`方法，扩充后的内容如下

```javascript
 // Vue.options 内容
 {
     components: {
     KeepAlive,
     // 新增 platformComponents
     Transition,
     // 新增 platformComponents
     TransitionGroup
   },
   filters: {},
   directives: {
     // 新增 platformDirectives
     model,
     // 新增 platformDirectives
     show
   },
   _base: Vue
 }
```

这也是为什么我们可以不用注册也能全局使用`v-model`、`v-show`的原因了，因为Vue已经帮我们全局注册了。

#### 6.2.3. /src/platforms/web/entry-runtime-with-compiler.js文件

```javascript
 import Vue from './runtime/index'
 ...
 
 const mount = Vue.prototype.$mount
 Vue.prototype.$mount = function (
   el?: string | Element,
   hydrating?: boolean
 ): Component {
     
     ...
     
   return mount.call(this, el, hydrating)
 }
 
 Vue.compile = compileToFunctions
 
 export default Vue
```

这里主要是重新实现了`$mount`方法，但是为什么原先在`runtime/index.js`文件里实现了`$mount`方法，这里又要重新实现一遍呢？因为`runtime/index.js`里的`$mount`与编译是无关的，无法处理template模板代码，而这里重写的`$mount`实际上还是调用了`runtime/index.js`里的`$mount`，但是在此之前，增加了从`template`到`render`的编译过程。

### 6.3. 实例化阶段

上述已经将Vue的各种方法属性挂载完毕，现在则是需要进行实例化了，也就是调用之前提到的`_init`方法。打开`/src/core/instance/init.js`文件，代码如下：

```javascript
 Vue.prototype._init = function (options?: Object) {
     const vm: Component = this
     ...
 
     // 1. 合并options
     if (options && options._isComponent) {
       initInternalComponent(vm, options)
     } else {
       vm.$options = mergeOptions(
         resolveConstructorOptions(vm.constructor),
         options || {},
         vm
       )
     }
   
     ...
 
     // 2. 初始化数据
     initLifecycle(vm)
     initEvents(vm)
     initRender(vm)
     callHook(vm, 'beforeCreate')
     initInjections(vm) // resolve injections before data/props
     initState(vm)
     initProvide(vm) // resolve provide after data/props
     callHook(vm, 'created')
 
     // 3. 挂载
     if (vm.$options.el) {
       vm.$mount(vm.$options.el)
     }
   }
```

在初始化的过程中，主要分为三个阶段：

1. 合并选项，将 Vue.options和传入的options进行合并；
2. 初始化数据，并对数据进行响应式处理；
3. 编译代码，得到render函数，将vnode生成真实节点，并挂载到界面；

具体的详细源码讲解，在后续课程中讲述。

# vue-cli

https://www.yuque.com/lpldplws/web/lhptox?singleDoc# 《2. xianzao-cli》 密码：bx09

https://github.com/xianzao/xianzao-cli

## 1.目标

实现一个项目初始化cli，为后续项目提供统一初始化脚手架

## 2.知识准备&技术选型

### 2.1命令行交互

目标：通过命令式的交互，完成在日常业务开发中，封装成具有交互行为的cli

常见的命令行交互的npm包有：

- [commander](https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md)：命令行完整的解决方案；
- [cac](https://github.com/cacjs/cac)：类似 Commander.js 但更轻巧、现代，支持插件；
- [chalk](https://github.com/chalk/chalk)：命令行样式处理；
- [Inquirer](https://github.com/SBoudrias/Inquirer.js/)：交互式的命令行界面；
- [minimist](https://github.com/minimistjs/minimist)：简单的命令行参数解析；
- [semver](https://github.com/semver/semver)：npm包语义化处理；
- [fs-extra](https://github.com/jprichardson/node-fs-extra)：fs包的代替，且继承了fs所有方法和为fs方法添加了promise的支持；

本次选择cac、fs-extra、inquirer、chalk开发

### 2.2开发调试

目标：方便在开发调试阶段时，实现快速开发node应用的工具类

- [nodemon](https://github.com/remy/nodemon)：监听文件更新变化，并自动重启进程；
- [cross-spawn](https://github.com/moxystudio/node-cross-spawn)：类似node.js 的子进程 (child_process) 的spawn模块，可以在调用 spawn 函数时，自动根据当前的运行平台执行指令；
- [ts-node](https://github.com/TypeStrong/ts-node)：提供TS的node运行环境，因为TS 是JS的超集，因此使用它意味着在 V8 引擎能够理解它们之前将TS 文件编译为纯JS；
- [typescript](https://github.com/microsoft/TypeScript)：给JS添加各种静态类型；

### 2.3开发标准化

- [husky](https://github.com/typicode/husky)：添加git hooks工具；
- [commitizen](https://github.com/commitizen/cz-cli)：优化commit提交规范；
- [commitlint](https://github.com/conventional-changelog/commitlint)：校验commit提交规范；
- [cz-customizable](https://github.com/leoforfree/cz-customizable)：定制commit提交规范；

## 3.开发

### 3.1目录结构

```js
|____.husky // husky配置
|____README.md
|____.gitignore
|____package-lock.json
|____package.json
|____.github // git action
|____commitlint.config.js // commit 限制
|____tsconfig.json // TS 配置
|____index.ts // 入口文件
|____build // 打包&更新package.json版本工具
|____src
| |____core
| | |____special.ts // 针对Vue3优化
| | |____husky.ts	// 针对husky配置
| | |____vscode.ts // 针对vscode配置
| | |____eslint.ts // 针对eslint配置
| | |____eslintignore.ts // eslint ignore配置
| | |____commitlint.ts // 针对commitlint配置
| |____template // 配置模板
| |____cli.ts // CLI执行入口
| |____utils // 工具类
| |____start.ts // 标准化配置执行入口
| |____interface.ts // TS interface
```

### 3.2配置项目基础内容

#### 3.2.1初始化项目

根据自己的项目配置

```js
npm init
git init
```

安装上述说明的各种依赖，配置如下：

```js
"dependencies": {
  "cac": "^6.7.14",
  "chalk": "^4.1.2",
  "cross-spawn": "^7.0.3",
  "fs-extra": "^10.1.0",
  "inquirer": "^8.2.4"
},
"devDependencies": {
  "@commitlint/cli": "^17.0.3",
  "@commitlint/config-angular": "^17.0.3",
  "@commitlint/cz-commitlint": "^17.0.3",
  "@types/cross-spawn": "^6.0.2",
  "@types/fs-extra": "^9.0.13",
  "@types/inquirer": "^9.0.2",
  "@types/node": "^18.11.0",
  "commitizen": "^4.2.4",
  "cz-customizable": "^6.9.0",
  "husky": "^8.0.1",
  "inquirer": "^8.0.0",
  "minimist": "^1.2.7",
  "nodemon": "^2.0.20",
  "ts-node": "^10.9.1",
  "typescript": "^4.8.4"
}
```

#### 3.2.2 tsconfig.json

配置esm打包，及入口文件

```js
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "outDir": "./dist",
    "removeComments": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["./index.ts", "src**/*.ts"]
}

```

#### 3.3.3 package.json

配置基础的script执行指令

```js
  "scripts": {
    "dev": "nodemon ./index.ts",
    "serve": "ts-node ./index.ts",
    "tsc": "tsc"
  },
```

### 3.3 配置入口文件

#### 3.3.1 index.ts

使用inquirer完成问题配置

```ts
#!/usr/bin/env node
import inquirer from 'inquirer';
import initCli from './src/cli';
import { answerType } from './src/interface';

// export interface answerType {
//   vue3: Boolean
//   plugins: Array<String>
// }


const promptList = [
  {
    type: 'confirm',
    message: '是否是Vue3项目？', // Vue3项目需要把package.json的type: module删除
    name: 'vue3',
  },
  {
    type: 'checkbox',
    message: '选择要安装的插件(默认全选)',
    name: 'plugins',
    choices: [
      {
        name: 'eslint注册',
        value: 'eslint',
        checked: true,
      },
      {
        name: 'husky注册',
        value: 'husky',
        checked: true,
      },
      {
        name: 'commitLint注册',
        value: 'commitLint',
        checked: true,
      },
      {
        name: 'vscode格式化注册',
        value: 'vscode',
        checked: true,
      },
    ],
  },
];

const question = async () => {
  // 运行时请使用 npm run serve, 避免使用nodemon，会导致arrow key press 无效： https://github.com/SBoudrias/Inquirer.js/issues/844#issuecomment-571412210
  const answers: answerType = await inquirer.prompt(promptList);
  initCli(answers);
};

question();
```

#### 3.3.2 cli.ts

指定项目配置入口，如果没有为base设置默认值，交给cli执行脚本

```ts
// src/cli.ts

import cac from 'cac';
import { start } from './start';
import { setEnv } from './utils/env';
import { name } from '../package.json';
import { getPackageJson } from './utils/env';
import { answerType } from './interface';

const cli = cac(name);

export default async (answers: answerType) => {
  const pkgJson = await getPackageJson();
  const { version } = pkgJson;

  cli
    .command('[root]')
    .alias('alias')
    .action(async (_root, options) => {
      let base: string = options.base;
      if (!base) {
        // 项目的最终路径
        base = process.cwd();
      }
      setEnv('base', base);
      await start(base, answers);
    });

  cli.help();
  cli.version(version);
  cli.parse();
};

```

#### 3.3.3 start.ts

根据用户交互式选择的指令，执行对应依赖的安装

```ts
// src/start.ts

// 开始分析项目
import { getPackageJson, initProjectInfo } from './utils/env'
import { eslintInit } from './core/eslint'
import { huskyInit } from './core/husky'
import { eslintIgnoreInit } from './core/eslintignore'
import { commitLintInit } from './core/commitlint'
import { specialFn } from './core/special'
import { vscodeInit } from './core/vscode'
import { debugError, debugProcess, debugTxt } from './utils/debug'
import { hasElementInArray } from './utils/tool'
import { answerType } from './interface'

export const start = async (base: string, answers: answerType) => {
  const pckJson = await getPackageJson(base)

  const { vue3 = false, plugins = [] } = answers

  await initProjectInfo(pckJson)

  try {
    // 针对Vue3模板特殊处理
    vue3 && (await specialFn())

    // 安装eslint 和 prettier 并自动生成配置文件
    hasElementInArray(plugins, 'eslint') && (await eslintInit())

    // 添加eslint忽略文件
    hasElementInArray(plugins, 'eslint') && (await eslintIgnoreInit())

    // 安装 husky 并自动生成配置文件
    hasElementInArray(plugins, 'husky') && (await huskyInit())

    // 生成.vscode 配置文件 支持自动格式化代码
    hasElementInArray(plugins, 'commitLint') && (await commitLintInit())

    // 格式化VSCode格式
    hasElementInArray(plugins, 'vscode') && (await vscodeInit())

    debugProcess(
      `恭喜您，成功注册${vue3 ? 'vue3' : ''} ${hasElementInArray(plugins, 'eslint')} ${hasElementInArray(plugins, 'husky')} ${hasElementInArray(
        plugins,
        'commitLint'
      )} ${hasElementInArray(plugins, 'vscode')} 插件`
    )

    // 部分版本依赖可能有冲突，建议重新安装node modules
    debugProcess('请重新安装依赖！npm install or yarn')
    debugTxt(``)
  } catch (error) {
    debugError(JSON.stringify(error))
  }
}

```

### 3.4 执行依赖安装

#### 3.4.1 husky

指定husky及lint-staged(避免每次修改都执行一次lint,一般绑定在git pre-commit hook上)

```typescript
// src/core/husky.ts
import { writeInPkg, run } from '../utils/tool';
import fs from 'fs-extra';
import { getPackageJson } from '../utils/env';
import { getPath } from '../utils/path';
import { debugInfo, debugWarning } from '../utils/debug';
import { pathExists } from '../utils/check';

// 需要安装的依赖
const devDependencies = ['husky@^8.0.1', 'lint-staged@^12.4.1'];

export const huskyInit = async () => {
  // 检查是否有git 如果没有 需要先初始化git
  if (!(await pathExists('.git', false))) {
    debugWarning(`请先初始化git`);
    debugInfo('参考命令 git init');
    process.exit();
  }
  // 安装依赖
  await writeInPkg(devDependencies);
  // 更改package
  let pkgJson = await getPackageJson();
  pkgJson.scripts['prepare'] = 'husky install';
  pkgJson.scripts['pre-commit'] = 'lint-staged';
  pkgJson.scripts['postinstallmac'] = 'git config core.hooksPath .husky && chmod 700 .husky/*';
  pkgJson.scripts['eslint'] = 'eslint --cache --max-warnings 0  "{src,mock}/**/*.{vue,ts,js,tsx}" --fix';
  pkgJson['lint-staged'] = {
    '*.{js,ts,vue,jsx,tsx}': ['npm run eslint'],
    '*.{js,jsx,ts,tsx,md,html,css,lees,scss,sass}': 'prettier --write',
  };
  fs.writeJsonSync(getPath('package.json'), pkgJson, { spaces: 2 });

  await run('npm run prepare');
  await run('npx husky add .husky/pre-commit "npm-run-pre-commit"');
};

```

#### 3.4.2 eslint

指定eslint对应配置规范，建议可以根据自身项目进行定制化配置，相关文档看对应prettier和eslint官网配置

针对不同开发框架，进行eslint注入(包括vue2/3，React)

```typescript
// src/core/eslint.ts

import fs from 'fs-extra';
import { writeInPkg } from '../utils/tool';
import { getPackageJson, getEnv } from '../utils/env';
import { prettierrcInit } from '../template/prettierrc';
import { eslintrcFn } from '../template/eslintrc';
import { getPath } from '../utils/path';

const baseDep = [
  'eslint@^7.25.0',
  'prettier@^2.7.1',
  'eslint-friendly-formatter@^4.0.1',
  'eslint-plugin-prettier@^4.0.0',
  'eslint-plugin-html@^6.2.0',
  'eslint-config-prettier@^8.5.0',
];

export const eslintInit = async () => {
  let devDependencies: string[] = baseDep;
  if (getEnv('isVue2')) {
    devDependencies = [...baseDep, 'eslint-plugin-vue@^6.2.2'];
  }
  if (getEnv('isVue3')) {
    devDependencies = [...baseDep, 'eslint-plugin-vue@^9.2.0', '@typescript-eslint/parser@^5.30.7'];
  }
  if (getEnv('isReact')) {
    devDependencies = [
      ...baseDep,
      'eslint-plugin-react@^7.30.1',
      'eslint-plugin-jsx-a11y@^6.6.1',
      '@typescript-eslint/parser@^5.30.7',
      '@typescript-eslint/eslint-plugin@5.30.7',
    ];
  }
  // writeInPkg 只是把依赖写入到package中
  await writeInPkg(devDependencies, 'devDependencies');
  fs.outputFileSync(getPath('./.eslintrc.js'), eslintrcFn());
  fs.outputFileSync(getPath('./.prettierrc'), prettierrcInit);

  let pkgJson = await getPackageJson();
  if (pkgJson['eslintConfig']) {
    delete pkgJson.eslintConfig;
  }
  fs.writeJsonSync(getPath('package.json'), pkgJson, { spaces: 2 });
};

```

- eslintrc

  ```typescript
  // template/eslintrc.ts
  
  import { getEnv } from '../utils/env';
  
  const baseEslint = `
  'prettier/prettier': 'error',
  'accessor-pairs': 2,
  'arrow-spacing': [
    2,
    {
      before: true,
      after: true
    }
  ],
  'block-spacing': [2, 'always'],
  'brace-style': [
    2,
    '1tbs',
    {
      allowSingleLine: true
    }
  ],
  camelcase: [
    0,
    {
      properties: 'always'
    }
  ],
  'comma-dangle': [
    'error',
    {
      arrays: 'never',
      objects: 'never',
      imports: 'never',
      exports: 'never',
      functions: 'never'
    }
  ],
  'comma-spacing': [
    2,
    {
      before: false,
      after: true
    }
  ],
  'comma-style': [2, 'last'],
  'constructor-super': 2,
  curly: [2, 'multi-line'],
  'dot-location': [2, 'property'],
  'eol-last': 2,
  eqeqeq: 'off',
  'generator-star-spacing': [
    2,
    {
      before: true,
      after: true
    }
  ],
  'handle-callback-err': [2, '^(err|error)$'],
  indent: 'off',
  'key-spacing': [
    2,
    {
      beforeColon: false,
      afterColon: true
    }
  ],
  'keyword-spacing': [
    2,
    {
      before: true,
      after: true
    }
  ],
  'new-cap': [
    2,
    {
      newIsCap: true,
      capIsNew: false
    }
  ],
  'new-parens': 2,
  'no-array-constructor': 2,
  'no-caller': 2,
  'no-console': 'off',
  'no-class-assign': 2,
  'no-cond-assign': 2,
  'no-const-assign': 2,
  'no-control-regex': 0,
  'no-delete-var': 2,
  'no-dupe-args': 2,
  'no-dupe-class-members': 2,
  'no-dupe-keys': 2,
  'no-duplicate-case': 2,
  'no-empty-character-class': 2,
  'no-empty-pattern': 2,
  'no-eval': 0,
  'no-ex-assign': 2,
  'no-extend-native': 2,
  'no-extra-bind': 2,
  'no-extra-boolean-cast': 2,
  'no-extra-parens': [2, 'functions'],
  'no-fallthrough': 2,
  'no-floating-decimal': 2,
  'no-func-assign': 2,
  'no-implied-eval': 2,
  'no-inner-declarations': [2, 'functions'],
  'no-invalid-regexp': 2,
  'no-irregular-whitespace': 2,
  'no-iterator': 2,
  'no-label-var': 2,
  'no-labels': [
    2,
    {
      allowLoop: false,
      allowSwitch: false
    }
  ],
  'no-lone-blocks': 2,
  'no-mixed-spaces-and-tabs': 2,
  'no-multi-spaces': 2,
  'no-multi-str': 2,
  'no-multiple-empty-lines': [
    2,
    {
      max: 1
    }
  ],
  'no-native-reassign': 2,
  'no-negated-in-lhs': 2,
  'no-new-object': 2,
  'no-new-require': 2,
  'no-new-symbol': 2,
  'no-new-wrappers': 2,
  'no-obj-calls': 2,
  'no-octal': 2,
  'no-octal-escape': 2,
  'no-path-concat': 2,
  'no-proto': 2,
  'no-redeclare': 2,
  'no-regex-spaces': 2,
  'no-return-assign': [2, 'except-parens'],
  'no-self-assign': 2,
  'no-self-compare': 2,
  'no-sequences': 2,
  'no-shadow-restricted-names': 2,
  'no-spaced-func': 2,
  'no-sparse-arrays': 2,
  'no-this-before-super': 2,
  'no-throw-literal': 2,
  'no-trailing-spaces': 2,
  'no-undef': 2,
  'no-undef-init': 2,
  'no-unexpected-multiline': 2,
  'no-unmodified-loop-condition': 2,
  'no-unneeded-ternary': [
    2,
    {
      defaultAssignment: false
    }
  ],
  'no-unreachable': 2,
  'no-unsafe-finally': 2,
  'no-unused-vars': [
    2,
    {
      vars: 'all',
      args: 'none'
    }
  ],
  'no-useless-call': 2,
  'no-useless-computed-key': 2,
  'no-useless-constructor': 2,
  'no-useless-escape': 0,
  'no-whitespace-before-property': 2,
  'no-with': 2,
  'one-var': [
    2,
    {
      initialized: 'never'
    }
  ],
  'operator-linebreak': [
    2,
    'after',
    {
      overrides: {
        '?': 'before',
        ':': 'before'
      }
    }
  ],
  'padded-blocks': [2, 'never'],
  quotes: 'off',
  semi: 'off',
  'semi-spacing': [
    2,
    {
      before: false,
      after: true
    }
  ],
  'space-before-blocks': [2, 'always'],
  'space-before-function-paren': 'off',
  'space-in-parens': [2, 'never'],
  'space-infix-ops': 2,
  'space-unary-ops': [
    2,
    {
      words: true,
      nonwords: false
    }
  ],
  'spaced-comment': 'off',
  'template-curly-spacing': [2, 'never'],
  'use-isnan': 2,
  'valid-typeof': 2,
  'wrap-iife': [2, 'any'],
  'yield-star-spacing': [2, 'both'],
  yoda: [2, 'never'],
  'prefer-const': 2,
  'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0,
  'object-curly-spacing': [
    0,
    'always',
    {
      objectsInObjects: false
    }
  ],
  'array-bracket-spacing': [2, 'never']
  `;
  
  export const eslintrcFn = () => {
    // vue2
    let eslintrcInit = `
  module.exports = {
      root: true,
      parserOptions: {
        ecmaVersion: 11,
        parser: 'babel-eslint',
        sourceType: 'module'
      },
      env: {
        browser: true,
        node: true,
        es6: true
      },
      plugins: ['prettier'],
      extends: ['plugin:vue/recommended', 'eslint:recommended', 'plugin:prettier/recommended'],
      rules: {
        'vue/order-in-components': 'off',
        'vue/html-self-closing': 'off',
        'vue/require-default-prop': 'off',
        'vue/max-attributes-per-line': [
          0,
          {
            singleline: 10,
            multiline: {
              max: 1,
              allowFirstLine: false
            }
          }
        ],
        'vue/singleline-html-element-content-newline': 'off',
        'vue/multiline-html-element-content-newline': 'off',
        'vue/name-property-casing': ['error', 'PascalCase'],
        'vue/no-v-html': 'off',
        ${baseEslint}
      } 
    }
    
  `;
    // vue3
    if (getEnv('isVue3')) {
      eslintrcInit = `
  module.exports = {
      root: true,
      parserOptions: {
        ecmaVersion: 11,
        sourceType: 'module',
        parser: '@typescript-eslint/parser'
      },
      env: {
        browser: true,
        node: true,
        es6: true
      },
      plugins: ['prettier'],
      extends: ['plugin:vue/vue3-recommended', 'eslint:recommended', 'plugin:prettier/recommended'],
      rules: {
        'vue/order-in-components': 'off',
        'vue/html-self-closing': 'off',
        'vue/require-default-prop': 'off',
        'vue/max-attributes-per-line': [
          0,
          {
            singleline: 10,
            multiline: {
              max: 1,
              allowFirstLine: false
            }
          }
        ],
        'vue/singleline-html-element-content-newline': 'off',
        'vue/multiline-html-element-content-newline': 'off',
        'vue/name-property-casing': 'off',
        'vue/no-v-html': 'off',
        ${baseEslint}
      }
    }
    `;
    }
    if (getEnv('isReact')) {
      eslintrcInit = `
  module.exports = {
    root: true,
    parserOptions: {
      ecmaVersion: 11,
      sourceType: 'module',
      parser: '@typescript-eslint/parser'
    },
    env: {
      browser: true,
      node: true,
      es6: true
    },
    plugins: ['react', 'prettier', '@typescript-eslint/eslint-plugin', 'jsx-a11y'],
    extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'eslint:recommended', 'plugin:prettier/recommended'],
      rules: {
        'react/react-in-jsx-scope': 0,
        ${baseEslint}
      }
    }
    `;
    }
    return eslintrcInit;
  };
  
  ```

- prettierrc

  ```typescript
  export const prettierrcInit = `
  {
      "semi": false,
      "singleQuote": true,
      "printWidth": 180,
      "tabWidth": 2,
      "trailingComma": "none"
    }
    
  `;
  
  ```

#### 3.4.3 comitlint

配合husky,提供commit时的规范

```typescript
// src/core/commitlint

/**
 * husk 结合 commitlint 提交信息校验
 */
import { getPackageJson } from '../utils/env';
import { writeInPkg, run } from '../utils/tool';
import fs from 'fs-extra';
import { commitLintConfig } from '../template/commitlint.config';
import { getPath } from '../utils/path';

const devDependencies = [
  '@commitlint/cli@^17.0.3',
  '@commitlint/config-angular@^17.0.3',
  'commitizen@^4.2.4',
  'cz-customizable@^6.9.0',
  '@commitlint/cz-commitlint@^17.0.3',
  'inquirer@^8.0.0',
];

const commitMsg = `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx --no-install commitlint --edit $1
`;

const preCommit = `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
npm run pre-commit
`;

const commitlintPath = getPath('commitlint.config.js');

export const commitLintInit = async () => {
  await writeInPkg(devDependencies);
  await run('npx husky add .husky/commit-msg "npm-run-test"');
  let pkgJson = await getPackageJson();
  pkgJson['config'] = {
    commitizen: {
      path: '@commitlint/cz-commitlint',
    },
  };
  pkgJson.scripts['commit'] = 'git add . && git-cz';
  fs.writeJsonSync(getPath('package.json'), pkgJson, { spaces: 2 });

  if (await fs.pathExists(commitlintPath)) {
    // 删除
    fs.removeSync(commitlintPath);
  }
  fs.outputFileSync(commitlintPath, commitLintConfig);
  fs.outputFileSync(getPath('./.husky/commit-msg'), commitMsg);
  fs.outputFileSync(getPath('./.husky/pre-commit'), preCommit);
};

```

- commitline.config

配置custom-commit配置

```typescript
export const commitLintConfig = `
module.exports={
  extends: ['@commitlint/config-angular'],
  parserPreset: {
    parserOpts: {
      headerPattern: /^(.*?)(?:\\((.*)\\))?:?\\s(.*)$/,
      headerCorrespondence: ['type', 'scope', 'subject'],
    },
  },
  rules: {
    'type-case': [0],
    'type-empty': [2, 'never'],
    'type-enum': [
      2,
      'always',
      [
        '📦build',
        '👷ci',
        '📝docs',
        '🌟feat',
        '🐛fix',
        '🚀perf',
        '🌠refactor',
        '🔂revert',
        '💎style',
        '🚨test',
      ],
    ],
    'scope-empty': [2, 'never'],
    'subject-empty': [2, 'never'],
  },
  prompt: {
    settings: {},
    skip: ['body', 'footer', 'issues'],
    messages: {
      skip: '回车直接跳过',
      max: '最大%d字符',
      min: '%d chars at least',
      emptyWarning: '内容不能为空，重新输入',
      upperLimitWarning: 'over limit',
      lowerLimitWarning: 'below limit',
    },
    questions: {
      type: {
        description: '请选择提交类型',
        enum: {
          '🌟feat': {
            description: '增加新功能',
            title: 'Features',
            emoji: '🌟',
          },
          '🐛fix': {
            description: '修复bug',
            title: 'Bug Fixes',
            emoji: '🐛',
          },
          '📝docs': {
            description: '修改文档',
            title: 'Documentation',
            emoji: '📝',
          },
          '💎style': {
            description: '样式修改不影响逻辑',
            title: 'Styles',
            emoji: '💎',
          },
          '🌠refactor': {
            description: '功能/代码重构',
            title: 'Code Refactoring',
            emoji: '🌠',
          },
          '🚀perf': {
            description: '性能优化',
            title: 'Performance Improvements',
            emoji: '🚀',
          },
          '🚨test': {
            description: '增删测试',
            title: 'Tests',
            emoji: '🚨',
          },
          '📦build': {
            description: '打包',
            title: '打包',
            emoji: '📦',
          },
          '👷ci': {
            description: 'CI部署',
            title: 'Continuous Integrations',
            emoji: '⚙️',
          },

          '🔂revert': {
            description: '版本回退',
            title: 'Reverts',
            emoji: '🔂',
          },
        },
      },
      scope: {
        description: '请输入修改的范围（必填）',
      },
      subject: {
        description: '请简要描述提交（必填）',
      },
      body: {
        description: '请输入详细描述（可选）',
      },
      isBreaking: {
        description: '有什么突破性的变化吗?',
      },
      breakingBody: {
        description:
          '一个破坏性的变更提交需要一个主体。 请输入提交本身的更长的描述  ',
      },
      breaking: {
        description: 'Describe the breaking changes',
      },
      isIssueAffected: {
        description: '是否有未解决的问题?',
      },
      issuesBody: {
        description:
          'If issues are closed, the commit requires a body. Please enter a longer description of the commit itself',
      },
      issues: {
        description: '请输入问题说明',
      },
    },
  },
}`;

```

#### 3.4.4 vue3

针对vue3,去除package.json中的type:module

src/core/special.ts

```typescript
// 一些特殊的处理
import fs from 'fs-extra';
import { env, getPackageJson } from '../utils/env';
import { getPath } from '../utils/path';

export const specialFn = async () => {
  const { isVue3 } = env;
  if (!isVue3) return;
  let pkgJson = await getPackageJson();
  if (pkgJson.type) {
    delete pkgJson.type;
  }
  fs.writeJsonSync(getPath('package.json'), pkgJson, { spaces: 2 });
  // 如果是vue3 的话 需要把package中的 type="module"去掉
};

```

#### 3.4.5 vscode

针对当前workspace,配置vscode配置，保证每个人的开发环境是一致的

```typescript
/**
 * vscode 配置
 */
import fs from 'fs-extra';
import { getPath } from '../utils/path';

export const vscodeInit = async () => {
  const haveVscodeSetting = await fs.pathExists(getPath('./vscode/settings.json'));

  let vscodeSetting = {};
  if (!haveVscodeSetting) {
    vscodeSetting = {
      // 每次保存自动格式化
      'editor.formatOnSave': true,
      // 每次保存的时候将代码按eslint格式进行修复
      'editor.codeActionsOnSave': {
        'source.fixAll.eslint': true,
      },
      'editor.defaultFormatter': 'esbenp.prettier-vscode',
      // vue文件默认格式化方式vetur
      '[vue]': {
        // "editor.defaultFormatter": "octref.vetur"
        'editor.defaultFormatter': 'esbenp.prettier-vscode',
      },

      'javascript.format.insertSpaceBeforeFunctionParenthesis': true, // 函数前加上空格 只有在默认vetur的时候生效
      // js文件默认格式化方式 和vue中的js保持一致使用编辑器自带的ts格式
      '[javascript]': {
        // "editor.defaultFormatter": "vscode.typescript-language-features"
        // javascript文件默认格式化方式prettier
        'editor.defaultFormatter': 'esbenp.prettier-vscode',
      },
      // json文件默认格式化方式prettier
      '[json]': {
        'editor.defaultFormatter': 'esbenp.prettier-vscode',
      },
      // css文件默认格式化方式prettier
      '[css]': {
        'editor.defaultFormatter': 'esbenp.prettier-vscode',
      },
      // typescript文件默认格式化方式prettier
      '[typescript]': {
        'editor.defaultFormatter': 'esbenp.prettier-vscode',
      },

      // 控制折行方式 - "on" (根据视区宽度折行)
      'editor.wordWrap': 'on',
      'editor.tabSize': 2, // 换行默认以tab缩进 2个字符
      'editor.snippetSuggestions': 'top', // 将建议的代码段优先级提前选择，比如输入for第一个提示是for循环代码段。
      'files.associations': {
        // 文件关联语言的优先级配置
        '*.js': 'javascriptreact',
        '*.vue': 'vue',
        '*.cshtml': 'html',
        '*.dwt': 'html',
      },
      // "eslint.validate": ["javascript", "javascriptreact", "typescript", "typescriptreact"],

      'editor.formatOnPaste': true,
    };
  } else {
    // const nowSetting = await getPackageJson('./vscode/settings.json');
    const nowSetting = fs.readJSON(getPath('./vscode/settings.json'));
    vscodeSetting = { ...nowSetting, ...vscodeSetting };
  }
  fs.outputFileSync(getPath('./.vscode/settings.json'), JSON.stringify(vscodeSetting, null, 2));
};

```

### 3.5 开发工具类

#### 3.5.1 env

提供环境读取的配置项

```typescript
// src/utils/env.ts

import path from 'path';
import fs from 'fs-extra';
import { checkVueVersion } from './check';

export const env = {
  base: '',
  isVue: false,
  isVue3: false,
  isReact: false,
  isVue2: false,
  isVueCli: false,
  isWebpack: true,
  isEslint: false,
};

type envKeys = keyof typeof env;

/**
 * @name 设置变量
 */
export const setEnv = (key: envKeys, val: any) => {
  env[key] = val as never;
};
/**
 * @name 获取变量
 */
export const getEnv = (key: envKeys) => {
  return env[key];
};

/**
 * @name 把package.json转化为json
 */
export const getPackageJson = async (base: string = getEnv('base') as string) => {
  // if (!(await pathExists('package.json'))) process.exit(0);
  const file = path.resolve(base, 'package.json');
  const json = fs.readJSON(file);
  return json;
};

export const initProjectInfo = async (pckJson: any) => {
  const deps = { ...pckJson.devDependencies, ...pckJson.dependencies };
  if (deps['vue']) {
    setEnv('isVue', true);
    if (checkVueVersion(deps['vue']) === 2) {
      setEnv('isVue2', true);
    }
    if (checkVueVersion(deps['vue']) === 3) {
      setEnv('isVue3', true);
    }
  }

  if (deps['react']) {
    setEnv('isReact', true);
  }

  if (deps['eslint']) {
    setEnv('isEslint', true);
  }
  return true;
};

```

#### 3.5.2 check

提供判断版本及文件是否存在的方法

```typescript
// 各种检测函数
import fs from 'fs-extra';
import { debugError } from './debug';
import { getEnv } from './env';

/**
 * @name 判断文件夹是否存在
 */
export const pathExists = async (name: string, ext: boolean = true): Promise<boolean | void> => {
  const base = getEnv('base') as string;
  const res = await fs.pathExists(`${base}/${name}`);
  if (!res) {
    ext && debugError(`${base}/${name}不存在`);
    return false;
  } else {
    return res;
  }
};

/**
 * @name 判断是哪个vue版本
 */
export const checkVueVersion = (version: string) => {
  const v = version.split('.')[0] as string;
  return Number(v.match(/\d+/g));
};

/**
 * @name 判断使用的是npm和yarn
 */
export const checkNpmOrYarn = async (_basePath?: string): Promise<string[]> => {
  // 如果原项目使用的是yarn进行安装的，那还是使用npm进行按照，否则就使用npm
  if (await pathExists('yarn.lock', false)) {
    return ['yarn', 'add'];
  }
  return ['npm', 'init'];
};

```

#### 3.5.3 getPath

通过env获取base路径

```typescript
import { getEnv } from './env';
import path from 'path';

export const getPath = (name: string) => {
  const basePath = getEnv('base') as string;
  return path.resolve(basePath, name);
};

```

#### 3.5.4 tools

各种读写包信息的操作

```typescript
import spawn from 'cross-spawn'
import fs from 'fs-extra'

import { getEnv, getPackageJson } from './env'
import { checkNpmOrYarn } from './check'
import { getPath } from './path'
import { debugInfo, debugWarning } from './debug'

export const hasElementInArray = (list: Array<String>, element: string) => {
  return list.indexOf(element) >= 0 ? element : ''
}

export const down = async (runName: string | string[], type: string) => {
  const basePath = getEnv('base') as string
  const [n, i] = await checkNpmOrYarn(basePath)
  if (typeof runName === 'string') {
    await spawnSync(n, i, runName, type, basePath)
    return false
  }
  runName.forEach(async (runItem) => {
    await spawnSync(n, i, runItem, type, basePath)
  })
}

export const spawnSync = (n: string, i: string, runItem: string, type: string, basePath: string) => {
  return new Promise((resolve) => {
    spawn.sync(n, [i, runItem, type], {
      stdio: 'pipe',
      cwd: basePath
    })
    debugInfo(`${runItem}✅`)

    resolve({ success: true })
  })
}

export const writeInPkg = async (devArr: string[], key: string = 'devDependencies') => {
  let pkg = await getPackageJson()
  devArr.forEach((item: string) => {
    // 为了防止安装包里面的名字有@
    const index = item.lastIndexOf('@')
    const k = index === -1 ? item : item.slice(0, index)
    const v = index === -1 ? '' : item.slice(index + 1) || ''
    pkg[key][k] = v
    debugInfo(`${item}✅`)
  })
  fs.writeJsonSync(getPath('package.json'), pkg, { spaces: 2 })
}

export const run = async (str: string) => {
  const basePath = getEnv('base') as string
  const runArr = str.split(' ')
  if (runArr.length < 2) {
    debugWarning(`运行参数错误${str}`)
    return false
  }
  const [npm, ...args] = runArr
  debugInfo(`${runArr.join(' ')}✅`)
  spawn.sync(npm, args, {
    stdio: 'pipe',
    cwd: basePath
  })
}

export const downNodeModules = async () => {
  const basePath = getEnv('base') as string
  const [n] = await checkNpmOrYarn(basePath)
  await run(`${n} install`)
}

```

#### 3.5.5 debug

根据chalk生成cli不同类型的样式

```typescript
import chalk from 'chalk';
const log = console.log;
let debugSwitch = true;

/**
 * debug开关，默认开启
 * @param debug boolean
 */
const switchDebug = (debug: boolean) => {
  debugSwitch = debug;
};

/**
 * debug 错误信息
 * @param type 类型
 * @param msg 信息
 */
const debugError = (msg: string) => {
  debugSwitch && log(chalk.hex('#646cff')(`[xianzao-cli]:`) + chalk.red(msg));
  // 如果出错就退出
  process.exit(0);
};

/**
 * debug 信息
 * @param type 类型
 * @param msg 信息
 */
const debugInfo = (msg: string) => {
  debugSwitch && log(chalk.hex('#646cff')(`[xianzao-cli]:`) + chalk.green(msg));
};

/**
 * debug 强调
 * @param type 类型
 * @param msg 信息
 */

const debugProcess = (msg: string) => {
  debugSwitch && log(chalk.hex('#646cff')(`[xianzao-cli]:`) + chalk.yellow(msg));
};
/**
 * debug warning信息
 * @param type 类型
 * @param msg 信息
 */
const debugWarning = (msg: string) => {
  log(chalk.hex('#646cff')(`[xianzao-cli]:`) + chalk.yellow(msg));
};

const debugTxt = (msg: string) => {
  log(chalk.hex('#646cff')(`[xianzao-cli]:`) + chalk.hex('#5c6d82')(msg));
};

export { switchDebug, debugInfo, debugError, debugWarning, debugProcess, debugTxt };

```

### 3.6 打包工具类

#### 3.6.1 index

根据tsconfig中指定的target及outDir配置打包

```typescript
// build/index.ts

import fs from 'fs-extra';
import { getPackageJson } from '../src/utils/env';
import { getPath } from '../src/utils/path';
const buildInit = async () => {
  const pkgJson = await getPackageJson();
  pkgJson['bin'] = {
    'xianzao-cli': 'index.js',
  };
  // 去掉husky
  delete pkgJson.scripts.prepare;
  pkgJson['main'] = 'index.js';
  fs.outputFileSync(getPath('./dist/package.json'), JSON.stringify(pkgJson));
  fs.copyFileSync(getPath('./README.md'), './dist/README.md');
};

buildInit();

```

####  3.6.2 version

支持在每次提交代码时更新patch版本

```typescript
import fs from 'fs-extra';

import { getPackageJson } from '../src/utils/env';
import { getPath } from '../src/utils/path';
import { debugInfo } from '../src/utils/debug';

const versionInit = async () => {
  // 默认为patch版本更新
  const pkgJson = await getPackageJson();
  let version = pkgJson.version.split('.');
  version[2] = Number(version[2]) + 1;

  pkgJson['version'] = version.join('.');
  fs.outputFileSync(getPath('./package.json'), JSON.stringify(pkgJson, null, 2));

  debugInfo(`当前版本升级为：${pkgJson['version']}`);
};

versionInit();

```

### 3.7 打包&发布npm

#### 3.7.1打包

在package.json中添加script

- build: 生产打包文件
- commit: 执行commit规范化
- update- version: 更新patch版本

```js
"build": "rm -rf dist && tsc && ts-node build/index.ts",
"commit": "git add . && git-cz ",
"update-version": "ts-node build/version.ts",
"commit-version": "npm run update-version && git add . && git-cz",
"prepare": "husky install",
"release": "rm -rf dist && tsc && ts-node build/index.ts"
```

#### 3.7.2 发布npm

在github上关联git  action ,需要先注册登录rpm,或者使用[publish](https://www.npmjs.com/package/publish)简化发布流程

```js
name: 发布npm
on:
  push:
    branches: [master]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: setupNode
        uses: actions/setup-node@v3
        with:
          node-version: '16.x'
          registry-url: 'https://registry.npmjs.org'
      - name: 依赖安装
        run: npm install
      - name: 构建
        run: npm run build
      - run: cd ./dist && npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NODE_AUTH_TOKEN }}

```

#### 3.7.3 指定package.json入口

完整的package.json如下：

```json
{
  "name": "xianzao-cli",
  "version": "1.0.0",
  "description": "项目初始化脚手架",
  "main": "dist/index.js",
  "scripts": {
    "dev": "nodemon ./index.ts",
    "serve": "ts-node ./index.ts",
    "tsc": "tsc",
    "build": "rm -rf dist && tsc && ts-node build/index.ts",
    "commit": "git add . && git-cz ",
    "update-version": "ts-node build/version.ts",
    "commit-version": "npm run update-version && git add . && git-cz",
    "prepare": "husky install",
    "release": "rm -rf dist && tsc && ts-node build/index.ts"
  },
  "bin": {
    "xianzao-cli": "dist/index.js"
  },
  "config": {
    "commitizen": {
      "path": "@commitlint/cz-commitlint"
    }
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/xianzao/xianzao-cli.git"
  },
  "keywords": [
    "cli",
    "xianzao"
  ],
  "author": "xianzao",
  "license": "ISC",
  "nodemonConfig": {
    "ignore": [
      "package.json"
    ]
  },
  "bugs": {
    "url": "https://github.com/xianzao/xianzao-cli/issues"
  },
  "homepage": "https://github.com/xianzao/xianzao-cli#readme",
  "dependencies": {
    "cac": "^6.7.14",
    "chalk": "^4.1.2",
    "cross-spawn": "^7.0.3",
    "fs-extra": "^10.1.0",
    "inquirer": "^8.2.4"
  },
  "devDependencies": {
    "@commitlint/cli": "^17.0.3",
    "@commitlint/config-angular": "^17.0.3",
    "@commitlint/cz-commitlint": "^17.0.3",
    "@types/cross-spawn": "^6.0.2",
    "@types/fs-extra": "^9.0.13",
    "@types/inquirer": "^9.0.2",
    "@types/node": "^18.11.0",
    "commitizen": "^4.2.4",
    "cz-customizable": "^6.9.0",
    "husky": "^8.0.1",
    "inquirer": "^8.0.0",
    "minimist": "^1.2.7",
    "nodemon": "^2.0.20",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.4"
  }
}
```

### 3.8使用

```bash
# 1. 项目中执行
npm i xianzao-cli -D

# 2. 在package.json中添加script
"scripts": {
"xianzao-cli": "xianzao-cli",
},

# 3. 执行npm run xianzao-cli, 即会自动添加依赖
```

## 4. 总结

github：https://github.com/xianzao/xianzao-cli

- npm：https://www.npmjs.com/package/xianzao-cli
  至此，我们就实现了一个简单基础的项目初始化脚手架，包括：

- 保存代码自动格式化
- 提交前 commit 校验
- eslint + prettier 校验
- husky 自动装载
- 提交时关联git action，自动发布npm包
  后续可以根据业务需求，在此基础上实现各种优化，后续，我们也会用它来完成后面项目的初始化。

# vue2源码解析(1/2)

https://vgbixa7nr9.feishu.cn/drive/folder/fldcnuszmspfoSJwl5QFtPrsCGg

https://www.yuque.com/lpldplws/web/ck0csfxciuzol315?singleDoc# 《Vue高级用法》 密码：tczl
https://www.yuque.com/lpldplws/web/hadz6f?singleDoc# 《Vue2源码解析（1/2）》 密码：mq90
https://www.yuque.com/lpldplws/web/xx3ygi?singleDoc# 《Vue2源码解析（2/2）》 密码：ya0n
https://www.yuque.com/lpldplws/web/gdw840?singleDoc# 《Vue3新特性&源码解析（1/3）》 密码：mmo8
https://www.yuque.com/lpldplws/web/gmptis?singleDoc# 《Vue3新特性&源码解析（2/3）》 密码：qke4
https://www.yuque.com/lpldplws/web/ty5nga?singleDoc# 《Vue3新特性&源码解析（3/3）》 密码：apwp
https://www.yuque.com/lpldplws/web/myfkf4?singleDoc# 《配套习题》 密码：oir9

https://www.yuque.com/lpldplws/web/sp3cao?singleDoc# 《配套习题》 密码：kv13

## 1.课程目标

掌握vue2.6(目前2.x最高版本)的核心源码

## 2.课程大纲

- 前置知识
- 数据驱动

## 3.前置知识

### 3.1 Flow

[Flow](https://flow.org/en/docs/getting-started/) 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，也就是文件顶部出现的

```js
/* @flow */
```

#### 3.1.2 使用Flow的原因

1. JavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug；

2. 类型检查是当前动态类型语言的发展趋势，可以帮助我们在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验；

3. 项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。 Vue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，主要是因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力；

   [Vue2.0选用Flow的具体原因](https://www.zhihu.com/question/46397274/answer/101193678)，当然Vue3.0还是还是用TS重构了

#### 3.1.3 Flow的工作方式

通常类型检查分为2种方式：

- 类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型；
- 类型注释：事先注释好我们期待的类型，Flow 会基于这些注释来判断；

##### 3.1.3.1 类型判断

它不需要任何代码修改即可进行类型检查，最小化开发者的工作量。它不会强制你改变开发习惯，因为它会自动推断出变量的类型。这就是所谓的类型推断，Flow 最重要的特性之一。

通过一个简单例子说明一下：

```js
/*@flow*/

function split(str) {
  return str.split(' ')
}

split(11)
```

Flow 检查上述代码后会报错，因为函数 split 期待的参数是字符串，而我们输入了数字；

##### 3.1.3.2 类型注释

如上所述，类型推断是 Flow 最有用的特性之一，不需要编写类型注释就能获取有用的反馈。但在某些特定的场景下，添加类型注释可以提供更好更明确的检查依据。
考虑如下代码：

```js
/*@flow*/

function add(x, y){
  return x + y
}

add('Hello', 11)
```

Flow 检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出` add()`的参数必须为数字。

在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 : 开头，可以在函数参数，返回值，变量声明中使用。

如果我们在上段代码中添加类型注释，就会变成如下：

```js
/*@flow*/

function add(x: number, y: number): number {
  return x + y
}

add('Hello', 11)
```

现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。

上面的例子是针对函数的类型注释。接下来我们来看看 Flow 能支持的一些常见的类型注释。

###### 3.1.3.2.1 数组

```js
/*@flow*/

var arr: Array<number> = [1, 2, 3]

arr.push('Hello')
```

数组类型注释的格式是 Array<T>，T 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow 能检查出错误。

###### 3.1.3.2.2 类和对象

```js
/*@flow*/

class Bar {
  x: string;           // x 是字符串
  y: string | number;  // y 可以是字符串或者数字
  z: boolean;

  constructor(x: string, y: string | number) {
    this.x = x
    this.y = y
    this.z = false
  }
}

var bar: Bar = new Bar('hello', 4)

var obj: { a: string, b: number, c: Array<string>, d: Bar } = {
  a: 'hello',
  b: 11,
  c: ['hello', 'world'],
  d: new Bar('hello', 3)
}
```

类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是，属性 y 的类型中间用 | 做间隔，表示 y 的类型即可以是字符串也可以是数字。

对象的注释类型类似于类，需要指定对象属性的类型。

###### 3.1.3.2.3 Null

若想任意类型 T 可以为 null 或者 undefined，只需类似如下写成 ?T 的格式即可

```js
/*@flow*/

var foo: ?string = null
```

此时，foo 可以为字符串，也可以为 null。

目前我们只列举了 Flow 的一些常见的类型注释。如果想了解所有类型注释，请移步 Flow 的[官方文档](https://flow.org/en/docs/types/)。

#### 3.1.4 Flow在vue.js源码中的应用

有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。

在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，文件内容为：

```js
flow
├── compiler.js        # 编译相关
├── component.js       # 组件数据结构
├── global-api.js      # Global API 结构
├── modules.js         # 第三方库定义
├── options.js         # 选项相关
├── ssr.js             # 服务端渲染相关
├── vnode.js           # 虚拟 node 相关
```

可以看到，Vue.js 有很多自定义类型的定义，在阅读源码的时候，如果遇到某个类型并想了解它完整的数据结构的时候，可以回来翻阅这些数据结构的定义。

### 3.2 vue目录结构设计

```js
src
├── compiler        # 编译相关 
├── core            # 核心代码 
├── platforms       # 不同平台的支持
├── server          # 服务端渲染
├── sfc             # .vue 文件解析
├── shared          # 共享代码
```

#### 3.2.1 compiler

包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。

编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。

#### 3.2.2 core

包含了vue.js的核心代码，包含内置组件，全局API封装，vue实例化、观察者、虚拟DOM、工具函数等等。

这里的代码可谓是 Vue.js 的灵魂，也是我们之后需要重点分析的地方。

#### 3.2.3 platform

Vue.js 是一个跨平台的 类MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js。

#### 3.2.4 server

Vue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。

这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。

服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。

#### 3.2.5 sfc

通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。

这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。

#### 3.2.6 shared

Vue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。

### 3.3 vue源码构建

Vue.js 源码是基于 [Rollup](https://github.com/rollup/rollup) 构建的，它的构建相关配置都在 scripts 目录下。

#### 3.3.1 构建脚本

Vue.js 源码构建的脚本如下：（只说跟build相关）

```js
  "build": "node scripts/build.js",
  "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",
  "build:weex": "npm run build -- weex",
```

这里总共有 3 条命令，作用都是构建 Vue.js，后面 2 条是在第一条命令的基础上，添加一些环境参数。

当在命令行运行 npm run build 的时候，实际上就会执行 node scripts/build.js，接下来我们来看看它实际是怎么构建的。

#### 3.3.2 构建过程

在 scripts/build.js 中：

```js
let builds = require('./config').getAllBuilds()

// filter builds via command line arg
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b => {
    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)
  })
} else {
  // filter out weex builds by default
  builds = builds.filter(b => {
    return b.output.file.indexOf('weex') === -1
  })
}

build(builds)
```

这段代码逻辑非常简单，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。接下来我们看一下配置文件，在 `scripts/config.js` 中：

```js
const builds = {
  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify
  'web-runtime-cjs': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.js'),
    format: 'cjs',
    banner
  },
  // Runtime+compiler CommonJS build (CommonJS)
  'web-full-cjs': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.common.js'),
    format: 'cjs',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime only (ES Modules). Used by bundlers that support ES Modules,
  // e.g. Rollup & Webpack 2
  'web-runtime-esm': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.esm.js'),
    format: 'es',
    banner
  },
  // Runtime+compiler CommonJS build (ES Modules)
  'web-full-esm': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.js'),
    format: 'es',
    alias: { he: './entity-decoder' },
    banner
  },
  // runtime-only build (Browser)
  'web-runtime-dev': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.js'),
    format: 'umd',
    env: 'development',
    banner
  },
  // runtime-only production build (Browser)
  'web-runtime-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.min.js'),
    format: 'umd',
    env: 'production',
    banner
  },
  // Runtime+compiler development build (Browser)
  'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime+compiler production build  (Browser)
  'web-full-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.min.js'),
    format: 'umd',
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },
  // ...
}
```

这里列举了一些 Vue.js 构建的配置，对于单个配置，它是遵循 Rollup 的构建规则的。其中 entry 属性表示构建的入口 JS 文件地址，dest 属性表示构建后的 JS 文件地址。format 属性表示构建的格式，cjs 表示构建出来的文件遵循 [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1) 规范，es 表示构建出来的文件遵循 [ES Module](http://exploringjs.com/es6/ch_modules.html) 规范。 umd 表示构建出来的文件遵循 [UMD](https://github.com/umdjs/umd) 规范。

以 `web-runtime-cjs-dev`配置为例，它的 entry 是 `resolve('web/entry-runtime.js')`，先来看一下 resolve 函数的定义。

源码目录：scripts/config.js

```js
const aliases = require('./alias')
const resolve = p => {
  const base = p.split('/')[0]
  if (aliases[base]) {
    return path.resolve(aliases[base], p.slice(base.length + 1))
  } else {
    return path.resolve(__dirname, '../', p)
  }
}
```

这里的 resolve 函数实现非常简单，它先把 resolve 函数传入的参数 p 通过 / 做了分割成数组，然后取数组第一个元素设置为 base。在我们这个例子中，参数 p 是 `web/entry-runtime.js`，那么 base 则为 web。base 并不是实际的路径，它的真实路径借助了别名的配置，我们来看一下别名配置的代码，在 scripts/alias 中：

```js
const path = require('path')

const resolve = p => path.resolve(__dirname, '../', p)

module.exports = {
  vue: resolve('src/platforms/web/entry-runtime-with-compiler'),
  compiler: resolve('src/compiler'),
  core: resolve('src/core'),
  shared: resolve('src/shared'),
  web: resolve('src/platforms/web'),
  weex: resolve('src/platforms/weex'),
  server: resolve('src/server'),
  sfc: resolve('src/sfc')
}

```

很显然，这里 web 对应的真实的路径是 path.resolve(__dirname, '../src/platforms/web')，这个路径就找到了 Vue.js 源码的 web 目录。然后 resolve 函数通过 `path.resolve(aliases[base], p.slice(base.length + 1))` 找到了最终路径，它就是 Vue.js 源码 web 目录下的 entry-runtime.js。因此，`web-runtime-cjs-dev` 配置对应的入口文件就找到了。

它经过 Rollup 的构建打包后，最终会在 dist 目录下生成 `dist/vue.runtime.common.dev.js`。

#### 3.3.3 Runtime Only VS Runtime + Compiler

通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 `Runtime Only` 版本的还是 `Runtime + Compiler` 版本。下面我们来对比这两个版本。

- Runtime only

  我们在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量；

- Runtime+Compiler

  我们如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示：

  ```js
  // 需要编译器的版本
  new Vue({
    template: '<div>{{ hi }}</div>'
  })
  
  // 这种情况不需要
  new Vue({
    render (h) {
      return h('div', this.hi)
    }
  })
  ```

  在 Vue.js 2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。

  很显然，这个编译过程对性能会有一定损耗，所以通常我们更推荐使用 Runtime-Only 的 Vue.js。

### 3.4 Vue入口

在 web场景下，我们来分析 Runtime + Compiler 构建出来的 Vue.js，它的入口是 `src/platforms/web/entry-runtime-with-compiler.js`：

```js
/* @flow */

import config from 'core/config'
import { warn, cached } from 'core/util/index'
import { mark, measure } from 'core/util/perf'

import Vue from './runtime/index'
import { query } from './util/index'
import { compileToFunctions } from './compiler/index'
import { shouldDecodeNewlines, shouldDecodeNewlinesForHref } from './util/compat'

const idToTemplate = cached(id => {
  const el = query(id)
  return el && el.innerHTML
})

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el: Element): string {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    const container = document.createElement('div')
    container.appendChild(el.cloneNode(true))
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions

export default Vue

```

当我们的代码执行 import Vue from 'vue' 的时候，就是从这个入口执行代码来初始化 Vue，来源为：

import Vue from './runtime/index'`，入口在`src/platforms/web/runtime/index.js

```js
/* @flow */

import Vue from 'core/index'
import config from 'core/config'
import { extend, noop } from 'shared/util'
import { mountComponent } from 'core/instance/lifecycle'
import { devtools, inBrowser } from 'core/util/index'

import {
  query,
  mustUseProp,
  isReservedTag,
  isReservedAttr,
  getTagNamespace,
  isUnknownElement
} from 'web/util/index'

import { patch } from './patch'
import platformDirectives from './directives/index'
import platformComponents from './components/index'

// install platform specific utils
Vue.config.mustUseProp = mustUseProp
Vue.config.isReservedTag = isReservedTag
Vue.config.isReservedAttr = isReservedAttr
Vue.config.getTagNamespace = getTagNamespace
Vue.config.isUnknownElement = isUnknownElement

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives)
extend(Vue.options.components, platformComponents)

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop

// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(() => {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue)
      } else if (
        process.env.NODE_ENV !== 'production' &&
        process.env.NODE_ENV !== 'test'
      ) {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        )
      }
    }
    if (process.env.NODE_ENV !== 'production' &&
      process.env.NODE_ENV !== 'test' &&
      config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        `You are running Vue in development mode.\n` +
        `Make sure to turn on production mode when deploying for production.\n` +
        `See more tips at https://vuejs.org/guide/deployment.html`
      )
    }
  }, 0)
}

export default Vue

```

这里关键的代码是 `import Vue from 'core/index'`，之后的逻辑都是对 Vue 这个对象做一些扩展，可以先不用看，我们来看一下真正初始化 Vue 的地方，在 `src/core/index.js` 中：

```js
import Vue from './instance/index'
import { initGlobalAPI } from './global-api/index'
import { isServerRendering } from 'core/util/env'
import { FunctionalRenderContext } from 'core/vdom/create-functional-component'

initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
})

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
})

Vue.version = '__VERSION__'

export default Vue
```

这里有 2 处关键的代码，`import Vue from './instance/index' `和 `initGlobalAPI(Vue)`，初始化全局 Vue API（我们稍后介绍），我们先来看第一部分，在 `src/core/instance/index.js` 中

#### 3.4.1 vue定义

```js
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

在这里，我们会发现，Vue实际上就是一个用 Function 实现的类，这也是为什么我们只能通过` new Vue` 去实例化它的原因。

Q：为何 Vue 不用 ES6 的 Class 去实现呢？

A：我们往后看这里有很多 xxxMixin 的函数调用，并把 Vue 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法，Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理。

#### 3.4.2 initGlobalAPI

Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 src/core/global-api/index.js 中：

```js
export function initGlobalAPI (Vue: GlobalAPI) {
  // config
  const configDef = {}
  configDef.get = () => config
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = () => {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      )
    }
  }
  Object.defineProperty(Vue, 'config', configDef)

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn,
    extend,
    mergeOptions,
    defineReactive
  }

  Vue.set = set
  Vue.delete = del
  Vue.nextTick = nextTick

  Vue.options = Object.create(null)
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue

  extend(Vue.options.components, builtInComponents)

  initUse(Vue)
  initMixin(Vue)
  initExtend(Vue)
  initAssetRegisters(Vue)
}
```

这里就是在 Vue 上扩展的一些全局方法的定义，Vue 官网中关于全局 API 都可以在这里找到，有一点要注意的是，`Vue.util`暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。具体的全局API后面详细讲解；

### 4. 数据驱动

Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。

在 Vue.js 中我们可以采用简洁的模板语法来声明式的将数据渲染为 DOM：

```js
<div id="app">
  {{ message }}
</div>

var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```

最终它会在页面上渲染出`Hello Vue`。接下来，我们会从源码角度来分析 Vue 是如何实现的。在这里，先弄清楚模板和数据如何渲染成最终的 DOM。

#### 4.1 new Vue时发生什么

从入口代码开始分析，我们先来分析 new Vue 背后发生了哪些事情。我们都知道，new 关键字在 Javascript 语言中代表实例化是一个对象，而 Vue 实际上是一个类，类在 Javascript 中是用 Function 来实现的，来看一下源码，在src/core/instance/index.js 中。

```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

可以看到 Vue 只能通过 new 关键字初始化，然后会调用 this._init 方法， 该方法在`initMixin(Vue)`时注入到prototype上，在 `src/core/instance/init.js`中定义。

```js
Vue.prototype._init = function (options?: Object) {
  const vm: Component = this
  // a uid
  vm._uid = uid++

  let startTag, endTag
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    startTag = `vue-perf-start:${vm._uid}`
    endTag = `vue-perf-end:${vm._uid}`
    mark(startTag)
  }

  // a flag to avoid this being observed
  vm._isVue = true
  // merge options
  if (options && options._isComponent) {
    // optimize internal component instantiation
    // since dynamic options merging is pretty slow, and none of the
    // internal component options needs special treatment.
    initInternalComponent(vm, options)
  } else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    initProxy(vm)
  } else {
    vm._renderProxy = vm
  }
  // expose real self
  vm._self = vm
  initLifecycle(vm)
  initEvents(vm)
  initRender(vm)
  callHook(vm, 'beforeCreate')
  initInjections(vm) // resolve injections before data/props
  initState(vm)
  initProvide(vm) // resolve provide after data/props
  callHook(vm, 'created')

  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    vm._name = formatComponentName(vm, false)
    mark(endTag)
    measure(`vue ${vm._name} init`, startTag, endTag)
  }

  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
}
```

Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。

Vue 的初始化逻辑写的非常清楚，把不同的功能逻辑拆成一些单独的函数执行，让主线逻辑一目了然，由于我们这一章的目标是弄清楚模板和数据如何渲染成最终的 DOM，所以各种初始化逻辑我们先不看。在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM，那么接下来我们来分析 Vue 的挂载过程。

#### 4.2 vue实例挂在的实现

Vue 中我们是通过 $mount 实例方法去挂载 vm 的，$mount 方法在多个文件中都有定义，如 `src/platform/web/entry-runtime-with-compiler.js`、`src/platform/web/runtime/index.js`、`src/platform/weex/runtime/index.js`。因为 $mount 这个方法的实现是和平台、构建方式都相关的。接下来我们重点分析带 compiler 版本的 $mount 实现，因为抛开 webpack 的 vue-loader，我们在纯前端浏览器环境分析 Vue 的工作原理，有助于我们对原理理解的深入。

先来看一下 `src/platform/web/entry-runtime-with-compiler.js `文件中定义：

```js
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

这段代码首先缓存了原型上的` $mount`方法，再重新定义该方法

1. 它对 el 做了限制，Vue 不能挂载在 body、html 这样的根节点上；
2. 如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法。在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 template 属性，最终都会转换成 render 方法；
3. 根据生成的template函数，会执行在线编译的过程，是调用 `compileToFunctions` 方法实现的，在后续的编译过程中讲解。最后，调用原先原型上的 $mount 方法挂载；

原先原型上的 $mount 方法在 `src/platform/web/runtime/index.js `中定义，之所以这么设计完全是为了复用，因为它是可以被`runtime only`版本的 Vue 直接使用的。

```js
// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```

$mount 方法支持传入 2 个参数，第一个是 el，它表示挂载的元素，可以是字符串，也可以是 DOM 对象，如果是字符串在浏览器环境下会调用 query 方法转换成 DOM 对象的。第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。

$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在` src/core/instance/lifecycle.js`文件中：

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

这里面核心就是先实例化一个渲染Watcher，在它的回调函数中会调用 `updateComponent` 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。

Watcher 在这里起到两个作用：（后面会详细讲解）

1. 初始化的时候会执行回调函数；
2. 当 vm 实例中的监测的数据发生变化的时候执行回调函数；

函数最后判断当根节点vm.$vnode为null时，执行mount初始化；接下来详细讲_render（生成VNode）和_update（更新DOM）

#### 4.3 render

Vue 的 `_render` 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 `src/core/instance/render.js` 文件中：

在`src/core/instance/init.js`中，执行`renderMixin`，注入到到Vue.prototype上：

```js
Vue.prototype._render = function (): VNode {
  const vm: Component = this
  const { render, _parentVnode } = vm.$options

  // reset _rendered flag on slots for duplicate slot check
  if (process.env.NODE_ENV !== 'production') {
    for (const key in vm.$slots) {
      // $flow-disable-line
      vm.$slots[key]._rendered = false
    }
  }

  if (_parentVnode) {
    vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject
  }

  // set parent vnode. this allows render functions to have access
  // to the data on the placeholder node.
  vm.$vnode = _parentVnode
  // render self
  let vnode
  try {
    vnode = render.call(vm._renderProxy, vm.$createElement)
  } catch (e) {
    handleError(e, vm, `render`)
    // return error render result,
    // or previous vnode to prevent render error causing blank component
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
        } catch (e) {
          handleError(e, vm, `renderError`)
          vnode = vm._vnode
        }
      } else {
        vnode = vm._vnode
      }
    } else {
      vnode = vm._vnode
    }
  }
  // return empty vnode in case the render function errored out
  if (!(vnode instanceof VNode)) {
    if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
      warn(
        'Multiple root nodes returned from render function. Render function ' +
        'should return a single root node.',
        vm
      )
    }
    vnode = createEmptyVNode()
  }
  // set parent
  vnode.parent = _parentVnode
  return vnode
}
```

最关键的是 render 方法的调用，在之前的 mounted 方法的实现中，会把 template 编译成 render 方法，具体的编译方法在后面讲

在_render 函数中的 render 方法的调用中：

```js
vnode = render.call(vm._renderProxy, vm.$createElement)
```

render 函数中的 createElement 方法就是 vm.$createElement 方法，其中vm.$createElement的方法是在initRender中定义的，其中vm.$createElement调用了createElement，另一个方法也调用了，这个方法是被模板编译成的 render 函数使用，而 vm.$createElement 是用户手写 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法

```js
vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
```

此方法，也是Vue中提到的render的第一个参数`createElement`

```js
render: function (createElement) {
  return createElement('div', {
     attrs: {
        id: 'app'
      },
  }, this.message)
}
```

#### 4.4 vdom

在了解createElement原理之前，先了解下Virtual DOM是什么。

在浏览器中，一个最简单的div所包含的元素也是很多的，因为浏览器的标准就把 DOM 设计的非常复杂。当我们频繁的去做 DOM 更新，会产生一定的性能问题。

```js
const div = document.createElement('div')
let str = '';
for (const key in div) str += key + ' '
```

而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。在 Vue.js 中，Virtual DOM 是用 VNode 这么一个 Class 去描述，它是定义在 src/core/vdom/vnode.js 中的。

```js
export default class VNode {
  tag: string | void;
  data: VNodeData | void;
  children: ?Array<VNode>;
  text: string | void;
  elm: Node | void;
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node

  // strictly internal
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?
  asyncFactory: Function | void; // async component factory function
  asyncMeta: Object | void;
  isAsyncPlaceholder: boolean;
  ssrContext: Object | void;
  fnContext: Component | void; // real context vm for functional nodes
  fnOptions: ?ComponentOptions; // for SSR caching
  fnScopeId: ?string; // functional scope id support

  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.fnContext = undefined
    this.fnOptions = undefined
    this.fnScopeId = undefined
    this.key = data && data.key
    this.componentOptions = componentOptions
    this.componentInstance = undefined
    this.parent = undefined
    this.raw = false
    this.isStatic = false
    this.isRootInsert = true
    this.isComment = false
    this.isCloned = false
    this.isOnce = false
    this.asyncFactory = asyncFactory
    this.asyncMeta = undefined
    this.isAsyncPlaceholder = false
  }

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  get child (): Component | void {
    return this.componentInstance
  }
}
```

实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库 [snabbdom](https://github.com/snabbdom/snabbdom) 的实现，然后加入了一些 Vue.js本身的东西，在后面的内容里，会在VNode的create、diff、patch等阶段讲解VNode的操作；

#### 4.5 createElement

Vue.js 利用 createElement 方法创建 VNode，它定义在 `src/core/vdom/create-element.js` 中：

```js
// wrapper function for providing a more flexible interface
// without getting yelled at by flow
export function createElement (
  context: Component,
  tag: any,
  data: any,
  children: any,
  normalizationType: any,
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE
  }
  return _createElement(context, tag, data, children, normalizationType)
}

export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  if (isDef(data) && isDef((data: any).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` +
      'Always create fresh vnode data objects in each render!',
      context
    )
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    if (!__WEEX__ || !('@binding' in data.key)) {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      )
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}

```

_createElement 方法有 5 个参数：

1. context 表示 VNode 的上下文环境，它是 Component 类型；
2. tag 表示标签，它可以是一个字符串，也可以是一个 Component；
3. data 表示 VNode 的数据，它是一个 VNodeData 类型，可以在 flow/vnode.js 中找到它的定义，这里先不展开说；
4. children 表示当前 VNode 的子节点，它是任意类型的，它接下来需要被规范为标准的 VNode 数组；
5. normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，它主要是参考 render 函数是编译生成的还是用户手写的。

createElement里核心的流程包含两个：

##### 4.5.1 children的规范化

由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。_createElement 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。

这里根据 normalizationType 的不同，调用了 `normalizeChildren(children) `和 `simpleNormalizeChildren(children) `方法，它们的定义都在 `src/core/vdom/helpers/normalzie-children.js `中：

```js
export function simpleNormalizeChildren (children: any) {
  for (let i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

export function normalizeChildren (children: any): ?Array<VNode> {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}
```

- simpleNormalizeChildren：

1. 调用场景是 render 函数是编译生成的。
2. 理论上编译生成的 children 都已经是 VNode 类型的，但这里有一个例外，就是 functional component 函数式组件返回的是一个数组而不是一个根节点，所以会通过 `Array.prototype.concat `方法把整个 children 数组打平，让它的深度只有一层。

- normalizeChildren 方法的调用场景有 2 种：

1. 一个场景是 render 函数是用户手写的，当 children 只有一个节点的时候，Vue.js 从接口层面允许用户把 children 写成基础类型用来创建单个简单的文本节点，这种情况会调用 `createTextVNode` 创建一个文本节点的 VNode；
2. 另一个场景是当编译 slot、v-for 的时候会产生嵌套数组的情况，会调用 `normalizeArrayChildren` 方法；

```js
function normalizeArrayChildren (children: any, nestedIndex?: string): Array<VNode> {
  const res = []
  let i, c, lastIndex, last
  for (i = 0; i < children.length; i++) {
    c = children[i]
    if (isUndef(c) || typeof c === 'boolean') continue
    lastIndex = res.length - 1
    last = res[lastIndex]
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
          c.shift()
        }
        res.push.apply(res, c)
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c)
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c))
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text)
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = `__vlist${nestedIndex}_${i}__`
        }
        res.push(c)
      }
    }
  }
  return res
}

```

normalizeArrayChildren 接收 2 个参数：

1. children：表示要规范的子节点；
2. nestedIndex：表示嵌套的索引；

因为单个 child 可能是一个数组类型。 `normalizeArrayChildren` 主要的逻辑就是遍历 children，获得单个节点 c，然后对 c 的类型判断：

1. 如果是一个数组类型，则递归调用 `normalizeArrayChildren`; 
2. 如果是基础类型，则通过 `createTextVNode` 方法转换成 VNode 类型；否则就已经是 VNode 类型了，如果 children 是一个列表并且列表还存在嵌套的情况，则根据 nestedIndex 去更新它的 key；

注意：在遍历的过程中，如果存在两个连续的 text 节点，会把它们合并成一个 text 节点

然后，children就变为了VNode的单节点或者数组了

#### 3.5.2 vnode的构建

规范完children后，需要创建一个VNode实例：

```js
let vnode, ns
if (typeof tag === 'string') {
  let Ctor
  ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
  if (config.isReservedTag(tag)) {
    // platform built-in elements
    if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
      warn(
        `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
        context
      )
    }
    vnode = new VNode(
      config.parsePlatformTagName(tag), data, children,
      undefined, undefined, context
    )
  } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
    // component
    vnode = createComponent(Ctor, data, context, children, tag)
  } else {
    // unknown or unlisted namespaced elements
    // check at runtime because it may get assigned a namespace when its
    // parent normalizes children
    vnode = new VNode(
      tag, data, children,
      undefined, undefined, context
    )
  }
} else {
  // direct component options / constructor
  vnode = createComponent(tag, data, context, children)
}
```

_update 的核心就是调用 vm.__patch__ 方法，这个方法实际上在不同的平台，比如 web 和 weex 上的定义是不一样的，因此在 web 平台中它的定义在 src/platforms/web/runtime/index.js 中：

```js
Vue.prototype.__patch__ = inBrowser ? patch : noop
```

在 web 平台上，是否是服务端渲染也会对这个方法产生影响。因为在服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器端渲染中，它指向了 patch 方法，它的定义在` src/platforms/web/runtime/patch.js`中：

```js
import * as nodeOps from 'web/runtime/node-ops'
import { createPatchFunction } from 'core/vdom/patch'
import baseModules from 'core/vdom/modules/index'
import platformModules from 'web/runtime/modules/index'

// the directive module should be applied last, after all
// built-in modules have been applied.
const modules = platformModules.concat(baseModules)

export const patch: Function = createPatchFunction({ nodeOps, modules })
```

该方法的定义是调用 `createPatchFunction` 方法的返回值，这里传入了一个对象，包含 nodeOps 参数和 modules 参数。其中，nodeOps 封装了一系列 DOM 操作的方法，modules 定义了一些模块的钩子函数的实现，我们这里先不详细介绍，来看一下 createPatchFunction 的实现，它定义在 `src/core/vdom/patch.js` 中：

```js
const hooks = ['create', 'activate', 'update', 'remove', 'destroy']

export function createPatchFunction (backend) {
  let i, j
  const cbs = {}

  const { modules, nodeOps } = backend

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = []
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]])
      }
    }
  }

  // ...

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              )
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode)
        }

        // replacing existing element
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (let i = 1; i < insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
}
```

createPatchFunction 内部定义了一系列的辅助方法，最终返回了一个 patch 方法，这个方法就赋值给了 vm._update 函数里调用的 `vm.__patch__`。

Q：为何 Vue.js 源码绕了这么一大圈，把相关代码分散到各个目录？

A：

1. 因为patch 是平台相关的，在 Web 和 Weex 环境，它们把虚拟 DOM 映射到 “平台 DOM” 的方法是不同的，并且对 “DOM” 包括的属性模块创建和更新也不尽相同。因此每个平台都有各自的 `nodeOps` 和 `modules`，它们的代码需要托管在 src/platforms 这个大目录下；
2. 不同平台的 patch 的主要逻辑部分是相同的，所以这部分公共的部分托管在 core 这个大目录下。差异化部分只需要通过参数`nodeOps` 和 `modules` 来区分：

1. 1. nodeOps 表示对 “平台 DOM” 的一些操作方法；
   2. modules 表示平台的一些模块，它们会在整个 patch 过程的不同阶段执行相应的钩子函数；

回到 patch 方法本身，它接收 4个参数：

1. oldVnode 表示旧的 VNode 节点，它也可以不存在或者是一个 DOM 对象；
2. vnode 表示执行 _render 后返回的 VNode 的节点；
3. hydrating 表示是否是服务端渲染；
4. removeOnly 是给 transition-group 用的；

先来回顾我们的例子：

```js
var app = new Vue({
  el: '#app',
  render: function (createElement) {
    return createElement('div', {
      attrs: {
        id: 'app'
      },
    }, this.message)
  },
  data: {
    message: 'Hello Vue!'
  }
})
```

在 vm._update 的方法里是这么调用 patch 方法的:

```js
// initial render
vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
```

结合我们的例子：

1. 我们的场景是首次渲染，所以在执行 patch 函数的时候，传入的 vm.$el 对应的是例子中 id 为 app 的 DOM 对象，这个也就是我们在 index.html 模板中写的 `<div id="app">`，vm.$el 的赋值是在之前 mountComponent 函数做的；
2. vnode 对应的是调用 render 函数的返回值；
3. hydrating 在非服务端渲染情况下为 false；
4. removeOnly 为 false；

这时候回顾patch的执行过程上

```js
const isRealElement = isDef(oldVnode.nodeType)
if (!isRealElement && sameVnode(oldVnode, vnode)) {
  // patch existing root node
  patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
} else {
  if (isRealElement) {
    // mounting to a real element
    // check if this is server-rendered content and if we can perform
    // a successful hydration.
    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
      oldVnode.removeAttribute(SSR_ATTR)
      hydrating = true
    }
    if (isTrue(hydrating)) {
      if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
        invokeInsertHook(vnode, insertedVnodeQueue, true)
        return oldVnode
      } else if (process.env.NODE_ENV !== 'production') {
        warn(
          'The client-side rendered virtual DOM tree is not matching ' +
          'server-rendered content. This is likely caused by incorrect ' +
          'HTML markup, for example nesting block-level elements inside ' +
          '<p>, or missing <tbody>. Bailing hydration and performing ' +
          'full client-side render.'
        )
      }
    }      
    // either not server-rendered, or hydration failed.
    // create an empty node and replace it
    oldVnode = emptyNodeAt(oldVnode)
  }

  // replacing existing element
  const oldElm = oldVnode.elm
  const parentElm = nodeOps.parentNode(oldElm)

  // create new node
  createElm(
    vnode,
    insertedVnodeQueue,
    // extremely rare edge case: do not insert if old element is in a
    // leaving transition. Only happens when combining transition +
    // keep-alive + HOCs. (#4590)
    oldElm._leaveCb ? null : parentElm,
    nodeOps.nextSibling(oldElm)
  )
}
```

由于我们传入的 oldVnode 实际上是一个 DOM，所以 isRealElement 为 true，接下来又通过 emptyNodeAt 方法把 oldVnode 转换成 VNode 对象，然后再调用 createElm 方法，来看一下它的实现：

```js
function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  if (isDef(vnode.elm) && isDef(ownerArray)) {
    // This vnode was used in a previous render!
    // now it's used as a new node, overwriting its elm would cause
    // potential patch errors down the road when it's used as an insertion
    // reference node. Instead, we clone the node on-demand before creating
    // associated DOM element for it.
    vnode = ownerArray[index] = cloneVNode(vnode)
  }

  vnode.isRootInsert = !nested // for transition enter check
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
    return
  }

  const data = vnode.data
  const children = vnode.children
  const tag = vnode.tag
  if (isDef(tag)) {
    if (process.env.NODE_ENV !== 'production') {
      if (data && data.pre) {
        creatingElmInVPre++
      }
      if (isUnknownElement(vnode, creatingElmInVPre)) {
        warn(
          'Unknown custom element: <' + tag + '> - did you ' +
          'register the component correctly? For recursive components, ' +
          'make sure to provide the "name" option.',
          vnode.context
        )
      }
    }

    vnode.elm = vnode.ns
      ? nodeOps.createElementNS(vnode.ns, tag)
      : nodeOps.createElement(tag, vnode)
    setScope(vnode)

    /* istanbul ignore if */
    if (__WEEX__) {
      // ...
    } else {
      createChildren(vnode, children, insertedVnodeQueue)
      if (isDef(data)) {
        invokeCreateHooks(vnode, insertedVnodeQueue)
      }
      insert(parentElm, vnode.elm, refElm)
    }

    if (process.env.NODE_ENV !== 'production' && data && data.pre) {
      creatingElmInVPre--
    }
  } else if (isTrue(vnode.isComment)) {
    vnode.elm = nodeOps.createComment(vnode.text)
    insert(parentElm, vnode.elm, refElm)
  } else {
    vnode.elm = nodeOps.createTextNode(vnode.text)
    insert(parentElm, vnode.elm, refElm)
  }
}
```

createElm 的作用是通过虚拟节点创建真实的 DOM 并插入到它的父节点中。 

1. createComponent 方法目的是尝试创建子组件，后面详细解释，在当前这个 case 下它的返回值为 false；
2. 接下来判断 vnode 是否包含 tag，如果包含，先简单对 tag 的合法性在非生产环境下做校验，看是否是一个合法标签；然后再去调用平台 DOM 的操作去创建一个占位符元素；（ns：nameSpace）

```js
vnode.elm = vnode.ns
  ? nodeOps.createElementNS(vnode.ns, tag)
  : nodeOps.createElement(tag, vnode)
```

接下来调用 createChildren 方法去创建子元素，也就是去遍历createElm的：

```js
createChildren(vnode, children, insertedVnodeQueue)

function createChildren (vnode, children, insertedVnodeQueue) {
  if (Array.isArray(children)) {
    if (process.env.NODE_ENV !== 'production') {
      checkDuplicateKeys(children)
    }
    for (let i = 0; i < children.length; ++i) {
      createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i)
    }
  } else if (isPrimitive(vnode.text)) {
    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))
  }
}
```

接着再调用 invokeCreateHooks 方法执行所有的 create 的钩子并把 vnode push 到 insertedVnodeQueue 中

```js
 if (isDef(data)) {
  invokeCreateHooks(vnode, insertedVnodeQueue)
}

function invokeCreateHooks (vnode, insertedVnodeQueue) {
  for (let i = 0; i < cbs.create.length; ++i) {
    cbs.create[i](emptyNode, vnode)
  }
  i = vnode.data.hook // Reuse variable
  if (isDef(i)) {
    if (isDef(i.create)) i.create(emptyNode, vnode)
    if (isDef(i.insert)) insertedVnodeQueue.push(vnode)
  }
}
```

最后调用 insert 方法把 DOM 插入到父节点中，因为是递归调用，子元素会优先调用 insert，所以整个 vnode 树节点的插入顺序是先子后父。来看一下 insert 方法，它的定义在 src/core/vdom/patch.js 上。

```js
insert(parentElm, vnode.elm, refElm)

function insert (parent, elm, ref) {
  if (isDef(parent)) {
    if (isDef(ref)) {
      if (ref.parentNode === parent) {
        nodeOps.insertBefore(parent, elm, ref)
      }
    } else {
      nodeOps.appendChild(parent, elm)
    }
  }
}
```

insert 调用一些 nodeOps 把子节点插入到父节点中，这些辅助方法定义在 src/platforms/web/runtime/node-ops.js 中：

```js
export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) {
  parentNode.insertBefore(newNode, referenceNode)
}

export function appendChild (node: Node, child: Node) {
  node.appendChild(child)
}
```

其实在web中，就是调用原生 DOM 的 API 进行 DOM 操作；

在 `createElm` 过程中，如果 vnode 节点不包含 tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本 vnode，它的 text 值取的就是之前的 this.message 的值 Hello Vue!。

再回到 `patch` 方法，首次渲染我们调用了 createElm 方法，这里传入的 parentElm 是 oldVnode.elm 的父元素，在我们的例子是 id 为 #app div 的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上；

最后，我们根据之前递归 createElm 生成的 vnode 插入顺序队列，执行相关的 insert 钩子函数；

以上就是数据在Vue2中如何渲染成DOM的过程。

![vue2渲染dom](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2渲染dom.png)

# Vue2源码解析（2/2）

## 1.课程目标

掌握Vue2.6（目前2.X最高版本）的核心源码；

https://www.yuque.com/lpldplws/web/xx3ygi?singleDoc# 《Vue2源码解析（2/2）》 密码：ya0n

## 2.课程大纲

- vue组件化

## 3. Vue 组件化

Vue.js的一个核心思想是组件化。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套，接下来我们会从源码的角度来分析 Vue 的组件内部是如何工作的。

接下来我们会用 Vue-cli 初始化的代码为例，来分析一下 Vue 组件初始化的一个过程。

```js
import Vue from 'vue'
import App from './App.vue'

var app = new Vue({
  el: '#app',
  // 这里的 h 是 createElement 方法
  render: h => h(App)
})
```

这段代码相信很多同学都很熟悉，它和我们上一章相同的点也是通过 render 函数去渲染的，不同的这次通过 createElement 传的参数是一个组件而不是一个原生的标签，接下来我们就开始分析这一过程中发生了什么。

## 3.1 createComponent

上节课中，我们在createElement 的实现中讲过，它会调用 _createElement 方法，其中有一段逻辑是对参数 tag 的判断，如果是一个普通的 html 标签，会实例化一个普通的VNode节点，否则通过 createComponent 方法创建一个组件 VNode。

- src/code/vdom/create-element.js

```js
if (typeof tag === 'string') {
  let Ctor
  ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
  if (config.isReservedTag(tag)) {
    // platform built-in elements
    vnode = new VNode(
      config.parsePlatformTagName(tag), data, children,
      undefined, undefined, context
    )
  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
    // component
    vnode = createComponent(Ctor, data, context, children, tag)
  } else {
    // unknown or unlisted namespaced elements
    // check at runtime because it may get assigned a namespace when its
    // parent normalizes children
    vnode = new VNode(
      tag, data, children,
      undefined, undefined, context
    )
  }
} else {
  // direct component options / constructor
  vnode = createComponent(tag, data, context, children)
}
```

在render函数中，我们传入的是render：h=>h(App)，是一个Component组件类型，会执行

```js
vnode = createComponent(Ctor, data, context, children, tag)
```

它定义在 `src/core/vdom/create-component.js `文件中

```js
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void {
  if (isUndef(Ctor)) {
    return
  }

  const baseCtor = context.$options._base

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor)
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn(`Invalid Component definition: ${String(Ctor)}`, context)
    }
    return
  }

  // async component
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {}

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor)

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }

  // extract props
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  const listeners = data.on
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data)

  // return a placeholder vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  if (__WEEX__ && isRecyclableComponent(vnode)) {
    return renderRecyclableComponentTemplate(vnode)
  }

  return vnode
}
```

内容相对较多，我们只看核心的部分：`构造子类构造函数`，`安装组件钩子函数`和`实例化 VNode`。

#### 3.1.1构造子类构造函数

```js
const baseCtor = context.$options._base

// plain options object: turn it into a constructor
if (isObject(Ctor)) {
  Ctor = baseCtor.extend(Ctor)
}
```

在开发业务组件的时候，我们经常是使用下列方式创建：

```js
import HelloWorld from './components/HelloWorld'

export default {
  name: 'app',
  components: {
    HelloWorld
  }
}
```

这里 export 的是一个对象，所以 createComponent 里的代码逻辑会执行到 baseCtor.extend(Ctor)，在这里 baseCtor 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 src/core/global-api/index.js 中的 initGlobalAPI 里定义的：

```js
// this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue
```

但是我们会发现，这里定义的是 `Vue.options`，而我们的 createComponent 取的是 `context.$options`，实际上在 `src/core/instance/init.js`里 Vue 原型上的 _init 函数中注入的这部分内容：

```js
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

这样就把 Vue 上的一些 option 扩展到了 `vm.$options` 上，所以我们也就能通过 `vm.$options._base` 拿到 Vue 这个构造函数了。mergeOptions后面详细讲解，现在只需要理解它的功能是把 Vue 构造函数的 options 和用户传入的 options 做一层合并，到 `vm.$options` 上。

在明确`baseCtor` 指向了 Vue 之后，我们来看一下 Vue.extend 函数的定义，在 `src/core/global-api/extend.js` 中：

```js
/**
   * Class inheritance
   */
  Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    const Super = this
    const SuperId = Super.cid
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name)
    }

    const Sub = function VueComponent (options) {
      this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    cachedCtors[SuperId] = Sub
    return Sub
  }
}
```

这里我们可以发现，Vue.extend的作用就是通过原型继承的方式，把一个继承于Vue的构造器，Sub返回，然后对Sub 这个对象本身扩展了一些属性，如扩展 options、添加全局 API 等；并且对配置中的 props 和 computed 做了初始化工作；最后对于这个 Sub 构造函数做了缓存，避免多次执行 Vue.extend 的时候对同一个子组件重复构造。
然后，当我们去实例化 Sub 的时候，就会执行 this._init 逻辑再次走到了 Vue 实例的初始化逻辑，实例化组件的方式后面说明。

```js
const Sub = function VueComponent (options) {
  this._init(options)
}
```

#### 3.1.2 安装钩子函数

```js
// install component management hooks onto the placeholder node
installComponentHooks(data
```

之前提到 Vue.js 使用的 Virtual DOM 参考的是开源库 [snabbdom](https://github.com/snabbdom/snabbdom)，它的一个特点是在 VNode 的 patch 流程中对外暴露了各种时机的钩子函数，方便我们做一些额外的事情，Vue.js 也是充分利用这一点，在初始化一个 Component 类型的 VNode 的过程中实现了几个钩子函数：

```js
const componentVNodeHooks = {
  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      const mountedNode: any = vnode // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },

  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance)
      } else {
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}

const hooksToMerge = Object.keys(componentVNodeHooks)

function installComponentHooks (data: VNodeData) {
  const hooks = data.hook || (data.hook = {})
  for (let i = 0; i < hooksToMerge.length; i++) {
    const key = hooksToMerge[i]
    const existing = hooks[key]
    const toMerge = componentVNodeHooks[key]
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
    }
  }
}

function mergeHook (f1: any, f2: any): Function {
  const merged = (a, b) => {
    // flow complains about extra args which is why we use any
    f1(a, b)
    f2(a, b)
  }
  merged._merged = true
  return merged
}
```

整个 `installComponentHooks` 的过程就是把 `componentVNodeHooks` 的钩子函数合并到 `data.hook`中，在 VNode 执行 patch 的过程中执行相关的钩子函数，具体的执行我们在后面`patch` 过程中介绍。这里要注意的是合并策略，在合并过程中，如果某个时机的钩子已经存在 `data.hook `中，那么通过执行 `mergeHook` 函数做合并，确保两个需要合并的钩子函数都执行。

#### 3.1.3 实例化vnode

```js
const name = Ctor.options.name || tag
const vnode = new VNode(
  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
  data, undefined, undefined, undefined, context,
  { Ctor, propsData, listeners, tag, children },
  asyncFactory
)
return vnode
```

最后，我们会通过`new VNode`方式实例化一个VNode并返回，这里要注意，此时的Component VNode元素是没有children的，且前缀是`vue-component`。这块在后续的patch过程中会用到。

#### 3.1.4 总结

到这里，对组件我们完成了`createComponent`的处理，此时我们生成了组件的VNode，接下来按照正常的元素渲染，_render_已经处理完成，需要进行`_update`，也就是`patch`的逻辑。

### 3.2 patch

跟普通元素类似，`createComponent` 创建了组件 VNode，接下来会走到 v`m._update`，执行 `vm.__patch__` 去把 VNode 转换成真正的 DOM 节点。我们对比普通元素，看下patch阶段对组件元素会有何种区别：

patch 的过程会调用 `createElm` 创建元素节点，回顾一下 createElm 的实现，它的定义在 `src/core/vdom/patch.js` 中：

```js
function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  // ...
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
    return
  }
  // ...
}
```

#### 3.2.1 createComponent

上节课有说过，对于非组件元素，我们在`createComponent`会返回false，接下来看下具体实现：

```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  let i = vnode.data
  if (isDef(i)) {
    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      i(vnode, false /* hydrating */)
    }
    // after calling the init hook, if the vnode is a child component
    // it should've created a child instance and mounted it. the child
    // component also has set the placeholder vnode's elm.
    // in that case we can just return the element and be done.
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      if (isTrue(isReactivated)) {
        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
      }
      return true
    }
  }
}
```

首先对vnode.data进行判断:

```js
let i = vnode.data
if (isDef(i)) {
  // ...
  if (isDef(i = i.hook) && isDef(i = i.init)) {
    i(vnode, false /* hydrating */)
    // ...
  }
  // ..
}
```

如果 vnode 是一个组件 VNode，那么条件会满足，并且得到 i 就是 init 钩子函数，回顾上节我们在创建组件 VNode 的时候合并钩子函数中就包含 init 钩子函数，定义在 `src/core/vdom/create-component.js` 中：

```js
init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
  if (
    vnode.componentInstance &&
    !vnode.componentInstance._isDestroyed &&
    vnode.data.keepAlive
  ) {
    // kept-alive components, treat as a patch
    const mountedNode: any = vnode // work around flow
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    const child = vnode.componentInstance = createComponentInstanceForVnode(
      vnode,
      activeInstance
    )
    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
},
```

我们先不考虑 keepAlive 的情况，它是通过 createComponentInstanceForVnode 创建一个 Vue 的实例，然后调用 $mount 方法挂载子组件， 先来看一下 createComponentInstanceForVnode 的实现：

```js
export function createComponentInstanceForVnode (
  vnode: any, // we know it's MountedComponentVNode but flow doesn't
  parent: any, // activeInstance in lifecycle state
): Component {
  const options: InternalComponentOptions = {
    _isComponent: true,
    _parentVnode: vnode,
    parent
  }
  // check inline-template render functions
  const inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  return new vnode.componentOptions.Ctor(options)
}
```

`createComponentInstanceForVnode` 函数构造的一个内部组件的参数，然后执行 `new vnode.componentOptions.Ctor(options)`。这里的`vnode.componentOptions.Ctor` 对应的就是子组件的构造函数，我们上一节分析了它实际上是继承于 Vue 的一个构造器 Sub，相当于 `new Sub(options)` 这里有几个关键参数要注意几个点，_isComponent 为 true 表示它是一个组件。

所以子组件的实例化实际上就是在这个时机执行的，并且它会执行实例的 _init 方法，这个过程有一些和之前不同的地方需要挑出来说，代码在 `src/core/instance/init.js`中：

```js
Vue.prototype._init = function (options?: Object) {
  const vm: Component = this
  // merge options
  if (options && options._isComponent) {
    // optimize internal component instantiation
    // since dynamic options merging is pretty slow, and none of the
    // internal component options needs special treatment.
    initInternalComponent(vm, options)
  } else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
  // ...
  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  } 
}
```

首先是合并 options 的过程有变化，_isComponent 为 true，所以走到了 initInternalComponent 过程：

```js
export function initInternalComponent (vm: Component, options: InternalComponentOptions) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}
```

这里着重注意下：`opts.parent = options.parent`、`opts._parentVnode = parentVnode`

最后，_init执行：

```js
if (vm.$options.el) {
   vm.$mount(vm.$options.el)
}
```

此时，回顾组件的init

```js
init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
  if (
    vnode.componentInstance &&
    !vnode.componentInstance._isDestroyed &&
    vnode.data.keepAlive
  ) {
    // kept-alive components, treat as a patch
    const mountedNode: any = vnode // work around flow
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    const child = vnode.componentInstance = createComponentInstanceForVnode(
      vnode,
      activeInstance
    )
    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
},
```

会执行 `child.$mount(hydrating ? vnode.elm : undefined, hydrating) `。这里 hydrating 为 true 一般是服务端渲染的情况，我们只考虑客户端渲染，所以这里 $mount 相当于执行 `child.$mount(undefined, false)`，它最终会调用 mountComponent 方法，进而执行 vm._render() 方法：

```js
Vue.prototype._render = function (): VNode {
  const vm: Component = this
  const { render, _parentVnode } = vm.$options

  
  // set parent vnode. this allows render functions to have access
  // to the data on the placeholder node.
  vm.$vnode = _parentVnode
  // render self
  let vnode
  try {
    vnode = render.call(vm._renderProxy, vm.$createElement)
  } catch (e) {
    // ...
  }
  // set parent
  vnode.parent = _parentVnode
  return vnode
}
```

这里的 `_parentVnode` 就是当前组件的父 VNode，而 render 函数生成的 vnode 当前组件的渲染 vnode，vnode 的 parent 指向了 `_parentVnode`，也就是 vm.$vnode，它们是一种父子的关系，在执行完 vm._render 生成 VNode 后，接下来就要执行 `vm._update` 去渲染 VNode 了。来看一下组件渲染的过程中有哪些需要注意的，`vm._update` 的定义在`src/core/instance/lifecycle.js` 中：

```js
export let activeInstance: any = null
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  const prevActiveInstance = activeInstance
  activeInstance = vm
  vm._vnode = vnode
  // Vue.prototype.__patch__ is injected in entry points
  // based on the rendering backend used.
  if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  activeInstance = prevActiveInstance
  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }
  // if parent is an HOC, update its $el as well
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
  // updated hook is called by the scheduler to ensure that children are
  // updated in a parent's updated hook.
}
```

首先，` vm._vnode = vnode `的逻辑，这个 vnode 是通过 vm._render() 返回的组件渲染 VNode，`vm._vnode` 和 `vm.$vnode` 的关系就是一种父子关系，用代码表达就是 `vm._vnode.parent === vm.$vnode`

```js
export let activeInstance: any = null
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  // ...
  const prevActiveInstance = activeInstance
  activeInstance = vm
  if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  activeInstance = prevActiveInstance
  // ...
}
```

这个 activeInstance 作用就是保持当前上下文的 Vue 实例，它是在 lifecycle 模块的全局变量，定义是 `export let activeInstance: any = null`，并且在之前我们调用 `createComponentInstanceForVnode` 方法的时候从 lifecycle 模块获取，并且作为参数传入的。因为实际上 JavaScript 是一个单线程，Vue 整个初始化是一个深度遍历的过程，在实例化子组件的过程中，它需要知道当前上下文的 Vue 实例是什么，并把它作为子组件的父 Vue 实例。前面我们提到过对子组件的实例化过程先会调用 `initInternalComponent(vm, options) `合并 options，把 parent 存储在 vm.$options 中，在 $mount 之前会调用 initLifecycle(vm) 方法：

```js
export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  // ...
}
```

可以看到 vm.$parent 就是用来保留当前 vm 的父实例，并且通过 parent.$children.push(vm) 来把当前的 vm 存储到父实例的 $children 中。

在 vm._update 的过程中，把当前的 vm 赋值给 activeInstance，同时通过 const prevActiveInstance = activeInstance 用 prevActiveInstance 保留上一次的 activeInstance。实际上，prevActiveInstance 和当前的 vm 是一个父子关系，当一个 vm 实例完成它的所有子树的 patch 或者 update 过程后，activeInstance 会回到它的父实例，这样就完美地保证了 `createComponentInstanceForVnode` 整个深度遍历过程中，我们在实例化子组件的时候能传入当前子组件的父 Vue 实例，并在 _init 的过程中，通过 vm.$parent 把这个父子关系保留。

那么回到 _update，最后就是调用 __patch__ 渲染 VNode：

```js
vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
 
function patch (oldVnode, vnode, hydrating, removeOnly) {
  // ...
  let isInitialPatch = false
  const insertedVnodeQueue = []

  if (isUndef(oldVnode)) {
    // empty mount (likely as component), create new root element
    isInitialPatch = true
    createElm(vnode, insertedVnodeQueue)
  } else {
    // ...
  }
  // ...
}

```

之前分析过负责渲染成 DOM 的函数是 createElm，注意这里我们只传了 2 个参数，所以对应的 parentElm 是 undefined。我们再来看看它的定义：

```js
function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  // ...
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
    return
  }

  const data = vnode.data
  const children = vnode.children
  const tag = vnode.tag
  if (isDef(tag)) {
    // ...

    vnode.elm = vnode.ns
      ? nodeOps.createElementNS(vnode.ns, tag)
      : nodeOps.createElement(tag, vnode)
    setScope(vnode)

    /* istanbul ignore if */
    if (__WEEX__) {
      // ...
    } else {
      createChildren(vnode, children, insertedVnodeQueue)
      if (isDef(data)) {
        invokeCreateHooks(vnode, insertedVnodeQueue)
      }
      insert(parentElm, vnode.elm, refElm)
    }
    
    // ...
  } else if (isTrue(vnode.isComment)) {
    vnode.elm = nodeOps.createComment(vnode.text)
    insert(parentElm, vnode.elm, refElm)
  } else {
    vnode.elm = nodeOps.createTextNode(vnode.text)
    insert(parentElm, vnode.elm, refElm)
  }
}
```

注意，这里我们传入的 vnode 是组件渲染的 vnode，也就是我们之前说的 vm._vnode，如果组件的根节点是个普通元素，那么 vm._vnode 也是普通的 vnode，这里 `createComponent(vnode, insertedVnodeQueue, parentElm, refElm)` 的返回值是 false。接下来的过程就和我们上一章一样了，先创建一个父节点占位符，然后再遍历所有子 VNode 递归调用 createElm，在遍历的过程中，如果遇到子 VNode 是一个组件的 VNode，则重复本节开始的过程，这样通过一个递归的方式就可以完整地构建了整个组件树。

由于我们这个时候传入的 `parentElm` 是空，所以对组件的插入，在 `createComponent` 有这么一段逻辑

```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  let i = vnode.data
  if (isDef(i)) {
    // ....
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      i(vnode, false /* hydrating */)
    }
    // ...
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      if (isTrue(isReactivated)) {
        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
      }
      return true
    }
  }
}
```

在完成组件的整个 patch 过程后，最后执行 `insert(parentElm, vnode.elm, refElm) `完成组件的 DOM 插入，如果组件 patch 过程中又创建了子组件，那么DOM 的插入顺序是先子后父。

至此，我们就讲完了一个组件VNode是如何创建、初始化、渲染的了。

### 3.3 合并配置

我们知道，`new Vue` 的过程通常有 2 种场景，一种是外部我们的代码主动调用 `new Vue(options)` 的方式实例化一个 Vue 对象；另一种是我们上一节分析的组件过程中内部通过 `new Vue(options)`实例化子组件

两者都会执行实例的 `_init(options)` 方法，它首先会执行一个` merge options` 的逻辑，相关的代码在 `src/core/instance/init.js` 中：

```js
Vue.prototype._init = function (options?: Object) {
  // merge options
  if (options && options._isComponent) {
    // optimize internal component instantiation
    // since dynamic options merging is pretty slow, and none of the
    // internal component options needs special treatment.
    initInternalComponent(vm, options)
  } else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
  // ...
}
```

可以发现，options有两种类型的传参，接下来会对options进行分析：
首先，我们举个简单的例子：

```js
import Vue from 'vue'

let childComp = {
  template: '<div>{{msg}}</div>',
  created() {
    console.log('child created')
  },
  mounted() {
    console.log('child mounted')
  },
  data() {
    return {
      msg: 'Hello Vue'
    }
  }
}

Vue.mixin({
  created() {
    console.log('parent created')
  }
})

let app = new Vue({
  el: '#app',
  render: h => h(childComp)
})
```

#### 3.3.1 外部调用场景

当执行 new Vue 的时候，在执行 `this._init(options) `的时候，就会执行如下逻辑去合并 options：

```js
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

通过调用 `mergeOptions` 方法来合并，它实际上就是把 `resolveConstructorOptions(vm.constructor) `的返回值和 `options` 做合并，`resolveConstructorOptions` 的实现先不考虑，在我们这个场景下，它还是简单返回 `vm.constructor.options`，相当于 Vue.options，那么这个值又是什么呢，其实在 initGlobalAPI(Vue) 的时候定义了这个值，

在 `src/core/global-api/index.js` 中：

```js
export function initGlobalAPI (Vue: GlobalAPI) {
  // ...
  Vue.options = Object.create(null)
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue

  extend(Vue.options.components, builtInComponents)
  // ...
}
```

首先通过 `Vue.options = Object.create(null)` 创建一个空对象，然后遍历 `ASSET_TYPES`，ASSET_TYPES 的定义在 `src/shared/constants.js` 中：

```js
export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]

// 遍历结果为：
Vue.options.components = {}
Vue.options.directives = {}
Vue.options.filters = {}
```

接着执行了 `Vue.options._base = Vue`；

最后通过 `extend(Vue.options.components, builtInComponents) `把一些内置组件扩展到 `Vue.options.components `上，Vue 的内置组件目前有 <keep-alive>、<transition> 和 <transition-group> 组件，这也就是为什么我们在其它组件中使用 <keep-alive> 组件不需要注册的原因，后续详细讲解。

回到 `mergeOptions` 这个函数，它的定义在 `src/core/util/options.js` 中：

```js
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
): Object {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child)
  }

  if (typeof child === 'function') {
    child = child.options
  }

  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm)
    }
    if (child.mixins) {
      for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options = {}
  let key
  for (key in parent) {
    mergeField(key)
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
  function mergeField (key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

主要功能就是把 parent 和 child 这两个对象根据一些合并策略，合并成一个新对象并返回。比较核心的几步，先递归把 extends 和 mixins 合并到 parent 上，然后遍历 parent，调用 mergeField，然后再遍历 child，如果 key 不在 parent 的自身属性上，则调用 mergeField

其中，mergeField 函数，它对不同的 key 有着不同的合并策略。举例来说，对于生命周期函数，它的合并策略是这样的：

```js
function mergeHook (
  parentVal: ?Array<Function>,
  childVal: ?Function | ?Array<Function>
): ?Array<Function> {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(hook => {
  strats[hook] = mergeHook
})
```

其中的 LIFECYCLE_HOOKS 的定义在 src/shared/constants.js 中：

```js
export const LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured'
]

```

这里定义了 Vue.js 所有的钩子函数名称，所以对于钩子函数，他们的合并策略都是 mergeHook 函数。
而nergeHook用了一个多层 3 元运算符，逻辑就是如果不存在 childVal ，就返回 parentVal；否则再判断是否存在 parentVal，如果存在就把 childVal 添加到 parentVal 后返回新数组；否则返回 childVal 的数组。所以回到 mergeOptions 函数，一旦 parent 和 child 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。
其他属性的内容在src/core/util/options
通过执行 mergeField 函数，把合并后的结果保存到 options 对象中，最终返回它。
因此，在我们当前这个 case 下，执行完如下合并后：

```js
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

vm.$options 的值差不多是如下这样：

```js
vm.$options = {
  components: { },
  created: [
    function created() {
      console.log('parent created')
    }
  ],
  directives: { },
  filters: { },
  _base: function Vue(options) {
    // ...
  },
  el: "#app",
  render: function (h) {
    //...
  }
}
```

#### 3.3.2 组件场景

组件的构造函数是通过 Vue.extend 继承自 Vue 的，先回顾一下这个过程，代码定义在 src/core/global-api/extend.js 中：

```js
/**
 * Class inheritance
 */
Vue.extend = function (extendOptions: Object): Function {
  // ...
  Sub.options = mergeOptions(
    Super.options,
    extendOptions
  )

  // ...
  // keep a reference to the super options at extension time.
  // later at instantiation we can check if Super's options have
  // been updated.
  Sub.superOptions = Super.options
  Sub.extendOptions = extendOptions
  Sub.sealedOptions = extend({}, Sub.options)

  // ...
  return Sub
}
```

我们只保留关键逻辑，这里的 `extendOptions` 对应的就是前面定义的组件对象，它会和 Vue.options 合并到 Sub.opitons 中。

接下来我们再回忆一下子组件的初始化过程，代码定义在` src/core/vdom/create-component.js` 中：

```js
export function createComponentInstanceForVnode (
  vnode: any, // we know it's MountedComponentVNode but flow doesn't
  parent: any, // activeInstance in lifecycle state
): Component {
  const options: InternalComponentOptions = {
    _isComponent: true,
    _parentVnode: vnode,
    parent
  }
  // ...
  return new vnode.componentOptions.Ctor(options)
}
```

这里的 `vnode.componentOptions.Ctor` 就是指向 `Vue.extend` 的返回值 Sub， 所以 执行 n`ew vnode.componentOptions.Ctor(options) `接着执行 this._init(options)，因为 `options._isComponent` 为 true，那么合并 options 的过程走到了 `initInternalComponent(vm, options)` 逻辑。在 `src/core/instance/init.js `中：

```js
export function initInternalComponent (vm: Component, options: InternalComponentOptions) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}
```

initInternalComponent 方法首先执行 const opts = vm.$options = Object.create(vm.constructor.options)，这里的 vm.constructor 就是子组件的构造函数 Sub，相当于 vm.$options = Object.create(Sub.options)。
接着又把实例化子组件传入的子组件父 VNode 实例 parentVnode、子组件的父 Vue 实例 parent 保存到 vm.$options 中，另外还保留了 parentVnode 配置中的如 propsData 等其它的属性。
这么看来，initInternalComponent 只是做了简单一层对象赋值，并不涉及到递归、合并策略等复杂逻辑。
因此，执行完成后

```js
initInternalComponent(vm, options)
```

Vm.$options的值大致为：

```js
vm.$options = {
  parent: Vue /*父Vue实例*/,
  propsData: undefined,
  _componentTag: undefined,
  _parentVnode: VNode /*父VNode实例*/,
  _renderChildren:undefined,
  __proto__: {
    components: { },
    directives: { },
    filters: { },
    _base: function Vue(options) {
        //...
    },
    _Ctor: {},
    created: [
      function created() {
        console.log('parent created')
      }, function created() {
        console.log('child created')
      }
    ],
    mounted: [
      function mounted() {
        console.log('child mounted')
      }
    ],
    data() {
       return {
         msg: 'Hello Vue'
       }
    },
    template: '<div>{{msg}}</div>'
  }
}
```

#### 3.3.3 总结

至此，Vue 初始化阶段对于 options 的合并过程就介绍完了，我们需要知道对于 options 的合并有 2 种方式，子组件初始化过程通过 `initInternalComponent` 方式要比外部初始化 Vue 通过 `mergeOptions` 的过程要快，合并完的结果保留在 `vm.$options` 中。

纵观一些库、框架的设计几乎都是类似的，自身定义了一些默认配置，同时又可以在初始化阶段传入一些定义配置，然后去 merge 默认配置，来达到定制化不同需求的目的，这个思路是值得借鉴的。

### 3.4 生命周期

每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue生命周期.png" alt="vue生命周期" style="zoom:50%;" />

在实际项目开发过程中，会非常频繁地和 Vue 组件的生命周期打交道，接下来我们就从源码的角度来看一下这些生命周期的钩子函数是如何被执行的。

源码中最终执行生命周期的函数都是调用 callHook 方法，它的定义在 `src/core/instance/lifecycle` 中：

```js
export function callHook (vm: Component, hook: string) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget()
  const handlers = vm.$options[hook]
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm)
      } catch (e) {
        handleError(e, vm, `${hook} hook`)
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  popTarget()
}
```

callHooks根据传入的字符串 hook，去拿到 `vm.$options[hook]` 对应的回调函数数组，然后遍历执行，执行的时候把 vm 作为函数执行的上下文。

在上一节中，我们详细地介绍了 Vue.js 合并 options 的过程，各个阶段的生命周期的函数也被合并到 `vm.$options` 里，并且是一个数组。因此 `callhook` 函数的功能就是调用某个生命周期钩子注册的所有回调函数。

了解了生命周期的执行方式后，接下来我们会具体介绍每一个生命周期函数它的调用时机。

#### 3.4.1 beforeCreate & created

`beforeCreate` 和 `created` 函数都是在实例化 Vue 的阶段，在 _init 方法中执行的，它的定义在 `src/core/instance/init.js` 中：

```js
Vue.prototype._init = function (options?: Object) {
  // ...
  initLifecycle(vm)
  initEvents(vm)
  initRender(vm)
  callHook(vm, 'beforeCreate')
  initInjections(vm) // resolve injections before data/props
  initState(vm)
  initProvide(vm) // resolve provide after data/props
  callHook(vm, 'created')
  // ...
}
```

可以看到 `beforeCreate` 和 `created` 的钩子调用是在 `initState` 的前后，initState 的作用是初始化 props、data、methods、watch、computed 等属性，之后我们会详细分析。那么显然 beforeCreate 的钩子函数中就不能获取到 props、data 中定义的值，也不能调用 methods 中定义的函数。

在这俩个钩子函数执行的时候，并没有渲染 DOM，所以我们也不能够访问 DOM，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问 props、data 等数据的话，就需要使用 created 钩子函数。

#### 3.4.2 beforeMount & mounted

`beforeMount` 钩子函数发生在 `mount`，也就是 DOM 挂载之前，它的调用时机是在 `mountComponent` 函数中，定义在 `src/core/instance/lifecycle.js` 中：

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  // ...
  callHook(vm, 'beforeMount')

  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

在执行 vm._render() 函数渲染 VNode 之前，执行了 beforeMount 钩子函数，在执行完 vm._update()把 VNode patch 到真实 DOM 后，执行 mounted 钩子。注意，这里对 mounted 钩子函数执行有一个判断逻辑，vm.$vnode 如果为 null，则表明这不是一次组件的初始化过程，而是我们通过外部 new Vue 初始化过程。那么对于组件，它的 mounted 时机在哪儿呢？
之前我们提到过，组件的 VNode patch 到 DOM 后，会执行 invokeInsertHook 函数，把 insertedVnodeQueue 里保存的钩子函数依次执行一遍，它的定义在 src/core/vdom/patch.js 中：

```js
function invokeInsertHook (vnode, queue, initial) {
  // delay insert hooks for component root nodes, invoke them after the
  // element is really inserted
  if (isTrue(initial) && isDef(vnode.parent)) {
    vnode.parent.data.pendingInsert = queue
  } else {
    for (let i = 0; i < queue.length; ++i) {
      queue[i].data.hook.insert(queue[i])
    }
  }
}
```

该函数会执行 insert 这个钩子函数，对于组件而言，insert 钩子函数的定义在 `src/core/vdom/create-component.js` 中的 `componentVNodeHooks` 中：

```js
const componentVNodeHooks = {
  // ...
  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    // ...
  },
}
```

我们可以看到，每个子组件都是在这个钩子函数中执行 `mounted` 钩子函数，并且我们之前分析过，`insertedVnodeQueue` 的添加顺序是先子后父，所以对于同步渲染的子组件而言，`mounted` 钩子函数的执行顺序也是先子后父。

#### 3.4.3 beforeUpdate & Updated

`beforeUpdate` 和 `updated` 的钩子函数执行时机都应该是在数据更新的时候，到目前为止，我们还没有分析 Vue 的数据双向绑定、更新相关，后续会详细介绍。

`beforeUpdate` 的执行时机是在渲染 Watcher 的 before 函数中，我们刚才提到过：

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  // ...

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  // ...
}

```

注意这里有个判断，也就是在组件已经 mounted 之后，才会去调用这个钩子函数。
update 的执行时机是在flushSchedulerQueue 函数调用的时候，它的定义在 src/core/observer/scheduler.js 中：

```js
function flushSchedulerQueue () {
  // ...
  // 获取到 updatedQueue
  callUpdatedHooks(updatedQueue)
}

function callUpdatedHooks (queue) {
  let i = queue.length
  while (i--) {
    const watcher = queue[i]
    const vm = watcher.vm
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated')
    }
  }
}
```

后续详细讲到具体的响应式更新后再讲解；

#### 3.4.4 beforeDestroy & destroy

`beforeDestroy` 和 `destroyed` 钩子函数的执行时机在组件销毁的阶段，组件的销毁过程之后会详细介绍，最终会调用 `$destroy`方法，它的定义在 `src/core/instance/lifecycle.js `中：

```js
Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // remove self from parent
    const parent = vm.$parent
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    callHook(vm, 'destroyed')
    // turn off all instance listeners.
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }

```

`beforeDestroy` 钩子函数的执行时机是在 `$destroy` 函数执行最开始的地方，接着执行了一系列的销毁动作，包括从 `parent` 的 `$children` 中删掉自身，删除 `watcher`，当前渲染的 VNode 执行销毁钩子函数等，执行完毕后再调用 `destroy` 钩子函数。

在 $destroy 的执行过程中，它又会执行 `vm.__patch__(vm._vnode, null) `触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 destroy 钩子函数执行顺序是先子后父，和 mounted 过程一样。

#### 3.4.5 activated & deactivated

后续讲到`Keep-alive`时详细讲解。

### 3.5 组件注册

在 Vue.js 中，除了它内置的组件如 `keep-alive、``component`、`transition`、`transition-group` 等，其它用户自定义组件在使用前必须注册。很多同学在开发过程中可能会遇到如下报错信息：

```js
'Unknown custom element: <xxx> - did you register the component correctly?
 For recursive components, make sure to provide the "name" option.'
```

一般报这个错的原因都是我们使用了未注册的组件。Vue.js 提供了 2 种组件的注册方式，全局注册和局部注册。接下来我们从源码分析的角度来分析这两种注册方式。

#### 3.5.1 全局注册

要注册一个全局组件，可以使用 `Vue.component(tagName, options)`。例如：

```js
Vue.component('my-component', {
  // 选项
})
```

`Vue.component `的定义过程发生在最开始初始化 Vue 的全局函数的时候，代码在 s`rc/core/global-api/assets.js `中：

```js
import { ASSET_TYPES } from 'shared/constants'
import { isPlainObject, validateComponentName } from '../util/index'

export function initAssetRegisters (Vue: GlobalAPI) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(type => {
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && type === 'component') {
          validateComponentName(id)
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id
          definition = this.options._base.extend(definition)
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition }
        }
        this.options[type + 's'][id] = definition
        return definition
      }
    }
  })
}
```

函数首先遍历 `ASSET_TYPES`，得到 type 后挂载到 Vue 上 。ASSET_TYPES 的定义在 `src/shared/constants.js` 中：

```js
export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]
```

所以实际上 Vue 是初始化了 3 个全局函数，并且如果 type 是 `component` 且 definition 是一个对象的话，通过 `this.opitons._base.extend`， 相当于 `Vue.extend` 把这个对象转换成一个继承于 Vue 的构造函数，最后通过 `this.options[type + 's'][id] = definition` 把它挂载到 `Vue.options.components `上。

由于我们每个组件的创建都是通过 `Vue.extend` 继承而来，我们之前分析过在继承的过程中有这么一段逻辑：

```js
Sub.options = mergeOptions(
  Super.options,
  extendOptions
)
```

也就是说它会把 Vue.options 合并到 Sub.options，也就是组件的 options 上， 然后在组件的实例化阶段，会执行 `merge options` 逻辑，把 `Sub.options.components` 合并到 `vm.$options.components` 上。

然后在创建 vnode 的过程中，会执行 _createElement 方法，我们再来回顾一下这部分的逻辑，它的定义在 `src/core/vdom/create-element.js` 中：

```js
export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  // ...
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
  // ...
}
```

这里有一个判断逻辑 `isDef(Ctor = resolveAsset(context.$options, 'components', tag))`，先来看一下 `resolveAsset` 的定义，在 `src/core/utils/options.js` 中：

```js
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
export function resolveAsset (
  options: Object,
  type: string,
  id: string,
  warnMissing?: boolean
): any {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  const assets = options[type]
  // check local registration variations first
  if (hasOwn(assets, id)) return assets[id]
  const camelizedId = camelize(id)
  if (hasOwn(assets, camelizedId)) return assets[camelizedId]
  const PascalCaseId = capitalize(camelizedId)
  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]
  // fallback to prototype chain
  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    )
  }
  return res
}
```

先通过 `const assets = options[type] `拿到 assets，然后再尝试拿 assets[id]，这里有个顺序，先直接使用 id 拿，如果不存在，则把 id 变成驼峰的形式再拿，如果仍然不存在则在驼峰的基础上把首字母再变成大写的形式再拿，如果仍然拿不到则报错。这样说明了我们在使用 `Vue.component(id, definition) `全局注册组件的时候，id 可以是连字符、驼峰或首字母大写的形式。

那么回到我们的调用 `resolveAsset(context.$options, 'components', tag)`，即拿 `vm.$options.components[tag]`，这样我们就可以在 resolveAsset 的时候拿到这个组件的构造函数，并作为 `createComponent` 的钩子的参数。

#### 3.5.2 局部注册

Vue.js 也同样支持局部注册，我们可以在一个组件内部使用 components 选项做组件的局部注册，例如

```js
import HelloWorld from './components/HelloWorld'

export default {
  components: {
    HelloWorld
  }
}
```

在组件的 Vue 的实例化阶段有一个合并 `option` 的逻辑，之前我们也分析过，所以就把 `components` 合并到 `vm.$options.components` 上，这样我们就可以在 `resolveAsset` 的时候拿到这个组件的构造函数，并作为 `createComponent` 的钩子的参数。

注意，局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 `Vue.options` 下，所以在所有组件创建的过程中，都会从全局的` Vue.options.components` 扩展到当前组件的 `vm.$options.components`下，这就是全局注册的组件能被任意使用的原因。

### 3.6 异步组件

在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，如下：

```js
Vue.component('async-example', function (resolve, reject) {
   // 这个特殊的 require 语法告诉 webpack
   // 自动将编译后的代码分割成不同的块，
   // 这些块将通过 Ajax 请求自动下载。
   require(['./my-async-component'], resolve)
})
```

我们可以看到，Vue 注册的组件不再是一个对象，而是一个工厂函数，函数有两个参数 resolve 和 reject，函数内部用 setTimout 模拟了异步，实际使用可能是通过动态请求异步组件的 JS 地址，最终通过执行 resolve 方法，它的参数就是我们的异步组件对象。

上一节我们分析了组件的注册逻辑，由于组件的定义并不是一个普通对象，所以不会执行 Vue.extend 的逻辑把它变成一个组件的构造函数，但是它仍然可以执行到 createComponent 函数，我们再来对这个函数做回顾，它的定义在 `src/core/vdom/create-component/js` 中：

```js
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void {
  if (isUndef(Ctor)) {
    return
  }

  const baseCtor = context.$options._base

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor)
  }
  
  // ...

  // async component
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }
}
```

由于我们这个时候传入的 Ctor 是一个函数，那么它也并不会执行 Vue.extend 逻辑，因此它的 cid 是 undefiend，进入了异步组件创建的逻辑。这里首先执行了 Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) 方法，它的定义在 `src/core/vdom/helpers/resolve-async-component.js` 中

```js
export function resolveAsyncComponent (
  factory: Function,
  baseCtor: Class<Component>,
  context: Component
): Class<Component> | void {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context)
  } else {
    const contexts = factory.contexts = [context]
    let sync = true

    const forceRender = () => {
      for (let i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate()
      }
    }

    const resolve = once((res: Object | Class<Component>) => {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor)
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender()
      }
    })

    const reject = once(reason => {
      process.env.NODE_ENV !== 'production' && warn(
        `Failed to resolve async component: ${String(factory)}` +
        (reason ? `\nReason: ${reason}` : '')
      )
      if (isDef(factory.errorComp)) {
        factory.error = true
        forceRender()
      }
    })

    const res = factory(resolve, reject)

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject)

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor)
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor)
          if (res.delay === 0) {
            factory.loading = true
          } else {
            setTimeout(() => {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true
                forceRender()
              }
            }, res.delay || 200)
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(() => {
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? `timeout (${res.timeout}ms)`
                  : null
              )
            }
          }, res.timeout)
        }
      }
    }

    sync = false
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}
```

这里面核心处理了三种异步组件的创建方法，除了上述例子，还有两种

```js
Vue.component(
  'async-webpack-example',
  // 该 `import` 函数返回一个 `Promise` 对象。
  () => import('./my-async-component')
)

const AsyncComp = () => ({
  // 需要加载的组件。应当是一个 Promise
  component: import('./MyComp.vue'),
  // 加载中应当渲染的组件
  loading: LoadingComp,
  // 出错时渲染的组件
  error: ErrorComp,
  // 渲染加载中组件前的等待时间。默认：200ms。
  delay: 200,
  // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity
  timeout: 3000
})
Vue.component('async-example', AsyncComp)
```

接下来依次分析

#### 3.6.1 普通的一步组件

针对普通函数的情况，前面几个 if 判断可以忽略，它们是为高级组件所用，进入实际加载逻辑，定义了 forceRender、resolve 和 reject 函数，注意 resolve 和 reject 函数用 once 函数做了一层包装，它的定义在 src/shared/util.js 中：

```js
/**
 * Ensure a function is called only once.
 */
export function once (fn: Function): Function {
  let called = false
  return function () {
    if (!called) {
      called = true
      fn.apply(this, arguments)
    }
  }
}
```

once 逻辑非常简单，传入一个函数，并返回一个新函数，它非常巧妙地利用闭包和一个标志位保证了它包装的函数只会执行一次，也就是确保 `resolve` 和 `reject` 函数只执行一次。

接下来执行 `const res = factory(resolve, reject) `逻辑，这块儿就是执行我们组件的工厂函数，同时把 `resolve` 和 `reject` 函数作为参数传入，组件的工厂函数通常会先发送请求去加载我们的异步组件的 JS 文件，拿到组件定义的对象 res 后，执行 resolve(res) 逻辑，它会先执行 `factory.resolved = ensureCtor(res, baseCtor)`

```js
function ensureCtor (comp: any, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}
```

这个函数目的是为了保证能找到异步组件 JS 定义的组件对象，并且如果它是一个普通对象，则调用 Vue.extend 把它转换成一个组件的构造函数。
resolve 逻辑最后判断了 sync，显然我们这个场景下 sync 为 false，那么就会执行 forceRender 函数，它会遍历 factory.contexts，拿到每一个调用异步组件的实例 vm, 执行 vm.$forceUpdate()方法，它的定义在 src/core/instance/lifecycle.js 中：

```js
  Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {
      vm._watcher.update()
    }
  }
```

`$forceUpdate` 调用渲染 watcher 的 update 方法，让渲染 watcher 对应的回调函数执行，也就是触发了组件的重新渲染。之所以这么做是因为 Vue 通常是数据驱动视图重新渲染，但是在整个异步组件加载过程中是没有数据发生变化的，所以通过执行 $forceUpdate 可以强制组件重新渲染一次。

#### 3.6.2 promise异步组件

```js
Vue.component(
  'async-webpack-example',
  // 该 `import` 函数返回一个 `Promise` 对象。
  () => import('./my-async-component')
)
```

webpack 2+ 支持了异步加载的语法糖：`() => import('./my-async-component')`，当执行完 `res = factory(resolve, reject)`，返回的值就是 import('./my-async-component') 的返回值，它是一个 Promise 对象。接着进入 if 条件，又判断了 `typeof res.then === 'function')`，条件满足，执行：

```js
if (isUndef(factory.resolved)) {
  res.then(resolve, reject)
}
```

当组件异步加载成功后，执行 `resolve`，加载失败则执行 `reject`，这样就非常巧妙地实现了配合 webpack 2+ 的异步加载组件的方式（Promise）加载异步组件。

#### 3.6.3 高级异步组件

由于异步加载组件需要动态加载 JS，有一定网络延时，而且有加载失败的情况，所以通常我们在开发异步组件相关逻辑的时候需要设计 loading 组件和 error 组件，并在适当的时机渲染它们。Vue.js 2.3+ 支持了一种高级异步组件的方式，它通过一个简单的对象配置，帮你搞定 loading 组件和 error 组件的渲染时机，你完全不用关心细节，非常方便。接下来我们就从源码的角度来分析高级异步组件是怎么实现的。

```js
const AsyncComp = () => ({
  // 需要加载的组件。应当是一个 Promise
  component: import('./MyComp.vue'),
  // 加载中应当渲染的组件
  loading: LoadingComp,
  // 出错时渲染的组件
  error: ErrorComp,
  // 渲染加载中组件前的等待时间。默认：200ms。
  delay: 200,
  // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity
  timeout: 3000
})
Vue.component('async-example', AsyncComp)
```

高级异步组件的初始化逻辑和普通异步组件一样，也是执行 resolveAsyncComponent，当执行完 res = factory(resolve, reject)，返回值就是定义的组件对象，显然满足 else if (isDef(res.component) && typeof res.component.then === 'function') 的逻辑，接着执行 res.component.then(resolve, reject)，当异步组件加载成功后，执行 resolve，失败执行 reject。
因为异步组件加载是一个异步过程，它接着又同步执行了如下逻辑：

```js
if (isDef(res.error)) {
  factory.errorComp = ensureCtor(res.error, baseCtor)
}

if (isDef(res.loading)) {
  factory.loadingComp = ensureCtor(res.loading, baseCtor)
  if (res.delay === 0) {
    factory.loading = true
  } else {
    setTimeout(() => {
      if (isUndef(factory.resolved) && isUndef(factory.error)) {
        factory.loading = true
        forceRender()
      }
    }, res.delay || 200)
  }
}

if (isDef(res.timeout)) {
  setTimeout(() => {
    if (isUndef(factory.resolved)) {
      reject(
        process.env.NODE_ENV !== 'production'
        ? `timeout (${res.timeout}ms)`
        : null
      )
    }
  }, res.timeout)
}
```

先判断res.error 是否定义了 error 组件，如果有的话则赋值给 factory.errorComp。 接着判断 res.loading 是否定义了 loading 组件，如果有的话则赋值给 factory.loadingComp，如果设置了 res.delay 且为 0，则设置 factory.loading = true，否则延时 delay 的时间执行

```js
if (isUndef(factory.resolved) && isUndef(factory.error)) {
    factory.loading = true
    forceRender()
}
```

最后判断 res.timeout，如果配置了该项，则在 res.timout 时间后，如果组件没有成功加载，执行 reject。
在 resolveAsyncComponent 的最后有一段逻辑：

```js
sync = false
return factory.loading
  ? factory.loadingComp
  : factory.resolved
```

如果 delay 配置为 0，则这次直接渲染 loading 组件，否则则延时 delay 执行 forceRender，那么又会再一次执行到 `resolveAsyncComponent`。

那么这时候我们有几种情况，按逻辑的执行顺序，对不同的情况做判断：

##### 3.6.3.1 异步组件加载失败

当异步组件加载失败，会执行reject函数：

```js
const reject = once(reason => {
  process.env.NODE_ENV !== 'production' && warn(
    `Failed to resolve async component: ${String(factory)}` +
    (reason ? `\nReason: ${reason}` : '')
  )
  if (isDef(factory.errorComp)) {
    factory.error = true
    forceRender()
  }
})
```

这个时候会把 factory.error 设置为 true，同时执行 `forceRender()`再次执行到 `resolveAsyncComponent`：

```js
if (isTrue(factory.error) && isDef(factory.errorComp)) {
  return factory.errorComp
}
```

那么这个时候就返回 `factory.errorComp`，直接渲染 `error` 组件。

##### 3.6.3.2 异步组件加载成功

当异步组件加载成功，会执行resolve函数

```js
const resolve = once((res: Object | Class<Component>) => {
  factory.resolved = ensureCtor(res, baseCtor)
  if (!sync) {
    forceRender()
  }
})
```

首先把加载结果缓存到 `factory.resolved`中，这个时候因为 sync 已经为 false，则执行 `forceRender()`再次执行到 `resolveAsyncComponent`：

```js
if (isDef(factory.resolved)) {
  return factory.resolved
}
```

那么这个时候直接返回 factory.resolved,渲染成功加载的组件

##### 3.6.3.3 异步组件加载中

如果异步组件加载中并未返回，这时候会走到这个逻辑：

```js
if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
  return factory.loadingComp
}
```

那么则会返回 `factory.loadingComp`，渲染 `loading` 组件。

##### 3.6.3.4 异步组件加载超时

如果超时，则走到了 `reject` 逻辑，之后逻辑和加载失败一样，渲染 error 组件。

#### 3.6.4 异步组件patch

回到createComponent的逻辑：

```js
Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)
if (Ctor === undefined) {
  return createAsyncPlaceholder(
    asyncFactory,
    data,
    context,
    children,
    tag
  )
}
```

如果是第一次执行 resolveAsyncComponent，除非使用高级异步组件 0 delay 去创建了一个 loading 组件，否则返回是 undefiend，接着通过 createAsyncPlaceholder 创建一个注释节点作为占位符。它的定义在 src/core/vdom/helpers/resolve-async-components.js中：

```js
export function createAsyncPlaceholder (
  factory: Function,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag: ?string
): VNode {
  const node = createEmptyVNode()
  node.asyncFactory = factory
  node.asyncMeta = { data, context, children, tag }
  return node
}
```

实际上就是就是创建了一个占位的注释 `VNode`，同时把 `asyncFactory` 和 `asyncMeta` 赋值给当前 `vnode`。

当执行 `forceRender` 的时候，会触发组件的重新渲染，那么会再一次执行 `resolveAsyncComponent`，这时候就会根据不同的情况，可能返回 loading、error 或成功加载的异步组件，返回值不为 undefined，因此就走正常的组件 render、patch 过程。

#### 3.6.5 总结

通过上面部分，我们知道了 3 种异步组件的实现方式，它实现了 `loading`、`resolve`、`reject`、`timeout` 4 种状态。异步组件实现的本质是 2 次渲染，除了 `0 delay` 的高级异步组件第一次直接渲染成 `loading` 组件外，其它都是第一次渲染生成一个注释节点，当异步获取组件成功后，再通过 `forceRender` 强制重新渲染，这样就能正确渲染出我们异步加载的组件了。

# vue3新特性&源码解析（1/3）

Object.defineProperty重新定义getter和setter，为什么换proxy代理

1.对于数组长度变化

2.在对象上增删元素的操作

3.数组方法push, pop,unshift,shift

4.想支持响应式的属性$set

https://www.yuque.com/lpldplws/web/gdw840?singleDoc# 《Vue3新特性&源码解析（1/3）》 密码：mmo8

## 1.课程目标

对比Vue2，对Vue3的新特性进行学习，掌握Vue3的关键技术点，以及能够使用vue3实现组件的开发；

## 2. 课程大纲

- vue3和vue2响应式原理的对比
- vue3新特性

## 3.vue2和vue3的对比

### 3.1 响应式原理

Object.defineProperty VS Proxy

我们知道，Vue2的响应式原理是基于Object.defineProperty的方法重新定义对象的getter和setter，而Vue3是基于Proxy代理对象，拦截对象属性的访问与赋值过程。差异在于，前者并不能对诸如数组长度变化、增删元素操作已经对对象新增属性进行感知，而在Vue层面也不得不重新一些数组方法（push、pop、unshift、shift等），动态的添加响应式属性，也要使用$set方法。而Proxy则完美的解决了这些问题，不过对于不支持Proxy对象的浏览器（诸如IE，虽然已经退出历史舞台，但目前占比还是很大），如果要使用Vue3，还需要降级兼容。

- 通过Object.defineProperty中的get与set属性实现响应式

  ```js
  // 假设我们在data函数中返回的数据为initData
  const initData = { value: 1 };
  
  // 基于initData创建响应式的代理对象data
  const data = {};
  
  Object.keys(initData).forEach(key => {
    Object.defineProperty(data, key, {
      get() {
        // 此处依赖收集
        console.log('访问了', key);
        return initData[key];
      },
      set(v) {
        // 此处进行了回调更新
        console.log('修改了', key);
        initData[key] = v;
      }
    });
  });
  
  // data.value
  // 访问了value
  // 1
  // data.value = 2
  // 修改了value
  // 2
  // data
  // {} 因为只是代理，不会对data进行设置
  // initData.value2 = 2
  // 2
  // data.value2
  // undefined 未在初始时设置，无法进行依赖收集
  ```

从上述代码可以看出，initData动态添加的属性，并不能被观测到，这也是Vue.set存在的原因；

Q：Vue.set是如何实现的

A：

set 方法主要作用是向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，对象不能是 Vue 实例，或者 Vue 实例的根数据对象

Vue.set( target, key, value ) / this.$set( target, key, value )

- target：要更改的数据源(可以是对象或者数组)
- key：要更改的具体数据，或者新增的属性名
- value ：重新赋的值

set 方法会对参数中的 target 进行类型判断

1. 如果是 undefined 、null 、基本数据类型，直接报错；
2. 如果为数组，取当前数组长度与 key 这两者的最大值作为数组的新长度，然后使用数组的 splice 方法将传入的索引 key 对应的 val 值添加进数组。target 在 observe 的时候，原型链被修改了， splice 方法也已经被重写了，触发之后会再次遍历数组，进行数据劫持，也就是说当使用 splice 方法向数组内添加元素时，该元素会自动被变成响应式的；
3. 如果为对象，会先判断 key 值是否存在于对象中，如果在，则直接替换 value。如果不在，就判断 target 是不是响应式对象（其实就是判断它是否有 __ob__ 属性），接着判断如果它是不是 Vue 实例，或者是 Vue 实例的根数据对象，如果是则抛出警告并退出程序。如果 target 不是响应式对象，就直接给 target 的 key 赋值，如果 target 是响应式对象，就调用 defineReactive 将新属性的值添加到 target 上，并进行依赖收集，更新视图更新；

```js
// example:
this.$set(data, a, 1);

// 源码
function set(target: Array<any> | Object, key: any, val: any): any {
  // isUndef 是判断 target 是不是等于 undefined 或者 null 。
  // isPrimitive 是判断 target 的数据类型是不是 string、number、symbol、boolean 中的一种
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }

  // 数组的处理
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }

  // 对象，并且该属性原来已存在于对象中，则直接更新
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }

  // vue给响应式对象(比如 data 里定义的对象)都加了一个 __ob__ 属性，
  // 如果一个对象有这个 __ob__ 属性，那么就说明这个对象是响应式对象，修改对象已有属性的时候就会触发页面渲染
  // 非 data 里定义的就不是响应式对象。
  const ob = (target: any).__ob__

  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }

  // 不是响应式对象
  if (!ob) {
    target[key] = val
    return val
  }

  // 是响应式对象，进行依赖收集
  defineReactive(ob.value, key, val)

  // 触发更新视图
  ob.dep.notify()
  return val
}
```

主要根据ob.dep.notify()，这个里面放着订阅者模式里面的订阅者，通过notify来通知订阅者做处理

- Proxy 可以观测到动态添加的属性的变化，以此实现响应式；

  课上不做过多介绍，详情见MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy

Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程；

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”；

ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。

```js
var proxy = new Proxy(target, handler);
```

Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。

Example：

1. get：用来初始化对象或获取值时，设置自定义前置检测

   ```js
   var proxy = new Proxy({}, {
     get: function(target, propKey) {
       return 35;
     }
   });
   
   let obj = Object.create(proxy);
   obj.time // 35
   
   var person = {
     name: "张三"
   };
   
   var proxy = new Proxy(person, {
     get: function(target, propKey) {
       if (propKey in target) {
         return target[propKey];
       } else {
         throw new ReferenceError("Prop name \"" + propKey + "\" does not exist.");
       }
     }
   });
   
   proxy.name // "张三"
   proxy.age // Uncaught ReferenceError: Prop name "age" does not exist.
   ```

2. Set：设置值时逻辑校验

   ```js
   let validator = {
     set: function(obj, prop, value) {
       if (prop === 'age') {
         if (!Number.isInteger(value)) {
           throw new TypeError('The age is not an integer');
         }
         if (value > 200) {
           throw new RangeError('The age seems invalid');
         }
       }
   
       // 对于满足条件的 age 属性以及其他属性，直接保存
       obj[prop] = value;
       return true;
     }
   };
   
   let person = new Proxy({}, validator);
   
   person.age = 100;
   
   person.age // 100
   person.age = 'young' // 报错
   person.age = 300 // 报错
   
   ```

   ```js
   const initData = { value: 1 };
   
   const proxy = new Proxy(initData, {
     get: function (target, key, receiver) {
       // 此处进行依赖收集
       console.log('访问了', key);
       return Reflect.get(target, key, receiver);
     },
     set: function (target, key, value, receiver) {
       // 此处执行回调更新
       console.log('修改了', key);
       return Reflect.set(target, key, value, receiver);
     }
   });
   
   // proxy.value
   // 访问了value
   // 1
   // proxy.value = 2
   // 修改了value
   // 2
   // proxy.value2 = 2
   // 修改了value2
   // 2
   // initData.value3 = 3
   // proxy.value3
   // 访问了value3
   // 3
   ```

### 3.2 vue3新特性

准备工作：安装vue3

```js
$ npm init vite-app <project-name>
$ cd <project name>
$ npm i -S
$ npm run dev

或者

$ yarn create vite-app <project-name>
$ cd <project name>
$ yarn
$ yarn dev
```

- 可以声明在入口文件内声明多个实例，实例间错误隔离，若没有阻断性错误，不会影响其他实例；
- 更好的支持单测；
- 支持不同人员并行开发；

```js
// Vue2
// 所有数据定义在data中，方法定义在methods中的，并且使用this来调用对应的数据和方法
new Vue({
});

// Vue3
createApp(App).mount('#app);
createApp(MyApp).mount('#app);
```

#### 3.2.1 Composition API

先来看个vue2的例子：

```js
<template>
  <div class="homePage">
    <p>count: {{ count }}</p>   
    <p>倍数： {{ multiple }}</p>        
    <div>
      <button style="margin-right: 10px" @click="increase">加1</button>
      <button @click="decrease">减一</button>    
    </div>      
  </div>
</template>
<script>
export default {
  data() {
    return { count: 0 };
  },
  computed: {
    multiple() {
      return 2 * this.count;
    },
  },
  methods: {
    increase() {
      this.count++;
    },
    decrease() {
      this.count--;
    },
  },
};
</script>
```

针对count的加减以及显示倍数， 就需要分别在 data、methods、computed 中进行操作，一个小的需求经常会导致在data、methods、computed中进行操作，随着业务复杂程度提升，其中内容会随之增加；

在vue2.x 版本给出的解决方案就是 Mixin, 但是使用 Mixin 也会遇到让人苦恼的问题：

1. 命名冲突问题；
2. 不清楚暴露出来的变量的作用；
3. 逻辑重用到其他 component 经常遇到问题；

 在Vue3.x 就推出了Composition API主要就是为了解决上面的问题，将零散分布的逻辑组合在一起来维护，并且还可以将单独的功能逻辑拆分成单独的文件。

##### 3.2.1.1 setup

setup() 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3 的 Composition API 新特性提供了统一的入口, setup 函数会在 beforeCreate 、created 之前执行, vue3也是取消了这两个钩子，统一用setup代替, 该函数相当于一个生命周期函数，vue中过去的data，methods，watch等全部都用对应的新增api写在setup()函数中

```js
setup(props, context) {
  // Attribute (非响应式对象，等同于 $attrs)
  context.attrs
  // 插槽 (非响应式对象，等同于 $slots)
  context.slots
  // 触发事件 (方法，等同于 $emit)
  context.emit
  // 暴露公共 property (函数)
  context.expose
    
  return {}
}

// example
<!-- MyBook.vue -->
<template>
  <div>{{ collectionName }}: {{ readersNumber }} {{ book.title }}</div>
</template>

<script>
  import { ref, reactive } from 'vue'

  export default {
    props: {
      collectionName: String
    },
    setup(props) {
      const readersNumber = ref(0)
      const book = reactive({ title: 'Vue 3 Guide' })

      // 暴露给 template
      return {
        readersNumber,
        book
      }
    }
  }
</script>
```

- props: 用来接收 props 数据, props 是响应式的，当传入新的 props 时，它将被更新；
- context 用来定义上下文, 上下文对象中包含了一些有用的属性，这些属性在 vue 2.x 中需要通过 this 才能访问到, 在 setup() 函数中无法访问到 this，是个 undefined；
- context 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 context 使用 ES6 解构；
- 返回值: return {}, 返回响应式数据, 模版中需要使用的函数；

注意： 因为 props 是响应式的， 你不能使用 ES6 解构，它会消除 prop 的响应性

```js
<script>
import { defineComponent, reactive, ref, toRefs } from 'vue';
export default defineComponent({
  setup(props, context) {
  
    const { title } = toRefs(props)
    
    console.log(title.value)
    
    return {}
  }
});
</script>
```

如果 title 是可选的 prop，则传入的 props 中可能没有 title 。在这种情况下，toRefs 将不会为 title 创建一个 ref 。你需要使用 toRef 替代它:

```js
<script lang="ts">
import { defineComponent, reactive, toRef, toRefs } from 'vue';
export default defineComponent({
  setup(props, context) {
  
    const { title } = toRef(props, 'title')
    
    console.log(title.value)
    
    return {}
  }
});
</script>
```

##### 3.2.1.2 reactive(),shallowReactive()

- reactive()

函数接收一个普通对象，返回一个响应式的数据对象, 相当于 Vue 2.x 中的 Vue.observable() API，响应式转换是“深层”的——它影响所有嵌套属性。基于proxy来实现，想要使用创建的响应式数据也很简单，创建出来之后，在setup中return出去，直接在template中调用即可；

```js
setup() {
  const person = {
    name: 'xianzao',
    age: 1,
    contacts: {
      phone: 123456789,
    },
  };

  const personReactive = reactive(person);

  // 查看 reactive 实例结构
  console.log('reactive', personReactive);

  // 获取嵌套对象属性
  const contacts = personReactive.contacts;
  // 因为深层响应，所以依然有响应性
  console.log('contacts属性：', contacts);

  // 获取简单类型的属性
  let name = toRef(personReactive.name);

  // name属性是简单类型的，所以失去响应性，如果需要响应式，需要使用toRef(name)
  console.log('name属性：', name);
},
```

- shallowReactive()：创建一个响应式代理，它跟踪其自身属性的响应性shallowReactive生成非递归响应数据，只监听第一层数据的变化，但不执行嵌套对象的深层响应式转换 (暴露原始值)；

  ```js
  const personShallowReactive = shallowReactive(person);
  // 查看 reactive 实例结构
  console.log('shallow reactive', personShallowReactive);
  
  // 获取嵌套对象属性
  const shallowContacts = personShallowReactive.contacts;
  // 因为深层响应，所以依然有响应性
  console.log('shallow contacts属性：', shallowContacts);
  
  // 获取简单类型的属性
  let shallowName = personShallowReactive.name;
  
  // name属性是简单类型的，所以失去响应性，如果需要响应式，需要使用toRef(name)
  console.log('shallow name属性：', shallowName);
  ```

##### 3.2.1.3 ref(),isRef(),toRefs()

- ref() 函数用来根据给定的值创建一个响应式的数据对象，ref() 函数调用的返回值是一个对象，这个对象上只包含一个 value 属性, 只在setup函数内部访问ref函数需要加.value，其用途创建独立的原始值；

```js
<template>
    <div class="mine">
        {{count}} // 10
    </div>
</template>

<script>
import { defineComponent, ref } from 'vue';
export default defineComponent({
  setup() {
    const count = ref<number>(10)
    // 在js 中获取ref 中定义的值, 需要通过value属性
    console.log(count.value);
    return {
       count
    }
   }
});
</script>
```

在reactive对象中访问ref创建的响应式数据

```js
<template>
    <div class="mine">
        {{count}} -{{t}} // 10 -100
    </div>
</template>

<script>
import { defineComponent, reactive, ref, toRefs } from 'vue';
export default defineComponent({
  setup() {
    const count = ref<number>(10)
    const obj = reactive({
      t: 100,
      count
    })
   
    // 通过reactive 来获取ref 的值时,不需要使用.value属性， ref 将被自动解包
    console.log(obj.count); // 10
    console.log(obj.count === count.value); // true
    
    // count 改变时，更新 `obj.count
    count.value = 12
    console.log(count.value) // 12
    console.log(obj.count) // 12
    
    // 反之，修改obj 的count 值 ，ref 也会更新
   obj.count = 20
   console.log(obj.count) // 20
   console.log(count.value) // 20
    
    return {
       ...toRefs(obj)
    }
   }
});
</script>
```

reactive 将解包所有深层的 refs，同时维持 ref 的响应性。当将 ref分配给 reactive property 时，ref 将被自动解包

- isRef()

  用来判断某个值是否为 ref() 创建出来的对象

```js
const count = ref(10);
const user = 'xianzao';

// 判断是否为ref创建出来的
console.log('user is ref? ', isRef(user));
console.log('count is ref? ', isRef(count));
```

- toRefs()

  将 reactive() 创建出来的响应式对象，转换为普通的对象，只不过，这个对象上的每个属性节点，都是 ref() 类型的响应式数据

##### 3.2.1.4 readonly()、isReadonly()、shallowReadonly()

- readonly: 传入ref或 reactive对象,并返回一个原始对象的只读代理,对象内部任何嵌套的属性也都是只读的、 并且是递归只读；
- isReadonly: 检查对象是否是由 readonly 创建的只读对象；

```js
const obj = reactive({
  t: 100,
  count,
});

// 设置obj为readonly
const objOnly = readonly(obj);
console.log('read only obj is: ', objOnly);
// obj.t = 200;
objOnly.t = 200;
console.log('changed obj is: ', obj);
console.log('changed read only obj is: ', objOnly);
console.log('changed obj is read only?: ', isReadonly(obj));
console.log('changed read only obj is read only?: ', isReadonly(objOnly), objOnly.t);
```

Q：如果设置obj.t = 200，那objonly.t是多少？

A：也是200，因为修改的非readonly，设置完readonly后的元素还是reactive的；

- shallowReadonly 作用只处理对象最外层属性的响应式（浅响应式）的只读，但不执行嵌套对象的深度只读转换 (暴露原始值)

```js
// 设置obj为shallowReadOnly
const objShallowOnly = shallowReadonly(obj);
console.log('shallow read only obj is: ', objShallowOnly);
objShallowOnly.t = 200;
objShallowOnly.userInfo.age = 777;
console.log('changed shallow read only obj is:', objShallowOnly);
```

##### 3.2.1.5 computed()、watch()、data

- computed()

  该函数用来创造计算属性，它返回的值是一个ref对象。 里面可以传方法，或者一个对象，对象中包含set()、get()方法；

```js
// 创建只读的计算属性
import { computed, defineComponent, ref } from 'vue';
export default defineComponent({
  setup(props, context) {
    const age = ref(18)

    // 根据 age 的值，创建一个响应式的计算属性 readOnlyAge,它会根据依赖的 ref 自动计算并返回一个新的 ref
    const readOnlyAge = computed(() => age.value++) // 19

    return {
      age,
      readOnlyAge
    }
  }
});
</script>

// 通过set()、get()方法创建一个可读可写的计算属性
<script>
import { computed, defineComponent, ref } from 'vue';
export default defineComponent({
  setup(props, context) {
    const age = ref<number>(18)

    const computedAge = computed({
      get: () => age.value + 1,
      set: value => age.value + value
    })
    // 为计算属性赋值的操作，会触发 set 函数, 触发 set 函数后，age 的值会被更新
    age.value = 100
    return {
      age,
      computedAge
    }
  }
});
</script>
```

- watch()

  watch 函数用来侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行的，也就是说仅在侦听的源数据变更时才执行回调；

```js
// 1. 监听reactive声明的数据源
<script>
import { computed, defineComponent, reactive, toRefs, watch } from 'vue';

export default defineComponent({
  setup(props, context) {
    const state = reactive({ name: 'vue', age: 10 })

    watch(
      () => state.age,
      (age, preAge) => {
        console.log(age); // 100
        console.log(preAge); // 10
      }
    )
    // 修改age 时会触发watch 的回调, 打印变更前后的值
    state.age = 100
    return {
      ...toRefs(state)
    }
  }
});
</script>

// 2. 监听用ref声明的数据源
<script>
import { defineComponent, ref, watch } from 'vue';

export default defineComponent({
  setup(props, context) {
    const age = ref(10);

    watch(age, () => console.log(age.value)); // 100
    
    // 修改age 时会触发watch 的回调, 打印变更后的值
    age.value = 100
    return {
      age
    }
  }
});
</script>

// 3. 同时监听多个值
<script>
import { computed, defineComponent, reactive, toRefs, watch } from 'vue';

export default defineComponent({
  setup(props, context) {
    const state = reactive({ name: 'vue', age: 10 })

    watch(
      [() => state.name, () => state.age],
      ([newName, newAge], [oldName, oldAge]) => {
        console.log(newName);
        console.log(newAge);

        console.log(oldName);
        console.log(oldAge);
      }
    )
    // 修改age 时会触发watch 的回调, 打印变更前后的值, 此时需要注意, 更改其中一个值, 都会执行watch的回调
    state.age = 100
    state.name = 'vue3'
    return {
      ...toRefs(state)
    }
  }
});
</script>

// 4. stop停止监听
// 在 setup() 函数内创建的 watch 监视，会在当前组件被销毁的时候自动停止。
// 如果想要明确地停止某个监视，可以调用 watch() 函数的返回值即可，语法如下：
<script>
import { set } from 'lodash';
import { computed, defineComponent, reactive, toRefs, watch } from 'vue';

export default defineComponent({
  setup(props, context) {
    const state = reactive({ name: 'vue', age: 10 })

    const stop =  watch(
      [() => state.age, () => state.name],
      ([newName, newAge], [oldName, oldAge]) => {
        console.log(newName);
        console.log(newAge);

        console.log(oldName);
        console.log(oldAge);
      }
    )
    // 修改age 时会触发watch 的回调, 打印变更前后的值, 此时需要注意, 更改其中一个值, 都会执行watch的回调
    state.age = 100
    state.name = 'vue3'

    setTimeout(()=> { 
      stop()
      // 此时修改时, 不会触发watch 回调
      state.age = 1000
      state.name = 'vue3-'
    }, 1000) // 1秒之后讲取消watch的监听
    
    return {
      ...toRefs(state)
    }
  }
});
</script>
```

- data

```js
// Vue3中唯一用法
data: {
  return {
    flag: true
  }
}
// Vue2中不推荐使用，但不会报错，但在Vue3中会报错
data: {
  flag: true
}
```

Q：为什么data不能使用一个对象，而是每次都返回一个函数？

A：如果是以对象中的数据返回的话，组件之中会共用同一块内存，在一个组件中修改数据，另一个组件也会受到影响；用函数 return 出去的形式，每次 return 都会alloc新的内存，各个组件中得 data 也就没有任何关系

##### 3.2.1.5 多根节点组件

多根节点允许template标签内直接出现多个子集的标签

类似React包含的<Fragment>，实际不会产生新的标签

#### 3.2.2 生命周期

详情参考官网：https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#beforecreate

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue3lifecycle.svg" alt="vue3lifecycle" style="zoom:50%;" />

新版的生命周期函数，可以按需导入到组件中，且只能在 setup() 函数中使用, 但是也可以在setup 外定义, 在 setup 中使用；

setup 是围绕 `beforeCreate `和 `created `生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写

https://www.yuque.com/lpldplws/web/gdw840?inner=GKD3b

| 选项式 API      | Hook inside setup |
| --------------- | ----------------- |
| beforeCreate    | Not needed*       |
| created         | Not needed*       |
| beforeMount     | onBeforeMount     |
| mounted         | onMounted         |
| beforeUpdate    | onBeforeUpdate    |
| updated         | onUpdated         |
| beforeUnmount   | onBeforeUnmount   |
| unmounted       | onUnmounted       |
| errorCaptured   | onErrorCaptured   |
| renderTracked   | onRenderTracked   |
| renderTriggered | onRenderTriggered |
| activated       | onActivated       |
| deactivated     | onDeactivated     |

注意，若要在setup中引入，需要在vue中引入对应hook

```js
import { defineComponent, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onErrorCaptured, onMounted, onUnmounted, onUpdated } from 'vue';
```

下面按照页面的生命周期进行说明：

##### 3.2.2.1 页面初始化

涉及钩子：`beforeCreate`、`created`、`beforeMount`、`renderTracked`、`mounted`；

```js
// 此时data还不可用
beforeCreate() {
  console.log('beforeCreate');
},

// data可用，DOM不可用
created() {
  console.log('created');
},
  
// 在这个钩子后，mounted生命周期钩子之前，render函数（渲染页面函数）首次被调用
beforeMount() {
  console.log('beforeMount');
},

// 页面有取值操作时（如：绑定数据，e.g. 插值语法{{ count }}）触发
renderTracked({ type, key, target, effect }) {
  console.log('renderTracked ----', { type, key, target, effect });
},

// 页面挂载完毕后触发
mounted() {
  console.log('mounted');
},
  
// 输出
beforeCreate
created
beforeMount
renderTracked ---- {type: "get", key: "count", target: {...}, effect: f}
mounted
```

Vue3.x新增生命周期renderTracked说明

官方解释：跟踪虚拟DOM重新渲染时调用（初始化渲染时也会调用）。钩子接收`debugger event`作为参数。此事件告诉你哪个操作跟踪了组件以及该操作的目标对象和键。

简单理解来说就是：页面上绑定了响应式数据（取值），就会触发该操作。

```js
methods: {
  addCount() {
    this.count += 1;
  },
},
```

debugger event说明

- type：操作类型，有get，has，iterate，也就是取值操作；
- key：键，简单理解就是操作数据的key，e.g.上文使用的count；
- target：响应式对象，如：data、ref、computed；
- effect：数据类型为Function，effect方法的作用是重新render视图；

##### 3.2.2.2 数据发生变化后触发

涉及钩子：renderTriggered、beforeUpdate、renderTracked、updated

```js
// 2. 数据发生改变后触发
	renderTriggered(e) {
		console.log('renderTriggered ----', e);
	},

	/*---------
  在数据发生改变后，DOM被更新之前调用。
  ----------*/
	beforeUpdate() {
		console.log('beforeUpdate');
	},

	/*---------
  DOM更新完毕之后调用。
  注意事项：updated不会保证所有子组件也都被重新渲染完毕
  ---------*/
	updated() {
		console.log('updated');
	},
    
// 输出
renderTriggered ---- {target: {...}, key: "count", type: "set", newValue: 2, effect: f, oldTarget: undefined, oldValue: 1}
beforeUpdate
update
```

Vue3.x新增生命周期renderTriggered说明

官方解释：当虚拟DOM重新渲染被触发时调用。接收debugger event作为参数。此事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键。

简单理解：做了某件事，从而引发了页面的重新渲染。

`debugger event`说明

- type：操作类型，有set、add、clear、delete，也就是修改操作；
- key：键，简单理解就是操作数据的key。e.g.上文使用的count；
- target：响应式对象，如：data、ref、computed；
- effect：数据类型为Function。英文单词意思为唤起、执行的意思。effect方法的作用是重新render视图；
- newValue：新值；
- oldValue：旧值；
- oldTarget：旧的响应式对象；

##### 3.2.2.3 组件被卸载时触发

涉及钩子：beforeUnmount、unmounted

```js
beforeUnmount() {
  console.log("beforeUnmount");
},

// 卸载组件实例后调用。
unmounted() {
  console.log("unmounted");
}
```

##### 3.2.2.4 捕获错误时触发

涉及钩子：`errorCaptured`

错误传播规则

- 默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报；
- 如果一个组件的继承链或父级链中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起；
- 如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler；
- 一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler；

#### 3.2.3 全局配置

详情参考官网：https://v3.cn.vuejs.org/api/application-config.html#globalproperties
在Vue2中，我们要在全局封装通用的方法，会在入口文件中统一声明：

```js
Vue.prototype.$api = api;
Vue.prototype.$http = http;
```

可以通过在原型上定义它们使其在每个 Vue 的实例中可用，从而达到在Vue实例里使用this.$XXX访问对应方法；但是有的时候它会让其他开发者感到混乱。例如他们可能看到了`this.$http`，会觉得没有见过此功能，或者你打算去搜索如何使用它，但是搜不到结果，因为他们并没有发现这是一个 axios 的别名；

从技术上讲，Vue 2 没有“app”的概念，我们定义的应用只是通过 new Vue() 创建的根 Vue 实例。从同一个 Vue 构造函数创建的每个根实例共享相同的全局配置，因此：

1. 在测试期间，全局配置很容易意外地污染其他测试用例。用户需要仔细地存储原始全局配置；
2. 全局配置使得在同一页面上的多个“应用”在全局配置不同时共享同一个 Vue 副本非常困难；

```js
// 这会影响到所有根实例
Vue.mixin({
  /* ... */
})

const app1 = new Vue({ el: '#app-1' })
const app2 = new Vue({ el: '#app-2' })
```

在Vue3里，通过vue 实例上config来配置,包含Vue应用程序全局配置的对象。您可以在挂载应用程序之前修改下面列出的属性；

```js
const app = Vue.createApp({})

app.config = {...}
```

为组件渲染功能和观察程序期间的未捕获错误分配处理程序。错误和应用程序实例将调用处理程序；

```js
app.config.errorHandler = (err, vm, info) => {}
```

可以在应用程序内的任何组件实例中访问的全局属性，组件的属性将具有优先权。同时，可以在组件用通过 getCurrentInstance() 来获取全局globalProperties 中配置的信息,getCurrentInstance 方法获取当前组件的实例，然后通过 ctx 属性获得当前上下文，这样我们就能在setup中使用router和vuex, 通过这个属性我们就可以操作变量、全局属性、组件属性等等；

```js
const app = Vue.createApp({})

app.config.globalProperties.$http = 'xxxxxxxxs'

setup( ) {
  const { ctx } = getCurrentInstance();
  ctx.$http   
}
```

#### 3.2.4 异步组件

详情参考官网：[https://v3.cn.vuejs.org/guide/migration/suspense.html#%E4%BB%8B%E7%BB%8D](https://v3.cn.vuejs.org/guide/migration/suspense.html#介绍)

Vue3中，异步组件需要使用`defineAsyncComponent`创建

全局注册

```js
// 可以利用返回值的实例去自定义注册异步组件，在哪个应用里生效，在哪个应用里注册
const AsyncComp = defineAsyncComponent(() => import('./components/AsyncComp.vue'));

app.component('async-comp', AsyncComp);
```

局部注册

```js
// main.js
const AsyncComp = defineAsyncComponent(() => import('./components/AsyncComp.vue'));

// app.vue
import AsyncComp from './components/AsyncComp.vue';

{
  components: {'async-comp': AsyncComp}
}
```

异步组件作用：

1. 打包后不会集成在index.js中，会单独进行打包，方便后续操作，可以进行缓存，如多个页面都使用一个相同的组件，可以将打包文件缓存下来；
2. 如果组件包过大，可以使用loading代替显示；

Vue3也支持了Suspense组件

在React V16.6.0中，官方提出了lazy和suspense组件

```js
import React, { Suspense } from 'react';
 
 
const myComponent = React.lazy(() => import('./Component'));
 
 
function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <myComponent />
      </Suspense>
    </div>
  );
}
```

在Vue3中，也实现了类似功能的Suspense：

1. <suspense> 组件有两个插槽。它们都只接收一个直接子节点。default 插槽里的节点会尽可能展示出来。如果不能，则展示 fallback 插槽里的节点；
2. 异步组件不需要作为 <suspense> 的直接子节点。它可以出现在组件树任意深度的位置，且不需要出现在和 <suspense> 自身相同的模板中。只有所有的后代组件都准备就绪，该内容才会被认为解析完毕；

```js
<template>
  <Suspense>
    <template #default>
      <my-component />
    </template>
    <template #fallback>
      Loading ...
    </template>
  </Suspense>
</template>

<script lang='ts'>
 import { defineComponent, defineAsyncComponent } from "vue";
 const MyComponent = defineAsyncComponent(() => import('./Component'));

export default defineComponent({
   components: {
     MyComponent
   },
   setup() {
     return {}
   }
})
 
 
</script>
```

3. 还有一种触发 fallback 的方式是让后代组件从 setup 函数中返回一个 Promise。通常这是通过 async 实现的，而不是显式地返回一个 Promise：

```js
export default {
  async setup() {
    // 在 `setup` 内部使用 `await` 需要非常小心
    const data = await loadData()

    // 它隐性地包裹在一个 Promise 内
    // 因为函数是 `async` 的
    return {
      // ...
    }
  }
}
```

```js
export default {
  async setup() {
    // 在 `setup` 内部使用 `await` 需要非常小心
    const data = await loadData()

    // 它隐性地包裹在一个 Promise 内
    // 因为函数是 `async` 的
    return {
      // ...
    }
  }
}
```

4. 如何通过子组件触发更新&事件更新

如果根结点发生了变化，它会触发 pending 事件。然而，默认情况下，它不会更新 DOM 以展示 fallback 内容。取而代之的是，它会继续展示旧的 DOM，直到新组件准备就绪。这个行为可以通过 timeout prop 进行控制。这个值是一个毫秒数，告诉 <suspense> 组件多久之后展示 fallback。如果这个值是 0 则表示它在 <suspense> 进入等待状态时会立即显示。除了 pending 事件以外，<suspense> 组件还拥有 resolve 和 fallback 事件。resolve 事件会在 default 插槽完成新内容的解析之后被触发。fallback 事件会在 fallback 插槽的内容展示的时候被触发；

#### 3.2.5 自定义指令

详情参考官网：[https://v3.cn.vuejs.org/guide/custom-directive.html#%E7%AE%80%E4%BB%8B](https://v3.cn.vuejs.org/guide/custom-directive.html#简介)

在Vue2里，我们通过以下方式执行

```js
Vue.directive('focus', {
  bind() {},
  inserted(el) {
    el.focus()
  },
  update() {},
  componentUpdated() {},
  unbind() {}
})
```

在Vue3中有所不同，需要在`Vue.createApp({})`中使用

- 参数：

- - {string} name
  - {Function | Object} [definition]

- 返回值：

- - 如果传入 definition 参数，则返回应用实例。
  - 如果不传入 definition 参数，则返回指令定义。

- 用法：注册或检索全局指令。

##### 3.2.5.1 指令支持形式

- 全局指令

  ```js
  const app = Vue.createApp({})
  // 注册一个全局自定义指令 `v-focus`
  app.directive('focus', {
    // 当被绑定的元素挂载到 DOM 中时……
    mounted(el) {
      // 聚焦元素
      el.focus()
    }
  })
  ```

- 局部指令

```js
directives: {
  focus: {
    // 指令的定义
    mounted(el) {
      el.focus()
    }
  }
}

<input v-focus />
```

指令定义对象可以提供如下几个钩子函数 (均为可选)：

- created：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加在普通的 v-on 事件监听器调用前的事件监听器中时，这很有用；
- beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用；
- mounted：在绑定元素的父组件被挂载后调用；
- beforeUpdate：在更新包含组件的 VNode 之前调用；

- updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用；
- beforeUnmount：在卸载绑定元素的父组件之前调用；
- unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次；

##### 3.2.5.2 vue3与vue2指令变化

| Vue3          | Vue2             |
| ------------- | ---------------- |
| created       |                  |
| beforeMount   | bind             |
| mounted       | inserted         |
| beforeUpdate  | update           |
| updated       | componentUpdated |
| beforeUnmount |                  |
| unmounted     | unbind           |

##### 3.2.5.3 动态指令参数

```js
// 固定到距离顶部200px位置
<div id="dynamic-arguments-example" class="demo">
  <p>Scroll down the page</p>
  <p v-pin="200">Stick me 200px from the top of the page</p>
</div>

const app = Vue.createApp({})

app.directive('pin', {
  mounted(el, binding) {
    el.style.position = 'fixed'
    // binding.value 是我们传递给指令的值——在这里是 200
    el.style.top = binding.value + 'px'
  }
})

app.mount('#dynamic-arguments-example')

// 固定在指定方向上指定位置
<div id="dynamicexample">
  <h3>Scroll down inside this section ↓</h3>
  <p v-pin:[direction]="200">I am pinned onto the page at 200px to the left.</p>
</div>

const app = Vue.createApp({
  data() {
    return {
      direction: 'right'
    }
  }
})

app.directive('pin', {
  mounted(el, binding) {
    el.style.position = 'fixed'
    // binding.arg 是我们传递给指令的参数
    const s = binding.arg || 'top'
    el.style[s] = binding.value + 'px'
  }
})

app.mount('#dynamic-arguments-example')
```

##### 3.2.5.4 例子

```js
// main.js
app.directive('copy', {
	beforeMount(el, binding) {
		const success = binding.arg;
		el.targetContent = binding.value;

		el.addEventListener('click', () => {
			if (!el.targetContent) return console.warn('没有需要复制的目标内容');
			// 创建textarea标签
			const textarea = document.createElement('textarea');
			// 设置相关属性
			textarea.readOnly = 'readonly';
			textarea.style.position = 'fixed';
			textarea.style.top = '-99999px';
			// 把目标内容赋值给它的value属性
			textarea.value = el.targetContent;
			// 插入到页面
			document.body.appendChild(textarea);
			// 调用onselect()方法
			textarea.select();
			// 把目标内容复制进剪贴板, 该API会返回一个Boolean
			const res = document.execCommand('Copy');
			res && success && console.log('复制成功，剪贴板内容：' + el.targetContent);
			// 移除textarea标签
			document.body.removeChild(textarea);
		});
	},
	updated(el, binding) {
		// 实时更新最新的目标内容
		el.targetContent = binding.value;
	},
	unmounted(el) {
		el.removeEventListener('click', () => {});
	},
});

// App.vue
<button v-copy:[success]="msg">点击复制</button>
```

#### 3.2.6 teleport

详情参考官网：https://v3.cn.vuejs.org/guide/teleport.html

teleport是一种将子节点渲染到存在于父组件以外的 DOM 节点的方案

当处理某些类型的组件（如模式，通知或提示）时，模板HTML的逻辑可能位于与我们希望渲染元素的位置不同的文件中。

很多时候，与我们的Vue应用程序的DOM完全分开处理时，这些元素的管理要容易得多。 所有这些都是因为处理嵌套组件的位置，z-index和样式可能由于处理其所有父对象的范围而变得棘手。

这种情况就是 Teleport 派上用场的地方。 我们可以在逻辑所在的组件中编写模板代码，这意味着我们可以使用组件的数据或 props。 但是，然后完全将其渲染到我们Vue应用程序的范围之外。

举个例子

```js
// Dialog.vue
<template>
	<div class="portals">
		<button @click="showNotification">Trigger Notification!</button>
		<teleport to="#portal">
			<div v-if="isOpen" class="notification">
				This is rendering outside of this child component!
			</div>
		</teleport>
	</div>
</template>

<script>
import { ref } from 'vue';
export default {
	setup() {
		const isOpen = ref(false);

		var closePopup;

		const showNotification = () => {
			isOpen.value = true;

			clearTimeout(closePopup);

			closePopup = setTimeout(() => {
				isOpen.value = false;
			}, 2000);
		};

		return {
			isOpen,
			showNotification,
		};
	},
};
</script>

<style scoped>
.notification {
	font-family: myriad-pro, sans-serif;
	position: fixed;
	bottom: 20px;
	left: 20px;
	width: 300px;
	padding: 30px;
	background-color: #fff;
}
</style>

// index.html
	<div id="portal"></div>
```

Teleport具有一个必填属性- to

to 需要 prop，必须是有效的查询选择器或 HTMLElement (如果在浏览器环境中使用)。指定将在其中移动 <teleport> 内容的目标元素

与React16提出的Portals功能十分类似，都是在指定的DOM节点下添加元素，可以参考各种组件库，基本上dialog等组件在Vue3中的实现都有使用到teleport，在React组件中都有用到Portals；

#### 3.2.7 自定义hooks

Vue3的hooks其实可以参考React的自定义hooks的定义， 在 React 中，在函数组件中保留 state 数据的同时，融入生命周期函数，将组件整体作为一个钩子函数。

当组件复杂时，多个组件中一些重复的逻辑可以被抽象出来。在 Hook 诞生之前，React 和 Vue 都拥有高阶组件的设计模式，在 React 使用到 HOC，在 Vue 2 中使用到 mixin。为什么要舍弃它们而使用 Hook，使用自定义 Hook 又有哪些优点，我们先简单了解一下 HOC 和 mixin ，对比后便知。

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue自定义mixin.png" alt="vue自定义mixin" style="zoom:50%;" />

HOC 的原理是把组件作为参数传入一个函数，加入复用部分后将新的组件作为返回值，使用了装饰器模式。mixin 像是把复用的部分拆解成一个个小零件，某个组件需要时就拼接进去。

在实践中，mixin 有如下缺点：

1. 引入了隐式依赖关系。
2. 不同 mixins 之间可能会有先后顺序甚至代码冲突覆盖的问题
3. mixin 代码会导致滚雪球式的复杂性
4. 多个 mixin 导致合并项不明来源

为了避开这些问题，React 采用 HOC，但它依然存在缺陷：

1. 一个组件的state影响许多组件的props
2. 造成地狱嵌套

不过使用全新的 Hook 组件结构，可以实现平铺式调用组件的复用部分，解决了 mixin 的来源不明和 HOC 的地狱嵌套问题。

##### 3.2.7.1 例子

在点击页面时，记录鼠标的位置

```js
// src/hooks/useMousePosition.ts
import { ref, onMounted, onUnmounted, Ref } from 'vue'

function useMousePosition() {
  const x = ref(0)
  const y = ref(0)

  const updateMouse = (e) => {
    x.value = e.pageX
    y.value = e.pageY
  }

  onMounted(() => {
    document.addEventListener('click', updateMouse)
  })

  onUnmounted(() => {
    document.removeEventListener('click', updateMouse)
  })

  return { x, y }
}

export default useMousePosition
```

#### 3.2.8. Provide/Inject

当我们需要从父组件向子组件传递数据时，可以使用 props。想象一下这样的结构：但对于一些深度嵌套的组件，如果仍然将 prop 沿着组件链逐级传递下去，会很麻烦。对于这种情况，我们可以使用一对 `provide `和 `inject`。无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两个部分：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这些数据。

##### 3.2.8.1 基础使用

```js
<script>
import { defineComponent } from 'vue';
export default defineComponent({
  provide: {
    provideData: { name: "先早" },
  }
});
</script>

// 子组件
<template>
  <div class="hello">
    <h1>{{ msg }}</h1>
    {{ provideData }}
  </div>
</template>

<script>
export default defineComponent({
  name: "HelloWorld",
  props: {
    msg: String,
  },
  inject: ["provideData"],
});
</script>
```

##### 3.2.8.2. setup()中使用

在 setup() 中使用, 则需要从 vue 显式导入provide、inject方法。导入以后，我们就可以调用它来定义暴露给我们的组件方式。

provide 函数允许你通过两个参数定义属性：

- name：参数名称
- value：属性的值

```js
// 父组件
<script>
import { provide } from "vue";
import HelloWorldVue from "./components/HelloWorld.vue";
export default defineComponent({
  name: "App",
  components: {
    HelloWorld: HelloWorldVue,
  },
  setup() {
    provide("provideData", {
      name: "先早",
    });
  },
});
</script>

// 子组件
<script>
import { provide, inject } from "vue";
export default defineComponent({
  name: "HelloWorld",
  props: {
    msg: String,
  },
  setup() {
    const provideData = inject("provideData");
    
    console.log(provideData); //  { name: "先早"  }

    return {
      provideData,
    };
  },
});
</script>
```

##### 3.2.8.3 传递响应数据

在 `provide `值时使用 `ref `或 `reactive`

```js
<script>
import { provide, reactive, ref } from "vue";
import HelloWorldVue from "./components/HelloWorld.vue";
export default defineComponent({
  name: "App",
  components: {
    HelloWorld: HelloWorldVue,
  },
  setup() {
    const age = ref(18);

    provide("provideData", {
      age,
      data: reactive({ name: "先早" }),
    });
  },
});
</script>


<script lang="ts">
import { inject } from "vue";
export default defineComponent({
  name: "HelloWorld",
  props: {
    msg: String,
  },
  setup() {
    const provideData = inject("provideData");

    console.log(provideData);

    return {
      provideData,
    };
  },
});
</script>
```

### 3.3 一个完整的Vue3组件模板

```js
<template>
  <div class="mine" ref="elmRefs">
    <span>{{name}}</span>
    <br>
    <span>{{count}}</span>
    <div>
      <button @click="handleClick">测试按钮</button>
    </div>

    <ul>
      <li v-for="item in list" :key="item.id">{{item.name}}</li>
    </ul>
  </div>
</template>

<script lang="ts">
import { computed, defineComponent, getCurrentInstance, onMounted, PropType, reactive, ref, toRefs } from 'vue';

interface IState {
  count: number
  name: string
  list: Array<object>
}

export default defineComponent({
  name: 'demo',
  // 父组件传子组件参数
  props: {
    name: {
      type: String as PropType<null | ''>,
      default: 'vue3.x'
    },
    list: {
      type: Array as PropType<object[]>,
      default: () => []
    }
  },
  components: {
    /// TODO 组件注册
  },
  emits: ["emits-name"], // 为了提示作用
  setup (props, context) {
    console.log(props.name)
    console.log(props.list)
    
    
    const state = reactive<IState>({
      name: 'vue 3.0 组件',
      count: 0,
      list: [
        {
          name: 'vue',
          id: 1
        },
        {
          name: 'vuex',
          id: 2
        }
      ]
    })

    const a = computed(() => state.name)

    onMounted(() => {

    })

    function handleClick () {
      state.count ++
      // 调用父组件的方法
      context.emit('emits-name', state.count)
    }
  
    return {
      ...toRefs(state),
      handleClick
    }
  }
});
</script>
```

# vue3新特性&源码解析（2/3）

https://www.yuque.com/lpldplws/web/gmptis?singleDoc# 《Vue3新特性&源码解析（2/3）》 密码：qke4

## 1.课程目标

深入理解Vue3核心源码，通过精简的核心源码，更好的去掌握Vue3具体执行逻辑；

## 2.课程大纲

1. Vue3模块源码解析；
2. Vue3执行逻辑解析；

## 3. vue3模块源码解析

课程代码已经发给班班，可以咨询班班，课程代码目录结构同官方目录结构一致，可以先看懂课程上的简版代码（主要添加注释及去除环境变量等），再深入官方源码进行学习；

官方地址：https://github.com/vuejs/core/tree/main/packages

基本核心模块目录结构如下：

```js
├─compiler-core
│  │  package.json
│  │
│  ├─src
│  │  │  ast.ts
│  │  │  codegen.ts
│  │  │  compile.ts
│  │  │  index.ts
│  │  │  parse.ts
│  │  │  runtimeHelpers.ts
│  │  │  transform.ts
│  │  │  utils.ts
│  │  │
│  │  └─transforms
│  │          transformElement.ts
│  │          transformExpression.ts
│  │          transformText.ts
│  │
│  └─__tests__
│      │  codegen.spec.ts
│      │  parse.spec.ts
│      │  transform.spec.ts
│      │
│      └─__snapshots__
│              codegen.spec.ts.snap
│
├─reactivity
│  │  package.json
│  │
│  ├─src
│  │      baseHandlers.ts
│  │      computed.ts
│  │      dep.ts
│  │      effect.ts
│  │      index.ts
│  │      reactive.ts
│  │      ref.ts
│  │
│  └─__tests__
│          computed.spec.ts
│          dep.spec.ts
│          effect.spec.ts
│          reactive.spec.ts
│          readonly.spec.ts
│          ref.spec.ts
│          shallowReadonly.spec.ts
│
├─runtime-core
│  │  package.json
│  │
│  ├─src
│  │  │  .pnpm-debug.log
│  │  │  apiInject.ts
│  │  │  apiWatch.ts
│  │  │  component.ts
│  │  │  componentEmits.ts
│  │  │  componentProps.ts
│  │  │  componentPublicInstance.ts
│  │  │  componentRenderUtils.ts
│  │  │  componentSlots.ts
│  │  │  createApp.ts
│  │  │  h.ts
│  │  │  index.ts
│  │  │  renderer.ts
│  │  │  scheduler.ts
│  │  │  vnode.ts
│  │  │
│  │  └─helpers
│  │          renderSlot.ts
│  │
│  └─__tests__
│          apiWatch.spec.ts
│          componentEmits.spec.ts
│          rendererComponent.spec.ts
│          rendererElement.spec.ts
│
├─runtime-dom
│  │  package.json
│  │
│  └─src
│          index.ts
│
├─runtime-test
│  └─src
│          index.ts
│          nodeOps.ts
│          patchProp.ts
│          serialize.ts
│
├─shared
│  │  package.json
│  │
│  └─src
│          index.ts
│          shapeFlags.ts
│          toDisplayString.ts
```

### 3.1 compiler-core

Vue3的编译核心，核心作用就是将字符串转换成 抽象对象语法树AST；

 

#### 3.1.1. 目录结构 

```js
├─compiler-core
│  │  package.json
│  │
│  ├─src
│  │  │  ast.ts
│  │  │  codegen.ts
│  │  │  compile.ts
│  │  │  index.ts
│  │  │  parse.ts
│  │  │  runtimeHelpers.ts
│  │  │  transform.ts
│  │  │  utils.ts
│  │  │
│  │  └─transforms
│  │          transformElement.ts
│  │          transformExpression.ts
│  │          transformText.ts
│  │
│  └─__tests__
│      │  codegen.spec.ts
│      │  parse.spec.ts
│      │  transform.spec.ts
│      │
│      └─__snapshots__
│              codegen.spec.ts.snap
│
├─reactivity
│  │  package.json
│  │
│  ├─src
│  │      baseHandlers.ts
│  │      computed.ts
│  │      dep.ts
│  │      effect.ts
│  │      index.ts
│  │      reactive.ts
│  │      ref.ts
│  │
│  └─__tests__
│          computed.spec.ts
│          dep.spec.ts
│          effect.spec.ts
│          reactive.spec.ts
│          readonly.spec.ts
│          ref.spec.ts
│          shallowReadonly.spec.ts
│
├─runtime-core
│  │  package.json
│  │
│  ├─src
│  │  │  .pnpm-debug.log
│  │  │  apiInject.ts
│  │  │  apiWatch.ts
│  │  │  component.ts
│  │  │  componentEmits.ts
│  │  │  componentProps.ts
│  │  │  componentPublicInstance.ts
│  │  │  componentRenderUtils.ts
│  │  │  componentSlots.ts
│  │  │  createApp.ts
│  │  │  h.ts
│  │  │  index.ts
│  │  │  renderer.ts
│  │  │  scheduler.ts
│  │  │  vnode.ts
│  │  │
│  │  └─helpers
│  │          renderSlot.ts
│  │
│  └─__tests__
│          apiWatch.spec.ts
│          componentEmits.spec.ts
│          rendererComponent.spec.ts
│          rendererElement.spec.ts
│
├─runtime-dom
│  │  package.json
│  │
│  └─src
│          index.ts
│
├─runtime-test
│  └─src
│          index.ts
│          nodeOps.ts
│          patchProp.ts
│          serialize.ts
│
├─shared
│  │  package.json
│  │
│  └─src
│          index.ts
│          shapeFlags.ts
│          toDisplayString.ts
```

#### 3.1.2 compile逻辑

详细代码见课上讲解

```js
// src/index.ts
export { baseCompile } from "./compile";

// src/compiler.ts
import { generate } from "./codegen";
import { baseParse } from "./parse";
import { transform } from "./transform";
import { transformExpression } from "./transforms/transformExpression";
import { transformElement } from "./transforms/transformElement";
import { transformText } from "./transforms/transformText";

export function baseCompile(template, options) {
  // 1. 先把 template 也就是字符串 parse 成 ast
  const ast = baseParse(template);
  // 2. 给 ast 加点料（- -#）
  transform(
    ast,
    Object.assign(options, {
      nodeTransforms: [transformElement, transformText, transformExpression],
    })
  );
  
  // 3. 生成 render 函数代码
  return generate(ast);
}

```

- baseParse

```typescript
export function baseParse(content: string) {
  const context = createParserContext(content);
  return createRoot(parseChildren(context, []));
}

function createParserContext(content) {
  console.log("创建 paserContext");
  return {
    source: content,
  };
}

function createRoot(children) {
  return {
    type: NodeTypes.ROOT,
    children,
    helpers: [],
  };
}

function parseChildren(context, ancestors) {
  console.log("开始解析 children");
  const nodes: any = [];
  
  while (!isEnd(context, ancestors)) {
    let node;
    const s = context.source;
    
    if (startsWith(s, "{{")) {
      // 看看如果是 {{ 开头的话，那么就是一个插值， 那么去解析他
      node = parseInterpolation(context);
    } else if (s[0] === "<") {
      if (s[1] === "/") {
        // 这里属于 edge case 可以不用关心
        // 处理结束标签
        if (/[a-z]/i.test(s[2])) {
          // 匹配 </div>
          // 需要改变 context.source 的值 -> 也就是需要移动光标
          parseTag(context, TagType.End);
          // 结束标签就以为这都已经处理完了，所以就可以跳出本次循环了
          continue;
        }
      } else if (/[a-z]/i.test(s[1])) {
        node = parseElement(context, ancestors);
      }
    }
    
    if (!node) {
      node = parseText(context);
    }
    
    nodes.push(node);
  }
  
  return nodes;
}
```

- transfrom

```typescript
export function transform(root, options = {}) {
  // 1. 创建 context
  
  const context = createTransformContext(root, options);
  
  // 2. 遍历 node
  traverseNode(root, context);
  
  createRootCodegen(root, context);
  
  root.helpers.push(...context.helpers.keys());
}

function createTransformContext(root, options): any {
  const context = {
    root,
    nodeTransforms: options.nodeTransforms || [],
    helpers: new Map(),
    helper(name) {
      // 这里会收集调用的次数
      // 收集次数是为了给删除做处理的， （当只有 count 为0 的时候才需要真的删除掉）
      // helpers 数据会在后续生成代码的时候用到
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
    },
  };
  
  return context;
}

function traverseNode(node: any, context) {
  const type: NodeTypes = node.type;
  
  // 遍历调用所有的 nodeTransforms
  // 把 node 给到 transform
  // 用户可以对 node 做处理
  const nodeTransforms = context.nodeTransforms;
  const exitFns: any = [];
  for (let i = 0; i < nodeTransforms.length; i++) {
    const transform = nodeTransforms[i];
    
    const onExit = transform(node, context);
    if (onExit) {
      exitFns.push(onExit);
    }
  }
  
  switch (type) {
    case NodeTypes.INTERPOLATION:
      // 插值的点，在于后续生成 render 代码的时候是获取变量的值
      context.helper(TO_DISPLAY_STRING);
      break;
      
    case NodeTypes.ROOT:
    case NodeTypes.ELEMENT:
      
      traverseChildren(node, context);
      break;
      
    default:
      break;
  }
  
  
  
  let i = exitFns.length;
  // i-- 这个很巧妙
  // 使用 while 是要比 for 快 (可以使用 https://jsbench.me/ 来测试一下)
  while (i--) {
    exitFns[i]();
  }
}

function createRootCodegen(root: any, context: any) {
  const { children } = root;
  
  // 只支持有一个根节点
  // 并且还是一个 single text node
  const child = children[0];
  
  // 如果是 element 类型的话 ， 那么我们需要把它的 codegenNode 赋值给 root
  // root 其实是个空的什么数据都没有的节点
  // 所以这里需要额外的处理 codegenNode
  // codegenNode 的目的是专门为了 codegen 准备的  为的就是和 ast 的 node 分离开
  if (child.type === NodeTypes.ELEMENT && child.codegenNode) {
    const codegenNode = child.codegenNode;
    root.codegenNode = codegenNode;
  } else {
    root.codegenNode = child;
  }
}

```

- generate

```typescript
export function generate(ast, options = {}) {
  // 先生成 context
  const context = createCodegenContext(ast, options);
  const { push, mode } = context;
  
  // 1. 先生成 preambleContext
  
  if (mode === "module") {
    genModulePreamble(ast, context);
  } else {
    genFunctionPreamble(ast, context);
  }
  
  const functionName = "render";
  
  const args = ["_ctx"];
  
  // _ctx,aaa,bbb,ccc
  // 需要把 args 处理成 上面的 string
  const signature = args.join(", ");
  push(`function ${functionName}(${signature}) {`);
  // 这里需要生成具体的代码内容
  // 开始生成 vnode tree 的表达式
  push("return ");
  genNode(ast.codegenNode, context);
  
  push("}");
  
  return {
    code: context.code,
  };
}
```

### 3.2 reactivity

负责Vue3中响应式实现的部分

#### 3.2.1 目录结构

```js
├─src
│      baseHandlers.ts // 基本处理逻辑
│      computed.ts // computed属性处理
│      dep.ts // effect对象存储逻辑
│      effect.ts // 依赖收集机制
│      index.ts // 入口文件
│      reactive.ts // 响应式处理逻辑
│      ref.ts // ref执行逻辑
│
└─__tests__ // 测试用例
        computed.spec.ts
        dep.spec.ts
        effect.spec.ts
        reactive.spec.ts
        readonly.spec.ts
        ref.spec.ts
        shallowReadonly.spec.ts
```

#### 3.2.2 reactivity逻辑

详细代码见课上讲解

- index.ts

```typescript
export {
reactive,
  readonly,
  shallowReadonly,
  isReadonly,
  isReactive,
  isProxy,
} from "./reactive";

export { ref, proxyRefs, unRef, isRef } from "./ref";

export { effect, stop, ReactiveEffect } from "./effect";

export { computed } from "./computed";

```

- reactive.ts

```typescript
import {
  mutableHandlers,
  readonlyHandlers,
  shallowReadonlyHandlers,
} from "./baseHandlers";

export const reactiveMap = new WeakMap();
export const readonlyMap = new WeakMap();
export const shallowReadonlyMap = new WeakMap();

export const enum ReactiveFlags {
  IS_REACTIVE = "__v_isReactive",
  IS_READONLY = "__v_isReadonly",
  RAW = "__v_raw",
}

export function reactive(target) {
  return createReactiveObject(target, reactiveMap, mutableHandlers);
}

export function readonly(target) {
  return createReactiveObject(target, readonlyMap, readonlyHandlers);
}

export function shallowReadonly(target) {
  return createReactiveObject(
    target,
    shallowReadonlyMap,
    shallowReadonlyHandlers
  );
}

export function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}

export function isReadonly(value) {
  return !!value[ReactiveFlags.IS_READONLY];
}

export function isReactive(value) {
  // 如果 value 是 proxy 的话
  // 会触发 get 操作，而在 createGetter 里面会判断
  // 如果 value 是普通对象的话
  // 那么会返回 undefined ，那么就需要转换成布尔值
  return !!value[ReactiveFlags.IS_REACTIVE];
}

export function toRaw(value) {
  // 如果 value 是 proxy 的话 ,那么直接返回就可以了
  // 因为会触发 createGetter 内的逻辑
  // 如果 value 是普通对象的话，
  // 我们就应该返回普通对象
  // 只要不是 proxy ，只要是得到了 undefined 的话，那么就一定是普通对象
  // TODO 这里和源码里面实现的不一样，不确定后面会不会有问题
  if (!value[ReactiveFlags.RAW]) {
    return value;
  }
  
  return value[ReactiveFlags.RAW];
}

function createReactiveObject(target, proxyMap, baseHandlers) {
  // 核心就是 proxy
  // 目的是可以侦听到用户 get 或者 set 的动作
  
  // 如果命中的话就直接返回就好了
  // 使用缓存做的优化点
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  
  const proxy = new Proxy(target, baseHandlers);
  
  // 把创建好的 proxy 给存起来，
  proxyMap.set(target, proxy);
  return proxy;
}

```

- ref.ts

```typescript
import { trackEffects, triggerEffects, isTracking } from "./effect";
import { createDep } from "./dep";
import { isObject, hasChanged } from "@mini-vue/shared";
import { reactive } from "./reactive";

export class RefImpl {
  private _rawValue: any;
  private _value: any;
  public dep;
  public __v_isRef = true;

  constructor(value) {
    this._rawValue = value;
    // 看看value 是不是一个对象，如果是一个对象的话
    // 那么需要用 reactive 包裹一下
    this._value = convert(value);
    this.dep = createDep();
  }

  get value() {
    // 收集依赖
    trackRefValue(this);
    return this._value;
  }

  set value(newValue) {
    // 当新的值不等于老的值的话，
    // 那么才需要触发依赖
    if (hasChanged(newValue, this._rawValue)) {
      // 更新值
      this._value = convert(newValue);
      this._rawValue = newValue;
      // 触发依赖
      triggerRefValue(this);
    }
  }
}

export function ref(value) {
  return createRef(value);
}

function convert(value) {
  return isObject(value) ? reactive(value) : value;
}

function createRef(value) {
  const refImpl = new RefImpl(value);

  return refImpl;
}

export function triggerRefValue(ref) {
  triggerEffects(ref.dep);
}

export function trackRefValue(ref) {
  if (isTracking()) {
    trackEffects(ref.dep);
  }
}

// 这个函数的目的是
// 帮助解构 ref
// 比如在 template 中使用 ref 的时候，直接使用就可以了
// 例如： const count = ref(0) -> 在 template 中使用的话 可以直接 count
// 解决方案就是通过 proxy 来对 ref 做处理

const shallowUnwrapHandlers = {
  get(target, key, receiver) {
    // 如果里面是一个 ref 类型的话，那么就返回 .value
    // 如果不是的话，那么直接返回value 就可以了
    return unRef(Reflect.get(target, key, receiver));
  },
  set(target, key, value, receiver) {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      return (target[key].value = value);
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
};

// 这里没有处理 objectWithRefs 是 reactive 类型的时候
// TODO reactive 里面如果有 ref 类型的 key 的话， 那么也是不需要调用 ref.value 的
// （but 这个逻辑在 reactive 里面没有实现）
export function proxyRefs(objectWithRefs) {
  return new Proxy(objectWithRefs, shallowUnwrapHandlers);
}

// 把 ref 里面的值拿到
export function unRef(ref) {
  return isRef(ref) ? ref.value : ref;
}

export function isRef(value) {
  return !!value.__v_isRef;
}

```

- effect

```typescript
export function effect(fn, options = {}) {
  const _effect = new ReactiveEffect(fn);

  // 把用户传过来的值合并到 _effect 对象上去
  // 缺点就是不是显式的，看代码的时候并不知道有什么值
  extend(_effect, options);
  _effect.run();

  // 把 _effect.run 这个方法返回
  // 让用户可以自行选择调用的时机（调用 fn）
  const runner: any = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}

export function stop(runner) {
  runner.effect.stop();
}
```

- computed

```typescript
import { createDep } from "./dep";
import { ReactiveEffect } from "./effect";
import { trackRefValue, triggerRefValue } from "./ref";

export class ComputedRefImpl {
  public dep: any;
  public effect: ReactiveEffect;

  private _dirty: boolean;
  private _value

  constructor(getter) {
    this._dirty = true;
    this.dep = createDep();
    this.effect = new ReactiveEffect(getter, () => {
      // scheduler
      // 只要触发了这个函数说明响应式对象的值发生改变了
      // 那么就解锁，后续在调用 get 的时候就会重新执行，所以会得到最新的值
      if (this._dirty) return;

      this._dirty = true;
      triggerRefValue(this);
    });
  }

  get value() {
    // 收集依赖
    trackRefValue(this);
    // 锁上，只可以调用一次
    // 当数据改变的时候才会解锁
    // 这里就是缓存实现的核心
    // 解锁是在 scheduler 里面做的
    if (this._dirty) {
      this._dirty = false;
      // 这里执行 run 的话，就是执行用户传入的 fn
      this._value = this.effect.run();
    }

    return this._value;
  }
}

export function computed(getter) {
  return new ComputedRefImpl(getter);
}

```

### 3.3 runtime-core

运行的核心流程，其中包括初始化流程和更新流程

#### 3.3.1 目录结构

```js
├─src
│  │  apiInject.ts	// 提供provider和inject
│  │  apiWatch.ts	// 提供watch
│  │  component.ts	// 创建组件实例
│  │  componentEmits.ts	// 执行组件props 里面的 onXXX 的函数
│  │  componentProps.ts	// 获取组件props
│  │  componentPublicInstance.ts	// 组件通用实例上的代理,如$el,$emit等
│  │  componentRenderUtils.ts	// 判断组件是否需要重新渲染的工具类
│  │  componentSlots.ts	// 组件的slot
│  │  createApp.ts	// 根据跟组件创建应用
│  │  h.ts	// 创建节点
│  │  index.ts	// 入口文件
│  │  renderer.ts	// 渲染机制,包含diff
│  │  scheduler.ts // 触发更新机制
│  │  vnode.ts	// vnode节点
│  │
│  └─helpers
│          renderSlot.ts	// 插槽渲染实现
│
└─__tests__	// 测试用例
        apiWatch.spec.ts
        componentEmits.spec.ts
        rendererComponent.spec.ts
        rendererElement.spec.ts
```

#### 3.3.2 runtime核心逻辑

详细代码见课上讲解

- provide/inject

  ```typescript
  import { getCurrentInstance } from "./component";
  
  export function provide(key, value) {
    const currentInstance = getCurrentInstance();
  
    if (currentInstance) {
      let { provides } = currentInstance;
  
      const parentProvides = currentInstance.parent?.provides;
  
      // 这里要解决一个问题
      // 当父级 key 和 爷爷级别的 key 重复的时候，对于子组件来讲，需要取最近的父级别组件的值
      // 那这里的解决方案就是利用原型链来解决
      // provides 初始化的时候是在 createComponent 时处理的，当时是直接把 parent.provides 赋值给组件的 provides 的
      // 所以，如果说这里发现 provides 和 parentProvides 相等的话，那么就说明是第一次做 provide(对于当前组件来讲)
      // 我们就可以把 parent.provides 作为 currentInstance.provides 的原型重新赋值
      // 至于为什么不在 createComponent 的时候做这个处理，可能的好处是在这里初始化的话，是有个懒执行的效果（优化点，只有需要的时候在初始化）
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
  
      provides[key] = value;
    }
  }
  
  export function inject(key, defaultValue) {
    const currentInstance = getCurrentInstance();
  
    if (currentInstance) {
      const provides = currentInstance.parent?.provides;
  
      if (key in provides) {
        return provides[key];
      } else if (defaultValue) {
        if (typeof defaultValue === "function") {
          return defaultValue();
        }
        return defaultValue;
      }
    }
  }
  
  ```

- watch

```typescript
import { ReactiveEffect } from "@mini-vue/reactivity";
import { queuePreFlushCb } from "./scheduler";

// Simple effect.
export function watchEffect(effect) {
  doWatch(effect);
}

function doWatch(source) {
  // 把 job 添加到 pre flush 里面
  // 也就是在视图更新完成之前进行渲染（待确认？）
  // 当逻辑执行到这里的时候 就已经触发了 watchEffect
  const job = () => {
    effect.run();
  };

  // 这里用 scheduler 的目的就是在更新的时候
  // 让回调可以在 render 前执行 变成一个异步的行为（这里也可以通过 flush 来改变）
  const scheduler = () => queuePreFlushCb(job);

  const getter = () => {
    source();
  };

  const effect = new ReactiveEffect(getter, scheduler);

  // 这里执行的就是 getter
  effect.run();
}

```

- component创建

```typescript
export function createComponentInstance(vnode, parent) {
  const instance = {
    type: vnode.type,
    vnode,
    next: null, // 需要更新的 vnode，用于更新 component 类型的组件
    props: {},
    parent,
    provides: parent ? parent.provides : {}, //  获取 parent 的 provides 作为当前组件的初始化值 这样就可以继承 parent.provides 的属性了
    proxy: null,
    isMounted: false,
    attrs: {}, // 存放 attrs 的数据
    slots: {}, // 存放插槽的数据
    ctx: {}, // context 对象
    setupState: {}, // 存储 setup 的返回值
    emit: () => {},
  };
  
  // 在 prod 坏境下的 ctx 只是下面简单的结构
  // 在 dev 环境下会更复杂
  instance.ctx = {
    _: instance,
  };
  
  // 赋值 emit
  // 这里使用 bind 把 instance 进行绑定
  // 后面用户使用的时候只需要给 event 和参数即可
  instance.emit = emit.bind(null, instance) as any;
  
  return instance;
}

```

- createApp

```typescript
import { createVNode } from "./vnode";

export function createAppAPI(render) {
  return function createApp(rootComponent) {
    const app = {
      _component: rootComponent,
      mount(rootContainer) {
        console.log("基于根组件创建 vnode");
        const vnode = createVNode(rootComponent);
        console.log("调用 render，基于 vnode 进行开箱");
        render(vnode, rootContainer);
      },
    };

    return app;
  };
}

```

- 创建vnode节点

```typescript
import { createVNode } from "./vnode";
export const h = (type: any , props: any = null, children: string | Array<any> = []) => {
  return createVNode(type, props, children);
};

```

- 入口文件

```typescript
export * from "./h";
export * from "./createApp";
export { getCurrentInstance, registerRuntimeCompiler } from "./component";
export { inject, provide } from "./apiInject";
export { renderSlot } from "./helpers/renderSlot";
export { createTextVNode, createElementVNode } from "./vnode";
export { createRenderer } from "./renderer";
export { toDisplayString } from "@mini-vue/shared";
export {
  // core
  reactive,
  ref,
  readonly,
  // utilities
  unRef,
  proxyRefs,
  isReadonly,
  isReactive,
  isProxy,
  isRef,
  // advanced
  shallowReadonly,
  // effect
  effect,
  stop,
  computed,
} from "@mini-vue/reactivity";

```

- render

```typescript
// 具体update的Diff见下节课内容;
function updateElement(n1, n2, container, anchor, parentComponent) {
    const oldProps = (n1 && n1.props) || {};
  const newProps = n2.props || {};
  // 应该更新 element
  console.log("应该更新 element");
  console.log("旧的 vnode", n1);
  console.log("新的 vnode", n2);

  // 需要把 el 挂载到新的 vnode
  const el = (n2.el = n1.el);

  // 对比 props
  patchProps(el, oldProps, newProps);

  // 对比 children
  patchChildren(n1, n2, el, anchor, parentComponent);
}
```

- scheduler

```typescript
// 具体的调度机制见下节课内容
const queue: any[] = [];
const activePreFlushCbs: any = [];

const p = Promise.resolve();
let isFlushPending = false;

export function nextTick(fn?) {
  return fn ? p.then(fn) : p;
}

export function queueJob(job) {
  if (!queue.includes(job)) {
    queue.push(job);
    // 执行所有的 job
    queueFlush();
  }
}

function queueFlush() {
  // 如果同时触发了两个组件的更新的话
  // 这里就会触发两次 then （微任务逻辑）
  // 但是着是没有必要的
  // 我们只需要触发一次即可处理完所有的 job 调用
  // 所以需要判断一下 如果已经触发过 nextTick 了
  // 那么后面就不需要再次触发一次 nextTick 逻辑了
  if (isFlushPending) return;
  isFlushPending = true;
  nextTick(flushJobs);
}

export function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs);
}

function queueCb(cb, activeQueue) {
  // 直接添加到对应的列表内就ok
  // todo 这里没有考虑 activeQueue 是否已经存在 cb 的情况
  // 然后在执行 flushJobs 的时候就可以调用 activeQueue 了
  activeQueue.push(cb);

  // 然后执行队列里面所有的 job
  queueFlush()
}

function flushJobs() {
  isFlushPending = false;

  // 先执行 pre 类型的 job
  // 所以这里执行的job 是在渲染前的
  // 也就意味着执行这里的 job 的时候 页面还没有渲染
  flushPreFlushCbs();

  // 这里是执行 queueJob 的
  // 比如 render 渲染就是属于这个类型的 job
  let job;
  while ((job = queue.shift())) {
    if (job) {
      job();
    }
  }
}

function flushPreFlushCbs() {
  // 执行所有的 pre 类型的 job
  for (let i = 0; i < activePreFlushCbs.length; i++) {
    activePreFlushCbs[i]();
  }
}

```

- vnode类型定义及格式规范

```typescript
import { ShapeFlags } from "@mini-vue/shared";

export { createVNode as createElementVNode }

export const createVNode = function (
  type: any,
  props?: any,
  children?: string | Array<any>
) {
  // 注意 type 有可能是 string 也有可能是对象
  // 如果是对象的话，那么就是用户设置的 options
  // type 为 string 的时候
  // createVNode("div")
  // type 为组件对象的时候
  // createVNode(App)
  const vnode = {
    el: null,
    component: null,
    key: props?.key,
    type,
    props: props || {},
    children,
    shapeFlag: getShapeFlag(type),
  };

  // 基于 children 再次设置 shapeFlag
  if (Array.isArray(children)) {
    vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN;
  } else if (typeof children === "string") {
    vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN;
  }

  normalizeChildren(vnode, children);

  return vnode;
};

export function normalizeChildren(vnode, children) {
  if (typeof children === "object") {
    // 暂时主要是为了标识出 slots_children 这个类型来
    // 暂时我们只有 element 类型和 component 类型的组件
    // 所以我们这里除了 element ，那么只要是 component 的话，那么children 肯定就是 slots 了
    if (vnode.shapeFlag & ShapeFlags.ELEMENT) {
      // 如果是 element 类型的话，那么 children 肯定不是 slots
    } else {
      // 这里就必然是 component 了,
      vnode.shapeFlag |= ShapeFlags.SLOTS_CHILDREN;
    }
  }
}
// 用 symbol 作为唯一标识
export const Text = Symbol("Text");
export const Fragment = Symbol("Fragment");

/**
 * @private
 */
export function createTextVNode(text: string = " ") {
  return createVNode(Text, {}, text);
}

// 标准化 vnode 的格式
// 其目的是为了让 child 支持多种格式
export function normalizeVNode(child) {
  // 暂时只支持处理 child 为 string 和 number 的情况
  if (typeof child === "string" || typeof child === "number") {
    return createVNode(Text, null, String(child));
  } else {
    return child;
  }
}

// 基于 type 来判断是什么类型的组件
function getShapeFlag(type: any) {
  return typeof type === "string"
    ? ShapeFlags.ELEMENT
    : ShapeFlags.STATEFUL_COMPONENT;
}

```

### 3.4 runtime-dom

Vue3靠虚拟dom，实现跨平台的能力，runtime-dom提供一个渲染器，这个渲染器可以渲染虚拟dom节点到指定的容器中；

#### 3.4.1 主要功能

详细代码见课上讲解

```typescript
// 源码里面这些接口是由 runtime-dom 来实现
// 这里先简单实现

import { isOn } from "@mini-vue/shared";
import { createRenderer } from "@mini-vue/runtime-core";

// 后面也修改成和源码一样的实现
function createElement(type) {
  console.log("CreateElement", type);
  const element = document.createElement(type);
  return element;
}

function createText(text) {
  return document.createTextNode(text);
}

function setText(node, text) {
  node.nodeValue = text;
}

function setElementText(el, text) {
  console.log("SetElementText", el, text);
  el.textContent = text;
}

function patchProp(el, key, preValue, nextValue) {
  // preValue 之前的值
  // 为了之后 update 做准备的值
  // nextValue 当前的值
  console.log(`PatchProp 设置属性:${key} 值:${nextValue}`);
  console.log(`key: ${key} 之前的值是:${preValue}`);

  if (isOn(key)) {
    // 添加事件处理函数的时候需要注意一下
    // 1. 添加的和删除的必须是一个函数，不然的话 删除不掉
    //    那么就需要把之前 add 的函数给存起来，后面删除的时候需要用到
    // 2. nextValue 有可能是匿名函数，当对比发现不一样的时候也可以通过缓存的机制来避免注册多次
    // 存储所有的事件函数
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[key];
    if (nextValue && existingInvoker) {
      // patch
      // 直接修改函数的值即可
      existingInvoker.value = nextValue;
    } else {
      const eventName = key.slice(2).toLowerCase();
      if (nextValue) {
        const invoker = (invokers[key] = nextValue);
        el.addEventListener(eventName, invoker);
      } else {
        el.removeEventListener(eventName, existingInvoker);
        invokers[key] = undefined;
      }
    }
  } else {
    if (nextValue === null || nextValue === "") {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, nextValue);
    }
  }
}

function insert(child, parent, anchor = null) {
  console.log("Insert");
  parent.insertBefore(child, anchor);
}

function remove(child) {
  const parent = child.parentNode;
  if (parent) {
    parent.removeChild(child);
  }
}

let renderer;

function ensureRenderer() {
  // 如果 renderer 有值的话，那么以后都不会初始化了
  return (
    renderer ||
    (renderer = createRenderer({
      createElement,
      createText,
      setText,
      setElementText,
      patchProp,
      insert,
      remove,
    }))
  );
}

export const createApp = (...args) => {
  return ensureRenderer().createApp(...args);
};

export * from "@mini-vue/runtime-core"

```

### 3.5 runtime-test

可以理解成runtime-dom的延伸，,因为runtime-test对外提供的确实是dom环境的测试，方便用于runtime-core的测试；

#### 3.5.1 目录结构

```js
──src
index.ts
nodeOps.ts
patchProp.ts
serialize.ts

```

#### 3.5.2 runtime-test 核心逻辑

详细代码见课上讲解

- index.ts

```typescript
// todo
// 实现 render 的渲染接口
// 实现序列化
import { createRenderer } from "@mini-vue/runtime-core";
import { extend } from "@mini-vue/shared";
import { nodeOps } from "./nodeOps";
import { patchProp } from "./patchProp";

export const { render } = createRenderer(extend({ patchProp }, nodeOps));

export * from "./nodeOps";
export * from "./serialize"
export * from '@mini-vue/runtime-core'
```

- nodeOps，节点定义及操作再runtime-core中的映射

```typescript
export const enum NodeTypes {
  ELEMENT = "element",
  TEXT = "TEXT",
}

let nodeId = 0;
// 这个函数会在 runtime-core 初始化 element 的时候调用
function createElement(tag: string) {
  // 如果是基于 dom 的话 那么这里会返回 dom 元素
  // 这里是为了测试 所以只需要反正一个对象就可以了
  // 后面的话 通过这个对象来做测试
  const node = {
    tag,
    id: nodeId++,
    type: NodeTypes.ELEMENT,
    props: {},
    children: [],
    parentNode: null,
  };

  return node;
}

function insert(child, parent) {
  parent.children.push(child);
  child.parentNode = parent;
}

function parentNode(node) {
  return node.parentNode;
}

function setElementText(el, text) {
  el.children = [
    {
      id: nodeId++,
      type: NodeTypes.TEXT,
      text,
      parentNode: el,
    },
  ];
}

export const nodeOps = { createElement, insert, parentNode, setElementText };

```

- Serialize, 序列化：把vnode处理成string

```typescript
// 把 node 给序列化
// 测试的时候好对比

import { NodeTypes } from "./nodeOps";

// 序列化： 把一个对象给处理成 string （进行流化）
export function serialize(node) {
  if (node.type === NodeTypes.ELEMENT) {
    return serializeElement(node);
  } else {
    return serializeText(node);
  }
}

function serializeText(node) {
  return node.text;
}

export function serializeInner(node) {
  // 把所有节点变成一个string
  return node.children.map((c) => serialize(c)).join(``);
}

function serializeElement(node) {
  // 把 props 处理成字符串
  // 规则：
  // 如果 value 是 null 的话 那么直接返回 ``
  // 如果 value 是 `` 的话，那么返回 key
  // 不然的话返回 key = value（这里的值需要字符串化）
  const props = Object.keys(node.props)
    .map((key) => {
      const value = node.props[key];
      return value == null
        ? ``
        : value === ``
        ? key
        : `${key}=${JSON.stringify(value)}`;
    })
    .filter(Boolean)
    .join(" ");

  console.log("node---------", node.children);
  return `<${node.tag}${props ? ` ${props}` : ``}>${serializeInner(node)}</${
    node.tag
  }>`;
}

```

### 3.6 shared

公用逻辑

#### 3.6.1 具体逻辑

```typescript
export * from '../src/shapeFlags';
export * from '../src/toDisplayString';

export const isObject = val => {
	return val !== null && typeof val === 'object';
};

export const isString = val => typeof val === 'string';

const camelizeRE = /-(\w)/g;
/**
 * @private
 * 把中划线命名方式转换成驼峰命名方式
 */
export const camelize = (str: string): string => {
	return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
};

export const extend = Object.assign;

// 必须是 on+一个大写字母的格式开头
export const isOn = key => /^on[A-Z]/.test(key);

export function hasChanged(value, oldValue) {
	return !Object.is(value, oldValue);
}

export function hasOwn(val, key) {
	return Object.prototype.hasOwnProperty.call(val, key);
}

/**
 * @private
 * 首字母大写
 */
export const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);

/**
 * @private
 * 添加 on 前缀，并且首字母大写
 */
export const toHandlerKey = (str: string) => (str ? `on${capitalize(str)}` : ``);

// 用来匹配 kebab-case 的情况
// 比如 onTest-event 可以匹配到 T
// 然后取到 T 在前面加一个 - 就可以
// \BT 就可以匹配到 T 前面是字母的位置
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
export const hyphenate = (str: string) => str.replace(hyphenateRE, '-$1').toLowerCase();


// 组件的类型
export const enum ShapeFlags {
  // 最后要渲染的 element 类型
  ELEMENT = 1,
  // 组件类型
  STATEFUL_COMPONENT = 1 << 2,
  // vnode 的 children 为 string 类型
  TEXT_CHILDREN = 1 << 3,
  // vnode 的 children 为数组类型
  ARRAY_CHILDREN = 1 << 4,
  // vnode 的 children 为 slots 类型
  SLOTS_CHILDREN = 1 << 5
}

export const toDisplayString = (val) => {
  return String(val);
};

```

## 4 vue3执行逻辑解析

详情见课上讲解

### 4.1 init

​	<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue3执行逻辑init.png" alt="vue3执行逻辑init" style="zoom:50%;" />

### 4.2 update

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue3执行逻辑update.png" alt="vue3执行逻辑update" style="zoom:50%;" />

### 4.3 关键函数调用

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue3执行逻辑functionCall.png" alt="vue3执行逻辑functionCall" style="zoom:50%;" />

# vue3新特性&源码解析（3/3）

https://www.yuque.com/lpldplws/web/ty5nga?singleDoc# 《Vue3新特性&源码解析（3/3）》 密码：apwp

## 1. 课程目标

掌握面试高频考点，从理论的角度分析问题后再代入源码，保证能够完整的掌握Vue3的内容；

## 2.课程大纲

- Diff算法

## 3. Diff算法

diff算法的目的是为了找到哪些节点发生了变化，哪些节点没有发生变化可以复用。如果用最传统的diff算法，如下图所示，每个节点都要遍历另一棵树上的所有节点做比较，这就是o(n^2)的复杂度，加上更新节点时的o(n)复杂度，那就总共达到了o(n^3)的复杂度，这对于一个结构复杂节点数众多的页面，成本是非常大的。

![vue3-Diff](/Volumes/F/zyl-study/web-zhuawa/20221203/vue3-Diff.png)



实际上vue和react都对虚拟dom的diff算法做了一定的优化，将复杂度降低到了o(n)级别，具体的策略是：同层的节点才相互比较；

1. 节点比较时，如果类型不同，则对该节点及其所有子节点直接销毁新建；

2. 类型相同的子节点，使用key帮助查找，并且使用算法优化查找效率。其中react和vue2以及vue3的diff算法都不尽相同；

   ![vue3同层的diff](/Volumes/F/zyl-study/web-zhuawa/20221203/vue3同层的diff.png)

主要对比Vue2和Vue3，掌握为什么要从Vue2升级到Vue3，并代入后续代码，掌握Vue实现diff的流程；

前提：

- `mount(vnode, parent, [refNode])`: 通过`vnode`生成真实的DOM节点。parent为其父级的真实DOM节点，`refNode`为真实的DOM节点，其父级节点为parent。如果refNode不为空，vnode生成的DOM节点就会插入到refNode之前；如果refNode为空，那么vnode生成的DOM节点就作为最后一个子节点插入到parent中
- `patch(prevNode, nextNode, parent)`: 可以简单的理解为给当前DOM节点进行更新，并且调用diff算法对比自身的子节点;

### 3.1 vue2 diff-双端比较

双端比较就是新列表和旧列表两个列表的头与尾互相对比，在对比的过程中指针会逐渐向内靠拢，直到某一个列表的节点全部遍历过，对比停止；

#### 3.1.1  patch

先判断是否是首次渲染，如果是首次渲染那么我们就直接createElm即可；如果不是就去判断新老两个节点的元素类型否一样；如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode；

```js
function patch(oldVnode, vnode, hydrating, removeOnly) {
    // 判断新的vnode是否为空
    if (isUndef(vnode)) {
      // 如果老的vnode不为空 卸载所有的老vnode
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }
    let isInitialPatch = false
    // 用来存储 insert钩子函数，在插入节点之前调用
    const insertedVnodeQueue = []
    // 如果老节点不存在，直接创建新节点
    if (isUndef(oldVnode)) {
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      // 是不是元素节点
      const isRealElement = isDef(oldVnode.nodeType)
      // 当老节点不是真实的DOM节点，并且新老节点的type和key相同，进行patchVnode更新工作
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        // 如果不是同一元素节点的话
        // 当老节点是真实DOM节点的时候
        if (isRealElement) {
          // 如果是元素节点 并且在SSR环境的时候 修改SSR_ATTR属性
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            // 就是服务端渲染的，删掉这个属性
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          // 这个判断里是服务端渲染的处理逻辑
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            }
          }
          // 如果不是服务端渲染的，或者混合失败，就创建一个空的注释节点替换 oldVnode
          oldVnode = emptyNodeAt(oldVnode)
        }

        // 拿到 oldVnode 的父节点
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // 根据新的 vnode 创建一个 DOM 节点，挂载到父节点上
        createElm(
          vnode,
          insertedVnodeQueue,
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )
        // 如果新的 vnode 的根节点存在，就是说根节点被修改了，就需要遍历更新父节点
        // 递归 更新父占位符元素
        // 就是执行一遍 父节点的 destory 和 create 、insert 的 钩子函数
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          // 更新父组件的占位元素
          while (ancestor) {
            // 卸载老根节点下的全部组件
            for (let i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            // 替换现有元素
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (let i = 1; i < insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            // 更新父节点
            ancestor = ancestor.parent
          }
        }
        // 如果旧节点还存在，就删掉旧节点
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          // 否则直接卸载 oldVnode
          invokeDestroyHook(oldVnode)
        }
      }
    }
    // 执行 虚拟 dom 的 insert 钩子函数
    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    // 返回最新 vnode 的 elm ，也就是真实的 dom节点
    return vnode.elm
 }
```

### 3.1.2 patchVnode

- 如果`Vnode`和`oldVnode`指向同一个对象，则直接return即可；
- 将旧节点的真实 DOM 赋值到新节点（真实 dom 连线到新子节点）称为elm，然后遍历调用 update 更新 `oldVnode `上的所有属性，比如 class,style,attrs,domProps,events...；
- 如果新老节点都有文本节点，并且文本不相同，那么就用`vnode`.text更新文本内容。
- 如果oldVnode有子节点而`Vnode`没有，则直接删除老节点即可；
- 如果oldVnode没有子节点而`Vnode`有，则将Vnode的子节点真实化之后添加到DOM中即可。
- 如果两者都有子节点，则执行`updateChildren`函数比较子节点。

```js
function patchVnode(
    oldVnode, // 老的虚拟 DOM 节点
    vnode, // 新节点
    insertedVnodeQueue, // 插入节点队列
    ownerArray, // 节点数组
    index, // 当前节点的下标
    removeOnly
  ) {
    // 新老节点对比地址一样，直接跳过
    if (oldVnode === vnode) {
      return
    }
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode)
    }
    const elm = vnode.elm = oldVnode.elm
    // 如果当前节点是注释或 v-if 的，或者是异步函数，就跳过检查异步组件
    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)
      } else {
        vnode.isAsyncPlaceholder = true
      }
      return
    }
    // 当前节点是静态节点的时候，key 也一样，或者有 v-once 的时候，就直接赋值返回
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance
      return
    }
    let i
    const data = vnode.data
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode)
    }
    const oldCh = oldVnode.children
    const ch = vnode.children
    if (isDef(data) && isPatchable(vnode)) {
      // 遍历调用 update 更新 oldVnode 所有属性，比如 class,style,attrs,domProps,events...
      // 这里的 update 钩子函数是 vnode 本身的钩子函数
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
      // 这里的 update 钩子函数是我们传过来的函数
      if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode)
    }
    // 如果新节点不是文本节点，也就是说有子节点
    if (isUndef(vnode.text)) {
      // 如果新老节点都有子节点
      if (isDef(oldCh) && isDef(ch)) {
        // 如果新老节点的子节点不一样，就执行 updateChildren 函数，对比子节点
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
      } else if (isDef(ch)) {
        // 如果新节点有子节点的话，就是说老节点没有子节点

        // 如果老节点是文本节点，就是说没有子节点，就清空
        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')
        // 添加新节点
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
      } else if (isDef(oldCh)) {
        // 如果新节点没有子节点，老节点有子节点，就删除
        removeVnodes(oldCh, 0, oldCh.length - 1)
      } else if (isDef(oldVnode.text)) {
        // 如果老节点是文本节点，就清空
        nodeOps.setTextContent(elm, '')
      }
    } else if (oldVnode.text !== vnode.text) {
      // 如果老节点的文本和新节点的文本不同，就更新文本
      nodeOps.setTextContent(elm, vnode.text)
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) i(oldVnode, vnode)
    }
 }
```

#### 3.1.3 updatChildren

为了方便理解，这里手动实现vue2中的updateChildren

##### 3.1.3.1 实现思路

我们先用四个指针指向两个列表的头尾

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[nextStartIndex],
    newEndNode = nextChildren[nextEndIndex];
}
```


根据四个指针找到四个节点，然后进行对比，那么如何对比呢？我们按照以下四个步骤进行对比

1. 使用旧列表的头一个节点`oldStartNode`与新列表的头一个节点`newStartNode`对比；
2. 使用旧列表的最后一个节点`oldEndNode`与新列表的最后一个节点`newEndNode`对比；
3. 使用旧列表的头一个节点`oldStartNode`与新列表的最后一个节点`newEndNode`对比；
4. 使用旧列表的最后一个节点`oldEndNode`与新列表的头一个节点`newStartNode`对比；

使用以上四步进行对比，去寻找key相同的可复用的节点，当在某一步中找到了则停止后面的寻找。具体对比顺序如下图：

![vue2-diff具体实现](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现.png)



对比顺序代码结构如下：

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newEndIndex];
  
  if (oldStartNode.key === newStartNode.key) {

  } else if (oldEndNode.key === newEndNode.key) {

  } else if (oldStartNode.key === newEndNode.key) {

  } else if (oldEndNode.key === newStartNode.key) {

  }
}
```

当对比时找到了可复用的节点，我们还是先`patch`给元素打补丁，然后将指针进行前/后移一位指针。根据对比节点的不同，我们移动的指针和方向也不同，具体规则如下：

1. 当旧列表的头一个节点`oldStartNode`与新列表的头一个节点`newStartNode`对比时key相同。那么旧列表的头指针`oldStartIndex`与新列表的头指针`newStartIndex`同时向后移动一位；
2. 当旧列表的最后一个节点`oldEndNode`与新列表的最后一个节点`newEndNode`对比时key相同。那么旧列表的尾指针oldEndIndex与新列表的尾指针`newEndIndex`同时向前移动一位；
3. 当旧列表的头一个节点`oldStartNode`与新列表的最后一个节点`newEndNode`对比时key相同。那么旧列表的头指针`oldStartIndex`向后移动一位；新列表的尾指针`newEndIndex`向前移动一位；
4. 当旧列表的最后一个节点`oldEndNode`与新列表的头一个节点`newStartNode`对比时key相同。那么旧列表的尾指针`oldEndIndex`向前移动一位；新列表的头指针`newStartIndex`向后移动一位；

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    oldEndIndex = prevChildren.length - 1,
    newStartIndex = 0,
    newEndIndex = nextChildren.length - 1;
  let oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldEndIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newEndIndex];

  if (oldStartNode.key === newStartNode.key) {
    patch(oldvStartNode, newStartNode, parent)

    oldStartIndex++
    newStartIndex++
    oldStartNode = prevChildren[oldStartIndex]
    newStartNode = nextChildren[newStartIndex]
  } else if (oldEndNode.key === newEndNode.key) {
    patch(oldEndNode, newEndNode, parent)

    oldEndIndex--
    newEndIndex--
    oldEndNode = prevChildren[oldEndIndex]
    newEndNode = nextChildren[newEndIndex]
  } else if (oldStartNode.key === newEndNode.key) {
    patch(oldStartNode, newEndNode, parent)

    oldStartIndex++
    newEndIndex--
    oldStartNode = prevChildren[oldStartIndex]
    newEndNode = nextChildren[newEndIndex]
  } else if (oldEndNode.key === newStartNode.key) {
    patch(oldEndNode, newStartNode, parent)

    oldEndIndex--
    nextStartIndex++
    oldEndNode = prevChildren[oldEndIndex]
    newStartNode = nextChildren[newStartIndex]
  }
}
```

至此整体的循环我们就全部完成了，下面我们需要考虑这样两个问题：

- 什么情况下DOM节点需要移动；
- DOM节点如何移动；

我们来解决第一个问题：什么情况下需要移动，我们还是以上图为例：

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现2.png" alt="vue2-diff具体实现2" style="zoom: 67%;" />

当我们在第一个循环时，在第四步发现旧列表的尾节点oldEndNode与新列表的头节点newStartNode的key相同，是可复用的DOM节点。通过观察我们可以发现，原本在旧列表末尾的节点，却是新列表中的开头节点，没有人比他更靠前，因为他是第一个，所以我们只需要把当前的节点移动到原本旧列表中的第一个节点之前，让它成为第一个节点即可。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
 // ...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
       // ...
    } else if (oldEndNode.key === newEndNode.key) {
      // ...
    } else if (oldStartNode.key === newEndNode.key) {
      // ...
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)
      // 移动到旧列表头节点之前
      parent.insertBefore(oldEndNode.el, oldStartNode.el)
      
      oldEndIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldEndIndex]
      newStartNode = nextChildren[newStartIndex]
    }
  }
}
```

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现3.png" alt="vue2-diff具体实现3" style="zoom:67%;" />

进入第二次循环，我们在第二步发现，旧列表的尾节点`oldEndNode`和新列表的尾节点`newEndNode`为复用节点。原本在旧列表中就是尾节点，在新列表中也是尾节点，说明该节点不需要移动，所以我们什么都不需要做。

同理，如果是旧列表的头节点`oldStartNode`和新列表的头节点`newStartNode`为复用节点，我们也什么都不需要做

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现4.png" alt="vue2-diff具体实现4" style="zoom:67%;" />

![img](https://cdn.nlark.com/yuque/0/2022/webp/2340337/1659366689365-b379cb31-3e87-4afa-a4d6-3bcf68a3c720.webp)

进入第三次循环，我们在第三部发现，旧列表的头节点`oldStartNode`和新列表的尾节点`newEndNode`为复用节点。，我们只要将DOM-A移动到DOM-B后面就可以了。

依照惯例我们还是解释一下，原本旧列表中是头节点，然后在新列表中是尾节点。那么只要在旧列表中把当前的节点移动到原本尾节点的后面，就可以了。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  // ...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
      // ...
    } else if (oldEndNode.key === newEndNode.key) {
      // ...
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldStartNode, newEndNode, parent)
      parent.insertBefore(oldStartNode.el, oldEndNode.el.nextSibling)

      oldStartIndex++
      newEndIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newEndIndex]
    } else if (oldEndNode.key === newStartNode.key) {
     //...
    }
  }
}
```

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现5.png" alt="vue2-diff具体实现5" style="zoom:67%;" />

进入最后一个循环。在第一步旧列表头节点`oldStartNode`与新列表头节点`newStartNode`位置相同，所以啥也不用做。然后结束循环。

##### 3.1.3.2 非理想情况

上文中有一个特殊情况，当四次对比都没找到复用节点时，我们只能拿新列表的第一个节点去旧列表中找与其key相同的节点。

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现6.png" alt="vue2-diff具体实现6" style="zoom:67%;" />

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
    }
  }
}
```

找节点的时候其实会有两种情况：一种在旧列表中找到了，另一种情况是没找到。

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现7.png" alt="vue2-diff具体实现7" style="zoom:67%;" />

当我们在旧列表中找到对应的VNode，我们只需要将找到的节点的DOM元素，移动到开头就可以了。这里的逻辑其实和第四步的逻辑是一样的，只不过第四步是移动的尾节点，这里是移动找到的节点。DOM移动后，由我们将旧列表中的节点改为undefined，这是至关重要的一步，因为我们已经做了节点的移动了所以我们不需要进行再次的对比了。最后我们将头指针newStartIndex向后移一位。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newtKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
      if (oldIndex > -1) {
        let oldNode = prevChildren[oldIndex];
        patch(oldNode, newStartNode, parent)
        parent.insertBefore(oldNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      }
      newStartNode = nextChildren[++newStartIndex]
    }
  }
}
```

如果在旧列表中没有找到复用节点，就直接创建一个新的节点放到最前面就可以了，然后后移头指针`newStartIndex`。

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现8.png" alt="vue2-diff具体实现8" style="zoom:67%;" />

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newtKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
      if (oldIndex > -1) {
        let oldNode = prevChildren[oldIndex];
        patch(oldNode, newStartNode, parent)
        parent.insertBefore(oldNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      } else {
      	mount(newStartNode, parent, oldStartNode.el)
      }
      newStartNode = nextChildren[++newStartIndex]
    }
  }
}
```

最后当旧列表遍历到undefind时就跳过当前节点。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode === undefind) {
    	oldStartNode = prevChildren[++oldStartIndex]
    } else if (oldEndNode === undefind) {
    	oldEndNode = prevChildren[--oldEndIndex]
    } else if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
    // ...
    }
  }
}
```

##### 3.1.3.3 添加节点

![vue2-diff具体实现9](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现9.png)



针对上述例子，几次循环都是尾节点相同，尾指针一直向前移动，直到循环结束；

![vue2-diff具体实现10](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现10.png)



此时`oldEndIndex`以及小于了`oldStartIndex`，但是新列表中还有剩余的节点，我们只需要将剩余的节点依次插入到`oldStartNode`的DOM之前就可以了。为什么是插入`oldStartNode`之前呢？原因是剩余的节点在新列表的位置是位于`oldStartNode`之前的，如果剩余节点是在`oldStartNode`之后，`oldStartNode`就会先行对比

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
  // ...
  }
  if (oldEndIndex < oldStartIndex) {
    for (let i = newStartIndex; i <= newEndIndex; i++) {
      mount(nextChildren[i], parent, prevStartNode.el)
    }
  }
}
```

##### 3.1.3.4 移除节点

当新列表的`newEndIndex`小于`newStartIndex`时，我们将旧列表剩余的节点删除即可。这里我们需要注意，旧列表的undefind。在第二小节中我们提到过，当头尾节点都不相同时，我们会去旧列表中找新列表的第一个节点，移动完DOM节点后，将旧列表的那个节点改为undefind。所以我们在最后的删除时，需要注意这些undefind，遇到的话跳过当前循环即可。

```js
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
  // ...
  }
  if (oldEndIndex < oldStartIndex) {
    for (let i = newStartIndex; i <= newEndIndex; i++) {
      mount(nextChildren[i], parent, prevStartNode.el)
    }
  } else if (newEndIndex < newStartIndex) {
    for (let i = oldStartIndex; i <= oldEndIndex; i++) {
      if (prevChildren[i]) {
        partent.removeChild(prevChildren[i].el)
      }
    }
  }
}
```

##### 3.1.3.5 总结

```js
function vue2diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    newStartIndex = 0,
    oldStartIndex = prevChildren.length - 1,
    newStartIndex = nextChildren.length - 1,
    oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldStartIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newStartIndex];
  while (oldStartIndex <= oldStartIndex && newStartIndex <= newStartIndex) {
    if (oldStartNode === undefined) {
      oldStartNode = prevChildren[++oldStartIndex]
    } else if (oldEndNode === undefined) {
      oldEndNode = prevChildren[--oldStartIndex]
    } else if (oldStartNode.key === newStartNode.key) {
      patch(oldStartNode, newStartNode, parent)

      oldStartIndex++
      newStartIndex++
      oldStartNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newEndNode.key) {
      patch(oldEndNode, newEndNode, parent)

      oldStartIndex--
      newStartIndex--
      oldEndNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldStartNode, newEndNode, parent)
      parent.insertBefore(oldStartNode.el, oldEndNode.el.nextSibling)
      oldStartIndex++
      newStartIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)
      parent.insertBefore(oldEndNode.el, oldStartNode.el)
      oldStartIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else {
      let newKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child && (child.key === newKey));
      if (oldIndex === -1) {
        mount(newStartNode, parent, oldStartNode.el)
      } else {
        let prevNode = prevChildren[oldIndex]
        patch(prevNode, newStartNode, parent)
        parent.insertBefore(prevNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      }
      newStartIndex++
      newStartNode = nextChildren[newStartIndex]
    }
  }
  if (newStartIndex > newStartIndex) {
    while (oldStartIndex <= oldStartIndex) {
      if (!prevChildren[oldStartIndex]) {
        oldStartIndex++
        continue
      }
      parent.removeChild(prevChildren[oldStartIndex++].el)
    }
  } else if (oldStartIndex > oldStartIndex) {
    while (newStartIndex <= newStartIndex) {
      mount(nextChildren[newStartIndex++], parent, oldStartNode.el)
    }
  }
}
```

#### 3.1.4 缺点

Vue2 是全量 Diff（当数据发生变化，它就会新生成一个DOM树，并和之前的DOM树进行比较，找到不同的节点然后更新），如果层级很深，很消耗内存；

### 3.2 vue3 diff-最长递增子序列

#### 3.2.1 vue3 diff优化点

1. 静态标记 + 非全量 Diff：（Vue 3在创建虚拟DOM树的时候，会根据DOM中的内容会不会发生变化，添加一个静态标记。之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。）；
2. 使用最长递增子序列优化对比流程，可以最大程度的减少 DOM 的移动，达到最少的 DOM 操作；

#### 3.2.2 实现思路

vue3的diff算法其中有两个理念。第一个是相同的前置与后置元素的预处理；第二个则是最长递增子序列

##### 3.2.2.1 前置与后置的预处理

我们看着两段文字

```js
hello xianzao
hey xianzao
```

我们会发现，这两段文字是有一部分是相同的，这些文字是不需要修改也不需要移动的，真正需要进行修改中间的几个字母，所以diff就变成以下部分

```js
text1: llo
text2: y
```

接下来换成`vnode`：

![vue2-diff具体实现11](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现11.png)

图中的被绿色框起来的节点，他们是不需要移动的，只需要进行打补丁`patch`就可以了。我们把该逻辑写成代码。

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  let j = 0,
    prevEnd = prevChildren.length - 1,
    nextEnd = nextChildren.length - 1,
    prevNode = prevChildren[j],
    nextNode = nextChildren[j];
  while (prevNode.key === nextNode.key) {
    patch(prevNode, nextNode, parent)
    j++
    prevNode = prevChildren[j]
    nextNode = nextChildren[j]
  }
  
  prevNode = prevChildren[prevEnd]
  nextNode = prevChildren[nextEnd]
  
  while (prevNode.key === nextNode.key) {
    patch(prevNode, nextNode, parent)
    prevEnd--
    nextEnd--
    prevNode = prevChildren[prevEnd]
    nextNode = prevChildren[nextEnd]
  }
}
```

这时候，我们需要考虑边界情况，一种是j > prevEnd；另一种是j > nextEnd。

![vue2-diff具体实现12](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现12.png)

在上图中，此时j > prevEnd且j <= nextEnd，只需要把新列表中 j 到nextEnd之间剩下的节点插入进去就可以了。相反， 如果j > nextEnd时，把旧列表中 j 到prevEnd之间的节点删除就可以了。

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  // ...
  if (j > prevEnd && j <= nextEnd) {
    let nextpos = nextEnd + 1,
      refNode = nextpos >= nextChildren.length
                ? null
                : nextChildren[nextpos].el;
    while(j <= nextEnd) mount(nextChildren[j++], parent, refNode)
    
  } else if (j > nextEnd && j <= prevEnd) {
    while(j <= prevEnd) parent.removeChild(prevChildren[j++].el)
  }
}
```

在while循环时，指针是从两端向内逐渐靠拢的，所以我们应该在循环中就应该去判断边界情况，我们使用label语法，当我们触发边界情况时，退出全部的循环，直接进入判断：

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  let j = 0,
    prevEnd = prevChildren.length - 1,
    nextEnd = nextChildren.length - 1,
    prevNode = prevChildren[j],
    nextNode = nextChildren[j];
  // label语法
  outer: {
    while (prevNode.key === nextNode.key) {
      patch(prevNode, nextNode, parent)
      j++
      // 循环中如果触发边界情况，直接break，执行outer之后的判断
      if (j > prevEnd || j > nextEnd) break outer
      prevNode = prevChildren[j]
      nextNode = nextChildren[j]
    }

    prevNode = prevChildren[prevEnd]
    nextNode = prevChildren[nextEnd]

    while (prevNode.key === nextNode.key) {
      patch(prevNode, nextNode, parent)
      prevEnd--
      nextEnd--
      // 循环中如果触发边界情况，直接break，执行outer之后的判断
      if (j > prevEnd || j > nextEnd) break outer
      prevNode = prevChildren[prevEnd]
      nextNode = prevChildren[nextEnd]
    }
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    let nextpos = nextEnd + 1,
      refNode = nextpos >= nextChildren.length
                ? null
                : nextChildren[nextpos].el;
    while(j <= nextEnd) mount(nextChildren[j++], parent, refNode)
    
  } else if (j > nextEnd && j <= prevEnd) {
    while(j <= prevEnd) parent.removeChild(prevChildren[j++].el)
  }
}
```

##### 3.2.2.2 判断是否需要移动

接下来，就是找到移动的节点，然后给他移动到正确的位置

当前/后置的预处理结束后，我们进入真正的diff环节。首先，我们先根据新列表剩余的节点数量，创建一个source数组，并将数组填满-1。

![vue2-diff具体实现13](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现13.png)



```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  outer: {
  // ...
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    // ...
  } else if (j > nextEnd && j <= prevEnd) {
    // ...
  } else {
    let prevStart = j,
      nextStart = j,
      nextLeft = nextEnd - nextStart + 1,     // 新列表中剩余的节点长度
      source = new Array(nextLeft).fill(-1);  // 创建数组，填满-1
     
  }
}
```

source是用来做新旧节点的对应关系的，我们将新节点在旧列表的位置存储在该数组中，我们在根据source计算出它的最长递增子序列用于移动DOM节点。为此，先建立一个对象存储当前新列表中的节点与index的关系，再去旧列表中去找位置。

注意：如果旧节点在新列表中没有的话，直接删除就好。除此之外，我们还需要一个数量表示记录我们已经patch过的节点，如果数量已经与新列表剩余的节点数量一样，那么剩下的旧节点我们就直接删除了就可以了

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  outer: {
  // ...
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    // ...
  } else if (j > nextEnd && j <= prevEnd) {
    // ...
  } else {
    let prevStart = j,
      nextStart = j,
      nextLeft = nextEnd - nextStart + 1,     // 新列表中剩余的节点长度
      source = new Array(nextLeft).fill(-1),  // 创建数组，填满-1
      nextIndexMap = {},                      // 新列表节点与index的映射
      patched = 0;                            // 已更新过的节点的数量
      
    // 保存映射关系  
    for (let i = nextStart; i <= nextEnd; i++) {
      let key = nextChildren[i].key
      nextIndexMap[key] = i
    } 
    
    // 去旧列表找位置
    for (let i = prevStart; i <= prevEnd; i++) {
      let prevNode = prevChildren[i],
      	prevKey = prevNode.key,
        nextIndex = nextIndexMap[prevKey];
      // 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点
      if (nextIndex === undefind || patched >= nextLeft) {
        parent.removeChild(prevNode.el)
        continue
      }
      // 找到对应的节点
      let nextNode = nextChildren[nextIndex];
      patch(prevNode, nextNode, parent);
      // 给source赋值
      source[nextIndex - nextStart] = i
      patched++
    }
  }
}
```

![vue2-diff具体实现14](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现14.png)

找到位置后，我们观察这个重新赋值后的source，我们可以看出，如果是全新的节点的话，其在source数组中对应的值就是初始的-1，通过这一步我们可以区分出来哪个为全新的节点，哪个是可复用的。
其次，我们要判断是否需要移动，如果我们找到的index是一直递增的，说明不需要移动任何节点。我们通过设置一个变量来保存是否需要移动的状态。

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  outer: {
  // ...
  }
  
  // 边界情况的判断
  if (j > prevEnd && j <= nextEnd) {
    // ...
  } else if (j > nextEnd && j <= prevEnd) {
    // ...
  } else {
    let prevStart = j,
      nextStart = j,
      nextLeft = nextEnd - nextStart + 1,     // 新列表中剩余的节点长度
      source = new Array(nextLeft).fill(-1),  // 创建数组，填满-1
      nextIndexMap = {},                      // 新列表节点与index的映射
      patched = 0,
      move = false,                           // 是否移动
      lastIndex = 0;                          // 记录上一次的位置
      
    // 保存映射关系  
    for (let i = nextStart; i <= nextEnd; i++) {
      let key = nextChildren[i].key
      nextIndexMap[key] = i
    } 
    
    // 去旧列表找位置
    for (let i = prevStart; i <= prevEnd; i++) {
      let prevNode = prevChildren[i],
      	prevKey = prevNode.key,
        nextIndex = nextIndexMap[prevKey];
      // 新列表中没有该节点 或者 已经更新了全部的新节点，直接删除旧节点
      if (nextIndex === undefind || patched >= nextLeft) {
        parent.removeChild(prevNode.el)
        continue
      }
      // 找到对应的节点
      let nextNode = nextChildren[nextIndex];
      patch(prevNode, nextNode, parent);
      // 给source赋值
      source[nextIndex - nextStart] = i
      patched++
      
      // 递增方法，判断是否需要移动
      if (nextIndex < lastIndex) {
      	move = true
      } else {
      	lastIndex = nextIndex
      }
    }
    
    if (move) {
    
    // 需要移动
    } else {
	
    //不需要移动
    }
  }
}
```

##### 3.3.2.3 DOM如何移动

判断完是否需要移动后，我们就需要考虑如何移动了。一旦需要进行DOM移动，我们首先要做的就是找到source的最长递增子序列。vue2和vue3响应式的区别

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
	const seq = lis(source); // [0, 1]
  // 需要移动
  } else {

  //不需要移动
  }
}
```

最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。

例如给定数值序列为：[ 0, 8, 4, 12 ]。

那么它的最长递增子序列就是：[0, 8, 12]。 

当然答案可能有多种情况，例如：[0, 4, 12] 也是可以的。

上面的代码中，我们调用lis 函数求出数组source的最长递增子序列为[ 0, 1 ]。我们知道 source 数组的值为 [2, 3, 1, -1]，很显然最长递增子序列应该是[ 2, 3 ]，计算出的结果是[ 0, 1 ]代表的是最长递增子序列中的各个元素在source数组中的位置索引，如下图所示：

![vue2-diff具体实现15](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现15.png)

我们根据source，对新列表进行重新编号，并找出了最长递增子序列。

我们从后向前进行遍历source每一项。此时会出现三种情况：

1. 当前的值为-1，这说明该节点是全新的节点，又由于我们是从后向前遍历，我们直接创建好DOM节点插入到队尾就可以了；
2. 当前的索引为最长递增子序列中的值，也就是i === seq[j]，这说说明该节点不需要移动；
3. 当前的索引不是最长递增子序列中的值，那么说明该DOM节点需要移动，这里也很好理解，我们也是直接将DOM节点插入到队尾就可以了，因为队尾是排好序的；

![vue2-diff具体实现16](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现16.png)

```js
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
   // 需要移动
	const seq = lis(source); // [0, 1]
    let j = seq.length - 1;  // 最长子序列的指针
    // 从后向前遍历
    for (let i = nextLeft - 1； i >= 0; i--) {
      let pos = nextStart + i, // 对应新列表的index
        nextNode = nextChildren[pos],	// 找到vnode
      	nextPos = pos + 1，    // 下一个节点的位置，用于移动DOM
        refNode = nextPos >= nextChildren.length ? null : nextChildren[nextPos].el, //DOM节点
        cur = source[i];  // 当前source的值，用来判断节点是否需要移动
    
      if (cur === -1) {
        // 情况1，该节点是全新节点
      	mount(nextNode, parent, refNode)
      } else if (cur === seq[j]) {
        // 情况2，是递增子序列，该节点不需要移动
        // 让j指向下一个
        j--
      } else {
        // 情况3，不是递增子序列，该节点需要移动
        parent.insetBefore(nextNode.el, refNode)
      }
    }
 
  } else {
  //不需要移动
  
  }
}
```

说完了需要移动的情况，再说说不需要移动的情况。如果不需要移动的话，我们只需要判断是否有全新的节点给他添加进去就可以了。具体代码如下：

```js

function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
	const seq = lis(source); // [0, 1]
    let j = seq.length - 1;  // 最长子序列的指针
    // 从后向前遍历
    for (let i = nextLeft - 1； i >= 0; i--) {
      let pos = nextStart + i, // 对应新列表的index
        nextNode = nextChildren[pos],	// 找到vnode
      	nextPos = pos + 1，    // 下一个节点的位置，用于移动DOM
        refNode = nextPos >= nextChildren.length ? null : nextChildren[nextPos].el, //DOM节点
        cur = source[i];  // 当前source的值，用来判断节点是否需要移动
    
      if (cur === -1) {
        // 情况1，该节点是全新节点
      	mount(nextNode, parent, refNode)
      } else if (cur === seq[j]) {
        // 情况2，是递增子序列，该节点不需要移动
        // 让j指向下一个
        j--
      } else {
        // 情况3，不是递增子序列，该节点需要移动
        parent.insetBefore(nextNode.el, refNode)
      }
    }
  } else {
    //不需要移动
    for (let i = nextLeft - 1； i >= 0; i--) {
      let cur = source[i];  // 当前source的值，用来判断节点是否需要移动
    
      if (cur === -1) {
       let pos = nextStart + i, // 对应新列表的index
          nextNode = nextChildren[pos],	// 找到vnode
          nextPos = pos + 1，    // 下一个节点的位置，用于移动DOM
          refNode = nextPos >= nextChildren.length ? null : nextChildren[nextPos].el, //DOM节点
      	mount(nextNode, parent, refNode)
      }
    }
  }
}
```

#### 3.2.3 最长递增子序列

强烈建议看leetcode原题解法：https://leetcode.cn/problems/longest-increasing-subsequence/

我们以该数组为例

```js
[10,9,2,5,3,8,7,13]
```

我们可以使用动态规划的思想考虑这个问题。动态规划的思想是将一个大的问题分解成多个小的子问题，并尝试得到这些子问题的最优解，子问题的最优解有可能会在更大的问题中被利用，这样通过小问题的最优解最终求得大问题的最优解。

我们先假设只有一个值的数组[13]，那么该数组的最长递增子序列就是[13]自己本身，其长度为1。那么我们认为每一项的递增序列的长度值均为1

那么我们这次给数组增加一个值[7, 13], 由于7 < 13，所以该数组的最长递增子序列是[7, 13]，那么该长度为2。那么我们是否可以认为，当[7]小于[13]时，以[7]为头的递增序列的长度是，[7]的长度和[13]的长度的和，即1 + 1 = 2。

ok，我们基于这种思想来给计算一下该数组。我们先将每个值的初始赋值为1

![vue2-diff具体实现17](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现17.png)

首先 7 < 13 那么7对应的长度就是13的长度再加1，1 + 1 = 2

![vue2-diff具体实现18](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现18.png)



继续，我们对比8。我们首先和7比，发现不满足递增，但是没关系我们还可以继续和13比，8 < 13满足递增，那么8的长度也是13的长度在加一，长度为2

![vue2-diff具体实现19](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现19.png)



我们再对比3，我们先让其与8进行对比，3 < 8，那么3的长度是8的长度加一，此时3的长度为3。但是还没结束，我们还需要让3与7对比。同样3 < 7，此时我们需要在计算出一个长度是7的长度加一同样是3，我们对比两个长度，如果原本的长度没有本次计算出的长度值大的话，我们进行替换，反之则我们保留原本的值。由于3 === 3，我们选择不替换。最后，我们让3与13进行对比，同样的3 < 13，此时计算出的长度为2，比原本的长度3要小，我们选择保留原本的值。

![vue2-diff具体实现20](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现20.png)



![vue2-diff具体实现21](/Volumes/F/zyl-study/web-zhuawa/20221203/vue2-diff具体实现21.png)

我们从中取最大的值4，该值代表的最长递增子序列的个数。代码如下：

```js
function lis(arr) {
  let len = arr.length,
    dp = new Array(len).fill(1); // 用于保存长度
  for (let i = len - 1; i >= 0; i--) {
    let cur = arr[i]
    for(let j = i + 1; j < len; j++) {
      let next = arr[j]
      // 如果是递增 取更大的长度值
      if (cur < next) dp[i] = Math.max(dp[j]+1, dp[i])
    }
  }
  return Math.max(...dp)
}
```

在vue3.0中，我们需要的是最长递增子序列在原本数组中的索引。所以我们还需要在创建一个数组用于保存每个值的最长子序列所对应在数组中的index。具体代码如下

```js
function lis(arr) {
  let len = arr.length,
    res = [],
    dp = new Array(len).fill(1);
  // 存默认index
  for (let i = 0; i < len; i++) {
    res.push([i])
  }
  for (let i = len - 1; i >= 0; i--) {
    let cur = arr[i],
      nextIndex = undefined;
    // 如果为-1 直接跳过，因为-1代表的是新节点，不需要进行排序
    if (cur === -1) continue
    for (let j = i + 1; j < len; j++) {
      let next = arr[j]
      // 满足递增条件
      if (cur < next) {
        let max = dp[j] + 1
        // 当前长度是否比原本的长度要大
        if (max > dp[i]) {
          dp[i] = max
          nextIndex = j
        }
      }
    }
    // 记录满足条件的值，对应在数组中的index
    if (nextIndex !== undefined) res[i].push(...res[nextIndex])
  }
  let index = dp.reduce((prev, cur, i, arr) => cur > arr[prev] ? i : prev, dp.length - 1)
  // 返回最长的递增子序列的index
  return result[index]
}
```

# Vue Router 源码解析（1/2）

https://www.yuque.com/lpldplws/web/gkiov622439zf64o?singleDoc# 《Vue Router源码解析(1/2)》 密码：zdfy

## 1.课程目标

1. 掌握Vue Router的核心源码；
2. 掌握前端中一个完整的Router需要实现怎样的效果；

## 2.课程大纲

- vue router源码解析

## 3.前置内容

1. 课前准备：将Vue Router官网中[教程](https://router.vuejs.org/zh/guide/)通读一遍；
2. 版本选择：选择的Vue Router版本为[V4.0.15](https://github.com/vuejs/router/releases/tag/v4.0.15)，跟目前最新版本除了极少部分调整外无任何区别；

## 4.router.install解析

### 4.1 vue-router的使用

在介绍`router.install`之前，我们先看下vue3中是如何使用`vue-router`的：

```js
import { createApp } from 'vue'
import { createRouter } from 'vue-router'

const router = createRouter({ ... })
const app = createApp({})

app.use(router).mount('#app')
```

在执行app.use的过程中，会执行router.install,并传入app实例（即安装插件）。那么详细看一下router.install的过程

### 4.2 router.install

Router.install源码位于createRouter中，文件位置src/router.ts

```typescript
install(app: App) {
  const router = this
  app.component('RouterLink', RouterLink)
  app.component('RouterView', RouterView)

  app.config.globalProperties.$router = router
  Object.defineProperty(app.config.globalProperties, '$route', {
    enumerable: true,
    get: () => unref(currentRoute),
  })

  if (
    isBrowser &&
    !started &&
    currentRoute.value === START_LOCATION_NORMALIZED
  ) {
    started = true
    push(routerHistory.location).catch(err => {
      if (__DEV__) warn('Unexpected error when starting the router:', err)
    })
  }

  const reactiveRoute = {} as {
    [k in keyof RouteLocationNormalizedLoaded]: ComputedRef<
      RouteLocationNormalizedLoaded[k]
    >
  }
  for (const key in START_LOCATION_NORMALIZED) {
    reactiveRoute[key] = computed(() => currentRoute.value[key])
  }

  app.provide(routerKey, router)
  app.provide(routeLocationKey, reactive(reactiveRoute))
  app.provide(routerViewLocationKey, currentRoute)

  const unmountApp = app.unmount
  installedApps.add(app)
  app.unmount = function () {
    installedApps.delete(app)
    if (installedApps.size < 1) {
      pendingLocation = START_LOCATION_NORMALIZED
      removeHistoryListener && removeHistoryListener()
      removeHistoryListener = null
      currentRoute.value = START_LOCATION_NORMALIZED
      started = false
      ready = false
    }
    unmountApp()
  }

  if ((__DEV__ || __FEATURE_PROD_DEVTOOLS__) && isBrowser) {
    addDevtools(app, router, matcher)
  }
}
```

在intall中，首先会注册routerLink与routerview两大组件

```js
app.component('RouterLink', RouterLink)
app.component('RouterView', RouterView)
```

然后会将当前的`router`对象赋值给`app.config.globalProperties.$router`；

同时拦截了`app.config.globalProperties.$route`的get操作，使`app.config.globalProperties.$route`始终获取`unref(currentRoute)`，`unref(currentRoute)`就是当前路由的一些信息（这里就是Vue源码中`unref`的实现，可以看上节课关于Vue源码的讲解），这里我们先不深究，在后续章节中会详细介绍。

这样一来，就可以在组件中通过`this.$router`获取router，通过`this.$route`来获取当前路由信息。

```js
app.config.globalProperties.$router = router
Object.defineProperty(app.config.globalProperties, '$route', {
  enumerable: true,
  get: () => unref(currentRoute),
})
```

紧接着会根据浏览器url地址进行第一次跳转（如果是浏览器环境）。

```js
if (
  isBrowser &&
  // 用于初始导航客户端，避免在多个应用中使用路由器时多次push
  !started &&
  currentRoute.value === START_LOCATION_NORMALIZED
) {
  started = true
  push(routerHistory.location).catch(err => {
    if (__DEV__) warn('Unexpected error when starting the router:', err)
  })
}
```

紧接着声明了一个`reactiveRoute`响应式对象，并遍历`START_LOCATION_NORMALIZED`对象，依次将`START_LOCATION_NORMALIZED`中的key复制到`reactiveRoute`中，同时将`reactiveRoute`中key对应的值变成一个计算属性。

这里`START_LOCATION_NORMALIZED`是`vue-router`提供的初始路由位置，通过`START_LOCATION_NORMALIZED`构建一个响应式的路由`reactiveRoute`，方便对路由变化进行追踪。

```js
START_LOCATION_NORMALIZED const reactiveRoute = {} as {
  [k in keyof RouteLocationNormalizedLoaded]: ComputedRef<
    RouteLocationNormalizedLoaded[k]
  >
}
for (const key in START_LOCATION_NORMALIZED) {
  reactiveRoute[key] = computed(() => currentRoute.value[key])
}

app.provide(routerKey, router)
app.provide(routeLocationKey, reactive(reactiveRoute))
app.provide(routerViewLocationKey, currentRoute)
```

这里使用`provide`又将`router`、`currentRoute`注入到app实例中，你可能会疑问，在前面过程中已经可以在组件中使用`this.$router`，`this.$route`获取到对应数据了，这里为什么又使用`provide`再次注入呢？这是因为在`setup`中式无法访问`this`的，这时通过`inject`就可以方便获取`router`及`currentRoute`。

最后会将app放入一个哈希表中，然后重写`app.unmount`。当app卸载时，首先从哈希表中删除app，然后判断哈希表的大小是否小于1，如果小于1代表已经没有实例使用`vue-router`了，那么这时就需要重置一些状态、移除一些监听。

```js
const unmountApp = app.unmount
installedApps.add(app)
app.unmount = function () {
  installedApps.delete(app)
  if (installedApps.size < 1) {
    pendingLocation = START_LOCATION_NORMALIZED
    removeHistoryListener && removeHistoryListener()
    removeHistoryListener = null
    currentRoute.value = START_LOCATION_NORMALIZED
    started = false
    ready = false
  }
  unmountApp()
}
```

## 4.3总结

通过分析，`router.install`主要做以下几件事：

1. 注册`RouterLink`、`RouterView`组件；
2. 设置全局属性`$router`、`$route`；
3. 根据地址栏进行首次的路由跳转；
4. 向app中注入一些路由相关信息，如路由实例、响应式的当前路由信息对象；
5. 拦截`app.unmount`方法，在卸载之前重置一些属性、删除一些监听函数；

## 5.createHistory 解析

在`vue-router 4.x`中创建`router`时，需要使用`createWebHistory`、`createWebHashHistory`、`createMemoryHistory`中的一个创建一个`history`，如下：

```js
const routerHistory = createWebHistory()

const router = createRouter({
    history: routerHistory,
    routes: [ ... ]
}) import { createWebHistory, createRouter } from 'vue-router'

const routerHistory = createWebHistory()

const router = createRouter({
    history: routerHistory,
    routes: [ ... ]
})
```

接下来就对着三种方法进行解析：

### 5.1 createWebHistory

`createWebHistory`源码所处位置：`src/history/html5.ts`
首先来看`createWebHistory`的参数，函数可以接受一个`base`字符串可选参数，该参数提供了一个基础路径。
在`createWebHistory`中首先会调用`normalizeBase`函数对传入的base进行标准化。

```js
base = normalizeBase(base)
```

来看下`base`标准化的过程：

```js
export function normalizeBase(base?: string): string {
  if (!base) {
      // 浏览其环境下尝试获取base标签的href属性
    if (isBrowser) {
      const baseEl = document.querySelector('base')
      base = (baseEl && baseEl.getAttribute('href')) || '/'
      // 去除htttp(s)://xxx/，如https://example.com/folder/ --> /folder/
      base = base.replace(/^\w+:\/\/[^\/]+/, '')
    } else {
      base = '/'
    }
  }
  // 确保base的前导/
  if (base[0] !== '/' && base[0] !== '#') base = '/' + base

  return removeTrailingSlash(base)
}
```

如果没有配置base的话，在浏览器环境下会尝试获取<base>标签的href属性作为base，如果没有<base>标签或<base>标签的href属性没有值，base取/，然后又对base进行了reaplce(/^\w+:\/\/[^\/]+/, '')操作，该操作是去除base的http(s)://xxx部分（如果base是https://example.com/floder/child，base最终会变成/floder/child）；非浏览器环境下，base直接取/。在最后会将base的末尾/去除，然后返回base，这样做的目的是后续我们可以通过base + fullPath的形式建立一个href。 base标准化后，会声明一个historyNavigation和historyListeners变量：

```js
const historyNavigation = useHistoryStateNavigation(base)
const historyListeners = useHistoryListeners(
  base,
  historyNavigation.state,
  historyNavigation.location,
  historyNavigation.replace
)
```

接下来看下`useHistoryStateNavigation()`、`useHistoryListeners()`的实现。

先看`useHistoryStateNavigation`：

```js
function useHistoryStateNavigation(base: string) {
  // 获取window.history、window.location
  const { history, location } = window

  const currentLocation: ValueContainer<HistoryLocation> = {
    value: createCurrentLocation(base, location),
  }
  const historyState: ValueContainer<StateEntry> = { value:  }
  // 如果history.state是空的，构建一条新的历史记录
  if (!historyState.value) {
    changeLocation(
      currentLocation.value,
      {
        back: null,
        current: currentLocation.value,
        forward: null,
        position: history.length - 1,
        replaced: true,
        scroll: null,
      },
      true
    )
  }
  // 修改历史记录
  function changeLocation(
    to: HistoryLocation,
    state: StateEntry,
    replace: boolean
  ): void {
    const hashIndex = base.indexOf('#')
    // 获取url，作为history.replaceState/pushState的参数
    // 如果hashIndex > -1，url = `{location.host && document.querySelector('base') ? base : base字符串#及后面字符}${to}`
    // 否则 url = `${location.protocol}//${location.host}${base}${to}`
    const url =
      hashIndex > -1
        ? (location.host && document.querySelector('base')
            ? base
            : base.slice(hashIndex)) + to
        : createBaseLocation() + base + to
    try {
      // 利用history.replaceState/pushState修改历史记录
      history[replace ? 'replaceState' : 'pushState'](state, '', url)
      // historyState更新为最新的历史记录
      historyState.value = state
    } catch (err) { // 如果历史记录修改过程中报错，则使用location.reaplce/assign导航到对应url
      if (__DEV__) {
        warn('Error with push/replace State', err)
      } else {
        console.error(err)
      }
      location[replace ? 'replace' : 'assign'](url)
    }
  }

  function replace(to: HistoryLocation, data?: HistoryState) {
    const state: StateEntry = assign(
      {},
      history.state,
      buildState(
        historyState.value.back,
        to,
        historyState.value.forward,
        true
      ),
      data,
      // 因为是replace操作，所以position不变
      { position: historyState.value.position }
    )

    changeLocation(to, state, true)
    // 修改当前历史为to
    currentLocation.value = to
  }

  function push(to: HistoryLocation, data?: HistoryState) {
    const currentState = assign(
      {},      historyState.value,
      history.state as Partial<StateEntry> | null,
      {
        forward: to,
        scroll: computeScrollPosition(),
      }
    )

    if (__DEV__ && !history.state) {
      warn(
        `history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\n` +
          `history.replaceState(history.state, '', url)\n\n` +
          `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`
      )
    }

    // 第一次changeLocation，使用replace刷新当前历史，目的是记录当前页面的滚动位置
    changeLocation(currentState.current, currentState, true)

    const state: StateEntry = assign(
      {},
      buildState(currentLocation.value, to, null),
      // push操作，历史记录的position+1
      { position: currentState.position + 1 },
      data
    )

    // 第二次跳转，跳转到需要跳转的位置
    changeLocation(to, state, false)
    currentLocation.value = to
  }

  return {
    location: currentLocation,
    state: historyState,

    push,
    replace,
  }
}
```

这个函数接收一个`base`参数，返回一个对象。这个对象中有四个属性：

1. `location`：一个包含`value`属性的对象，`value`值是`createCurrentLocation()`方法的返回值。那么这个`value`是什么呢？看下`createCurrentLocation`做了什么。

`createCurrentLocation`的作用是通过`window.location`创建一个规范化的`history location`，方法接收两个参数：经过标准化的`base`字符串和一个`window.location`对象。

```js
createCurrentLocation function createCurrentLocation(
  base: string,
  location: Location
): HistoryLocation {
  const { pathname, search, hash } = location
  // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end
  // 从base中获取#的索引
  const hashPos = base.indexOf('#')
  // 如果base中包含#
  if (hashPos > -1) {
    // 如果hash包含base中的#后面部分，slicePos为base中#及后面字符串的的长度，否则为1
    let slicePos = hash.includes(base.slice(hashPos))
      ? base.slice(hashPos).length
      : 1
    // 从location.hash中获取path，/#add, #add
    let pathFromHash = hash.slice(slicePos)
    // 在开头加上/，形成/#的格式
    if (pathFromHash[0] !== '/') pathFromHash = '/' + pathFromHash
    // stripBase(pathname, base)：将pathname去除base部分
    return stripBase(pathFromHash, '')
  }
  // 如果base中不包含#，把pathname中的base部分删除
  const path = stripBase(pathname, base)
  return path + search + hash
}
```

可以看到`createCurrentLocation`其实就是获取`window.location`相对`base`的`location`。

举几个例子（以下几个例子的base都经过标准化）：

1. `window.location.pathname`为`/a/b/c`，`base`为`/a`，那么通过`createCurrentLocation`得到的`location`为`/b/c`；
2. 有`hash`的情况，`window.location.hash`为`#/a/b/c`，`base`为`#/a`，那么通过`createCurrentLocation`得到的`location为/b/c`；`window.location.hash`为`#/a/b/c`，`base`为`#`，那么通过`createCurrentLocation`得到的`location`为`/a/b/c`；
3. `state`：一个包含`value`属性的对象，`value`存储的是当前的`history.state`；
4. `push`：向历史记录中添加一条记录。在push过程中你会发现调用了两次`changeLocation`：第一次调用`changeLocation`时，目的是为了记录当前页面在的滚动位置，如果使用`history.back()`或浏览器回退/前进按钮回到这个页面，页面会滚动到对应位置，为了不再历史栈中保存新的记录，第一次记录使用的`reaplceState`替换当前历史记录。第二次调用`changeLocation`是会跳转到需要跳转的位置；
5. `reaplce`：替换当前历史记录；

接下来看下`useHistoryListeners`方法：

```js
function useHistoryListeners(
  base: string,
  historyState: ValueContainer<StateEntry>,
  currentLocation: ValueContainer<HistoryLocation>,
  replace: RouterHistory['replace']
) {
  let listeners: NavigationCallback[] = []
  let teardowns: Array<() => void> = []
  let pauseState: HistoryLocation | null = null

  const popStateHandler: PopStateListener = ({
    state,
  }: {
    state: StateEntry | null
  }) => {
    const to = createCurrentLocation(base, location)
    const from: HistoryLocation = currentLocation.value
    const fromState: StateEntry = historyState.value
    let delta = 0

    if (state) {
      currentLocation.value = to
      historyState.value = state

      // 如果暂停监听了，则直接return，同时pauseState赋为null
      if (pauseState && pauseState === from) {
        pauseState = null
        return
      }
      // 计算移动步数
      delta = fromState ? state.position - fromState.position : 0
    } else {
      replace(to)
    }
    // 执行监听函数列表
    listeners.forEach(listener => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta
          ? delta > 0
            ? NavigationDirection.forward
            : NavigationDirection.back
          : NavigationDirection.unknown,
      })
    })
  }

  function pauseListeners() {
    pauseState = currentLocation.value
  }

  function listen(callback: NavigationCallback) {
    listeners.push(callback)

    const teardown = () => {
      const index = listeners.indexOf(callback)
      if (index > -1) listeners.splice(index, 1)
    }

    teardowns.push(teardown)
    return teardown
  }

  function beforeUnloadListener() {
    const { history } = window
    if (!history.state) return
    // 当页面关闭时记录页面滚动位置
    history.replaceState(
      assign({}, history.state, { scroll: computeScrollPosition() }),
      ''
    )
  }

  function destroy() {
    for (const teardown of teardowns) teardown()
    teardowns = []
    window.removeEventListener('popstate', popStateHandler)
    window.removeEventListener('beforeunload', beforeUnloadListener)
  }

  window.addEventListener('popstate', popStateHandler)
  window.addEventListener('beforeunload', beforeUnloadListener)

  return {
    pauseListeners,
    listen,
    destroy,
  }
}
```

`useHistoryListeners`方法接收四个参数：

1. `base`（标准化的base）；
2. `historyState`；
3. `currentLocation`；
4. `replace`（后三个参数来自`useHistoryStateNavigation`的返回值）；

在`useHistoryListeners`中，会监听[popstate](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event)、[beforeunload](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/beforeunload_event)。

`useHistoryListeners`同样返回一个对象，该对象包含三个属性：

1. `pauseListeners`：一个暂停监听的函数；
2. `listen`：接收一个回调函数，并返回一个删除监听的函数。该回调函数会被加入`listeners`数组中，并向`teardowns`数组中添加卸载函数；
3. `destroy`：销毁函数，清空`listeners`与`teardowns`，移除`popstate`、`beforeunload`监听。

现在我们知道了`useHistoryStateNavigation`、`useHistoryListeners`的实现后。现在我们回到`createWebHistory`中，创建完`historyNavigation`、`historyListeners`之后，紧跟着声明一个`go`函数。该函数接收两个变量：`delta`历史记录移动的步数，`triggerListeners`是否触发监听：

```js
function go(delta: number, triggerListeners = true) {
  if (!triggerListeners) historyListeners.pauseListeners()
  history.go(delta)
}
```

最后创建一个routerHistory对象，并将其返回

```js
const routerHistory: RouterHistory = assign(
  {
    location: '',
    base,
    go,
    createHref: createHref.bind(null, base),
  },
  historyNavigation,
  historyListeners
)

// 拦截routerHistory.location，使routerHistory.location返回当前路由地址
Object.defineProperty(routerHistory, 'location', {
  enumerable: true,
  get: () => historyNavigation.location.value,
})

// 拦截routerHistory.state，使routerHistory.state返回当前的的history.state
Object.defineProperty(routerHistory, 'state', {
  enumerable: true,
  get: () => historyNavigation.state.value,
})

return routerHistory
```

### 5.2 createWebHashHistory

`createWebHashHistory`利用`createWebHashHistory`实现。

```js
export function createWebHashHistory(base?: string): RouterHistory {
  // 对于使用文件协议打开的页面location.host是空字符串，这时的base为''
  // 也就是说在使用文件协议打开页面时，设置了base是不生效的，因为base始终是''
  base = location.host ? base || location.pathname + location.search : ''
  // 允许中间的#: `/base/#/app`
  if (!base.includes('#')) base += '#'

  if (__DEV__ && !base.endsWith('#/') && !base.endsWith('#')) {
    warn(
      `A hash base must end with a "#":\n"${base}" should be "${base.replace(
        /#.*$/,
        '#'
      )}".`
    )
  }
  return createWebHistory(base)
}
```

### 5.3 createMemoryHistory

`createMemoryHistory`会创建一个基于内存历史记录，主要用来处理`SSR`。

```js
export function createMemoryHistory(base: string = ''): RouterHistory {
  // 用户存储监听函数的数组
  let listeners: NavigationCallback[] = []
  // 使用一个队列维护历史记录
  let queue: HistoryLocation[] = [START]
  // 当前历史记录在队列中的位置
  let position: number = 0
  // base标准化
  base = normalizeBase(base)

  // 设置记录
  function setLocation(location: HistoryLocation) {
    position++
    // 队列长度等于position时，直接push
    if (position === queue.length) {
      queue.push(location)
    } else {
      // 当历史记录在队列中的非末尾位置时，删除position及之后的记录，然后再push
      // 如果某一刻处在非结尾的历史记录时，这时要进行push或reqlace操作，此时position之后的记录就会失效
      queue.splice(position)
      queue.push(location)
    }
  }

  // 触发监听
  function triggerListeners(
    to: HistoryLocation,
    from: HistoryLocation,
    { direction, delta }: Pick<NavigationInformation, 'direction' | 'delta'>
  ): void {
    const info: NavigationInformation = {
      direction,
      delta,
      type: NavigationType.pop,
    }
    for (const callback of listeners) {
      callback(to, from, info)
    }
  }

  const routerHistory: RouterHistory = {
    location: START,
    state: {},
    base,
    createHref: createHref.bind(null, base),

    replace(to) {
      // 移除queue中索引为position的记录，并将position--
      queue.splice(position--, 1)
      // 在setLocation会对position重新++操作，所以position会恢复要之前的值
      setLocation(to)
    },

    push(to, data?: HistoryState) {
      setLocation(to)
    },

    listen(callback) {
      listeners.push(callback)
      return () => {
        const index = listeners.indexOf(callback)
        if (index > -1) listeners.splice(index, 1)
      }
    },
    destroy() {
      listeners = []
      queue = [START]
      position = 0
    },

    go(delta, shouldTrigger = true) {
      const from = this.location
      // go的方向。delta < 0 为 back，相反为 forward
      const direction: NavigationDirection =
        delta < 0 ? NavigationDirection.back : NavigationDirection.forward
      // go之后所处的position：Math.min(position + delta, queue.length - 1)保证了position<=queue.length - 1, 如果position + delta超出了数组最大索引，就取最大索引
      // Math.max(0, Math.min(position + delta, queue.length - 1))进一步保证了position>=0，如果position + delta < 0, 则取0
      position = Math.max(0, Math.min(position + delta, queue.length - 1))
      // 根据shouldTrigger决定是否触发监听函数
      if (shouldTrigger) {
        triggerListeners(this.location, from, {
          direction,
          delta,
        })
      }
    },
  }

  Object.defineProperty(routerHistory, 'location', {
    enumerable: true,
    get: () => queue[position],
  })

  if (__TEST__) {
    routerHistory.changeURL = function (url: string) {
      const from = this.location
      queue.splice(position++ + 1, queue.length, url)
      triggerListeners(this.location, from, {
        direction: NavigationDirection.unknown,
        delta: 0,
      })
    }
  }

  return routerHistory
}
```

和`createWebHistory`、`createWebHashHistory`一样，`createMemoryHistory`同样返回一个`RouterHistory`类型的对象。与前面两个方法不同的是，`createMemoryHistory`维护一个队列`queue`和一个`position`，来保证历史记录存储的正确性。

## 6 matcher解析

### 6.1 matcher初识

在开始介绍`matcher`的实现之前，我们先了解下`matcher`是什么？它的作用是什么？
在`vue-router`中，每一个我们定义的路由都会被解析成一个对应的`matcher`（`RouteRecordMatcher`类型），路由的增删改查都会依靠`matcher`来实现。

### 6.2. createRouterMatcher

在`createRouter`中会通过`createRouterMatcher`创建一个`matcher`（`RouterMatcher`类型）。

```js
export function createRouterMatcher(
  routes: RouteRecordRaw[],
  globalOptions: PathParserOptions
): RouterMatcher {
  const matchers: RouteRecordMatcher[] = []
  const matcherMap = new Map<RouteRecordName, RouteRecordMatcher>()
  globalOptions = mergeOptions(
    { strict: false, end: true, sensitive: false } as PathParserOptions,
    globalOptions
  )

  function getRecordMatcher(name: RouteRecordName) { // ... }

  function addRoute(
    record: RouteRecordRaw,
    parent?: RouteRecordMatcher,
    originalRecord?: RouteRecordMatcher
  ) {
    // ...
  }

  function removeRoute(matcherRef: RouteRecordName | RouteRecordMatcher) { // ... }

  function getRoutes() { // ... }

  function insertMatcher(matcher: RouteRecordMatcher) { // ... }

  function resolve(
    location: Readonly<MatcherLocationRaw>,
    currentLocation: Readonly<MatcherLocation>
  ): MatcherLocation {
    // ...
  }

  routes.forEach(route => addRoute(route))

  return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher }
}
```

`createRouterMatcher`接收两个参数：`routes`、`globalOptions`。

其中`routes`为我们定义的路由表，也就是在`createRouter`时传入的`options.routes`，而`globalOptions`就是`createRouter`中的`options`。
`createRouterMatcher`中声明了两个变量`matchers`、`matcherMap`，用来存储通过路由表解析的`matcher`（`RouteRecordMatcher`类型），然后遍历`routes`，对每个元素调用`addRoute`方法。最后返回一个对象，该对象有`addRoute`、`resolve`、`removeRoute`、`getRoute`、`getRecordMatcher`几个属性，这几个属性都对应着一个函数。
接下来我们看下这几个函数：

#### 6.2.1 addRoute

addRoute函数接收三个参数：record（新增的路由）、parent（父matcher）、originalRecord（原始matcher）。

```js
function addRoute(
  record: RouteRecordRaw,
  parent?: RouteRecordMatcher,
  originalRecord?: RouteRecordMatcher
) {
  // used later on to remove by name
  const isRootAdd = !originalRecord
  // 标准化化路由记录
  const mainNormalizedRecord = normalizeRouteRecord(record)
  // aliasOf表示此记录是否是另一个记录的别名
  mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record
  const options: PathParserOptions = mergeOptions(globalOptions, record)
  // 声明一个记录的数组用来处理别名
  const normalizedRecords: typeof mainNormalizedRecord[] = [
    mainNormalizedRecord,
  ]
  // 如果record设置了别名
  if ('alias' in record) {
    // 别名数组
    const aliases =
      typeof record.alias === 'string' ? [record.alias] : record.alias!
    // 遍历别名数组，并根据别名创建记录存储到normalizedRecords中
    for (const alias of aliases) {
      normalizedRecords.push(
        assign({}, mainNormalizedRecord, {
          components: originalRecord
            ? originalRecord.record.components
            : mainNormalizedRecord.components,
          path: alias,
          // 如果有原始记录，aliasOf为原始记录，如果没有原始记录就是它自己
          aliasOf: originalRecord
            ? originalRecord.record
            : mainNormalizedRecord,
        }) as typeof mainNormalizedRecord
      )
    }
  }

  let matcher: RouteRecordMatcher
  let originalMatcher: RouteRecordMatcher | undefined

  // 遍历normalizedRecords
  for (const normalizedRecord of normalizedRecords) {
    
    // 处理normalizedRecord.path为完整的path
    const { path } = normalizedRecord
    // 如果path不是以/开头，那么说明它不是根路由，需要拼接为完整的path
    // { path: '/a', children: [ { path: 'b' } ] } -> { path: '/a', children: [ { path: '/a/b' } ] }
    if (parent && path[0] !== '/') {
      const parentPath = parent.record.path
      const connectingSlash =
        parentPath[parentPath.length - 1] === '/' ? '' : '/'
      normalizedRecord.path =
        parent.record.path + (path && connectingSlash + path)
    }

    // 提示*应使用正则表示式形式
    if (__DEV__ && normalizedRecord.path === '*') {
      throw new Error(
        'Catch all routes ("*") must now be defined using a param with a custom regexp.\n' +
          'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.'
      )
    }

    // 创建一个路由记录匹配器
    matcher = createRouteRecordMatcher(normalizedRecord, parent, options)

    // 检查是否有丢失的参数
    if (__DEV__ && parent && path[0] === '/')
      checkMissingParamsInAbsolutePath(matcher, parent)

    // 如果有originalRecord，将matcher放入原始记录的alias中，以便后续能够删除
    if (originalRecord) {
      originalRecord.alias.push(matcher)
      // 检查originalRecord与matcher中动态参数是否相同
      if (__DEV__) {
        checkSameParams(originalRecord, matcher)
      }
    } else { // 没有originalRecord
      // 因为原始记录索引为0，所以originalMatcher为有原始记录所产生的matcher
      originalMatcher = originalMatcher || matcher
      // 如果matcher不是原始记录产生的matcher，说明此时matcher是由别名记录产生的，此时将matcher放入originalMatcher.alias中
      if (originalMatcher !== matcher) originalMatcher.alias.push(matcher)
      // 如果命名并且仅用于顶部记录，则删除路由（避免嵌套调用）
      if (isRootAdd && record.name && !isAliasRecord(matcher))
        removeRoute(record.name)
    }

    // 遍历children，递归addRoute
    if ('children' in mainNormalizedRecord) {
      const children = mainNormalizedRecord.children
      for (let i = 0; i < children.length; i++) {
        addRoute(
          children[i],
          matcher,
          originalRecord && originalRecord.children[i]
        )
      }
    }

    originalRecord = originalRecord || matcher
    // 添加matcher
    insertMatcher(matcher)
  }

  // 返回一个删除原始matcher的方法
  return originalMatcher
    ? () => {
        removeRoute(originalMatcher!)
      }
    : noop
}
```

在`addRoute`中，会对`record`进行标准化处理（`normalizeRouteRecord`），如果存在原始的`matcher`，也就是`originalRecord`，说明此时要添加的路由是另一记录的别名，这时会将`originalRecord.record`存入`mainNormalizedRecord.aliasOf`中。

```js
const isRootAdd = !originalRecord
// 标准化化路由记录
const mainNormalizedRecord = normalizeRouteRecord(record)
// aliasOf表示此记录是否是另一个记录的别名
mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record
const options: PathParserOptions = mergeOptions(globalOptions, record)
// 声明一个记录的数组用来处理别名
const normalizedRecords: typeof mainNormalizedRecord[] = [
  mainNormalizedRecord,
]
```

然后会遍历`record`的别名，向`normalizedRecords`中添加由别名产生的路由：

```js
if ('alias' in record) {
  // 别名数组
  const aliases =
    typeof record.alias === 'string' ? [record.alias] : record.alias!
  // 遍历别名数组，并根据别名创建记录存储到normalizedRecords中
  for (const alias of aliases) {
    normalizedRecords.push(
      assign({}, mainNormalizedRecord, {
        components: originalRecord
          ? originalRecord.record.components
          : mainNormalizedRecord.components,
        path: alias,
        // 如果有原始记录，aliasOf为原始记录，如果没有原始记录就是它自己
        aliasOf: originalRecord
          ? originalRecord.record
          : mainNormalizedRecord,
      }) as typeof mainNormalizedRecord
    )
  }
}
```

紧接着会遍历normalizedRecords：在这个遍历过程中，会首先将path处理成完整的path，然后通过createRouteRecordMatcher方法创建一个matcher（RouteRecordMatcher类型），如果matcher是由别名产生的，那么matcher会被加入由原始记录产生的matcher中的alias属性中。然后会遍历mainNormalizedRecord的children属性，递归调用addRoute方法。在最后，调用insertMatcher添加新创建的matcher。

```js
for (const normalizedRecord of normalizedRecords) {
  
  // 处理normalizedRecord.path为完整的path
  const { path } = normalizedRecord
  // 如果path不是以/开头，那么说明它不是根路由，需要拼接为完整的path
  // { path: '/a', children: [ { path: 'b' } ] } -> { path: '/a', children: [ { path: '/a/b' } ] }
  if (parent && path[0] !== '/') {
    const parentPath = parent.record.path
    const connectingSlash =
      parentPath[parentPath.length - 1] === '/' ? '' : '/'
    normalizedRecord.path =
      parent.record.path + (path && connectingSlash + path)
  }

  // 提示*应使用正则表示式形式
  if (__DEV__ && normalizedRecord.path === '*') {
    throw new Error(
      'Catch all routes ("*") must now be defined using a param with a custom regexp.\n' +
        'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.'
    )
  }

  // 创建一个路由记录匹配器
  matcher = createRouteRecordMatcher(normalizedRecord, parent, options)

  // 检查是否有丢失的参数
  if (__DEV__ && parent && path[0] === '/')
    checkMissingParamsInAbsolutePath(matcher, parent)

  // 如果有originalRecord，将matcher放入原始记录的alias中，以便后续能够删除
  if (originalRecord) {
    originalRecord.alias.push(matcher)
    // 检查originalRecord与matcher中动态参数是否相同
    if (__DEV__) {
      checkSameParams(originalRecord, matcher)
    }
  } else { // 没有originalRecord
    // 因为原始记录索引为0，所以originalMatcher为有原始记录所产生的matcher
    originalMatcher = originalMatcher || matcher
    // 如果matcher不是原始记录产生的matcher，说明此时matcher是由别名记录产生的，此时将matcher放入originalMatcher.alias中
    if (originalMatcher !== matcher) originalMatcher.alias.push(matcher)
    // 如果存在record.name并且是顶部记录，则删除路由（避免嵌套调用）
    if (isRootAdd && record.name && !isAliasRecord(matcher))
      removeRoute(record.name)
  }

  // 遍历children，递归addRoute
  if ('children' in mainNormalizedRecord) {
    const children = mainNormalizedRecord.children
    for (let i = 0; i < children.length; i++) {
      addRoute(
        children[i],
        matcher,
        originalRecord && originalRecord.children[i]
      )
    }
  }
  // 如果originalRecord是方法传入的，那么originalRecord继续保持
  // 如果originalRecord方法未传入。由于原始的matcher总是在索引为0的位置，所以如果有别名，那么这些别名的原始matcher会始终指向索引为0的位置
  originalRecord = originalRecord || matcher
  // 添加matcher
  insertMatcher(matcher)
}
```

在最后，`addRoute`会返回一个删除原始`matcher`的方法。

在`addRoute`的过程中，会调用`createRouteRecordMatcher`方法来创建`matcher`，那么`matcher`究竟是什么？它是如何被创建的？接下来我们看下`createRouteRecordMatcher`的实现。那么在看`createRouteRecordMatcher`之前，我们先来了解`tokenizePath`、`tokensToParser`这两个函数，因为这两个函数是创建`matcher`的核心。
`tokenizePath`的作用是将`path`转为一个`token`数组。而`tokensToParser`会根据`token`数组创建一个路径解析器。这里提到了一个`token`的概念，那么什么是`token`呢？我们看下`vue-router`中`token`的类型定义：

```js
interface TokenStatic {
  type: TokenType.Static
  value: string
}

interface TokenParam {
  type: TokenType.Param
  regexp?: string
  value: string
  optional: boolean
  repeatable: boolean
}

interface TokenGroup {
  type: TokenType.Group
  value: Exclude<Token, TokenGroup>[]
}

export type Token = TokenStatic | TokenParam | TokenGroup
```

从其类型中我们可以看出token分为三种：

1. `TokenStatic`：一种静态的`token`，说明`token`不可变；
2. `TokenParam`：参数`token`，说明`token`是个参数；
3. `TokenGroup`：分组的`token`；

为了更好理解`token`，这里我们举几个例子：

1. `/one/two/three`对应的`token`数组：

```js
[
  [{ type: TokenType.Static, value: 'one' }],
  [{ type: TokenType.Static, value: 'two' }],
  [{ type: TokenType.Static, value: 'three' }]
]
```

2. `/user/:id`对应的`token`数组是：

```js
[
  [
   {
     type: TokenType.Static,
     value: 'user',
   },
  ],
  [
   {
     type: TokenType.Param,
     value: 'id',
     regexp: '',
     repeatable: false,
     optional: false,
   }
  ]
]
```

3. /:id(\\d+)new对应的token数组：

   ```js
   [
     [
    {
      type: TokenType.Param,
      value: 'id',
      regexp: '\\d+',
      repeatable: false,
      optional: false,
    },
    {
      type: TokenType.Static,
      value: 'new'
    }
     ]
   ]
   ```

从上面几个例子可以看出，`token`数组详细描述了`path`的每一级路由的组成。例如第3个例子`/:id(\\d+)new`，通过`token`数组我们能够知道他是一个一级路由`（token.lenght = 1）`，并且它的这级路由是由两部分组成，其中第一部分是参数部分，第二部分是静态的，并且在参数部分还说明了参数的正则及是否重复、是否可选的配置。

接下来我们看下`tokenizePath`是如何将`path`转为`token`的：

##### 6.2.1.1. tokenizePath

`tokenizePath`的过程就是利用[有限状态自动机](https://zh.wikipedia.org/wiki/有限状态机)生成token数组。

```js
export const enum TokenType {
  Static,
  Param,
  Group,
}

const ROOT_TOKEN: Token = {
  type: TokenType.Static,
  value: '',
}

export function tokenizePath(path: string): Array<Token[]> {
  if (!path) return [[]]
  if (path === '/') return [[ROOT_TOKEN]]
  // 如果path不是以/开头，抛出错误
  if (!path.startsWith('/')) {
    throw new Error(
      __DEV__
        ? `Route paths should start with a "/": "${path}" should be "/${path}".`
        : `Invalid path "${path}"`
    )
  }
  
  function crash(message: string) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`)
  }

  // token所处状态
  let state: TokenizerState = TokenizerState.Static
  // 前一个状态
  let previousState: TokenizerState = state
  const tokens: Array<Token[]> = []
  //  声明一个片段，该片段最终会被存入tokens中
  let segment!: Token[]

  // 添加segment至tokens中，同时segment重新变为空数组
  function finalizeSegment() {
    if (segment) tokens.push(segment)
    segment = []
  }

  let i = 0
  let char: string
  let buffer: string = ''
  // custom regexp for a param
  let customRe: string = ''

  // 消费buffer，即生成token添加到segment中
  function consumeBuffer() {
    if (!buffer) return

    if (state === TokenizerState.Static) {
      segment.push({
        type: TokenType.Static,
        value: buffer,
      })
    } else if (
      state === TokenizerState.Param ||
      state === TokenizerState.ParamRegExp ||
      state === TokenizerState.ParamRegExpEnd
    ) {
      if (segment.length > 1 && (char === '*' || char === '+'))
        crash(
          `A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`
        )
      segment.push({
        type: TokenType.Param,
        value: buffer,
        regexp: customRe,
        repeatable: char === '*' || char === '+',
        optional: char === '*' || char === '?',
      })
    } else {
      crash('Invalid state to consume buffer')
    }
    // 消费完后置空
    buffer = ''
  }

  function addCharToBuffer() {
    buffer += char
  }

  // 遍历path
  while (i < path.length) {
    char = path[i++]

    // path='/\\:'
    if (char === '\\' && state !== TokenizerState.ParamRegExp) {
      previousState = state
      state = TokenizerState.EscapeNext
      continue
    }

    switch (state) {
      case TokenizerState.Static:
        if (char === '/') {
          if (buffer) {
            consumeBuffer()
          }
          // char === /时说明已经遍历完一层路由，这时需要将segment添加到tokens中
          finalizeSegment()
        } else if (char === ':') { // char为:时，因为此时状态是TokenizerState.Static，所以:后是参数，此时要把state变为TokenizerState.Param
          consumeBuffer()
          state = TokenizerState.Param
        } else { // 其他情况拼接buffer
          addCharToBuffer()
        }
        break

      case TokenizerState.EscapeNext:
        addCharToBuffer()
        state = previousState
        break

      case TokenizerState.Param:
        if (char === '(') { // 碰到(，因为此时state为TokenizerState.Param，说明后面是正则表达式，所以修改state为TokenizerState.ParamRegExp
          state = TokenizerState.ParamRegExp
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer()
        } else { // 例如/:id/one，当遍历到第二个/时，消费buffer，state变为Static，并让i回退，回退后进入Static
          consumeBuffer()
          state = TokenizerState.Static
          if (char !== '*' && char !== '?' && char !== '+') i--
        }
        break

      case TokenizerState.ParamRegExp: 
        // it already works by escaping the closing )
        // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)
        // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#
        // is this really something people need since you can also write
        // /prefix_:p()_suffix
        if (char === ')') {
          // 如果是\\)的情况,customRe = customRe去掉\\ + char
          if (customRe[customRe.length - 1] == '\\')
            customRe = customRe.slice(0, -1) + char
          else state = TokenizerState.ParamRegExpEnd // 如果不是\\)说明正则表达式已经遍历完
        } else {
          customRe += char
        }
        break

      case TokenizerState.ParamRegExpEnd: // 正则表达式已经遍历完
        // 消费buffer
        consumeBuffer()
        // 重置state为Static
        state = TokenizerState.Static
        // 例如/:id(\\d+)new，当遍历到n时，使i回退，下一次进入Static分支中处理
        if (char !== '*' && char !== '?' && char !== '+') i--
        customRe = ''
        break

      default:
        crash('Unknown state')
        break
    }
  }

  // 如果遍历结束后，state还是ParamRegExp状态，说明正则是没有结束的，可能漏了)
  if (state === TokenizerState.ParamRegExp)
    crash(`Unfinished custom RegExp for param "${buffer}"`)

  // 遍历完path，进行最后一次消费buffer
  consumeBuffer()
  // 将segment放入tokens
  finalizeSegment()

  // 最后返回tokens
  return tokens
}
```

为了更好理解`tokenizePath`的过程。我们以`path = '/:id(\\d+)new'`例，我们看一下`tokenizePath`的过程：

1. 初始状态：

```js
state=TokenizerState.Static;
previousState=TokenizerState.Static;
tokens=[];
segment;
buffer='';
i=0;
char='';
customRe='';
```

2. 当`i=0`时，进入`TokenizerState.Static`分支，此时`char='/'`; `buffer='';`，不会执行`consumeBuffer`，执行`finalizeSegment`，该轮结束后发生变化的是：

```js
segment=[];
i=1;
char='/';
```

3. 当`i=1`时，进入`TokenizerState.Static`分支，此时`char=':';` `buffer='';`，执行`consumeBuffer`，因为`buffer=''`，所以`consumeBuffer`中什么都没做，最后`state=TokenizerState.Param`，该轮结束后发生变化的是：

```js
state=TokenizerState.Param;
i=2;
char=':';
```

4. 当i=2时，进入TokenizerState.Param分支，此时char='i'; buffer='';，执行addCharToBuffer，该轮结束后发生变化的是：

```js
buffer='i';
i=3;
char='i';
```

5. 当`i=3`时，过程同4，该轮结束后发生变化的是：

```js
buffer='id';
i=4;
char='d';
```

6. 当`i=4`时，进入`TokenizerState.Param`分支，此时`char='('`; `buffer='id';`，此时会将state变为`TokenizerState.ParamRegExp`，说明(后面是正则，该轮结束后发生变化的是：

```js
state=TokenizerState.ParamRegExp;
i=5;
char='(';
```

7. 当i=5时，进入TokenizerState.ParamRegExp分支，此时char='\\'; buffer='id';，执行customRe+=char，该轮结束后发生变化的是：

```js
char='\\';
i=6;
customRe='\\'
```

8. 当i=6、i=7时，过程同5，最终发生变化的是：

```js
i=8;
char='+';
customRe='\\d+'
```

9. 当i=8时，进入TokenizerState.ParamRegExp分支，此时char=')'; buffer='id'; customRe='\\d+'，state变为TokenizerState.ParamRegExpEnd，代表正则结束，该轮结束后发生变化的是：

```js
state=TokenizerState.ParamRegExpEnd;
i=9;
char=')';
```

10. 当i=9时，进入TokenizerState.ParamRegExpEnd分支，此时char='n'; buffer='id'; customRe='\\d+'，执行consumeBuffer，在consumeBuffer中会向segment添加一条token并将buffer置为空字符串，该token是{type: TokenType.Param, value: 'id', regexp: '\\d+', repeatable: false, optional: false}，执行完consumeBuffer后，state重置为Static，customRe重置为空字符串，i回退1，该轮结束后发生变化的是segment=[{...}]; 

```js
state=TokenizerState.ParamRegExpEnd;
i=9; // 注意此时i=9
char=')';
state=TokenizerState.Static;
buffer='';
customRe='';
char='n';，
```

11. 上一轮结束后i=9，进入TokenizerState.Static分支，此时此时char='n'; buffer='';，执行addCharToBuffer方法，该轮结束后发生变化的是：

```js
buffer='n';
i=10;
char='n'
```

12. 当i=10、i=11时，过程同11，结束后发生变化的是:

```js
buffer='new';
i=12;
char='w'
```
13. 当i=12，结束遍历，执行consumeBuffer，向segment添加{type: TokenType.Static, value: 'new'}一条记录并将buffer置为空字符串。然后执行finalizeSegment，将segment添加到tokens中，并将segment置为空数组。最后返回的tokens如下：

```js
[
  [
 {
   type: TokenType.Param,
   value: 'id',
   regexp: '\\d+',
   repeatable: false,
   optional: false,
 },
 {
   type: TokenType.Static,
   value: 'new'
 }
  ]
]
```
状态转移过程图示：

<img src="/Volumes/F/zyl-study/web-zhuawa/20221203/vue3-状态转移过程.png" alt="vue3-状态转移过程" style="zoom:67%;" />

##### 6.2.1.2 tokensToParser

tokensToParser函数接收一个token数组和一个可选的extraOptions，在函数中会构造出path对应的正则表达式、动态参数列表keys、token对应的分数（相当于权重，该分数在后续path的比较中会用到）、一个可以从path中提取动态参数的函数（parse）、一个可以根据传入的动态参数生成path的函数（stringify），最后将其组成一个对象返回：

```js
const enum PathScore {
  _multiplier = 10,
  Root = 9 * _multiplier, // 只有一个/时的分数
  Segment = 4 * _multiplier, // segment的基础分数
  SubSegment = 3 * _multiplier, // /multiple-:things-in-one-:segment
  Static = 4 * _multiplier, // type=TokenType.Static时的分数
  Dynamic = 2 * _multiplier, // 动态参数分数 /:someId
  BonusCustomRegExp = 1 * _multiplier, // 用户自定义正则的分数 /:someId(\\d+) 
  BonusWildcard = -4 * _multiplier - BonusCustomRegExp, // /:namedWildcard(.*) we remove the bonus added by the custom regexp
  BonusRepeatable = -2 * _multiplier, // 当正则是可重复时的分数 /:w+ or /:w*
  BonusOptional = -0.8 * _multiplier, // 当正则是可选择时的分数 /:w? or /:w*
  // these two have to be under 0.1 so a strict /:page is still lower than /:a-:b
  BonusStrict = 0.07 * _multiplier, // options.strict: true时的分数
  BonusCaseSensitive = 0.025 * _multiplier, // options.strict:true时的分数
}
const BASE_PATH_PARSER_OPTIONS: Required<_PathParserOptions> = {
  sensitive: false,
  strict: false,
  start: true,
  end: true,
}
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g
export function tokensToParser(
  segments: Array<Token[]>,
  extraOptions?: _PathParserOptions
): PathParser {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions)

  // 除了根段“/”之外，分数的数量与segments的长度相同
  const score: Array<number[]> = []
  // 正则的字符串形式
  let pattern = options.start ? '^' : ''
  // 保存路由中的动态参数
  const keys: PathParserParamKey[] = []

  for (const segment of segments) {
    // 用一个数组保存token的分数，如果segment.length为0，使用PathScore.Root
    const segmentScores: number[] = segment.length ? [] : [PathScore.Root]

    // options.strict代表是否禁止尾部/，如果禁止了pattern追加/
    if (options.strict && !segment.length) pattern += '/'
    // 开始遍历每个token
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex]
      // 当前子片段（单个token）的分数：基础分数+区分大小写 ? PathScore.BonusCaseSensitive : 0
      let subSegmentScore: number =
        PathScore.Segment +
        (options.sensitive ? PathScore.BonusCaseSensitive : 0)

      if (token.type === TokenType.Static) {
        // 在开始一个新的片段（tokenIndex !== 0）前pattern需要添加/
        if (!tokenIndex) pattern += '/'
        // 将token.value追加到pattern后。追加前token.value中的.、+、*、?、^、$等字符前面加上\\
        // 关于replace，参考MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace
        pattern += token.value.replace(REGEX_CHARS_RE, '\\$&')
        subSegmentScore += PathScore.Static
      } else if (token.type === TokenType.Param) {
        const { value, repeatable, optional, regexp } = token
        // 添加参数
        keys.push({
          name: value,
          repeatable,
          optional,
        })
        const re = regexp ? regexp : BASE_PARAM_PATTERN
        // 用户自定义的正则需要验证正则的正确性
        if (re !== BASE_PARAM_PATTERN) {
          subSegmentScore += PathScore.BonusCustomRegExp
          // 使用前确保正则是正确的
          try {
            new RegExp(`(${re})`)
          } catch (err) {
            throw new Error(
              `Invalid custom RegExp for param "${value}" (${re}): ` +
                (err as Error).message
            )
          }
        }

        // /:chapters*
        // 如果是重复的，必须注意重复的前导斜杠
        let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`

        // prepend the slash if we are starting a new segment
        if (!tokenIndex)
          subPattern =
            // avoid an optional / if there are more segments e.g. /:p?-static
            // or /:p?-:p2
            optional && segment.length < 2
              ? `(?:/${subPattern})`
              : '/' + subPattern
        if (optional) subPattern += '?'

        pattern += subPattern

        subSegmentScore += PathScore.Dynamic
        if (optional) subSegmentScore += PathScore.BonusOptional
        if (repeatable) subSegmentScore += PathScore.BonusRepeatable
        if (re === '.*') subSegmentScore += PathScore.BonusWildcard
      }

      segmentScores.push(subSegmentScore)
    }

    score.push(segmentScores)
  }

  // only apply the strict bonus to the last score
  if (options.strict && options.end) {
    const i = score.length - 1
    score[i][score[i].length - 1] += PathScore.BonusStrict
  }

  // TODO: dev only warn double trailing slash
  if (!options.strict) pattern += '/?'

  if (options.end) pattern += '$'
  // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else
  else if (options.strict) pattern += '(?:/|$)'

  // 根据组装好的pattern创建正则表达式，options.sensitive决定是否区分大小写
  const re = new RegExp(pattern, options.sensitive ? '' : 'i')

  // 根据path获取动态参数对象
  function parse(path: string): PathParams | null {
    const match = path.match(re)
    const params: PathParams = {}

    if (!match) return null

    for (let i = 1; i < match.length; i++) {
      const value: string = match[i] || ''
      const key = keys[i - 1]
      params[key.name] = value && key.repeatable ? value.split('/') : value
    }

    return params
  }

  // 根据传入的动态参数对象，转为对应的path
  function stringify(params: PathParams): string {
    let path = ''
    // for optional parameters to allow to be empty
    let avoidDuplicatedSlash: boolean = false
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith('/')) path += '/'
      avoidDuplicatedSlash = false

      for (const token of segment) {
        if (token.type === TokenType.Static) {
          path += token.value
        } else if (token.type === TokenType.Param) {
          const { value, repeatable, optional } = token
          const param: string | string[] = value in params ? params[value] : ''

          if (Array.isArray(param) && !repeatable)
            throw new Error(
              `Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`
            )
          const text: string = Array.isArray(param) ? param.join('/') : param
          if (!text) {
            if (optional) {
              // if we have more than one optional param like /:a?-static and there are more segments, we don't need to
              // care about the optional param
              if (segment.length < 2 && segments.length > 1) {
                // remove the last slash as we could be at the end
                if (path.endsWith('/')) path = path.slice(0, -1)
                // do not append a slash on the next iteration
                else avoidDuplicatedSlash = true
              }
            } else throw new Error(`Missing required param "${value}"`)
          }
          path += text
        }
      }
    }

    return path
  }

  return {
    re,
    score,
    keys,
    parse,
    stringify,
  }
}
```
然后我们来看createRouteRecordMatcher的实现

```js
export function createRouteRecordMatcher(
  record: Readonly<RouteRecord>,
  parent: RouteRecordMatcher | undefined,
  options?: PathParserOptions
): RouteRecordMatcher {
  // 生成parser对象
  const parser = tokensToParser(tokenizePath(record.path), options)

  // 如果有重复的动态参数命名进行提示
  if (__DEV__) {
    const existingKeys = new Set<string>()
    for (const key of parser.keys) {
      if (existingKeys.has(key.name))
        warn(
          `Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`
        )
      existingKeys.add(key.name)
    }
  }

  // 将record，parent合并到parser中，同时新增children，alias属性，默认值为空数组
  const matcher: RouteRecordMatcher = assign(parser, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: [],
  })

  if (parent) {
    // 两者都是alias或两者都不是alias
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher)
  }

  return matcher
}
```
#### 6.2.2 resolve

resolve根据传入的location进行路由匹配，找到对应的matcher的路由信息。方法接收一个location和currentLocation参数，返回一个MatcherLocation类型的对象，该对象的属性包含：name、path、params、matched、meta：

```js
function resolve(
    location: Readonly<MatcherLocationRaw>,
    currentLocation: Readonly<MatcherLocation>
  ): MatcherLocation {
    let matcher: RouteRecordMatcher | undefined
    let params: PathParams = {}
    let path: MatcherLocation['path']
    let name: MatcherLocation['name']

    if ('name' in location && location.name) { // 如果location存在name属性，可根据name从matcherMap获取matcher
      matcher = matcherMap.get(location.name)

      if (!matcher)
        throw createRouterError<MatcherError>(ErrorTypes.MATCHER_NOT_FOUND, {
          location,
        })

      name = matcher.record.name
      // 合并location.params和currentLocation中的params
      params = assign(
        paramsFromLocation(
          currentLocation.params,
          matcher.keys.filter(k => !k.optional).map(k => k.name)
        ),
        location.params
      )
      // 如果不能通过params转为path抛出错误
      path = matcher.stringify(params)
    } else if ('path' in location) { // 如果location存在path属性，根据path从matchers获取对应matcher
      path = location.path

      if (__DEV__ && !path.startsWith('/')) {
        warn(
          `The Matcher cannot resolve relative paths but received "${path}". Unless you directly called \`matcher.resolve("${path}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`
        )
      }

      matcher = matchers.find(m => m.re.test(path))

      if (matcher) {
        // 通过parse函数获取params
        params = matcher.parse(path)!
        name = matcher.record.name
      }
    } else { // 如果location中没有name、path属性，就使用currentLocation的name或path获取matcher
      matcher = currentLocation.name
        ? matcherMap.get(currentLocation.name)
        : matchers.find(m => m.re.test(currentLocation.path))
      if (!matcher)
        throw createRouterError<MatcherError>(ErrorTypes.MATCHER_NOT_FOUND, {
          location,
          currentLocation,
        })
      name = matcher.record.name
      params = assign({}, currentLocation.params, location.params)
      path = matcher.stringify(params)
    }

    // 使用一个数组存储匹配到的所有路由
    const matched: MatcherLocation['matched'] = []
    let parentMatcher: RouteRecordMatcher | undefined = matcher
    while (parentMatcher) {
      // 父路由始终在数组的开头
      matched.unshift(parentMatcher.record)
      parentMatcher = parentMatcher.parent
    }

    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched),
    }
  }
```

#### 6.2.3 removeRoute

删除路由。接收一个matcherRef参数，removeRoute会将matcherRef对应的matcher从matcherMap和matchers中删除，并清空matcherRef对应matcher的children与alias属性。由于matcherRef对应的matcher被删除后，其子孙及别名也就没用了，也需要把他们从matcherMap中和matchers中删除:

```js
function removeRoute(matcherRef: RouteRecordName | RouteRecordMatcher) {
  // 如果是路由名字：string或symbol
  if (isRouteName(matcherRef)) {
    const matcher = matcherMap.get(matcherRef)
    if (matcher) {
      // 删除matcher
      matcherMap.delete(matcherRef)
      matchers.splice(matchers.indexOf(matcher), 1)
      // 清空matcher中的children与alias，
      matcher.children.forEach(removeRoute)
      matcher.alias.forEach(removeRoute)
    }
  } else {
    const index = matchers.indexOf(matcherRef)
    if (index > -1) {
      matchers.splice(index, 1)
      if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name)
      matcherRef.children.forEach(removeRoute)
      matcherRef.alias.forEach(removeRoute)
    }
  }
}
```

#### 6.2.4 getRoutes
获取所有matcher：

```js
function getRoutes() {
  return matchers
}
```

#### 6.2.5 getRecordMatcher
根据路由名获取对应matcher：

```js
function getRecordMatcher(name: RouteRecordName) {
  return matcherMap.get(name)
}
```
#### 6.2.6 insertMatcher
在添加matcher时，并不是直接matchers.add，而是根据matcher.score进行排序。比较分数时根据数组中的每一项挨个比较，不是比较总分：

```js
function insertMatcher(matcher: RouteRecordMatcher) {
  let i = 0
  while (
    i < matchers.length &&
    // matcher与matchers[i]比较，matchers[i]应该在前面
    comparePathParserScore(matcher, matchers[i]) >= 0 &&
    // matcher的path与matchers[i]不同或matcher不是matchers[i]的孩子
    (matcher.record.path !== matchers[i].record.path ||
      !isRecordChildOf(matcher, matchers[i]))
  )
    i++
  // 插入matcher
  matchers.splice(i, 0, matcher)
  // 只添加原始matcher到map中
  if (matcher.record.name && !isAliasRecord(matcher))
    matcherMap.set(matcher.record.name, matcher)
}
```

```js
// 返回0表示a与b相等；返回>0，b先排序；返回<0，a先排序
export function comparePathParserScore(a: PathParser, b: PathParser): number {
  let i = 0
  const aScore = a.score
  const bScore = b.score
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i])
    if (comp) return comp

    i++
  }

  return bScore.length - aScore.length
}

function compareScoreArray(a: number[], b: number[]): number {
  let i = 0
  while (i < a.length && i < b.length) {
    const diff = b[i] - a[i]
    // 一旦a与b对位索引对应的值有差值，直接返回
    if (diff) return diff

    i++
  }
  if (a.length < b.length) {
      // 如果a.length为1且第一个值的分数为PathScore.Static + PathScore.Segment，返回-1，表示a先排序，否则返回1，表示b先排序
    return a.length === 1 && a[0] === PathScore.Static + PathScore.Segment
      ? -1
      : 1
  } else if (a.length > b.length) {
    // 如果b.length为1且第一个值的分数为PathScore.Static + PathScore.Segment，返回-1，表示b先排序，否则返回1，表示a先排序
    return b.length === 1 && b[0] === PathScore.Static + PathScore.Segment
      ? 1
      : -1
  }

  return 0
}
```
假设matcherA是需要添加的，matchers中此时只有一个matcherB，matcherA.score=[[1, 2]]，matcherB.score=[[1,3]]，那么matcherA是怎么添加到matchers中的呢？过程如下：

1. 初始化matchers索引i=0；
2. 首先比较matcherA.score[0][0]与matcherB.score[0][0]，matcherB.score[0][0]-matcherA.score[0][0] === 0继续比较；
   matcherA.score[0][1]与matcherB.score[0][1]，因为matcherB.score[0][1]-matcherA.score[0][1] > 0，i++；
   i=1时，由于i=matchers.length，结束循环；

3. 执行matchers.splice(i, 0, matcher)，此时i=1,所以matcherA会被添加到索引为1的位置；
4. 如果matcherA.score=[[1,3,4]]呢？ 在比较时因为前两个索引对应的值都是一样的，这时会进入compareScoreArray的以下分支：

```js
if (a.length > b.length) {
  return b.length === 1 && b[0] === PathScore.Static + PathScore.Segment
    ? 1
    : -1
}
```

以上结果返回-1，matcherA会被添加索引为0的位置

如果matcherA.score=[[1]]，进入compareScoreArray的以下分支：

```js
 if (a.length < b.length) {
  return a.length === 1 && a[0] === PathScore.Static + PathScore.Segment
    ? -1
    : 1
}
```

因为matcherA.score[0].length === 1，这时就需要考虑token的类型里，假设token是个Static类型的，那么返回-1，matcherA添加到索引为0的位置。如果token不是Static类型的，返回1，matcherA添加到索引为1的位置。
所以insertMatcher，会将权重高的matcher放在matchers前面；matcherMap中只存放原始matcher。

### 6.3 总结

经过上面分析，我们知道了matcher是什么，如何实现的。
在vue-router通过matcher完成路由的匹配、增删改查等操作，其中会使用matchers和matcherMap来存储matcher。matchers中权重（分数）高的matcher优先；matcherMap中的key是注册路由时路由表的name，只存放原始matcher。
matcher中包含了路由path对应的正则re、路由的分数score、动态参数列表keys、可从path中提取动态参数的parse(path)函数、可传入参数对象将其转为对应path的stringify(param)函数、父matcher（parent）、路由的标准化版本record、子matcher（children）、由别名产生的matcher（alias）：

```typescript
export interface PathParser {
  re: RegExp
  score: Array<number[]>
  keys: PathParserParamKey[]
  parse(path: string): PathParams | null
  stringify(params: PathParams): string
}
export interface RouteRecordMatcher extends PathParser {
  record: RouteRecord
  parent: RouteRecordMatcher | undefined
  children: RouteRecordMatcher[]
  // aliases that must be removed when removing this record
  alias: RouteRecordMatcher[]
}

```

在生成matcher的过程中会将patch转换成token数组（二维数组，第一维度中每个维度代表一级路由，第二维度中每个维度代表路由的组成），路由正则的生成、动态参数的的提取、分数的计算、stringify全都依托这个token数组实现


## 7.createRouter解析
### 7.1 使用demo

```js
const routerHistory = createWebHistory()
export const router = createRouter({
  history: routerHistory,
  strict: true,
  routes: [
    { path: '/home', redirect: '/' },
    {
      path: '/',
      components: { default: Home, other: component },
      props: { default: to => ({ waited: to.meta.waitedFor }) },
    },
    {
      path: '/nested',
      alias: '/anidado',
      component: Nested,
      name: 'Nested',
      children: [
        {
          path: 'nested',
          alias: 'a',
          name: 'NestedNested',
          component: Nested,
          children: [
            {
              name: 'NestedNestedNested',
              path: 'nested',
              component: Nested,
            },
          ],
        },
        {
          path: 'other',
          alias: 'otherAlias',
          component: Nested,
          name: 'NestedOther',
        },
        {
          path: 'also-as-absolute',
          alias: '/absolute',
          name: 'absolute-child',
          component: Nested,
        },
      ],
    },
  ],
  async scrollBehavior(to, from, savedPosition) {
    await scrollWaiter.wait()
    if (savedPosition) {
      return savedPosition
    } else {
      if (to.matched.every((record, i) => from.matched[i] !== record))
        return { left: 0, top: 0 }
    }
    return false
  },
})

```

### 7.2 createRouter

在分析createRouter之前，先来看下它的参数类型

```typescript
 export interface _PathParserOptions {
  // 使用正则时区分大小写，默认false
  sensitive?: boolean
  // 是否禁止尾随斜杠，默认false
  strict?: boolean
  // 正则表达式前应该加^，默认true
  start?: boolean
  // 正则表达式以$结尾，默认为true
  end?: boolean
}

export type PathParserOptions = Pick<
  _PathParserOptions,
  'end' | 'sensitive' | 'strict'
  >

export interface RouterOptions extends PathParserOptions {
  history: RouterHistory
  // 路由表
  routes: RouteRecordRaw[]
  // 在页面之间导航时控制滚动行为。可以返回一个 Promise 来延迟滚动。
  scrollBehavior?: RouterScrollBehavior
  // 用于自定义如何解析query
  parseQuery?: typeof originalParseQuery
  // 用于自定义查询对象如何转为字符串
  stringifyQuery?: typeof originalStringifyQuery
  // 激活RouterLink的默认类
  linkActiveClass?: string
  // 精准激活RouterLink的默认类
  linkExactActiveClass?: string
}
```

我们来看下createRouter具体做了什么。createRouter方法共885（包含空行）行，乍一看可能会觉得方法很复杂，仔细观察，其实很大一部分代码都是声明一些函数。我们可以先暂时抛开这些函数声明看其余部分。
首先会使用createRouterMatcher方法创建了一个路由匹配器matcher，从options中提取parseQuery、stringifyQuery、history属性，如果options中没有history，抛出错误。

```typescript
const matcher = createRouterMatcher(options.routes, options)
const parseQuery = options.parseQuery || originalParseQuery
const stringifyQuery = options.stringifyQuery || originalStringifyQuery
const routerHistory = options.history
if (__DEV__ && !routerHistory)
    throw new Error(
      'Provide the "history" option when calling "createRouter()":' +
        ' https://next.router.vuejs.org/api/#history.'
    )
```

紧接着声明了一些全局守卫相关的变量，和一些关于params的处理方法，其中有关全局守卫的变量都是通过useCallbacks创建的，params相关方法通过applyToParams创建。

```js
// 全局前置守卫相关方法
const beforeGuards = useCallbacks<NavigationGuardWithThis<undefined>>()
// 全局解析守卫相关方法
const beforeResolveGuards = useCallbacks<NavigationGuardWithThis<undefined>>()
// 全局后置钩子方法
const afterGuards = useCallbacks<NavigationHookAfter>()

// 当前路由，浅层响应式对象
const currentRoute = shallowRef<RouteLocationNormalizedLoaded>(
  START_LOCATION_NORMALIZED
)
let pendingLocation: RouteLocation = START_LOCATION_NORMALIZED

// 如果浏览器环境下设置了scrollBehavior，那么需要防止页面自动恢复页面位置
// https://developer.mozilla.org/zh-CN/docs/Web/API/History/scrollRestoration
if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {
  history.scrollRestoration = 'manual'
}

// 标准化params，转字符串
const normalizeParams = applyToParams.bind(
  null,
  paramValue => '' + paramValue
)
// 编码param
const encodeParams = applyToParams.bind(null, encodeParam)
// 解码params
const decodeParams: (params: RouteParams | undefined) => RouteParams =
  applyToParams.bind(null, decode)

```

关于useCallbacks的实现：在useCallbacks中声明一个handlers数组用来保存所有添加的方法，useCallbacks的返回值中包括三个方法：add（添加一个handler，并返回一个删除handler的函数）、list（返回所有handler）、reset（清空所有handler）

```js
export function useCallbacks<T>() {
  let handlers: T[] = []

  function add(handler: T): () => void {
    handlers.push(handler)
    return () => {
      const i = handlers.indexOf(handler)
      if (i > -1) handlers.splice(i, 1)
    }
  }

  function reset() {
    handlers = []
  }

  return {
    add,
    list: () => handlers,
    reset,
  }
}
```
applyToParams的实现：接收一个处理函数和params对象，遍历params对象，并对每一个属性值执行fn并将结果赋给一个新的对象：

```js
export function applyToParams(
  fn: (v: string | number | null | undefined) => string,
  params: RouteParamsRaw | undefined
): RouteParams {
  const newParams: RouteParams = {}

  for (const key in params) {
    const value = params[key]
    newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value)
  }

  return newParams
}
```

然后声明了大量的函数，包括addRoute、removeRoute、getRoutes等，这些函数也就是我们日常使用的addRoute、removeRoute等。
在createRouter的最后创建了一个router对象，并将其返回，该对象几乎包含了声明的所有函数。

### 7.3 总结

createRouter函数中声明了一些全局钩子所需的变量和很多函数，这些函数就是我们日常使用的一些方法，如addRoute、removeRoute等，在函数的最后，声明了一个router对象，前面所声明的函数多数都会被包含在这个对象里，最终会将router返回。

## 8 createRouter内置方法解析

这里分析分析router.addRoute、router.removeRoute、router.hasRoute、router.getRoutes的实现。
### 8.1 使用

1. addRoute：当使用addRoute添加路由时，如果第一个参数为路由name，那么会添加一个嵌套路由；否则添加的是个非嵌套路由。

```js
// 添加非嵌套路由
router.addRoute({ name: 'admin', path: '/admin', component: Admin })
// 添加嵌套路由
router.addRoute('admin', { path: 'settings', component: AdminSettings })
```

以上代码等同于：

```js
router.addRoute({
  name: 'admin',
  path: '/admin',
  component: Admin,
  children: [{ path: 'settings', component: AdminSettings }],
})
```

2. remove Router

```js
router.removeRoute('admin')
```
3. hashRoute

```js
router.hasRoute('admin')
```
- getRoutes

```js
router.getRoutes()
```
### 8.2 addRoute

addRoute可接受两个参数：parentOrRoute（父路由的name或一个新的路由，如果是父路由的name，name第二个参数是必须的）、record（要添加的路由）。返回一个删除新增路由的函数。

```js
function addRoute(
    parentOrRoute: RouteRecordName | RouteRecordRaw,
    route?: RouteRecordRaw
  ) {
    let parent: Parameters<typeof matcher['addRoute']>[1] | undefined
    let record: RouteRecordRaw
    // 如果parentOrRoute是路由名称，parent为parentOrRoute对应的matcher，被添加的route是个嵌套路由
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute)
      record = route!
    } else { // 如果parentOrRoute不是路由名称，parentOrRoute就是要添加的路由
      record = parentOrRoute
    }

    // 调用matcher.addRoute添加新的记录，返回一个移除路由的函数
    return matcher.addRoute(record, parent)
  }

```

在定义parent时，使用了一个Paramerer<Type>类型，对于该类型的使用可参考这里。在该方法中，parent的类型会取matcher.addRoute方法中的第2个参数的类型。
isRouteName：通过判断name是否为string或symbol类型，来决定是不是routeName。
```js
export function isRouteName(name: any): name is RouteRecordName {
  return typeof name === 'string' || typeof name === 'symbol'
}
```

### 8.3 removeRoute

删除路由。removeRoute接收一个name（现有路由的名称）参数。

```js
function removeRoute(name: RouteRecordName) {
  // 根据name获取对应的routeRecordMatcher
  const recordMatcher = matcher.getRecordMatcher(name)
  if (recordMatcher) {
    // 如果存在recordMatcher，调用matcher.removeRoute
    matcher.removeRoute(recordMatcher)
  } else if (__DEV__) {
    warn(`Cannot remove non-existent route "${String(name)}"`)
  }
}
```

### 8.4 hashRoute

用于判断路由是否存在。hasRoute接收一个name字符串，返回一个boolen值。
通过matcher.getRecordMatcher来获取对应的matcher，在matcher.getRecordMatcher会在matcherMap中取寻找对应的matcher，如果没有找到说明路由不存在：

```js
function hasRoute(name: RouteRecordName): boolean {
  return !!matcher.getRecordMatcher(name)
}
```

### 8.5 getRoutes

获取标准化后的路由列表。标准化后的路由会被存储到matcher.record中。

```js
function getRoutes() {
  // 遍历matchers，routeMatcher.record中存储着路由的标准化版本
  return matcher.getRoutes().map(routeMatcher => routeMatcher.record)
}
```

### 8.6总结

router.addRoute、router.removeRoute、router.hasRoute、router.getRoutes几个API全都依赖matcher实现，可见matcher是vue-router的核心。

## 9. router.resolve

### 9.1 使用

router.resolve方法返回路由地址的标准化版本。

```js

router.resolve('admin')
router.resolve({ path: '/admin' })

```
### 9.2 resolve

resolve接收两个参数：rawLocation、currentLocation（可选）。其中rawLocation是待转换的路由，rawLocation可以是个对象也可以是个字符串。currentLocation不传默认是currentRoute。
在resolve中有是两个分支：
- 如果rawLocation是string类型；
调用parseURL解析rawLocation；

```js

const locationNormalized = parseURL(
  parseQuery,
  rawLocation,
  currentLocation.path
)

```

parseURL接收三个参数：parseQuery（一个query解析函数）、location（被解析的location）、currentLocation（当前的location）。

```js

export function parseURL(
  parseQuery: (search: string) => LocationQuery,
  location: string,
  currentLocation: string = '/'
): LocationNormalized {
let path: string | undefined,
  query: LocationQuery = {},
  searchString = '',
  hash = ''

  // location中?的位置
  const searchPos = location.indexOf('?')
  // location中#的位置，如果location中有?，在?之后找#
  const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0)
  
  // 如果
  if (searchPos > -1) {
    // 从location中截取[0, searchPos)位置的字符串作为path
    path = location.slice(0, searchPos)
    // 从location截取含search的字符串，不包含hash部分
    searchString = location.slice(
      searchPos + 1,
      hashPos > -1 ? hashPos : location.length
    )
    // 调用parseQuery生成query对象
    query = parseQuery(searchString)
  }
  // 如果location中有hash
  if (hashPos > -1) {
    path = path || location.slice(0, hashPos)
    // 从location中截取[hashPos, location.length)作为hash（包含#）
    hash = location.slice(hashPos, location.length)
  }
  
  // 解析以.开头的相对路径
  path = resolveRelativePath(path != null ? path : location, currentLocation)
  // empty path means a relative query or hash `?foo=f`, `#thing`
  
  return {
    // fullPath = path + searchString + hash
    fullPath: path + (searchString && '?') + searchString + hash,
    path,
    query,
    hash,
  }
}

```

来看下，相对路径的解析过程：

```js

export function resolveRelativePath(to: string, from: string): string {
// 如果to以/开头，说明是个绝对路径，直接返回即可
if (to.startsWith('/')) return to
// 如果from不是以/开头，那么说明from不是绝对路径，也就无法推测出to的绝对路径，此时直接返回to
if (__DEV__ && !from.startsWith('/')) {
  warn(
    `Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from}". It should look like "/${from}".`
  )
  return to
}

if (!to) return from
// 使用/分割from与to
const fromSegments = from.split('/')
const toSegments = to.split('/')

// 初始化position默认为fromSegments的最后一个索引
let position = fromSegments.length - 1
let toPosition: number
let segment: string

for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
  segment = toSegments[toPosition]
    // 保证position不会小于0
    if (position === 1 || segment === '.') continue
    if (segment === '..') position--
    else break
  }
  
  return (
    fromSegments.slice(0, position).join('/') +
    '/' +
    toSegments
      .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))
      .join('/')
  )
}

```

1. to=cc，from=/aa/bb，经过resolveRelativePath后：/aa/cc；
2. to=cc，from=/aa/bb/，经过resolveRelativePath后：/aa/bb/cc；
3. to=./cc，from=/aa/bb，经过resolveRelativePath后：/aa/cc；
4. to=./cc，from=/aa/bb/，经过resolveRelativePath后：/aa/bb/cc；
5. to=../cc，from=/aa/bb，经过resolveRelativePath后：/aa；
6. to=../cc，from=/aa/bb/，经过resolveRelativePath后：/aa/cc；
7. 如果from/，to=cc、to=./cc、to=../cc、to=../../cc、to=./../cc、to=.././cc经过resolveRelativePath始终返回/cc。

回到resolve中，解析完rawLocation后，调用matcher.resolve：

```js
const matchedRoute = matcher.resolve(
  { path: locationNormalized.path },
  currentLocation
)
// 使用routerHistory.createHref创建href
const href = routerHistory.createHref(locationNormalized.fullPath)

```

最后返回对象：

```js

return assign(locationNormalized, matchedRoute, {
  // 对params中的value进行decodeURIComponent
  params:decodeParams(matchedRoute.params),
  // 对hash进行decodeURIComponent
  hash: decode(locationNormalized.hash),
  redirectedFrom: undefined,
  href,
})

```

- rawLocation不是string类型

```js
let matcherLocation: MatcherLocationRaw

// 如果rawLocation中有path属性
if ('path' in rawLocation) {
  // rawLocation中的params会被忽略
  if (
    __DEV__ &&
    'params' in rawLocation &&
    !('name' in rawLocation) &&
    Object.keys(rawLocation.params).length
  ) {
    warn(
      `Path "${
        rawLocation.path
      }" was passed with params but they will be ignored. Use a named route alongside params instead.`
    )
  }
  // 处理path为绝对路径
  matcherLocation = assign({}, rawLocation, {
    path: parseURL(parseQuery, rawLocation.path, currentLocation.path).path,
  })
} else {
  // 删除空的参数
  const targetParams = assign({}, rawLocation.params)
  for (const key in targetParams) {
    if (targetParams[key] == null) {
      delete targetParams[key]
    }
  }
  // 对params进行编码
  matcherLocation = assign({}, rawLocation, {
    params: encodeParams(rawLocation.params),
  })
  // 将当前位置的params编码 当前位置的参数被解码，我们需要对它们进行编码以防匹配器合并参数
  currentLocation.params = encodeParams(currentLocation.params)
}

// 调用matcher.resolve获取路由相关信息
const matchedRoute = matcher.resolve(matcherLocation, currentLocation)
const hash = rawLocation.hash || ''

if (__DEV__ && hash && !hash.startsWith('#')) {
  warn(
    `A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`
  )
}

// 由于matcher已经合并了当前位置的参数，所以需要进行解码
matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params))

// 生成完整path
const fullPath = stringifyURL(
  stringifyQuery,
  assign({}, rawLocation, {
    hash: encodeHash(hash),
    path: matchedRoute.path,
  })
)
// routerHistory.createHref会删除#之前的任意字符
const href = routerHistory.createHref(fullPath)
if (__DEV__) {
  if (href.startsWith('//')) {
    warn(
      `Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`
    )
  } else if (!matchedRoute.matched.length) {
    warn(
      `No match found for location with path "${
        'path' in rawLocation ? rawLocation.path : rawLocation
      }"`
    )
  }
}

return assign(
  {
    fullPath,
    hash,
    query:
    // 如果query是个嵌套对象，normalizeQuery会将嵌套的对象toString，如果用户使用qs等库，我们需要保持query的状态
    // https://github.com/vuejs/router/issues/328#issuecomment-649481567
      stringifyQuery === originalStringifyQuery
        ? normalizeQuery(rawLocation.query)
        : ((rawLocation.query || {}) as LocationQuery),
  },
  matchedRoute,
  {
    redirectedFrom: undefined,
    href,
  }
)
```

## 10. Router.push 和router.replace解析

### 10.1 使用

使用`router.push`方法导航到不同的 URL。这个方法会向`history`栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL；

使用`router.replace`方法导航到不同的 URL。这个方法会在`history`栈替换历史记录；

```js
router.push('/search?name=pen')
router.push({ path: '/search', query: { name: 'pen' } })
router.push({ name: 'search', query: { name: 'pen' } })
// 以上三种方式是等效的。

router.replace('/search?name=pen')
router.replace({ path: '/search', query: { name: 'pen' } })
router.replace({ name: 'search', query: { name: 'pen' } })
// 以上三种方式是等效的。
```

### 10.2 push

`push`方法接收一个to参数，表示要跳转的路由，它可以是个字符串，也可以是个对象。在push方法中调用了一个`pushWithRedirect`函数，并返回其结果。

```js
function push(to: RouteLocationRaw | RouteLocation) {
  return pushWithRedirect(to)
}
```

`pushWithRedirect`接收两个参数：`to`、`redirectedFrom`，并返回`pushWithRedirect`的结果。其中`to`是要跳转到的路由，`redirectedFrom`代表`to`是从哪个路由重定向来的，如果多次重定向，它只是最初重定向的那个路由。

```js
function pushWithRedirect(
  to: RouteLocationRaw | RouteLocation,
  redirectedFrom?: RouteLocation
): Promise<NavigationFailure | void | undefined> {
  // ...
}
```

因为要到的`to`中可能存在重定向，所以`pushWithRedirect`中首先要处理重定向：当to中存在重定向时，递归调用`pushWithRedirect`。

```js
// 将to处理为规范化的路由
const targetLocation: RouteLocation = (pendingLocation = resolve(to))
// 当前路由
const from = currentRoute.value
// 使用 History API(history.state) 保存的状态
const data: HistoryState | undefined = (to as RouteLocationOptions).state
// force代表强制触发导航，即使与当前位置相同
const force: boolean | undefined = (to as RouteLocationOptions).force
// replace代表是否替换当前历史记录
const replace = (to as RouteLocationOptions).replace === true

// 获取要重定向的记录
const shouldRedirect = handleRedirectRecord(targetLocation)

// 如果需要重定向，递归调用pushWithRedirect方法
if (shouldRedirect)
  return pushWithRedirect(
    assign(locationAsObject(shouldRedirect), {
      state: data,
      force,
      replace,
    }),
    // 重定向的根来源
    redirectedFrom || targetLocation
  )
```

`handleRedirectRecord`函数的实现：

```js
function handleRedirectRecord(to: RouteLocation): RouteLocationRaw | void {
  // 找到匹配的路由，to.matched中的路由顺序是父路由在子路由前面，所以最后一个路由是我们的最终路由
  const lastMatched = to.matched[to.matched.length - 1]
  // 如果路由存在redirect
  if (lastMatched && lastMatched.redirect) {
    const { redirect } = lastMatched
    // 如果redirect是函数，需要执行函数
    let newTargetLocation =
      typeof redirect === 'function' ? redirect(to) : redirect

    // 如果newTargetLocation是string
    if (typeof newTargetLocation === 'string') {
      // 如果newTargetLocation中存在?或#，需要将newTargetLocation解析成一个LocationNormalized类型的对象
      newTargetLocation =
        newTargetLocation.includes('?') || newTargetLocation.includes('#')
          ? (newTargetLocation = locationAsObject(newTargetLocation))
          : { path: newTargetLocation }
      // 设置params为一个空对象
      newTargetLocation.params = {}
    }

    // 如果newTargetLocation中没有path和name属性，则无法找到重定向的路由，开发环境下进行提示
    if (
      __DEV__ &&
      !('path' in newTargetLocation) &&
      !('name' in newTargetLocation)
    ) {
      warn(
        `Invalid redirect found:\n${JSON.stringify(
          newTargetLocation,
          null,
          2
        )}\n when navigating to "${
          to.fullPath
        }". A redirect must contain a name or path. This will break in production.`
      )
      throw new Error('Invalid redirect')
    }

    return assign(
      {
        query: to.query,
        hash: to.hash,
        params: to.params,
      },
      newTargetLocation
    )
  }
}
```

处理完重定向后，接下来会检测要跳转到的路由和当前路由是否为同一个路由，如果是同一个路由并且不强制跳转，会创建一个失败函数赋给`failure`，然后处理滚动行为。

```js
const toLocation = targetLocation as RouteLocationNormalized

// 设置重定向的来源
toLocation.redirectedFrom = redirectedFrom
let failure: NavigationFailure | void | undefined

// 如果要跳转到的路由与当前路由一致并且不强制跳转
if (!force && isSameRouteLocation(stringifyQuery, from, targetLocation)) {
  // 创建一个错误信息，该错误信息代表重复的导航
  failure = createRouterError<NavigationFailure>(
    ErrorTypes.NAVIGATION_DUPLICATED,
    { to: toLocation, from }
  )
  // 处理滚动行为
  handleScroll(
    from,
    from,
    true,
    false
  )
}
```

关于handleScroll的实现如下：首先从options中找到scrollBehavior选项，如果不是浏览器环境或不存在scrollBehavior，返回一个Promise对象。相反，获取滚动位置（根据历史记录中的position和path获取），然后在下一次DOM刷新后，执行定义的滚动行为函数，滚动行为函数执行完后，将滚动行为函数结果作为最终的滚动位置将页面滚动到指定位置。

```js
function handleScroll(
  to: RouteLocationNormalizedLoaded,
  from: RouteLocationNormalizedLoaded,
  isPush: boolean,
  isFirstNavigation: boolean
): Promise<any> {
  const { scrollBehavior } = options
  if (!isBrowser || !scrollBehavior) return Promise.resolve()

  // 获取滚动位置
  const scrollPosition: _ScrollPositionNormalized | null =
    (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||
    ((isFirstNavigation || !isPush) &&
      (history.state as HistoryState) &&
      history.state.scroll) ||
    null

  // 下一次DOM更新后触发滚动行为，滚动行为执行完后，滚动到指定位置
  return nextTick()
    .then(() => scrollBehavior(to, from, scrollPosition))
    .then(position => position && scrollToPosition(position))
    .catch(err => triggerError(err, to, from))
}

export function getScrollKey(path: string, delta: number): string {
  // history.state.position记录着当前路由在历史记录中的位置，该位置从0开始
  const position: number = history.state ? history.state.position - delta : -1
  // key值为 在历史记录中的位置+path
  return position + path
}

export function getSavedScrollPosition(key: string) {
  // 根据key值查找滚动位置
  const scroll = scrollPositions.get(key)
  // 查完后，删除对应记录
  scrollPositions.delete(key)
  return scroll
}
```

在`pushWithRedirect`最后返回一个`Promise`。如果有`failure`，返回`failure`。如果没有`failure`则执行`navigate(toLocation, from)`。

那么`navigate`是做什么的呢？`navigate`函数接收两个参数：`to`、`from`。

`navigate`中首先调用了一个`extractChangingRecords`函数，该函数的作用是将`from`、`to`所匹配到的路由分别存到三个数组中：`from`、`to`所共有的路由放入`updatingRecords`（正在更新的路由）、`from`独有的路由放入`leavingRecords`（正要离开的路由）、`to`独有的路由放入`enteringRecords`（正在进入的新路由）。紧接着又调用了一个`extractComponentsGuards`函数，用来获取组件内的`beforeRouteLeave`钩子，注意`extractComponentsGuards`函数只能获取使用`beforeRouteLeave(){}`方式注册的函数，对于使用`onBeforeRouteLeave`注册的函数需要单独处理。

```js
const [leavingRecords, updatingRecords, enteringRecords] =
  extractChangingRecords(to, from)

guards = extractComponentsGuards(
  // 这里leavingRecords需要反转，因为matched中的顺序是父路由在子路由前，当离开时，应先离开子路由再离开父路由
  leavingRecords.reverse(),
  'beforeRouteLeave',
  to,
  from
)

// 向guards中添加使用onBeforeRouteLeave方式注册的方法
for (const record of leavingRecords) {
  record.leaveGuards.forEach(guard => {
    guards.push(guardToPromiseFn(guard, to, from))
  })
}

// 如果发生了新的导航canceledNavigationCheck可以帮助跳过后续所有的导航
const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(
  null,
  to,
  from
)

guards.push(canceledNavigationCheck)
```

`extractChangingRecords`的实现过程：如果`to`和`from`配配到的路由中有公共的，说明这些路由在跳转过程中是更新操作，将其加入`updatingRecords`中；如果是`from`所匹配到独有的路由，说明要离开这些路由，将它们放入`leavingRecords`中；相反，如果`to`匹配到的路由中，from没有匹配到，说明是新的路由，将它们放入`enteringRecords`中。

```js
function extractChangingRecords(
  to: RouteLocationNormalized,
  from: RouteLocationNormalizedLoaded
) {
  // 要离开的路由
  const leavingRecords: RouteRecordNormalized[] = []
  // 更新的路由
  const updatingRecords: RouteRecordNormalized[] = []
  // 要进入的新的路由（在from.matched中未出现过）
  const enteringRecords: RouteRecordNormalized[] = []

  const len = Math.max(from.matched.length, to.matched.length)
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i]
    if (recordFrom) {
      // 如果recordFrom在to.matched中存在，将recordFrom加入到updatingRecords，否则加入到leavingRecords中
      if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom)
      else leavingRecords.push(recordFrom)
    }
    const recordTo = to.matched[i]
    if (recordTo) {
      // 如果recordTo在from.matched中找不到，说明是个新的路由，将recordTo加入到enteringRecords
      if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo)
      }
    }
  }

  return [leavingRecords, updatingRecords, enteringRecords]
}
```

`extractComponentsGuards`是专门用来从路由组件中提取钩子函数的。`extractComponentsGuards`接收四个参数：

1. `matched`（从`to`、`from`中提取出的`leavingRecords`、`updatingRecords`、`enteringRecords`之一）；
2. `guardType`（钩子类型，可以取的值`beforeRouteEnter`、`beforeRouteUpdate`、`beforeRouteLeave`）；
3. `to`；
4. `from`。

返回值是一个钩子函数列表。

```js
export function extractComponentsGuards(
  matched: RouteRecordNormalized[],
  guardType: GuardType,
  to: RouteLocationNormalized,
  from: RouteLocationNormalizedLoaded
) {
  // 声明一个数组保存钩子函数
  const guards: Array<() => Promise<void>> = []

  for (const record of matched) {
    // 遍历路由对应的组件components
    for (const name in record.components) {
      let rawComponent = record.components[name]
      // 开发环境下进行提示
      if (__DEV__) {
        // 如果组件不存在或组件不是object和function，提示不是有效的组件
        if (
          !rawComponent ||
          (typeof rawComponent !== 'object' &&
            typeof rawComponent !== 'function')
        ) {
          warn(
            `Component "${name}" in record with path "${record.path}" is not` +
              ` a valid component. Received "${String(rawComponent)}".`
          )
          // 抛出错误
          throw new Error('Invalid route component')
        } else if ('then' in rawComponent) { // 如果使用import('./xxx.vue')的方式使用组件，进行提示，并转为() => import('./xxx.vue')
          warn(
            `Component "${name}" in record with path "${record.path}" is a ` +
              `Promise instead of a function that returns a Promise. Did you ` +
              `write "import('./MyPage.vue')" instead of ` +
              `"() => import('./MyPage.vue')" ? This will break in ` +
              `production if not fixed.`
          )
          const promise = rawComponent
          rawComponent = () => promise
        } else if (
          (rawComponent as any).__asyncLoader &&
          // warn only once per component
          !(rawComponent as any).__warnedDefineAsync
        ) { // 如果使用defineAsyncComponent()方式定义的组件，进行提示
          ;(rawComponent as any).__warnedDefineAsync = true
          warn(
            `Component "${name}" in record with path "${record.path}" is defined ` +
              `using "defineAsyncComponent()". ` +
              `Write "() => import('./MyPage.vue')" instead of ` +
              `"defineAsyncComponent(() => import('./MyPage.vue'))".`
          )
        }
      }

      // 如果路由组件没有被挂载跳过update和leave钩子
      if (guardType !== 'beforeRouteEnter' && !record.instances[name]) continue

      // 如果是个路由组件
      // 路由组件需要满足：rawComponent是object || rawComponent有['displayName', 'props`、`__vccOpts`]中的任一属性
      if (isRouteComponent(rawComponent)) {
        // __vccOpts是由vue-class-component添加的
        const options: ComponentOptions =
          (rawComponent as any).__vccOpts || rawComponent
        const guard = options[guardType]
        // 向guards中添加一个异步函数
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name))
      } else {
        // 能进入这个方法的表示rawComponent是个函数；例如懒加载() => import('./xx.vue')；函数式组件() => h('div', 'HomePage')
        // 注意这个的分支只发生在调用beforeRouteEnter之前，后续过程不会进行该过程。
        // 因为在调用beforeRouteEnter钩子之前，会进行异步路由组件的解析，一旦异步路由组件解析成功，会将解析后的组件挂载至对应的components[name]下
        
        // 执行rawComponent，例如懒加载() => import('./xx.vue')；如果函数式组件未声明displayName也会进入此分支
        let componentPromise: Promise<
          RouteComponent | null | undefined | void
        > = (rawComponent as Lazy<RouteComponent>)()

        // 对于函数式组件需要添加一个displayName属性，如果没有，进行提示，并将componentPromise转为一个Promise
        if (__DEV__ && !('catch' in componentPromise)) {
          warn(
            `Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`
          )
          componentPromise = Promise.resolve(componentPromise as RouteComponent)
        }

        // 向guards中添加一个钩子函数，在这个钩子的执行过程中先解析异步路由组件，然后调用钩子函数
        guards.push(() =>
          componentPromise.then(resolved => {
            // 如果解析失败抛出错误
            if (!resolved)
              return Promise.reject(
                new Error(
                  `Couldn't resolve component "${name}" at "${record.path}"`
                )
              )
            // 判断解析后的组件是否为esm，如果是esm，需要取resolved.default
            const resolvedComponent = isESModule(resolved)
              ? resolved.default
              : resolved
            // 使用解析完的组件替换对应的components[name]
            record.components[name] = resolvedComponent
            const options: ComponentOptions =
              (resolvedComponent as any).__vccOpts || resolvedComponent
            // 对应的组件内的钩子
            const guard = options[guardType]
            // 钩子转promise，并执行
            return guard && guardToPromiseFn(guard, to, from, record, name)()
          })
        )
      }
    }
  }

  return guards
}
```

在`navigate`函数最后会调用`guards`中的钩子，并在`beforeRouteLeave`钩子执行完后执行了一系列操作。其实在这里就体现了`vue-router`中钩子的执行顺序：

```js
return (
  runGuardQueue(guards)
    .then(() => {
      // 调用全局beforeEach钩子
      guards = []
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from))
      }
      guards.push(canceledNavigationCheck)

      return runGuardQueue(guards)
    })
    .then(() => {
      // 获取组件中的beforeRouteUpdate钩子，以beforeRouteUpdate() {}方式声明
      guards = extractComponentsGuards(
        updatingRecords,
        'beforeRouteUpdate',
        to,
        from
      )

      // 以onBeforeRouteUpdate注册的
      for (const record of updatingRecords) {
        record.updateGuards.forEach(guard => {
          guards.push(guardToPromiseFn(guard, to, from))
        })
      }
      guards.push(canceledNavigationCheck)

      // 调用beforeRouteUpdate钩子
      return runGuardQueue(guards)
    })
    .then(() => {
      guards = []
      for (const record of to.matched) {
        // 不在重用视图上触发beforeEnter
        // 路由配置中有beforeEnter，并且from不匹配record
        if (record.beforeEnter && !from.matched.includes(record)) {
          if (Array.isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from))
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from))
          }
        }
      }
      guards.push(canceledNavigationCheck)

      // 调用路由配置中的beforeEnter
      return runGuardQueue(guards)
    })
    .then(() => {

      // 清除存在的enterCallbacks 由extractComponentsGuards添加
      to.matched.forEach(record => (record.enterCallbacks = {}))

      // 获取被激活组件中的beforeRouteEnter钩子，在之前会处理异步路由组件
      guards = extractComponentsGuards(
        enteringRecords,
        'beforeRouteEnter',
        to,
        from
      )
      guards.push(canceledNavigationCheck)

      return runGuardQueue(guards)
    })
    .then(() => {
      guards = []
      // 处理全局beforeResolve钩子
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from))
      }
      guards.push(canceledNavigationCheck)

      return runGuardQueue(guards)
    })
    // 捕获任何取消的导航
    .catch(err =>
      isNavigationFailure(err, ErrorTypes.NAVIGATION_CANCELLED)
        ? err
        : Promise.reject(err)
    )
)
```

截止目前一个欠完整的导航的解析流程（包含钩子的执行顺序）如下 ：

1. 导航被触发；
2. 调用失活组件中的`beforeRouteLeave`钩子；
3. 调用全局`beforeEach`钩子；
4. 调用重用组件内的`beforeRouteUpdate`钩子；
5. 调用路由配置中的`beforeEnter`钩子；
6. 解析异步路由组件；
7. 调用激活组件中的`beforeRouteEnter`钩子；
8. 调用全局的`beforeResolve`钩子；

你可能发现了，在每放入一个周期的钩子函数之后，都会紧跟着向`guards`中添加一个`canceledNavigationCheck`函数。这个`canceledNavigationCheck`的函数作用是如果在导航期间有了新的导航，则会`reject`一个`ErrorTypes.NAVIGATION_CANCELLED`错误信息。

```js
function checkCanceledNavigationAndReject(
  to: RouteLocationNormalized,
  from: RouteLocationNormalized
): Promise<void> {
  const error = checkCanceledNavigation(to, from)
  return error ? Promise.reject(error) : Promise.resolve()
}

function checkCanceledNavigation(
  to: RouteLocationNormalized,
  from: RouteLocationNormalized
): NavigationFailure | void {
  if (pendingLocation !== to) {
    return createRouterError<NavigationFailure>(
      ErrorTypes.NAVIGATION_CANCELLED,
      {
        from,
        to,
      }
    )
  }
}
```

在向guards中放入钩子时，都使用了一个guardToPromiseFn，guardToPromiseFn可以将钩子函数转为promise函数。

```js
export function guardToPromiseFn(
  guard: NavigationGuard,
  to: RouteLocationNormalized,
  from: RouteLocationNormalizedLoaded,
  record?: RouteRecordNormalized,
  name?: string
): () => Promise<void> {
  const enterCallbackArray =
    record &&
    (record.enterCallbacks[name!] = record.enterCallbacks[name!] || [])

  return () =>
    new Promise((resolve, reject) => {
      // 这个next函数就是beforeRouteEnter中的next
      const next: NavigationGuardNext = (
        valid?: boolean | RouteLocationRaw | NavigationGuardNextCallback | Error
      ) => {
        // 如果调用next时传入的是false，取消导航
        if (valid === false)
          reject(
            createRouterError<NavigationFailure>(
              ErrorTypes.NAVIGATION_ABORTED,
              {
                from,
                to,
              }
            )
          )
        else if (valid instanceof Error) { // 如果传入了一个Error实例
          reject(valid)
        } else if (isRouteLocation(valid)) { // 如果是个路由。可以进行重定向
          reject(
            createRouterError<NavigationRedirectError>(
              ErrorTypes.NAVIGATION_GUARD_REDIRECT,
              {
                from: to,
                to: valid,
              }
            )
          )
        } else {
          // 如果valid是个函数，会将这个函数添加到record.enterCallbacks[name]中
          // 关于record.enterCallbacks的执行时机，将会在RouterView中进行分析
          if (
            enterCallbackArray &&
            // since enterCallbackArray is truthy, both record and name also are
            record!.enterCallbacks[name!] === enterCallbackArray &&
            typeof valid === 'function'
          )
            enterCallbackArray.push(valid)
          resolve()
        }
      }

      // 调用guard，绑定this为组件实例
      const guardReturn = guard.call(
        record && record.instances[name!],
        to,
        from,
        // next应该只允许被调用一次，如果使用了多次开发环境下给出提示
        __DEV__ ? canOnlyBeCalledOnce(next, to, from) : next
      )
      // 使用Promise.resolve包装guard的返回结果，以允许异步guard
      let guardCall = Promise.resolve(guardReturn)

      // 如果guard参数小于3,guardReturn会作为next的参数
      if (guard.length < 3) guardCall = guardCall.then(next)
      // 如果guard参数大于2
      if (__DEV__ && guard.length > 2) {
        const message = `The "next" callback was never called inside of ${
          guard.name ? '"' + guard.name + '"' : ''
        }:\n${guard.toString()}\n. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`
        // guardReturn是个promise
        if (typeof guardReturn === 'object' && 'then' in guardReturn) {
          guardCall = guardCall.then(resolvedValue => {
            // 未调用next。如：
            // beforeRouteEnter(to, from ,next) {
            //  return Promise.resolve(11)
            // }
            if (!next._called) {
              warn(message)
              return Promise.reject(new Error('Invalid navigation guard'))
            }
            return resolvedValue
          })
          // TODO: test me!
        } else if (guardReturn !== undefined) {
          // 如果有返回值，并且未调用next。如
          // beforeRouteEnter(to, from ,next) {
          //  return 11
          // }
          if (!next._called) {
            warn(message)
            reject(new Error('Invalid navigation guard'))
            return
          }
        }
      }
      // 捕获错误
      guardCall.catch(err => reject(err))
    })
}
```

`guardToPromiseFn`中声明的的`next`方法会作为钩子函数的第三个参数。如果在使用钩子函数时，形参的数量<3，那么钩子函数的返回值会作为next函数的参数；形参数量>2时，如果钩子函数的返回值是`Promise`，但未调用`next`，会抛出错误`Invalid navigation guard`，如果钩子函数的返回值不为`undefined`，也未调用next也会抛出错误`Invalid navigation guard`。

所以如果在使用路由钩子的过程中，如果钩子函数的形参>2，也就是你的形参中有`next`，你必须要调用`next`。如果你不想自己调用`next`，那么你要保证形参<2，同时钩子函数返回某个数据，这样`vue-router`会自动调用next。这里需要注意如果传递给next的参数是个function，那么这个function会被存入`record.enterCallbacks[name]`中。关于钩子函数中`next`的使用以下是一些示例：

```js
beforeRouteEnter(from, to) {
    return false
}
// 等同于
beforeRouteEnter(from, to, next) {
    next(false)
}
// 不能写为如下
beforeRouteEnter(from, to, next) {
    return false
}

// 返回Promise
beforeRouteEnter(from, to) {
    return Promise.resolve(...)
}
// 返回function
beforeRouteEnter(from, to) {
    return function() { ... }
}
```

执行钩子列表的函数`runGuardQueue`，只有当前钩子执行完毕，才会执行下一个钩子：

```js
function runGuardQueue(guards: Lazy<any>[]): Promise<void> {
  return guards.reduce(
    (promise, guard) => promise.then(() => guard()),
    Promise.resolve()
  )
}
```

在`pushWithRedirect`函数最后，在`navigate`执行完后并没有结束，而是又进行了以下操作：

```js
// 首先判断之前的操作是否出错
// 如果出错，将failure使用Promise.resolve包装，进入.then
// 如果未出错，调用navigate()，navigate过程中失败，进入.catch，成功进入.then
// 注意这里catch发生在then之前，所以catch运行完，可能会继续进入then
return (failure ? Promise.resolve(failure) : navigate(toLocation, from))
  .catch((error: NavigationFailure | NavigationRedirectError) =>
    isNavigationFailure(error)
      ? 
      isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT)
        ? error // navigate过程中发生的重定向，进入.then
        : markAsReady(error)
      : // reject 未知的错误
      triggerError(error, toLocation, from)
  )
  .then((failure: NavigationFailure | NavigationRedirectError | void) => {
    if (failure) {
      // 如果是重定向错误
      if (
        isNavigationFailure(failure, ErrorTypes.NAVIGATION_GUARD_REDIRECT)
      ) {
        // 如果是循环的重定向（检测循环次数超过10次）
        if (
          __DEV__ &&
          // 重定向的位置与toLocation相同
          isSameRouteLocation(
            stringifyQuery,
            resolve(failure.to),
            toLocation
          ) &&
          redirectedFrom &&
          // 循环次数
          (redirectedFrom._count = redirectedFrom._count
            ? 
            redirectedFrom._count + 1
            : 1) > 10
        ) {
          warn(
            `Detected an infinite redirection in a navigation guard when going from "${from.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`
          )
          return Promise.reject(
            new Error('Infinite redirect in navigation guard')
          )
        }

        // 递归调用pushWithRedirect，进行重定向
        return pushWithRedirect(
          // keep options
          assign(locationAsObject(failure.to), {
            state: data,
            force,
            replace,
          }),
          // preserve the original redirectedFrom if any
          redirectedFrom || toLocation
        )
      }
    } else {
      // 如果在navigate过程中没有抛出错误信息
      failure = finalizeNavigation(
        toLocation as RouteLocationNormalizedLoaded,
        from,
        true,
        replace,
        data
      )
    }
    // 触发全局afterEach钩子
    triggerAfterEach(
      toLocation as RouteLocationNormalizedLoaded,
      from,
      failure
    )
    return failure
  })
```

可以发现，如果navigate过程执行顺利的话，最后会执行一个finalizeNavigation方法，然后触发全局afterEach钩子。那么我们来看下finalizeNavigation是做什么的。

```js
function finalizeNavigation(
  toLocation: RouteLocationNormalizedLoaded,
  from: RouteLocationNormalizedLoaded,
  isPush: boolean,
  replace?: boolean,
  data?: HistoryState
): NavigationFailure | void {
  // 检查是否取消了导航
  const error = checkCanceledNavigation(toLocation, from)
  if (error) return error

  // 第一次导航
  const isFirstNavigation = from === START_LOCATION_NORMALIZED
  const state = !isBrowser ? {} : history.state

  // 仅当用户进行了push/replace并且不是初始导航时才更改 URL，因为它只是反映了 url
  if (isPush) {
    // replace为true或首次导航，使用routerHistory.replace 
    if (replace || isFirstNavigation)
      routerHistory.replace(
        toLocation.fullPath,
        assign(
          {
            // 如果是第一次导航，重用history.state中的scroll
            scroll: isFirstNavigation && state && state.scroll,
          },
          data
        )
      )
    else routerHistory.push(toLocation.fullPath, data)
  }

  // toLocation成为了当前导航
  currentRoute.value = toLocation
  // 处理滚动
  handleScroll(toLocation, from, isPush, isFirstNavigation)

  // 路由相关操作准备完毕
  markAsReady()
}
```

可以看出finalizeNavigation函数的作用是确认我们的导航，它主要做两件事：改变url(如果需要改变)、处理滚动行为。在最后有个markAsReady方法，我们继续看markAsReady是做什么的。

```js
function markAsReady<E = any>(err?: E): E | void {
  // 只在ready=false时进行以下操作
  if (!ready) {
    // 如果发生错误，代表还是未准备好
    ready = !err
    // 设置监听器
    setupListeners()
    // 执行ready回调
    readyHandlers
      .list()
      .forEach(([resolve, reject]) => (err ? reject(err) : resolve()))
    // 重置ready回调列表
    readyHandlers.reset()
  }
  return err
}
```

`markAsReady`函数会标记路由的准备状态，执行通过`isReady`添加的回调。

截止到此，`push`方法也就结束了，此时一个欠完整的的导航解析流程可以更新为：

1. 导航被触发；
2. 调用失活组件中的`beforeRouteLeave`钩子；
3. 调用全局`beforeEach`钩子；
4. 调用重用组件内的`beforeRouteUpdate`钩子；
5. 调用路由配置中的`beforeEnter`钩子；
6. 解析异步路由组件；
7. 调用激活组件中的`beforeRouteEnter`钩子；
8. 调用全局的`beforeResolve`钩子；
9. 导航被确认；
10. 调用全局的`afterEach`钩子；

### 10.3 replace

`replace`与`push`作用几乎相同，如果`push`时指定`replace: true`，那么和直接使用`replace`一致。

```js
function replace(to: RouteLocationRaw | RouteLocationNormalized) {
  return push(assign(locationAsObject(to), { replace: true }))
}
```

这里调用了一个`locationAsObject`，如果`to`是`string`，会调用`parseURL`解析`to`，关于`parseURL`的实现可参考之前`router.resolve`的分析，它的主要作用是将`to`解析成一个含有`fullPath（fullPath = path + searchString + hash）`、`path`（一个绝对路径）、`query`（query对象）、`hash`（#及#之后的字符串）的对象。

```js
function locationAsObject(
  to: RouteLocationRaw | RouteLocationNormalized
): Exclude<RouteLocationRaw, string> | RouteLocationNormalized {
  return typeof to === 'string'
    ? parseURL(parseQuery, to, currentRoute.value.path)
    : assign({}, to)
}
```

### 10.4 总结

简单描述`push`的执行流程：先进行重定向的判断，如果需要重定向，立马指向重定向的路由；然后判断要跳转到的路由地址与`from`的路由地址是否相同，如果相同，在未指定`force`的情况下，会创建一个错误信息，并处理滚动行为；紧接着调用`extractChangingRecords`，将`to`与`from`所匹配到的路由进行分组，并依此提取并执行钩子函数，如果过程中不出错的话，最后会执行`finalizeNavigation`方法，在`finalizeNavigation`调用`routerHistory.reaplce/push`更新历史栈，并处理滚动，最后执行`markAsReady`，将`ready`设置为`true`，并调用通过`isReady`添加的方法。

通过分析`push`的实现过程，我们可以初步得出了一个完整的导航解析流程：

1. 导航被触发；
2. 调用失活组件中的`beforeRouteLeave`钩子；
3. 调用全局`beforeEach`钩子；
4. 调用重用组件内的`beforeRouteUpdate`钩子；
5. 调用路由配置中的`beforeEnter`钩子；
6. 解析异步路由组件；
7. 调用激活组件中的`beforeRouteEnter`钩子；
8. 调用全局的`beforeResolve`钩子；
9. 导航被确认；
10. 调用全局的`afterEach`钩子；

下面我们使用流程图来总结下整个`push`过程：

![vue3-router-push](/Volumes/F/zyl-study/web-zhuawa/20221203/vue3-router-push.png)



# Vue Router源码解析（2/2）

https://www.yuque.com/lpldplws/web/mo0sqg37epmtp41w?singleDoc# 《Vue Router源码解析(2/2)》 密码：bq3h

## 1.课程目标

1. 掌握Vue Router的核心源码；
2. 掌握前端中一个完整的Router需要实现怎样的效果；

## 2.课程大纲

- vue router源码解析

## 3.router.action解析

这里的action主要指代 `router.go`、`router.back`、`router.forward`。

#### 3.1 使用

`go`函数允许你在历史中前进或后退，指定步数如果`>0`，代表前进；`<0`代表后退。

```js
router.go(-2)

router.back()
// 等同于
router.go(-1)

router.forward()
// 等同于
router.go(1)
```

#### 3.2 go

`go`接收一个参数`delta`，表示相对当前页面，移动多少步，负数表示后退，正数表示前进。

```js
const go = (delta: number) => routerHistory.go(delta)
```

在routerHistory.go中会调用history.go，进而触发popstate监听函数。如果你看过之前createWebHistory的解析，你会知道在createWebHistory中通过useHistoryListeners创建historyListeners时，会注册一个popstate监听函数，这个监听函数在调用history.go后就会触发。

```js
// 文件位置：src/history/html5.ts useHistoryListeners方法
window.addEventListener('popstate', popStateHandler)

const popStateHandler: PopStateListener = ({
 state,
}: {
  state: StateEntry | null
}) => {
  // 当前location，字符串
  const to = createCurrentLocation(base, location)
  const from: HistoryLocation = currentLocation.value
  const fromState: StateEntry = historyState.value
  let delta = 0

  // 如果不存在state
  // 关于为什么state可能为空，可参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event
  if (state) {
    currentLocation.value = to
    historyState.value = state

    // 如果暂停监听了，并且暂停时的状态是from，直接return
    if (pauseState && pauseState === from) {
      pauseState = null
      return
    }
    // 计算移动的步数
    delta = fromState ? state.position - fromState.position : 0
  } else {
    replace(to)
  }

  // 循环调用监听函数
  listeners.forEach(listener => {
    listener(currentLocation.value, from, {
      delta,
      type: NavigationType.pop,
      direction: delta
        ? delta > 0
          ? NavigationDirection.forward
          : NavigationDirection.back
        : NavigationDirection.unknown,
    })
  })
}
```

可以看到，在监听函数最后会循环调用listeners中的listener，那么listener是什么？什么时候被添加的呢？
在上节课介绍install的实现时，其中有一步非常重要的操作就是要根据地址栏的url进行第一次跳转。而个跳转是通过调用push方法完成的，因为push会调用pushWidthRedirect方法，在pushWidthRedirect中的最后会执行finalizeNavigation（不考虑中间reject错误）。而在finalizeNavigation中的最后会调用一个markAsReady方法。

```js
function markAsReady<E = any>(err?: E): E | void {
  if (!ready) {
    // still not ready if an error happened
    ready = !err
    setupListeners()
    readyHandlers
      .list()
      .forEach(([resolve, reject]) => (err ? reject(err) : resolve()))
    readyHandlers.reset()
  }
  return err
}
```

在markAsReady中调用了setupListeners的一个方法。在这个方法中会调用routerHistory.listen()添加一个函数。

```js
let removeHistoryListener: undefined | null | (() => void)
function setupListeners() {
  // 如果有removeHistoryListener，说明已经添加过listener
  if (removeHistoryListener) return
  // 调用routerHistory.listen添加监听函数，routerHistory.listen返回一个删除这个listener函数
  removeHistoryListener = routerHistory.listen((to, _from, info) => {
    const toLocation = resolve(to) as RouteLocationNormalized

    // 确定是否存在重定向
    const shouldRedirect = handleRedirectRecord(toLocation)
    if (shouldRedirect) {
      pushWithRedirect(
        assign(shouldRedirect, { replace: true }),
        toLocation
      ).catch(noop)
      return
    }

    pendingLocation = toLocation
    const from = currentRoute.value

    // 保存from滚动位置
    if (isBrowser) {
      saveScrollPosition(
        getScrollKey(from.fullPath, info.delta),
        computeScrollPosition()
      )
    }
    
    navigate(toLocation, from)
      .catch((error: NavigationFailure | NavigationRedirectError) => {
        // 导航被取消
        if (
          isNavigationFailure(
            error,
            ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_CANCELLED
          )
        ) {
          return error
        }
        // 在钩子中进行了重定向
        if (
          isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT)
        ) {
          pushWithRedirect(
            (error as NavigationRedirectError).to,
            toLocation
          )
            .then(failure => {
              // 钩子中的重定向过程中如果导航被取消或导航冗余，回退一步
              if (
                isNavigationFailure(
                  failure,
                  ErrorTypes.NAVIGATION_ABORTED |
                    ErrorTypes.NAVIGATION_DUPLICATED
                ) &&
                !info.delta &&
                info.type === NavigationType.pop
              ) {
                routerHistory.go(-1, false)
              }
            })
            .catch(noop)
          return Promise.reject()
        }
        // 恢复历史记录，，但不触发监听
        if (info.delta) routerHistory.go(-info.delta, false)
        // 无法识别的错误，交给全局错误处理器
        return triggerError(error, toLocation, from)
      })
      .then((failure: NavigationFailure | void) => {
        failure =
          failure ||
          finalizeNavigation(
            toLocation as RouteLocationNormalizedLoaded,
            from,
            false
          )
        
        if (failure) {
          // 如果存在错误信息，回到原始位置，但不触发监听
          if (info.delta) {
            routerHistory.go(-info.delta, false)
          } else if (
            info.type === NavigationType.pop &&
            isNavigationFailure(
              failure,
              ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED
            )
          ) { // 错误类型时导航被取消或冗余，回退历史记录，但不触发监听
            routerHistory.go(-1, false)
          }
        }

        // 触发全局afterEach钩子
        triggerAfterEach(
          toLocation as RouteLocationNormalizedLoaded,
          from,
          failure
        )
      })
      .catch(noop)
  })
}
```

可以看到这个监听函数和`push`的过程十分相似，与`push`不同的是，在触发监听时，一旦出现了一些错误信息（如导航被取消、导航时冗余的、位置错误），需要将历史记录回退到相应位置。

go的执行流程：

![vue3-router-go](/Volumes/F/zyl-study/web-zhuawa/20221203/vue3-router-go.png)

### 3.3 back

`back`，回退一个历史记录，相当于`go(-1)`。

```js
const router = {
  // ...
  back: () => go(-1),
  // ...
}
```

### 3.4 forward

forward，前进一个历史记录，相当于go(1)。

```js
const router = {
  // ...
  forward: () => go(1),
  // ...
}
```

### 3.5. 总结

`go`、`back`、`forward`方法最终通过调用`history.go`方法，触发`popstate`事件（`popstate`中的监听函数在第一次路由跳转时被添加），而在`popstate`事件中的过程和`push`的过程是十分相似的，与`push`不同的是，一旦出现了一些错误信息（如导航被取消、导航时冗余的、位置错误），需要将历史记录回退到相应位置。

## 4. 全局导航守卫解析

### 4.1 使用

全局导航守卫有三种：

- `beforeEach`：在任何导航之前执行。返回一个删除已注册导航守卫的函数；
- `beforeResolve`：在导航解析之前执行。返回一个删除已注册导航守卫的函数；
- `afterEach`：在任何导航之后执行。返回一个删除已注册导航守卫的函数；

```js
const router = createRouter({ // ... })

router.beforeEach = function() { // ... }
router.beforeResolve = function() { // ... }
router.afterEach = function() { // ... }
```

### 4.2 全局导航守卫实现

全局导航守卫和`onError`的实现都是通过维护一个数组进行实现。在`vue-router`中通过一个`useCallbacks`的函数可以创建一个可以重置的列表，全局钩子及`onError`就是通过`useCallbacks`实现。

```js
const beforeGuards = useCallbacks<NavigationGuardWithThis<undefined>>()
const beforeResolveGuards = useCallbacks<NavigationGuardWithThis<undefined>>()
const afterGuards = useCallbacks<NavigationHookAfter>()
let errorHandlers = useCallbacks<_ErrorHandler>()

const router = {
  // ...
  beforeEach: beforeGuards.add,
  beforeResolve: beforeResolveGuards.add,
  afterEach: afterGuards.add,
  onError: errorHandlers.add,
  // ...
}
```

useCallbacks

```js
export function useCallbacks<T>() {
  let handlers: T[] = []

  function add(handler: T): () => void {
    handlers.push(handler)
    return () => {
      const i = handlers.indexOf(handler)
      if (i > -1) handlers.splice(i, 1)
    }
  }

  function reset() {
    handlers = []
  }

  return {
    add,
    list: () => handlers,
    reset,
  }
}
```

`useCallbacks`返回一个对象，该对象有三个属性。其中`list`是内部维护的列表；`add`是一个添加`handler`的函数，它返回一个删除对应`handler`的函数；`reset`是个重置列表的函数。

除此之外，全局导航守卫的具体执行时机同`router.push`。

## 5. isReady解析

### 5.1 使用

```js
router.isReady()
  .then(() => {
    // 成功
  })
  .catch(() => {
    // 失败
  })
```

### 5.2 isReady

isReady不接受任何参数。如果路由器已经完成了初始化导航，那么会立即解析Promise，相反如果还没有完成初始化导航，那么会将resolve和reject放入一个数组中，并添加到一个列表中，等待初始化导航完成进行触发。

```js
let readyHandlers = useCallbacks<OnReadyCallback>()

function isReady(): Promise<void> {
  // ready为true并且当前路由不是初始路由，导航已经初始化完毕，立即解析promise
  if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
    return Promise.resolve()
  // 相反，会将resolve、reject存入一个列表
  return new Promise((resolve, reject) => {
    readyHandlers.add([resolve, reject])
  })
}
```

在之前解析的push过程中，无论过程中是否有错误信息，都会执行一个markAsReady函数。在markAsReady中会将isReady处理函数进行触发，触发完毕后，会将列表清空。

```js
function markAsReady<E = any>(err?: E): E | void {
  if (!ready) {
    // 如果存在err，说明还未准备好，如果不存在err，那么说明初始化导航已经完成，ready变为true，之后就不会再进入这个分支
    ready = !err
    // 设置popstate监听函数
    setupListeners()
    // 触发ready处理函数，有错误执行reject(err)，没有执行resolve()
    readyHandlers
      .list()
      .forEach(([resolve, reject]) => (err ? reject(err) : resolve()))
    // 执行完，清空列表
    readyHandlers.reset()
  }
  return err
}
```

## 6. onBeforeRouteLeave、onBeforeRouteUpdate解析

### 6.1 使用

`onBeforeRouteLeave`、`onBeforeRouteUpdate`是`vue-router`提供的两个`composition api`，它们只能被用于`setup`中。

```js
export default {
  setup() {
    onBeforeRouteLeave() {}
    
    onBeforeRouteUpdate() {}
  }
}
```

### 6.2 onBeforeRouteLeave

```js
export function onBeforeRouteLeave(leaveGuard: NavigationGuard) {
  // 开发模式下没有组件实例，进行提示并return
  if (__DEV__ && !getCurrentInstance()) {
    warn(
      'getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function'
    )
    return
  }

  // matchedRouteKey是在RouterView中进行provide的，表示当前组件所匹配到到的路由记录（经过标准化处理的）
  const activeRecord: RouteRecordNormalized | undefined = inject(
    matchedRouteKey,
    // to avoid warning
    {} as any
  ).value

  if (!activeRecord) {
    __DEV__ &&
      warn(
        'No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?'
      )
    return
  }

  // 注册钩子
  registerGuard(activeRecord, 'leaveGuards', leaveGuard)
}
```

因为`onBeforeRouteLeave`是作用在组件上的，所以`onBeforeRouteLeave`开头就需要检查当前是否有vue实例（只在开发环境下），如果没有实例进行提示并`return`。

```js
if (__DEV__ && !getCurrentInstance()) {
  warn(
    'getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function'
  )
  return
}
```

然后使用`inject`获取一个`matchedRouteKey`，并赋给一个`activeRecord`，那么个`activeRecord`是个什么呢？

```js
const activeRecord: RouteRecordNormalized | undefined = inject(
  matchedRouteKey,
  // to avoid warning
  {} as any
).value
```

要想知道`activeRecord`是什么，我们就需要知道`matchedRouteKey`是什么时候`provide`的。因为`onBeforeRouteLeave`式作用在路由组件中的，而路由组件一定是`RouterView`的子孙组件，所以我们可以从`RouterView`中找一下答案。

在`RouterView`中的`setup`有这么几行代码：

```js
setup(props, ...) {
  // ...
  const injectedRoute = inject(routerViewLocationKey)!
  const routeToDisplay = computed(() => props.route || injectedRoute.value)
  const depth = inject(viewDepthKey, 0)
  const matchedRouteRef = computed<RouteLocationMatched | undefined>(
    () => routeToDisplay.value.matched[depth]
  )

  provide(viewDepthKey, depth + 1)
  provide(matchedRouteKey, matchedRouteRef)
  provide(routerViewLocationKey, routeToDisplay)
  // ...
}
```

可以看到就是在`RouterView`中进行了`provide(matchedRouteKey, matchedRouteRef)`的，那么`matchedRouteRef`是什么呢？

首先`matchedRouteRef`是个计算属性，它的返回值是`routeToDisplay.value.matched[depth]`。接着我们看`routeToDisplay`和`depth`，先看`routeToDisplay`，`routeToDisplay`也是个计算属性，它的值是`props.route`或`injectedRoute.value`，因为`props.route`使用户传递的，所以这里我们只看`injectedRoute.value`，`injectedRoute`也是通过`inject`获取的，获取的`key`是`routerViewLocationKey`。看到这个`key`是不是有点熟悉，在`vue-router`进行`install`中向`app`中注入了几个变量，其中就有`routerViewLocationKey`。

```js
install(app) {
  //...
  app.provide(routerKey, router)
  app.provide(routeLocationKey, reactive(reactiveRoute))
  // currentRoute路由标准化对象
  app.provide(routerViewLocationKey, currentRoute)
  //...
}
```

现在我们知道routeToDisplay是当前路由的标准化对象。接下来看depth是什么。depth也是通过inject(viewDepthKey)的方式获取的，但它有默认值，默认是0。你会发现紧跟着有一行provide(viewDepthKey, depth + 1)，RouterView又把viewDepthKey注入进去了，不过这次值加了1。为什么这么做呢？
我们知道RouterView是允许嵌套的，来看下面代码：

```js
<RouterView>
  <RouterView>
    <RouterView />
  </RouterView>
</RouterView>
```

在第一层RouterView中，因为找不到对应的viewDepthKey，所以depth是0，然后将viewDepthKey注入进去，并+1；在第二层中，我们可以找到viewDepthKey（在第一次中注入），depth为1，然后再将viewDepthKey注入，并+1，此时viewDepthKey的值会覆盖第一层的注入；在第三层中，我们也可以找到viewDepthKey（在二层中注入，并覆盖了第一层的值），此时depth为2。是不是发现了什么？depth其实代表当前RouterView在嵌套RouterView中的深度（从0开始）。
现在我们知道了routeToDisplay和depth，现在我们看routeToDisplay.value.matched[depth]。我们知道routeToDisplay.value.matched中存储的是当前路由所匹配到的路由，并且他的顺序是父路由在子路由前。那么索引为depth的路由有什么特别含义呢？我们看下面一个例子：

```js
// 注册的路由表
const router = createRouter({
  // ...
  routes: {
    path: '/parent',
    component: Parent,
    name: 'Parent',
    children: [
      {
        path: 'child',
        name: 'Child',
        component: Child,
        children: [
          {
            name: 'ChildChild',
            path: 'childchild',
            component: ChildChild,
          },
        ],
      },
    ],
  }
})
```

```js
<!-- Parent -->
<template>
  <div>
    <p>parent</p>
    <router-view></router-view>
  </div>
</template>

<!-- Child -->
<template>
  <div>
    <p>child</p>
    <router-view></router-view>
  </div>
</template>

<!-- ChildChild -->
<template>
  <div>
    <p>childchild</p>
  </div>
</template>
```

使用`router.resolve({ name: 'ChildChild' })`，打印其结果，观察matched属性。

1. 在第一层`RouterView`中，`depth`为0，`matched[0]`为`{path:'/parent', name: 'Parent', ...}`(此处只列几个关键属性)，`level`为1；
2. 在第二层`RouterView`中，`depth`为1，`matched[1]`为`{path:'/parent/child', name: 'Child', ...}`，`level`为2；
3. 在第三层`RouterView`中，`depth`为2，`matched[2]`为`{path:'/parent/child/childchild', name: 'ChildChild', ...}`，`level`为3；

通过观察，`depth`的值与路由的匹配顺序刚好一致。`matched[depth].name`恰好与当前`resolve`的`name`一致。也就是说`onBeforeRouteLeave`中的`activeRecord`当前组件所匹配到的路由。

接下来看下钩子时如何注册的？在`onBeforeRouteLeave`，会调用一个`registerGuard`函数，`registerGuard`接收三个参数：

1. `record`（所在组件所匹配到的标准化路由）；
2. `name`（钩子名，只能取leaveGuards、updateGuards之一）;
3. `guard`（待添加的导航守卫）;

```js
function registerGuard(
  record: RouteRecordNormalized,
  name: 'leaveGuards' | 'updateGuards',
  guard: NavigationGuard
) {
  // 一个删除钩子的函数
  const removeFromList = () => {
    record[name].delete(guard)
  }

  // 卸载后移除钩子
  onUnmounted(removeFromList)
  // 被keep-alive缓存的组件失活时移除钩子
  onDeactivated(removeFromList)

  // 被keep-alive缓存的组件激活时添加钩子
  onActivated(() => {
    record[name].add(guard)
  })

  // 添加钩子，record[name]是个set，在路由标准化时处理的
  record[name].add(guard)
}
```

### 6.3 onBeforeRouteUpdate

onBeforeRouteUpdate的实现与onBeforeRouteLeave的实现完全一致，只是调用registerGuard传递的参数不一样。

```js
export function onBeforeRouteUpdate(updateGuard: NavigationGuard) {
  if (__DEV__ && !getCurrentInstance()) {
    warn(
      'getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function'
    )
    return
  }

  const activeRecord: RouteRecordNormalized | undefined = inject(
    matchedRouteKey,
    // to avoid warning
    {} as any
  ).value

  if (!activeRecord) {
    __DEV__ &&
      warn(
        'No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?'
      )
    return
  }

  registerGuard(activeRecord, 'updateGuards', updateGuard)
}
```

## 7. useRoute、useRouter、useLink解析

### 7.1 使用

```typescript
<script lant="ts" setup>
  import { useRouter, useRoute } from 'vue-router'
  
  // router为创建的router实例
  const router = useRouter()
  // currentRoute当前路由
  const currentRoute = useRoute()
</script>
```

使用useLink可以自定义我们自己的RouterLink，如下面自定的MyRouterLink，如果是外部链接，我们需要让它新打开一个页面。

```typescript
<template>
  <a
    v-if="isExternalLink"
    v-bind="$attrs"
    :class="classes"
    :href="to"
    target="_blank"
  >
    <slot />
  </a>
  <a
    v-else
    v-bind="$attrs"
    :class="classes"
    :href="href"
    @click="navigate"
  >
    <slot />
  </a>
</template>

<script lang="ts">
export default {
  name: 'MyRouterLink',
}
</script>

<script lang="ts" setup>
import { useLink, useRoute, RouterLink } from 'vue-router'
import { computed } from 'vue'

const props = defineProps({
  // @ts-ignore
  ...RouterLink.props
})

const { route, href, navigate, isActive, isExactActive  } = useLink(props)

const isExternalLink= computed(() => typeof props.to === 'string' && props.to.startsWith('http'))

const currentRoute = useRoute()

const classes = computed(() => ({
  'router-link-active':
    isActive.value || currentRoute.path.startsWith(route.value.path),
  'router-link-exact-active':
    isExactActive.value || currentRoute.path === route.value.path,
}))
</script>
```

`MyRouterLink`使用：

```js
<my-router-link to="https://www.xxx.com">MyRouterLink External Link</my-router-link>
<my-router-link to="/home">MyRouterLink /home</my-router-link>
```

### 7.2 useRouter、useRoute

```typescript
export function useRouter(): Router {
  return inject(routerKey)!
}

export function useRoute(): RouteLocationNormalizedLoaded {
  return inject(routeLocationKey)!
}
```

useRouter和useRoute都是使用inject来进行获取对应值。对应值都是在install过程中注入的。

```js
install(app) {
  // ...
  app.provide(routerKey, router)
  app.provide(routeLocationKey, reactive(reactiveRoute))
  // ...
}
```

### 7.3 useLink

```typescript
export function useLink(props: UseLinkOptions) {
  // router实例
  const router = inject(routerKey)!
  // 当前路由地址
  const currentRoute = inject(routeLocationKey)!

  // 目标路由相关信息
  const route = computed(() => router.resolve(unref(props.to)))

  // 被激活记录的索引
  const activeRecordIndex = computed<number>(() => {
    const { matched } = route.value
    const { length } = matched
    // 目标路由所匹配到的完整路由
    const routeMatched: RouteRecord | undefined = matched[length - 1]
    const currentMatched = currentRoute.matched
    // 如果没有匹配到的目标路由或当前路由也没有匹配到的路由返回-1
    if (!routeMatched || !currentMatched.length) return -1
    // 在当前路由所匹配到的路由中寻找目标路由
    const index = currentMatched.findIndex(
      isSameRouteRecord.bind(null, routeMatched)
    )
    if (index > -1) return index
    // 目标路由匹配到的路由的父路由的path（如果父路由是由别名产生，取源路由的path）
    const parentRecordPath = getOriginalPath(
      matched[length - 2] as RouteRecord | undefined
    )
    return (
      length > 1 &&
        // 如果目标路由的父路由与
        getOriginalPath(routeMatched) === parentRecordPath &&
        // 避免将孩子与父路由比较
        currentMatched[currentMatched.length - 1].path !== parentRecordPath
        ? currentMatched.findIndex(
            isSameRouteRecord.bind(null, matched[length - 2])
          )
        : index
    )
  })

  // 当前router-link是否处于激活状态，activeRecordIndex大于-1并且，当前路由的params与目标路由的params相同
  const isActive = computed<boolean>(
    () =>
      activeRecordIndex.value > -1 &&
      includesParams(currentRoute.params, route.value.params)
  )
  // 是否完全匹配，目标路由必须和当前路由所匹配到的路由最后一个相同
  const isExactActive = computed<boolean>(
    () =>
      activeRecordIndex.value > -1 &&
      activeRecordIndex.value === currentRoute.matched.length - 1 &&
      isSameRouteLocationParams(currentRoute.params, route.value.params)
  )

  // 利用push或replace进行路由跳转
  function navigate(
    e: MouseEvent = {} as MouseEvent
  ): Promise<void | NavigationFailure> {
    // 对于一些特殊情况，不能进行跳转
    if (guardEvent(e)) {
      return router[unref(props.replace) ? 'replace' : 'push'](
        unref(props.to)
      ).catch(noop)
    }
    return Promise.resolve()
  }

  // devtools only
  if ((__DEV__ || __FEATURE_PROD_DEVTOOLS__) && isBrowser) {
    // ...
  }

  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate,
  }
}
```

在进行路由跳转时，一些特殊情况下是不能跳转的，这些情况包括：

1. 按住了`window`⊞（MAC的`commond`）键、`alt`键、`ctrl`键、`shift`键中的任一键；
2. 调用过`e.preventDefault()`；
3. 右键；
4. `target='_blank'`；

```typescript
function guardEvent(e: MouseEvent) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return
  // don't redirect when preventDefault called
  if (e.defaultPrevented) return
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) return
  // don't redirect if `target="_blank"`
  // @ts-expect-error getAttribute does exist
  if (e.currentTarget && e.currentTarget.getAttribute) {
    // @ts-expect-error getAttribute exists
    const target = e.currentTarget.getAttribute('target')
    if (/\b_blank\b/i.test(target)) return
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) e.preventDefault()

  return true
}
```

## 8. RouterLink解析

## 8.1使用

```js
<RouterLink
 to="/inex"
 reaplace
 custom
 activeClass="active"
 exactActiveClass="exact-active"
 ariaCurrentValue="page"
>To Index Page</RouterLink>
```

### 8.2 RouterLink

```js
export const RouterLinkImpl = /*#__PURE__*/ defineComponent({
  name: 'RouterLink',
  props: {
    // 目标路由的链接
    to: {
      type: [String, Object] as PropType<RouteLocationRaw>,
      required: true,
    },
    // 决定是否调用router.push()还是router.replace()
    replace: Boolean,
    // 链接被激活时，用于渲染a标签的class
    activeClass: String,
    // inactiveClass: String,
    // 链接精准激活时，用于渲染a标签的class
    exactActiveClass: String,
    // 是否不应该将内容包裹在<a/>标签中
    custom: Boolean,
    // 传递给aria-current属性的值。https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current
    ariaCurrentValue: {
      type: String as PropType<RouterLinkProps['ariaCurrentValue']>,
      default: 'page',
    },
  },
  useLink,

  setup(props, { slots }) {
    // 使用useLink创建router-link所需的一些属性和行为
    const link = reactive(useLink(props))
    // createRouter时传入的options
    const { options } = inject(routerKey)!

    // class对象
    const elClass = computed(() => ({
      [getLinkClass(
        props.activeClass,
        options.linkActiveClass,
        'router-link-active'
      )]: link.isActive, // 被激活时的class
      [getLinkClass(
        props.exactActiveClass,
        options.linkExactActiveClass,
        'router-link-exact-active'
      )]: link.isExactActive, // 被精准激活的class
    }))

    return () => {
      // 默认插槽
      const children = slots.default && slots.default(link)
      // 如果设置了props.custom，直接显示chldren，反之需要使用a标签包裹
      return props.custom
        ? children
        : h(
            'a',
            {
              'aria-current': link.isExactActive
                ? props.ariaCurrentValue
                : null,
              href: link.href,
              onClick: link.navigate,
              class: elClass.value,
            },
            children
          )
    }
  },
})

export const RouterLink = RouterLinkImpl as unknown as {
  new (): {
    $props: AllowedComponentProps &
      ComponentCustomProps &
      VNodeProps &
      RouterLinkProps

    $slots: {
      default: (arg: UnwrapRef<ReturnType<typeof useLink>>) => VNode[]
    }
  }
  useLink: typeof useLink
}
```

## 9. RouterView解析

### 9.1 使用

```js
<RouterView></RouterView>
```

### 9.2 RouterView

```js
export const RouterViewImpl = /*#__PURE__*/ defineComponent({
  name: 'RouterView',
  inheritAttrs: false,
  props: {
    // 如果设置了name，渲染对应路由配置下中components下的相应组件
    name: {
      type: String as PropType<string>,
      default: 'default',
    },
    route: Object as PropType<RouteLocationNormalizedLoaded>,
  },

  // 为@vue/compat提供更好的兼容性
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },

  setup(props, { attrs, slots }) {
    // 如果<router-view>的父节点是<keep-alive>或<transition>进行提示
    __DEV__ && warnDeprecatedUsage()

    // 当前路由
    const injectedRoute = inject(routerViewLocationKey)!
    // 要展示的路由，优先取props.route
    const routeToDisplay = computed(() => props.route || injectedRoute.value)
    // router-view的深度，从0开始
    const depth = inject(viewDepthKey, 0)
    // 要展示的路由匹配到的路由
    const matchedRouteRef = computed<RouteLocationMatched | undefined>(
      () => routeToDisplay.value.matched[depth]
    )

    provide(viewDepthKey, depth + 1)
    provide(matchedRouteKey, matchedRouteRef)
    provide(routerViewLocationKey, routeToDisplay)

    const viewRef = ref<ComponentPublicInstance>()
    
    watch(
      () => [viewRef.value, matchedRouteRef.value, props.name] as const,
      ([instance, to, name], [oldInstance, from, oldName]) => {
        if (to) {
          // 当导航到一个新的路由，更新组件实例
          to.instances[name] = instance
          // 组件实例被应用于不同路由
          if (from && from !== to && instance && instance === oldInstance) {
            if (!to.leaveGuards.size) {
              to.leaveGuards = from.leaveGuards
            }
            if (!to.updateGuards.size) {
              to.updateGuards = from.updateGuards
            }
          }
        }

        // 触发beforeRouteEnter next回调
        if (
          instance &&
          to &&
          (!from || !isSameRouteRecord(to, from) || !oldInstance)
        ) {
          ;(to.enterCallbacks[name] || []).forEach(callback =>
            callback(instance)
          )
        }
      },
      { flush: 'post' }
    )

    return () => {
      const route = routeToDisplay.value
      const matchedRoute = matchedRouteRef.value
      // 需要显示的组件
      const ViewComponent = matchedRoute && matchedRoute.components[props.name]
      const currentName = props.name

      // 如果找不到对应组件，使用默认的插槽
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route })
      }

      // 路由中的定义的props
      const routePropsOption = matchedRoute!.props[props.name]
      // 如果routePropsOption为空，取null
      // 如果routePropsOption为true，取route.params
      // 如果routePropsOption是函数，取函数返回值
      // 其他情况取routePropsOption
      const routeProps = routePropsOption
        ? routePropsOption === true
          ? route.params
          : typeof routePropsOption === 'function'
          ? routePropsOption(route)
          : routePropsOption
        : null

      // 当组件实例被卸载时，删除组件实例以防止泄露
      const onVnodeUnmounted: VNodeProps['onVnodeUnmounted'] = vnode => {
        if (vnode.component!.isUnmounted) {
          matchedRoute!.instances[currentName] = null
        }
      }

      // 生成组件
      const component = h(
        ViewComponent,
        assign({}, routeProps, attrs, {
          onVnodeUnmounted,
          ref: viewRef,
        })
      )

      if (
        (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &&
        isBrowser &&
        component.ref
      ) {
        // ...
      }

      return (
        // 有默认插槽则使用默认默认插槽，否则直接使用component
        normalizeSlot(slots.default, { Component: component, route }) ||
        component
      )
    }
  },
})
```

为了更好理解router-view的渲染过程，我们看下面的例子：
先规定我们的路由表如下：

```js
const router = createRouter({
  // ...
  // Home和Parent都是两个简单组件
  routes: [
    {
      name: 'Home',
      path: '/',
      component: Home,
    },
    {
      name: 'Parent',
      path: '/parent',
      component: Parent,
    },
  ]
})
```

假设我们的地址是`http://localhost:3000`。现在我们访问`http://localhost:3000`，肯定能够想到`router-view`中显示的肯定是`Home`组件。那么它是怎样渲染出来的呢？

首先我们要知道`vue-router`在进行`install`时，会进行第一次的路由跳转并立马向`app`注入一个默认的`currentRoute（START_LOCATION_NORMALIZED）`，此时`router-view`会根据这个`currentRoute`进行第一次渲染。因为这个默认的`currentRoute`中的`matched`是空的，所以第一次渲染的结果是空的。等到第一次路由跳转完毕后，会执行一个`finalizeNavigation`方法，在这个方法中更新`currentRoute`，这时在`currentRoute`中就可以找到需要渲染的组件`Home`，`router-view`完成第二次渲染。第二次完成渲染后，紧接着触发`router-view`中的`watch`，将最新的组件实例赋给`to.instance[name]`，并循环执行`to.enterCallbacks[name]`通过在钩子中使用next()添加的函数，过程结束。

然后我们从`http://localhost:3000`跳转至`http://localhost:3000/parent`，假设使用`push`进行跳转，同样在跳转完成后会执行`finalizeNavigation`，更新`currentRoute`，这时`router-view`监听到`currentRoute`的变化，找到需要渲染的组件，将其显示。在渲染前先执行旧组件卸载钩子，将路由对应的`instance`重置为`null`。渲染完成后，接着触发`watch`，将最新的组件实例赋给`to.instance[name]`，并循环执行`to.enterCallbacks[name]`，过程结束。

在之前分析`router.push`的过程中，我们曾经得到过一个欠完整的导航解析流程，那么在这里我们可以将其补齐了：

1. 导航被触发；
2. 调用失活组件中的`beforeRouteLeave`钩子；
3. 调用全局`beforeEach`钩子；
4. 调用重用组件内的`beforeRouteUpdate`钩子；
5. 调用路由配置中的`beforeEnter`钩子；
6. 解析异步路由组件；
7. 调用激活组件中的`beforeRouteEnter`钩子；
8. 调用全局的`beforeResolve`钩子；
9. 导航被确认；
10. 调用全局的`afterEach`钩子；
11. DOM更新；
12. 调用`beforeRouteEnter`守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入；

### 9.3 总结

router-view根据currentRoute及depth找到匹配到的路由，然后根据props.name、slots.default来确定需要展示的组件。



Vue2 diff 双端比较

vue3 diff 优化点

vue2全部需要比较，全量diff

vue3则是：

1. 静态标记+非全量diff
2. 最长递增子序列，对于最长递增子序列不移动位置,dom的操作变少了

# vue实战

## 1.课程目标

https://www.yuque.com/lpldplws/web/qpafpkpkcfufkgtl?singleDoc# 《Vue实战》 密码：fw42

1. 通过Vue3 + Vite实现一个完整的Vue项目；

## 2. 课程大纲

- Vue3 + Vite初始化配置；
- 项目布局设置；

## 3. vue3+vite初始化

### 3.1 创建项目

首先我们要创建一个 Vue3+Vite 项目，目前 Vue 官方创建项目时默认就是 Vite 构建了，所以直接按照官网来就可以，如下：
确保你安装了最新版本的 [Node.js](https://nodejs.org/en/)，然后在命令行中运行以下命令：

```b
npm init vue@latest

# or

pnpm create vue@latest
```

这一指令将会安装并执行 [create-vue](https://github.com/vuejs/create-vue)，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示，我们的选择如下：

```js
✔ Project name（项目名）: xianzao-vue-tools
✔ Add TypeScript（添加TS）? : No
✔ Add JSX Support（添加JSX支持）? : No
✔ Add Vue Router for Single Page Application development（添加Vue-router）? : Yes
✔ Add Pinia for state management（添加状态管理Pinia）? : Yes
✔ Add Vitest for Unit testing（为单元测试添加Vitest）? : No
✔ Add Cypress for both Unit and End-to-End testing（为单元测试与端到端测试添加Cypress）? : No
✔ Add ESLint for code quality（为代码质量添加ESLint）? : Yes
✔ Add Prettier for code formatting（为代码格式添加Prettier）? : Yes

Scaffolding project in ./tooldog...
Done.
```

到这一步就创建好了项目，按照提示执行：

```js
cd xianzao-vue-tools
npm install
npm run lint
npm run dev
```

能够正常打开页面：

![vue打开正常页面](/Volumes/F/zyl-study/web-zhuawa/20221203/vue打开正常页面.png)

如果遇到了类似的报错：

```
Error: Cannot find module'node:url'
```

原因是使用了node相对较高版本的代码：

```js
// vite.config.js 中引入 node url 模块时使用了 'node:url'
// 详见：https://nodejs.org/dist/latest-v16.x/docs/api/url.html#url
import { fileURLToPath, URL } from 'node:url'
```

Vue 官方文档上明确说了开始项目之前，请确保安装了最新版本的 NodeJS，我们的 node 版本要在 v16+ 。
这里推荐大家安装nvm和nrm，没有使用过的可以自行搜索。
nvm：npm的包版本管理工具；
nrm：设置npm源的管理工具；
常见的指令如下：

- nvm：

```js
nvm ls-remote # 查看node所有版本
nvm install node # 安装最新node可用版本
nvm version/nvm current # 查看当前nvm使用node版本
nvm list available # 查看可安装node版本
nvm list/nvm ls # 查看已安装版本
nvm install <version> # 安装指定node版本
nvm uninstall <version> # 卸载指定node版本
nvm use <version> # 切换使用指定版本node
nvm use [version] [arch] # 切换指定node版本和位数
nvm reinstall-packages <version> # 在当前版本node环境下，重新全局安装指定版本号的npm包

nvm on # 打开nodejs控制
nvm off # 关闭nodejs控制
nvm alias <name> <version> # 给不同的版本号添加别名
nvm unalias <name> # 删除已定义别名
nvm proxy # 查看设置与代理
nvm node_mirror [url] # 设置setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/
nvm npm_mirror [url] # 设置setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.
nvm root [path] # 设置和查看root路径
```

补充：在软件工程中，常见的软件版本型号（也是nvm的版本型号）

```bash
Dev # 开发版，频繁出新功能，另外还修复了一些Bug和不稳定因素
Alpha # 软件或系统的内部测试版本，会有不少Bug，仅内部人员使用浏览器
Beta # 软件或系统的测试版本，这一版本一般是在Alpha版本后，会有不少新功能，同时也有很多Bug
Gamma # 软件或系统接近于成熟的版本，只须要作一些小的改进就能发行测试
RC # 发行候选版本，和Beta版最大的差别在于Beta阶段会一直加入新的功能，但是到了RC版本，几乎不会加入新功能，主要在于除错。RC版本是最终发放给用户的最接近正式版的版本，发行后改正bug就是正式版，正式版之前的最后一个测试版。
Release # 正式发布版本，最终交付用户使用的一个版本，该版本也称为标准版，也可用符号 ® 表示
GA # 也代表正式发布版本，这个版本也是正式版本，国外大多都是用GA来说明Release版本
Stable # 稳定版，在开源软件中，都有stable版，就是开源软件的最终发行版，此版本一般基于Beta版，已知Bug都被修复，一般情况下更新较慢
LTS # 长期支持版，这一版本会持续进行支持，最早用在 Ubuntu
```

所以，LTS 就是长期支持版，在 node 中它代表此版本会长期进行支持，很稳定，放心使用的意思。
而 Latest 就是字面理解的最新版本的意思。
而大家可能接触比较少的Gallium 其实就是 node 发版对应的一个代号，这个就比较随意了，就是个情怀，比如大家耳熟能详的 Vue ，扒一扒发版记录，它的每次发版都有代号：

```bash
Vue3.0 # One Piece：海贼王
Vue2.7 # Naruto：火影忍者
Vue2.6 # Macross：超时空要塞
Vue2.5 # Level E：灵异E接触
Vue2.4 # Kill la Kill：斩服少女
Vue2.3 # JoJo's Bizarre Adventure：JoJo的奇妙冒险
Vue2.2 # Initial D：头文字D 
Vue2.1 # Hunter X Hunter：全职猎人
Vue2.0 # Ghost in the Shell：攻壳机动队
Vue1.0 # Evangelion：新世纪福音战士
Vue0.12 # Dragon Ball：龙珠
Vue0.11 # Cowboy Bebop：星际牛仔
Vue0.10 # Blade Runner：银翼杀手
Vue0.9  # Animatrix：黑客帝国动画版
```

- nrm

```bash
nrm -h /nrm -help  # 查看 nrm 帮助（相关命令、信息）
nrm -V             # 查看当前 nrm 版本
nrm ls             # 查看当前 nrm 中可用的镜像源地址
nrm current        # 查看当前使用镜像源

nrm use <registry> # 切换为某个镜像源 registry-镜像源名
nrm add <registry> <url> # 添加一个镜像源 registry-镜像源名 url-镜像源地址
nrm del <registry>  # 删除一个镜像源
nrm test <registry> # 测试该镜像源下载响应时间
```

### 3.2项目配置

到此我们已经初步创建并启动了项目，其实很多人只关注代码开发相关的文件，并不会去纠结项目中和核心开发无关配置文件的作用，这是不对的，我们应该对自己的项目做到极致掌控，了解项目中每一个文件每一行代码对项目的作用，接下来就来一起看看我们创建的项目中所有文件的作用吧！

在初始化创建项目时，默认创建了很多子文件（一些组件、样式文件等等），我们先把不需要的项目无关文件删干净，需要我们处理的无用文件都在 `src` 文件夹下：

- 删除 `src/views` 下所有文件
- 删除 `src/stores` 下所有文件
- 删除 `src/components` 下所有文件
- 删除 `src/assets` 下所有文件

清除干净之后，我们在 `src/views` 文件夹下新建一个 `HomePage.vue` 文件：

```js
<script setup></script>

<template>
  <div>hello xianzao, This is home page!</div>
</template>

<style scoped></style>
```

修改一下 `router/index.js` 路由文件，删掉之前页面的路由，加上 `HomePage` 页面的路由：

```js
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'HomePage',
      component: () => import('@/views/HomePage.vue')
    }
  ]
})

export default router
```

修改一下项目根组件src/App.vue 的内容：

```js
<script setup>
import { RouterView } from 'vue-router'
</script>

<template>
  <RouterView />
</template>

<style scoped></style>
```

最后，项目入口文件里，有一行 css 样式的引入，删除掉

```js
import { createApp } from 'vue'
import { createPinia } from 'pinia'

import App from './App.vue'
import router from './router'

// 删除掉，css文件已经删除过了
// import './assets/main.css'

const app = createApp(App)

app.use(createPinia())
app.use(router)

app.mount('#app')
```

运行没有问题后，至此，实现了项目的初始化配置。

#### 3.2.1 安装组件库

这里我们用字节的 [arco.design](https://arco.design/vue/docs/start) （主要没用过，可以尝试下）。

```bash
npm install --save-dev @arco-design/web-vue

# or 

pnpm add -D @arco-design/web-vue
```

接下来，配置按需加载，我们使用 [unplugin-vue-components](https://github.com/antfu/unplugin-vue-components) 和 [unplugin-auto-import](https://github.com/antfu/unplugin-auto-import) 这两款 `vite` 插件来开启按需加载及自动导入，插件会自动解析模板中的使用到的组件，并导入组件和对应的样式文件。

这两个插件一个是自动帮我们引入一些组件和指令（只做 `HTML` 中使用的常规组件例如各种 `.vue` 组件的引入以及指令的自动引入），另一个是自动帮我们做一些 `API` 组件的自动引入（像直接在 `script` 中引入的必须用 `API` 调用的 `Message` 组件以及后面我们还会用它做 `Vue` 的一些 `API` 自动引入等等）

```js
npm i unplugin-vue-components -D
npm i -D unplugin-auto-import

# or

pnpm add -D unplugin-vue-components
pnpm add -D unplugin-auto-import
```

在 `vite.config.js` 文件中配置使用一下插件：

```js
import { fileURLToPath, URL } from "node:url";

import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

import AutoImport from "unplugin-auto-import/vite";
import Components from "unplugin-vue-components/vite";
import { ArcoResolver } from "unplugin-vue-components/resolvers";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    AutoImport({
      resolvers: [ArcoResolver()],
    }),
    Components({
      resolvers: [
        ArcoResolver({
          sideEffect: true,
        }),
      ],
    }),
  ],
  resolve: {
    alias: {
      "@": fileURLToPath(new URL("./src", import.meta.url)),
    },
  },
});
```

可以看到上面我们在 `unplugin-vue-components/resolvers` 中导出了一个 `ArcoResolver` ，它是什么呢？

其实，它是插件内置的解析器，像常用的组件库（`element`、`antd` 等）自动引入的一些配置都被内置了，[查看内置支持的组件库解析器](https://github.com/antfu/unplugin-vue-components#importing-from-ui-libraries)，我们只需要导出对应 UI库 的解析器用就可以了。

OK，现在组件库和自动引入都做好了，先试一试，我们在 `home` 页面分别用 `ArcoVue` 的普通按钮 `AButton` 组件和全局提示 `AMessage` 组件试一试。

```js
<script setup>
const handleClickMini = () => {
  AMessage.info("hello xianzao, click mini AButton!");
};
</script>
<template>
  <div>hello xianzao, This is home page!</div>
  <a-space>
    <a-button type="primary" size="mini" @click="handleClickMini"
      >Mini</a-button
    >
    <a-button type="primary" size="small">Small</a-button>
    <a-button type="primary">Medium</a-button>
    <a-button type="primary" size="large">Large</a-button>
  </a-space>
</template>
<style scoped lang="scss"></style>
```

接下来就可以在项目内不引入组件，随意使用组件库中的组件了

这里强烈建议大家，可以好好参考下这两个插件的实现，后续按照此类实现，就不用在项目中重复引入组件代码了。

![vue-arcoVue组件展示](/Volumes/F/zyl-study/web-zhuawa/20221203/vue-arcoVue组件展示.png)

#### 3.2.2 配置项目内组件 & api的自动引入

我们在使用 `Vue` 的过程中，每个 `script` 以及 `js` 文件中或多或少需要引入一些像 `ref`、`reactive` 等 `VueAPI`，包括 `VueRouter`、`Pinia` 等都要引入一些 API，还有我们自己写的组件也都需要我们手动去引入使用。

那既然配置了组件库自动引入，我们接下来也配置API、以及页面组件的自动引入。

还是在 `vite.config.js` 文件中进行修改：

```js
import { fileURLToPath, URL } from "node:url";

import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

import AutoImport from "unplugin-auto-import/vite";
import Components from "unplugin-vue-components/vite";
import { ArcoResolver } from "unplugin-vue-components/resolvers";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    AutoImport({
      // 需要去解析的文件
      include: [
        /\.[tj]sx?$/, // .ts, .tsx, .js, .jsx
        /\.vue$/,
        /\.vue\?vue/, // .vue
        /\.md$/, // .md
      ],
      // imports 指定自动引入的包位置（名）
      imports: ["vue", "pinia", "vue-router"],
      // 生成相应的自动导入json文件。
      eslintrc: {
        // 启用
        enabled: true,
        // 生成自动导入json文件位置
        filepath: "./.eslintrc-auto-import.json",
        // 全局属性值
        globalsPropValue: true,
      },
      resolvers: [ArcoResolver()],
    }),
    Components({
      // imports 指定组件所在目录，默认为 src/components
      dirs: ["src/components/", "src/view/"],
      // 需要去解析的文件
      include: [/\.vue$/, /\.vue\?vue/, /\.md$/],
      resolvers: [
        ArcoResolver({
          sideEffect: true,
        }),
      ],
    }),
  ],
  resolve: {
    alias: {
      "@": fileURLToPath(new URL("./src", import.meta.url)),
    },
  },
});
```

如上，在 API 自动引入插件 AutoImport 中我们写了指定要去解析的文件 include 配置，然后在 import 选项中指定了自动引入的包名，并且所有自动引入的 API 在被自动引入时会添加记录到根目录的 ./.eslintrc-auto-import.json 文件中，方便我们查看都自动引入了哪些东西，后面我们使用这几个包的 API ，就不需要手动引入了，插件会帮我们在文件解析时自动引入。

同样的，在组件自动引入插件 Components 中，我们配置了指定要去解析的文件 include 配置，然后在 import 选项中指定了自动引入的组件目录，以后只要是在这几个目录下写的组件，我们在使用时都必须要手动去引入了

ok，我们来试一下。

我们在 src/components 文件夹下新建一个 HelloWorld.vue 文件，写上下面内容。

```js
<script setup>
const name = ref("xianzao");
</script>
<template>
  <div>hello {{ name }}, this is helloworld components</div>
</template>

<style scoped></style>
```

然后，直接在 `src/views/HomePage.vue` 文件中使用 `HelloWorld` 组件，不要引入，如下：

```js
<script setup>
const handleClickMini = () => {
  AMessage.info("hello xianzao, click mini AButton!");
};
</script>
<template>
  <div>hello xianzao, This is home page!</div>
  <a-space>
    <a-button type="primary" size="mini" @click="handleClickMini"
      >Mini</a-button
    >
    <a-button type="primary" size="small">Small</a-button>
    <a-button type="primary">Medium</a-button>
    <a-button type="primary" size="large">Large</a-button>
  </a-space>

  <!-- 这里 -->
  <HelloWorld />
</template>
<style scoped lang="scss"></style>
```

然后，直接在 `src/views/HomePage.vue` 文件中使用 `HelloWorld` 组件，不要引入，如下：

```js
<script setup>
const handleClickMini = () => {
  AMessage.info("hello xianzao, click mini AButton!");
};
</script>
<template>
  <div>hello xianzao, This is home page!</div>
  <a-space>
    <a-button type="primary" size="mini" @click="handleClickMini"
      >Mini</a-button
    >
    <a-button type="primary" size="small">Small</a-button>
    <a-button type="primary">Medium</a-button>
    <a-button type="primary" size="large">Large</a-button>
  </a-space>

  <!-- 这里 -->
  <HelloWorld />
</template>
<style scoped lang="scss"></style>
```

这里我们在创建的 `HelloWorld` 组件中使用了 Vue 的 `ref API`，并没有引入它，而后在 `HomePage` 页面中使用该组件也没有引入，效果如下：

![vue-arcoVue组件展示2](/Volumes/F/zyl-study/web-zhuawa/20221203/vue-arcoVue组件展示2.png)

后面我们使用 `Vue`、`VueRouter`、`Pinia`、`ArcoVue` 包括自建组件等等都不需要手动引入了。

#### 3.2.3 安装vueuse

[VueUse](https://vueuse.org/) 可以把它理解为一个基于 `Vue` 的工具库，`Vue2`、`Vue3` 都可以用，有很多实用的方法、组件包括指令，超级方便，后续我们会用到其中的一些方法，所以先装上。

##### 3.2.3.1 安装

```js
npm i @vueuse/core

// or

pnpm add @vueuse/core
```

##### 3.2.3.2 配置自动引入

`VueUse` 不止有方法，还有组件和指令，所以我们还是需要上面两个自动引入的插件去处理，那由于作者是一个人，解析器都内置在自动引入插件中了，所以我们直接导出用就可以了。

我们配置 `VueUse` 的组件和指令自动引入需要两个解析器，还是在 `vite.config.js` 配置文件中引入，如下：

```js
// ArcoVue、VueUse 组件和指令的自动引入解析器
import {
  ArcoResolver,
  VueUseComponentsResolver,
  VueUseDirectiveResolver,
} from "unplugin-vue-components/resolvers";
```

使用的话，只需要在配置文件 `plugins` 模块中之前写过的 `Components` 插件中使用一下这两个解析器就好了：

```js
Components({
  // imports 指定组件所在目录，默认为 src/components
  dirs: ["src/components/", "src/views/"],
  // 需要去解析的文件
  include: [/\.vue$/, /\.vue\?vue/, /\.md$/],
  resolvers: [
    ArcoResolver({
      sideEffect: true,
    }),
    VueUseComponentsResolver(),
    VueUseDirectiveResolver(),
  ],
}),
```

API 方法的自动引入就很简单了，还是配置文件中只需要在之前用过的 AutoImport 插件中添加一个 VueUse 包名配置就行了：

```js
AutoImport({
  // 需要去解析的文件
  include: [
    /\.[tj]sx?$/, // .ts, .tsx, .js, .jsx
    /\.vue$/,
    /\.vue\?vue/, // .vue
    /\.md$/, // .md
  ],
  // 新增 '@vueuse/core'
  imports: ["vue", "pinia", "vue-router", "@vueuse/core"],
  // 生成相应的自动导入json文件。
  eslintrc: {
    // 启用
    enabled: true,
    // 生成自动导入json文件位置
    filepath: "./.eslintrc-auto-import.json",
    // 全局属性值
    globalsPropValue: true,
  },
  resolvers: [ArcoResolver()],
}),
```

这样我们就可以在项目中随时随地的使用 `VueUse` 了！

建议大家有时间可以去看看 `VueUse` 的源码实现，也并不复杂，它有很多最佳实践，可以给我们使用 `Vue3` 提供很大的帮助。

#### 3.2.4 配置Eslint和Prettier

上述内容中，我们配置了自动引入，但是大家会发现，由于之前我们给项目安装了 `ESLint` 和 `Prettier` ，虽然还没有进行配置，但是默认配置会给那些自动引入的 `API` 报红，就比如下面这样：

![img](https://cdn.nlark.com/yuque/0/2023/png/2340337/1675332162964-d31495c0-7101-46b7-9435-827659f92fd3.png)

查看当前项目中的`.eslintrc.cjs`，这是 `ESLint` 配置，当前默认如下：

```js
/* eslint-env node */
require("@rushstack/eslint-patch/modern-module-resolution");

module.exports = {
  root: true,
  extends: [
    "plugin:vue/vue3-essential",
    "eslint:recommended",
    "@vue/eslint-config-prettier",
  ],
  parserOptions: {
    ecmaVersion: "latest",
  },
};
```

根目录下的 `.prettierrc.json` 是 `Prettier` 配置，当前默认如下

```js
{}
```

如何让我们自动引入的那些 API 不报红呢？
还记得我们自动引入配置的那个导出文件吗？我们所有自动引入的 API 都生成了记录在这个文件，你只需要将它写入 ESLint 配置的 extends 中让 Lint 工具识别下就好了，如下：

```js
/* eslint-env node */
require('@rushstack/eslint-patch/modern-module-resolution')

module.exports = {
  root: true,
  'extends': [
    // 这里
    './.eslintrc-auto-import.json',
    'plugin:vue/vue3-essential',
    'eslint:recommended',
    '@vue/eslint-config-prettier'
  ],
  parserOptions: {
    ecmaVersion: 'latest'
  }
}
```

注意，`extends` 这个继承配置的是一个数组，最终会将所有规则项进行合并，出现冲突的时候，后面的会覆盖前面的，我们在初始化项目安装时默认给加上去了 3 个：

- `plugin:vue/vue3-essential` ：ESLint Vue3 插件扩展
- `eslint:recommended`：ESLint 官方扩展
- `@vue/eslint-config-prettier` ：Prettier NPM 扩展

我们把 Prettier 扩展放到最后面，原因是 Prettier 会格式化代码，是为了保证最终代码格式统一。



接下来，由于我们接下来要使用 `Vue3` 的 `CompositionAPI`，那 Vue3 有几个可以直接在 `<script setup> `中可用的全局 API，比如 `defineProps`、`defineEmits`、`defineExpose`，如果你使用 TS，还会用到 `withDefaults` 。

那我们的 `ESLint` 默认是识别不了这些全局 API 的，此时需要向 `ESlint` 规则中添加需要辨认的全局变量。

那 `ESLint` 配置中的 `globals` 属性就是让项目在 `lint` 执行期间访问额外的全局变量，简单说就是开发者自定义的全局变量，我们依次加上这些属性就可以了。

```js
/* eslint-env node */
require("@rushstack/eslint-patch/modern-module-resolution");

module.exports = {
  root: true,
  extends: [
    "./.eslintrc-auto-import.json",
    "plugin:vue/vue3-essential",
    "eslint:recommended",
    "@vue/eslint-config-prettier",
  ],
  // 这里
  globals: {
    defineEmits: "readonly",
    defineProps: "readonly",
    defineExpose: "readonly",
    withDefaults: "readonly",
  },
  parserOptions: {
    ecmaVersion: "latest",
  },
};
```

如上，添加全局属性时，`readonly` 代表只读，`writable` 代表可写，可写就是可以手动覆盖这个全局变量的意思，我们当然是不允许覆盖了，所以全部都设置成了 `readonly`。

我们可以看到在 `.eslintrc.cjs` 文件中第一行有个 `/* eslint-env node */`注释，它是用来指定文件为 `node` 环境的。

如果不想这样展示，只要在`eslint`中用 `node` 规则解析即可。这里我们给 `ESLint` 指定一下常用环境，即 `env` 属性配置，让 `ESLint` 自己去匹配，我们不写这个配置的话默认它只支持浏览器 `browser` 的规则解析，写上环境配置：

```js
require("@rushstack/eslint-patch/modern-module-resolution");

module.exports = {
  // 这里
  env: {
    // 浏览器环境
    browser: true,
    // Node环境
    node: true,
    // 启用除了modules以外的所有 ECMAScript 6 特性
    es2021: true,
  },
  root: true,
  extends: [
    "./.eslintrc-auto-import.json",
    "plugin:vue/vue3-essential",
    "eslint:recommended",
    "@vue/eslint-config-prettier",
  ],
  globals: {
    defineEmits: "readonly",
    defineProps: "readonly",
    defineExpose: "readonly",
    withDefaults: "readonly",
  },
  parserOptions: {
    ecmaVersion: "latest",
  },
  rules: {
    semi: ["warn", "never"], // 禁止尾部使用分号
    "no-debugger": "warn", // 禁止出现 debugger
  },
};
```

如上所示，我们在环境这块配置了三个：

1. browser ── 浏览器环境；
2. node ── Node 环境；
3. es6 ── 启用除了 modules 以外的所有 ECMAScript 6 特性；

都用的到，直接都开启就好。
可能我们也都发现了，我们新增了一个 rules 属性，如单词字面意思，就是规则的配置，可以配置启用一些规则及其各自的错误级别，那由于每个人的喜好不同，所以我没有过多配置，只配置了 2 个。
rules 的规则配置有三种：

1. off 或 0 关闭对该规则的校验；
2. warn 或 1 启用规则，不满足时抛出警告，不会退出编译进程；
3. error 或 2 启用规则，不满足时抛出错误，会退出编译进程；

配置完了 ESLint ，我们再来看Prettier，我这边配置了几个常用的，如下

```js
{
  "semi": false,
  "singleQuote": true,
  "printWidth": 80,
  "trailingComma": "none",
  "arrowParens": "avoid",
  "tabWidth": 2
}
```

1. `semi` 代码结尾是否加分号；
2. `singleQuote` 是否使用单引号；
3. `printWidth` 超过多少字符强制换行；
4. `trailingComma` 代码末尾不需要逗号；
5. `arrowParens` 单个参数的箭头函数不加括号 `x => x`；
6. `tabWidth` 使用 n 个空格缩进；

Prettier 配置就比较简单，按照文档和喜好在 `.prettierrc.json` 文件中配置就可以。

#### 3.2.5 styles公共样式管理、初始化样式

接下来我们简单做一下 `CSS` 公共样式的处理，我们在项目 src 目录下新增一个 `styles` 文件夹，此文件夹我们后期可以放一些公共的样式文件。

大家都知道，`HTML` 标签是有默认样式的，一般我们在写项目时都会直接清除掉这个默认样式，也就是做个重置。

那相较于 [Eric Merer](https://meyerweb.com/eric/tools/css/reset/) 原版的清楚样式文件，`Normalize.css` 它在默认的 HTML 元素样式上提供了跨浏览器的高度一致性，是一种现代的、为 HTML5 准备的优质替代方案，所以我们直接使用它就好了。

下载 [Normalize.css](https://necolas.github.io/normalize.css/latest/normalize.css) 到 Styles 文件夹下，当然你也可以直接 npm 安装它，不过我比较喜欢直接下载下来这个文件。

下载下来之后直接在 `main.js`最上面引入一下就行了，如下

```js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
// 这里
import '@/styles/normalize.css'

import App from './App.vue'
import router from './router'

const app = createApp(App)

app.use(createPinia())
app.use(router)

app.mount('#app')
```

其他的公共 `css` 文件我们用到的时候也可以这样引入一下就可以了。

#### 3.2.6 配置Unocss

CSS 这块，我们的原则是能简单就简单，所以我们基于 ACSS 即原子化的 CSS 框架来做。

[Tailwind CSS](https://tailwindcss.com/) 大家应该都知道， [WindiCSS](https://windicss.org/) 算是他的一个超集，由于`WindiCSS` 作者们都不咋维护了，然后 [UnoCSS](https://github.com/unocss/unocss) 又这么便捷，配置文件都不需要写，直接引入 `Vite` 插件和对应的预设就可以了，所以这里选择unoCSS。

`UnoCSS`，官方说它是一个按需原子 `CSS` 引擎，它默认提供了流行实用程序优先框架 `Tailwind CSS`、`Windi CSS`、`Bootstrap`、`Tachyon` 等的通用超集，如果你习惯这些框架，依旧可以按照熟悉的方式写，无缝衔接。

这里看个人喜好了，用不用，有什么，怎么用，还是看具体个人使用。

```js
npm install --save-dev unocss @unocss/preset-uno @unocss/preset-attributify @unocss/transformer-directives

# or

pnpm i -D unocss @unocss/preset-uno @unocss/preset-attributify @unocss/transformer-directives
```

##### 3.2.6.1 安装

如上，我们装了 4 个包

1. [unocss](https://github.com/unocss/unocss) 核心插件；
2. [@unocss/preset-uno](https://github.com/unocss/unocss/tree/main/packages/preset-uno) 默认预设，`Tailwind` / `WindiCSS` 等超集；
3. [@unocss/preset-attributify](https://github.com/unocss/unocss/tree/main/packages/preset-attributify) 属性预设，为其他预设和规则提供[属性模式](https://github.com/unocss/unocss/tree/main/packages/preset-attributify#attributify-mode)；

- [@unocss/transformer-directives](https://github.com/unocss/unocss/blob/main/packages/transformer-directives/README.md) 指令转换器插件，允许使用 `@apply`指令在 `style` 中写原子化 css；

##### 3.2.6.2 配置

还是在 `Vite` 插件配置中，也就是 `vite.config.js` 文件中配置

```js
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// ...

// Unocss 插件
import Unocss from 'unocss/vite'
// Unocss 默认预设
import presetUno from '@unocss/preset-uno'
// Unocss 属性模式预设
import presetAttributify from '@unocss/preset-attributify'
// Unocss 指令转换插件
import transformerDirective from '@unocss/transformer-directives'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    // ...

    // 新增一个 Unocss 插件配置
    Unocss({
      // 预设
      presets: [presetUno(), presetAttributify()],
      // 指令转换插件
      transformers: [transformerDirective()],
      // 自定义规则
      rules: []
    }),
  ]

  // ...
})
```

##### 3.2.6.3 使用

在使用之前我们先在入口文件 main.js中一下 UnoCSS 的 css 文件：

```js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import '@/styles/normalize.css' 

// 导入Unocss样式 
import 'uno.css' 
```

##### 3.2.6.4 基础使用

```js
<button class="bg-blue-400 hover:bg-blue-500 text-sm text-white font-mono font-light py-2 px-4 rounded border-2 border-blue-200 dark:bg-blue-500 dark:hover:bg-blue-600">
  Button
</button>
```

如果不熟悉，可以直接在[此文档](https://uno.antfu.me/)查看对应属性。

除此外，既然我们用的预设支持 `Tailwind / WindiCSS` ，可以参考这两个文档，了解一个大概，按照这两个东西的写法来就可以，有不会的去这两个的文档里搜

- [TailwindCSS](https://tailwindcss.com/)；
- [WindiCSS](https://windicss.org/)；

除此外，我们上面安装了 `@unocss/preset-attributify` 属性预设，所以我们也可以使用属性模式，可以将实用程序分为多个属性，这样写：

```js
<button 
  bg="blue-400 hover:blue-500 dark:blue-500 dark:hover:blue-600"
  text="sm white"
  font="mono light"
  p="y-2 x-4"
  border="2 rounded blue-200"
>
  Button
</button>
```

如果有人觉得原子化 CSS 全写在 HTML 中，太多的话，就可以使用指令转换器插件 @unocss/transformer-directives 。
它允许我们使用 @apply指令在 style 中写原子化 CSS ：

```js
<button class="btn-style">
  Button
</button>

<style>
.btn-style{
  @apply bg-blue-400 text-sm text-white font-mono font-light py-2 px-4 rounded border-2 border-blue-200;
  @apply hover:bg-blue-500;
  @apply dark:bg-blue-500 dark:hover:bg-blue-600;
}
</style>
```

##### 3.2.6.5 其他

我们安装一下 `UnoCSS` 官方的 `VSCode` 插件，`VSCode` 扩展中搜索：`UnoCSS`。

详细的原子化CSS也会在后面的工程化&实战中介绍使用。

#### 3.2.7 Utils、Hooks、API 管理

我们在项目 `src` 目录下添加一个 `utils` 文件夹，此文件夹用于存放我们项目中用到的一些公共方法文件；

同样的，我们在项目 `src` 目录下添加一个 `hooks` 文件夹，此文件夹用于存放我们项目中用到的一些 `hooks` 文件，因为我们用 `Vue3` 的 `CompsitionAPI`，后面用多了自然会有很多 `hooks` 文件，针对一些公用的，我们统一管理在此文件夹下；

平常我们做项目，一般和请求相关的文件都统一放在一个文件夹下，所以我们在项目 `src` 目录下添加一个 `api` 文件夹，用于存放和请求相关的文件；

#### 3.2.8 其他vite配置

这里使用vite的[环境配置](https://cn.vitejs.dev/guide/env-and-mode.html#env-files)，在 env 目录下新建下面 3 个文件
1.env 所有模式下都会加载；
2.env.development 只在开发模式下加载；
3.env.production 只在生产模式下加载；
.env 文件在所有模式下都会加载，所以这里我们可以写一些所有环境都通用的环境变量，如下：

```js
# 所有环境都会加载

# 项目标识代码
VITE_APP_CODE="XIANZAO_VUE_TOOLS"

# 项目名
VITE_APP_NAME="工具类"

# 项目描述
VITE_APP_DESCRIPTION="工具类集合"
```

注意，我们在 Vite 中配置的环境变量默认只有以 VITE_ 开头的配置，才会暴露给客户端，我们才能在项目中获取到。
开发模式 .env.development配置：

```bash
# 开发环境加载

# 环境标识
VITE_APP_ENV="development"

# 公共基础路径
VITE_BASE="/"

# 代理URL路径
VITE_BASE_URL ="/api"

# 模拟数据接口路径
VITE_BASE_MOCK_URL ="/mock-api"

# 服务端接口路径
VITE_BASE_SERVER_URL = "..."

# 打包是否使用Mock
VITE_APP_PRODMOCK=false
```

那生产环境除了环境标识 `VITE_APP_ENV` 和开发模式标识不同，其他配置项应尽量保持一致，只是配置项的内容不同而已，不一一的展示了。

接下来修改下 `package.json` 脚本命令如下：

```js
{
    "scripts": {
    "serve": "vite --mode development",
    "build": "vite build --mode production",
    "preview": "vite preview --port 8081",
    "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs --fix --ignore-path .gitignore"
  }
}
```

在 serve 脚本命令配置中，我们还传了一个 mode，其实这个 mode 就是对应我们的环境文件 .env.[mode]
开发环境默认 mode 就是 development，生产环境默认 mode 就是 development，所以脚本命令这里我不传 mode 也可以，但是如果大家把开发环境文件由 .env.development 改成 .env.dev，那脚本中 mode 就得传 --mode dev，build 时也是一样的道理，如果有其他环境，那脚本命令传入对应的 mode 就可以了。
如果想要在 vite.config.js 文件中获取对应运行 mode 环境变量的配置，我们可以使用 vite 的 [loadEnv API](https://cn.vitejs.dev/guide/api-javascript.html#loadenv)。
Vite 的 defineConfig 方法也可以接收一个返回配置对象的回调函数，回调函数的参数里我们可以拿到运行脚本命令时传入的 mode 值，从而使用 loadEnv 方法去在 Vite 配置文件中获取对应 mode 下的环境变量，如下：

```js
// export default defineConfig({}) 修改

export default defineConfig(({mode}) => {
	return {}
})
```

截止到这里，我们的配置为：

```js
import { fileURLToPath, URL } from 'node:url'

import { defineConfig, loadEnv } from 'vite'
import vue from '@vitejs/plugin-vue'

// API自动引入插件
import AutoImport from 'unplugin-auto-import/vite'
// 组件自动引入插件
import Components from 'unplugin-vue-components/vite'
// ArcoVue、VueUse 组件和指令自动引入解析器
import {
  ArcoResolver,
  VueUseComponentsResolver,
  VueUseDirectiveResolver
} from 'unplugin-vue-components/resolvers'
// icon 插件
import Icons from 'unplugin-icons/vite'
// icon 自动引入解析器
import IconsResolver from 'unplugin-icons/resolver'
// icon 加载 loader
import { FileSystemIconLoader } from 'unplugin-icons/loaders'
// Unocss 插件
import Unocss from 'unocss/vite'
// Unocss 默认预设
import presetUno from '@unocss/preset-uno'
// Unocss 属性模式预设
import presetAttributify from '@unocss/preset-attributify'
// Unocss 指令插件
import transformerDirective from '@unocss/transformer-directives'

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => {
  const viteEnv = loadEnv(mode, './')

  return {
    base: viteEnv.VITE_BASE,
    server: {
      host: '0.0.0.0',
      port: '8080',
      open: true,
      // 端口占用直接退出
      strictPort: true
      // 本地服务 CORS 是否开启
      // cors: true,
      // proxy: {
      //   [viteEnv.VITE_BASE_URL]: {
      //     target: viteEnv.VITE_BASE_SERVER_URL,
      //     // 允许跨域
      //     changeOrigin: true,
      //     rewrite: path => path.replace(viteEnv.VITE_BASE_URL, '/')
      //   }
      // }
    },
    build: {
      outDir: 'dist',
      assetsDir: 'static/assets',
      // sourcemap: true,
      // 规定触发警告的 chunk 大小，消除打包大小超过500kb警告
      chunkSizeWarningLimit: 2000,
      // 静态资源打包到dist下的不同目录
      rollupOptions: {
        output: {
          chunkFileNames: 'static/js/[name]-[hash].js',
          entryFileNames: 'static/js/[name]-[hash].js',
          assetFileNames: 'static/[ext]/[name]-[hash].[ext]'
        }
      }
    },
    resolve: {
      alias: {
        '@': fileURLToPath(new URL('./src', import.meta.url))
      }
    },
    plugins: [
      vue(),
      // 使用Unocss
      Unocss({
        // 预设
        presets: [presetUno(), presetAttributify()],
        // 指令转换插件
        transformers: [transformerDirective()],
        // 自定义规则
        rules: []
      }),
      AutoImport({
        include: [
          /\.[tj]sx?$/, // .ts, .tsx, .js, .jsx
          /\.vue$/,
          /\.vue\?vue/, // .vue
          /\.md$/ // .md
        ],
        imports: ['vue', 'pinia', 'vue-router', '@vueuse/core'],
        // 生成相应的自动导入json文件。
        // eslint globals Docs - https://eslint.org/docs/user-guide/configuring/language-options#specifying-globals
        eslintrc: {
          enabled: true,
          filepath: './.eslintrc-auto-import.json', // Default `./.eslintrc-auto-import.json`
          globalsPropValue: true // Default `true`, (true | false | 'readonly' | 'readable' | 'writable' | 'writeable')
        },
        resolvers: [ArcoResolver()]
      }),
      Components({
        // imports 指定组件所在位置，默认为 src/components
        dirs: ['src/components/', 'src/view/'],
        include: [/\.vue$/, /\.vue\?vue/, /\.md$/],
        resolvers: [
          ArcoResolver({
            sideEffect: true
          }),
          VueUseComponentsResolver(),
	  VueUseDirectiveResolver(),
          IconsResolver({
            // icon自动引入的组件前缀 - 为了统一组件icon组件名称格式
            prefix: 'icon',
            // 自定义的icon模块集合
            customCollections: ['user', 'home']
          })
        ]
      }),
      Icons({
        compiler: 'vue3',
        customCollections: {
          // user图标集，给svg文件设置fill="currentColor"属性，使图标的颜色具有适应性
          user: FileSystemIconLoader('src/assets/svg/user', svg =>
            svg.replace(/^<svg /, '<svg fill="currentColor" ')
          ),
          // home 模块图标集
          home: FileSystemIconLoader('src/assets/svg/home', svg =>
            svg.replace(/^<svg /, '<svg fill="currentColor" ')
          )
        },
        autoInstall: true
      })
    ]
  }
})
```

#### 3.2.8 添加Config配置

上面说了，环境变量默认以 `VITE_` 开头的配置，才会暴露给客户端，我们也写了几个 `VITE_` 开头的配置，所以在项目运行时，我们可以直接 `import.meta.env.VITE_XXX` 去查看配置，但是这样太麻烦了，所以我们写一个统一的配置文件去获取环境变量，包括项目后期的一些全局配置也可以写里面

项目 src 目录下新建 `config/config.js` 文件，写入下面文件：

```js
// 获取环境变量
const ENV = import.meta.env
// 配置文件
let config = {}
// 默认配置文件
const configSource = {
  appCode: ENV.VITE_APP_CODE,
  // 项目标识代码
  projectCode: `${ENV.VITE_APP_CODE}_${ENV.VITE_APP_ENV}`,
  // 项目名
  projectName: ENV.VITE_APP_NAME,
  // 项目描述
  projectDesc: ENV.VITE_APP_DESCRIPTION,
  // 资源base地址
  base: ENV.VITE_BASE,
  // 接口代理URL路径
  baseUrl: ENV.VITE_BASE_URL,
  // 模拟数据接口路径
  mockBaseUrl: ENV.VITE_BASE_MOCK_URL,
  // 服务端接口路径
  serverUrl: ENV.VITE_BASE_SERVER_URL
}

const setConfig = cfg => {
  config = Object.assign(config, cfg)
  return config
}

const resetConfig = () => {
  config = { ...configSource }
  return config
}
resetConfig()

const getConfig = key => {
  if (typeof key === 'string') {
    const arr = key.split('.')
    if (arr && arr.length) {
      let data = config
      arr.forEach(v => {
        if (data && typeof data[v] !== 'undefined') {
          data = data[v]
        } else {
          data = null
        }
      })
      return data
    }
  }
  if (Array.isArray(key)) {
    const data = config
    if (key && key.length > 1) {
      let res = {}
      key.forEach(v => {
        if (data && typeof data[v] !== 'undefined') {
          res[v] = data[v]
        } else {
          res[v] = null
        }
      })
      return res
    }
    return data[key]
  }
  return { ...config }
}

export { getConfig, setConfig, resetConfig }
```

这样，我们写入配置时，只需要在 configSource 对象中写入就可以了，项目中使用起来的话如下：

```js
import { getConfig, setConfig, resetConfig } from "@/config/config.js"

// 获取配置
getConfig("a")
getConfig("a.b")
getConfig("a.b.c")

// 动态设置
setConfig({ ... })

// 重置配置
resetConfig()
```

至此，一个Vue3 + Vite的基础项目配置就已经配置完成了，代码可以参考[此链接](https://github.com/xianzao/xianzao-vue-tools/tree/init_config)；

## 4. 项目布局

### 4.1 布局思路梳理

我们平常所说的多布局比较笼统，仔细分来其实有两种需要多布局的场景，大家可以自行匹配一下：

1. 项目有很多页面，有些页面是一样的布局，但还有些页面是另外一种布局，所以我们需要多种布局提供给不同的页面；
2. 项目有很多页面，页面都是统一的布局，但是我们需要提供多种可以自由切换的布局，让用户在生产环境自己去选择；

#### 4.1.1 多页面不同布局

如果只是需要在不同的页面使用不同的布局，那么很简单。

因为你只需要写多个不同的布局组件，然后使用二级路由通过指定父级路由的 `component` 就可以决定采用哪个布局，如下：

假如我们有 2 个布局：

```js
// layout 1
Layout1.vue

// layout 2
Layout2.vue
```

页面 `page_a` 想要使用`Layout1`布局，页面 `page_b` 想要使用 `Layout2` 布局，那么只需在配置路由时如下：

```js
{
  routes: [
    {
      path: '/layout1',
      name: 'Layout1',
      component: () => import('***/Layout1.vue'),
      redirect: '/layout1/page_a',
      children: [
        {
          path: 'page_a',
          name: 'PageA',
          component: () => import('***/PageA.vue')
        },
	
        // ...
      ]
    },
    {
      path: '/layout2',
      name: 'Layout2',
      component: () => import('***/Layout2.vue'),
      redirect: '/layout2/page_b',
      children: [
        {
          path: 'page_b',
          name: 'PageB',
          component: () => import('***/PageB.vue')
        },
	
        // ...
      ]
    }
  ]
}
```

只需要在根组件和布局组件中写上 `<router-view />`即可。

#### 4.1.2. 可动态切换的布局

再来看可以动态切换的布局，一般来说，我们使用 Vue 的 `component` 组件，通过 `is` 属性去动态的渲染布局组件就可以了，如下：

```vue
<!-- SwitchLayout.vue -->
<script setup>
  const isOneLayout = ref(true)
  import Layout1 from "./Layout1.vue"
  import Layout2 from "./Layout2.vue"
</script>

<template>
  <button @click="isOneLayout = !isOneLayout" />
  <component :is="isOneLayout ? Layout1 : Layout2" />
</template>
```

然后，我们直接在父路由中引入此页面，就可以通过改变状态来动态切换所有的子路由布局了，如下：

```js
{
  routes: [
    {
      path: '/',
      component: () => import('***/SwitchLayout.vue'),
      redirect: '/page_a',
      children: [
        {
          path: 'page_a',
          name: 'PageA',
          component: () => import('***/PageA.vue')
        },
	
        // ...
      ]
    },
}
```

### 4.2 准备工作

咱们先写一个可以动态切换的布局，首先，在项目 `src` 目录下创建一个布局文件夹 `layout` 。

接下来我们在 `src/layout` 文件下创建一个可切换布局的入口组件 `SwitchIndex.vue`，内容和上面所写的差不多，如下：

```vue
<script setup></script>

<template>
  <div class="switch-index">
    <!-- <component :is="" /> -->
  </div>
</template>

<style scoped></style>
```

`component` 组件我们暂且注释，因为目前还没有布局组件。

接下来我们创建两个布局组件，由于我们要把这两种布局的选择权交给用户，所以我们在 `layout` 文件夹下新建一个 `switch` 文件夹，把可以切换的这两个布局组件放到里面统一管理下。

创建可切换的默认布局文件：`layout/switch/DefaultLayout.vue`：

```vue
<script setup></script>

<template>
  <div>DefaultLayout</div>
</template>

<style scoped></style>
```

创建可切换的边栏布局文件：`layout/switch/SidebarLayout.vue`：

```vue
<script setup></script>

<template>
  <div>SidebarLayout</div>
</template>

<style scoped></style>
```

布局形式如下：

![img](https://cdn.nlark.com/yuque/0/2023/png/2340337/1675332168117-4e9dc9e7-4e66-44f2-b8af-fac4d9057671.png)

其实就是两种很普通很常见的布局，一种是有侧边栏的 `SidebarLayout`（ 下文叫它边栏布局）、一种无侧边栏的 `DefaultLayout`（下文叫它默认布局），先了解下格式。

### 4.3 默认布局组件 DefaultLayout

修改一下 `DefaultLayout` 组件，如下：

```vue
<script setup></script>

<template>
  <div>
    DefaultLayout
    <router-view v-slot="{ Component }">
      <component :is="Component" />
    </router-view>
  </div>
</template>

<style scoped></style>
```

然后直接在 SwitchIndex 组件引入使用这个布局，上文中我们虽然配置了组件自动引入，但是并没有配置 layout 目录，所以 layout 文件夹下的组件是不会被自动引入的，那我们还需要现在 vite.config.js 配置文件中把 layout 目录加上，如下：

```js
export default defineConfig(({ mode }) => {
  return {
     // ...

    plugins: [
      // ...

      Components({
        // 新增 'src/layout' 目录配置
        dirs: ['src/components/', 'src/view/', 'src/layout'],
        include: [/\.vue$/, /\.vue\?vue/, /\.md$/],
        resolvers: [
          ArcoResolver({
            sideEffect: true
          }),
          VueUseComponentsResolver(),
          VueUseDirectiveResolver(),
          IconsResolver({
            prefix: 'icon',
            customCollections: ['user', 'home']
          })
        ]
      }),
    ]
  }
})
```

然后就可以直接在 SwitchIndex 组件中使用 DefaultLayout 布局组件了，我们写的组件是匿名组件，默认组件名即文件名，如下：

```js
<script setup></script>

<template>
  <div class="switch-index">
    <!-- <component :is="" /> -->
    <DefaultLayout />
  </div>
</template>

<style scoped></style>
```

接下来，修改下路由文件 router/index.js ，把 SwitchIndex 组件作为一级路由组件，那此路由下的所有子路由就都可以使用我们的布局了：

```js
routes: [
  {
    path: '/',
    name: 'Layout',
    component: () => import('@/layout/SwitchIndex.vue'),
    redirect: '/',
    children: [
      {
        path: '/',
        name: 'HomePage',
        meta: {
          title: 'TOOLSDOG'
        },
        component: () => import('@/views/HomePage.vue')
      }
    ]
  }
]
```

#### 4.3.1 设计样式

上文我们已经装好了 ArcoDesign，同样也配置了其组件自动引入，这里我们直接使用 ArcoDesign 的 layout 布局组件做一个常规的上中下三分布局即可，需要注意的是，我们给 Navbar 导航部分加了一个固钉组件 a-affix，用于固定在页面顶部。
注意：ArcoDesign 组件均以子母 a 开头。
修改 DefaultLayout 组件，如下：

```js
<script setup></script>

<template>
  <div>
    <div class="default-layout">
      <a-layout>
        <a-affix>
          <a-layout-header> Navbar </a-layout-header>
        </a-affix>
        <a-layout-content>
          <router-view v-slot="{ Component }">
            <component :is="Component" />
          </router-view>
        </a-layout-content>
        <a-layout-footer> Footer </a-layout-footer>
      </a-layout>
    </div>
  </div>
</template>

<style scoped></style>
```

注意，

1. CSS 这里我们接上文的配置，使用的是原子化 CSS 框架 [UnoCSS](https://github.com/unocss/unocss) ；
2. 由于我们想保证风格统一，对于一些颜色、字体、尺寸方面，我这边直接全使用了 `ArcoDesign` 抛出的 `CSS` 变量，没有自己去自定义一套基础变量；

这里，我们参考ArcoDesign的[设计变量](https://arco.design/react/docs/token)

![img](https://cdn.nlark.com/yuque/0/2023/png/2340337/1675332167237-8f88976e-d159-4480-a11b-f537eff8c18f.png)

如上，我们直接使用对应的 CSS 变量即可。
布局样式如下：

```vue
<script setup></script>

<template>
  <div>
    <div class="default-layout">
      <a-layout class="min-h-[calc(100vh+48px)]">
        <a-affix>
          <a-layout-header> Navbar </a-layout-header>
        </a-affix>
        <a-layout-content>
          <router-view v-slot="{ Component }">
            <component :is="Component" />
          </router-view>
        </a-layout-content>
        <a-layout-footer> Footer </a-layout-footer>
      </a-layout>
    </div>
  </div>
</template>

<style scoped>
  @apply
  .default-layout :deep(.arco-layout-header),
  .default-layout :deep(.arco-layout-footer),
  .default-layout :deep(.arco-layout-content) {
    @apply text-[var(--color-text-1)] text-14px;
  }

  .default-layout :deep(.arco-layout-header) {
    @apply w-full h-58px overflow-hidden;
    @apply bg-[var(--color-bg-3)]  border-b-[var(--color-border-1)] border-b-solid border-b-width-1px box-border;
  }
  .default-layout :deep(.arco-layout-content) {
    @apply flex flex-col justify-center items-center;
    @apply bg-[var(--color-bg-1)] relative;
  }
  .default-layout :deep(.arco-layout-footer) {
    @apply w-full flex justify-center items-center;
    @apply border-t-[var(--color-border-1)] border-t-solid border-t-width-1px box-border;
    @apply bg-[var(--color-bg-2)] text-[var(--color-text-1)] text-14px;
  }
</style>
```

如上，我们做了这样的事情：

1. 给`Navbar` 一个下边框以及 `58px` 高度；
2. 给 `Footer` 一个上边框；
3. 给 `Navbar`、`Content`、`Footer` 加了不同级别的背景颜色（`AcroDesign` 背景色 CSS 变量）；
4. 为了让 `Footer` 首页不显示出来，给 `a-layout-content` 组件加了一个最小高度，使用视口高度 `100vh` 减去 `Navbar` 的高度就是该组件的最小高度了；

#### 4.3.2 导航组件Navbar

接下来填充布局内容，先来做 Navbar 组件。

我们想要实现的两种布局都有导航栏，唯一的区别就是菜单的位置，所以我们这里把导航栏中的各个元素单独拆分作为独立的组件，使用插槽的方式在 Navbar 组件去使用，Navbar 组件相当于导航栏的一个布局组件。这样导航栏组件在哪种布局中都是可用的，避免重复代码。

在 src/layout 文件夹下新建 components 文件夹存放布局相关的公共组件。

在 src/layout/components文件夹下创建 Navbar.vue 文件，内容如下：

```vue
<template>
  <div class="w-full h-full flex px-20px box-border">
    <div class="h-full flex">
      <slot name="left" />
    </div>
    <div class="h-full flex-1">
      <slot />
      <slot name="center" />
    </div>
    <div class="h-full flex flex-shrink-0 items-center">
      <div>
        <slot name="right" />
      </div>
    </div>
  </div>
</template>
```

如上，我们给 Navbar 组件做了三个具名插槽，采用左中右这种结构并使用 flex 布局将中间的插槽撑满，同时我们也将默认插槽放在了中间的插槽位置，这样默认会往布局中间填充内容。
注意，导航区域的高度在布局组件中已经固定写死 58px 了，导航组件这里我没有设置高度，让它自己撑满就行了。因为在任何布局下，导航栏高度是相同的。
我们在 DefaultLayout 布局组件中的 a-layout-header 标签中使用一下导航条组件，同样无需引入直接使用，如下：

```vue
<a-layout-header>
  <Navbar>
    <!-- left插槽 -->
    <template #left></template>

    <!-- 默认插槽和center插槽，默认插槽可不加template直接写内容，作用同center插槽 -->
    <template #center></template>

    <!-- right插槽 -->
    <template #right></template>
  </Navbar>
</a-layout-header>
```

由于插槽中没有写内容，所以页面上没有东西，导航条壳子搞好了，接下来我们开始填充内容。

左侧插槽我们写一个 `Logo` 组件，中间插槽就是导航菜单 Menu 组件了，右侧插槽则是一些页面小功能组件，暂定为 `Github` 组件（用来跳转 `Github` 的）、做布局切换的 `SwitchLayout` 组件。

### 4.3.3. Logo 组件

在 src/layout/components 文件夹下新建 Logo.vue 文件，写入如下内容：

```vue
<script setup>
const route = useRoute()
const title = useTitle()

watchEffect(() => {
  title.value = route.meta.title || 'TOOLSDOG'
})
</script>
<template>
  <div
    class="h-full flex items-center text-16px font-700 text-shadow-sm cursor-pointer"
    @click="$router.push('/')"
  >
    <div
      class="w-36px h-36px rounded-[50%] flex justify-center items-center mr-2px cursor-pointer"
      hover="bg-[var(--color-fill-1)]"
    >
      <icon-ri-hammer-fill class="text-18px" />
    </div>
    {{ title }}
  </div>
</template>
```

然后把 `Logo` 组件填充到我们 `DefaultLayout` 组件下 `Navbar` 组件的 左侧插槽中即可：

```vue
<Navbar>
  <template #left>
    <Logo />
  </template>
</Navbar>
```

关于 logo 我们直接在 [iconify](https://icones.js.org/) 图标库中找了一个图标用，我们这里用的是 `ri:hammer-fill` 图标，另外，点击 logo 会跳转首页。

标题直接用 Vue 的 `watchEffect` 方法监听了当前路由 `meta` 对象中的 `title` 属性并赋值给响应式变量 `title` ，这样后面我们每次跳转到某个功能页面时， `Logo` 旁边的文字信息以及浏览器 `Tab` 页签都会变成该页面路由中配置的 `title` 信息。

`useRoute` 方法是 `Vue3` 组合式 `API`，它返回一个当前页面路由的响应式对象，同样 `Vue` 的核心 API 我们都做了自动引入，所以这里没有引入。

`watchEffect` 也是 `Vue3` 的 `API`，该方法会立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。简单来说就是只要该回调中有响应式数据，这些响应式数据的依赖发生改变时就会重新执行此回调，默认会立即执行一次。那在这个场景下就比 watch 好用多了。

那响应式变量 title 是怎么来的呢？代码中我们使用了 `useTitle` 方法，同样没有引入，它不是 Vue 的 API，其实，它是 VueUse 库中的[一个方法](https://vueuse.org/core/usetitle/#usetitle)，在上文我们已经给 `VueUse` 这个库的方法做了自动引入，所以可以直接用，该方法会返回一个响应式变量，这个响应式变量在改变时会自动改变我们的网页标题，注意这里的标题指的是浏览器 Tab 标签中的标题，

#### 4.3.4 Github跳转组件

写 `Github` 跳转组件之前我们需要在 `config/index.js` 文件中配置一下 `GitHub Url` 地址。

在 `config/index.js` 文件的 `configSource` 对象中新增一个 github 属性，属性值写上我们的项目地址，如下：

```js
const configSource = {
  // ...

  github: 'https://github.com/xianzao/xianzao-vue-tools'
}
```

`Github` 跳转组件很简单，就是字面意思，我们搞一个图标放上去，然后能够点击打开一个新标签跳转到项目的 `GitHub` 地址就行了。在 `src/layout/components` 文件夹下新建 `Github.vue` 文件，写入如下内容：

```js
<script setup>
import { getConfig } from '@/config'
const openNewWindow = () => window.open(getConfig('github'), '_blank')
</script>
<template>
  <a-button type="text" @click="openNewWindow">
    <template #icon>
      <icon-mdi-github class="text-[var(--color-text-1)] text-16px" />
    </template>
  </a-button>
</template>
```

`GitHub` 的图标我们用的 `iconify` 图标库中 `mdi:github` 图标。

接着我们去使用一下，把 Github 组件填充到默认布局 `DefaultLayout` 组件下 `Navbar` 组件的右侧插槽中即可：

```vue
<Navbar>
  <template #right>
    <Github />
  </template>
</Navbar>
```

#### 4.3.5 菜单组件Menu

这里实现一个路由页面。

首先，在 `src/views` 文件夹下新建 `DemoPage.vue` 文件作为demo页面组件：

```js
<script setup></script>

<template>
  <div>demo</div>
</template>

<style scoped></style>
```

接着我们要配置一下路由，注意，由于现在写的页面路由它同时还是个菜单，所以我们把这些可以作为菜单的路由单独写一个路由文件，这样我们后期可以直接可以导出当作菜单项配置用。

在 `src/router` 文件夹下新建 `menuRouter`.js 文件，导出一个菜单路由数组，如下：

```js
export const menuRouter = []
```

在 `src/router/index.js` 中使用一下：

```vue
import { createRouter, createWebHistory } from 'vue-router'
  // 导入菜单路由
  import { menuRouter } from './menuRouter'

  const router = createRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes: [
      {
        path: '/',
        name: 'Layout',
        component: () => import('@/layout/index.vue'),
        redirect: '/',
        children: [
          {
            path: '/',
            name: 'HomePage',
            meta: {
              title: 'XIANZAO VUE DASHBOARD'
            },
            component: () => import('@/views/HomePage.vue')
          },
          // 使用菜单路由
          ...menuRouter
        ]
      }
    ]
  })

  export default router
```

接下来我们配置菜单路由数组，由于我们将来可能会写到很多不同种类的功能，所以我们使用多级路由的方式给这些页面做个分类，假设demo页面属于开发工具类，所以我们给它一个 `devtools` 的父级路由，另外，在菜单路由中，每个父级菜单我们给他在 `meta` 对象中添加一个 `icon` 属性，然后导入一个图片组件作为对应 icon 的值，这样做的目的是将来要在导航菜单中给每个分类的菜单都加个图标。

修改 `menuRouter.js` 文件如下

```js
import IconMaterialSymbolsCodeBlocksOutline from '~icons/material-symbols/code-blocks-outline'

export const menuRouter = [
  {
    path: 'devtools',
    name: 'DevTools',
    meta: {
      title: '开发工具',
      icon: markRaw(IconMaterialSymbolsCodeBlocksOutline)
    },
    redirect: { name: 'DemoPage' },
    children: [
      {
        path: 'demo',
        name: 'DemoPage',
        meta: {
          title: 'demo'
        },
        component: () => import('@/views/DemoPage.vue')
      }
    ]
  }
]
```

如上，我们如果想要访问此页面，只需要访问 /devtools/demo 路由即可，那可能有些人注意到该配置中的父级路由的重定向中我们使用的是 name 来做的重定向，这里不用 path 是为了更安全，这个安全指的是由于我们单独抽离出了这个菜单路由模块，虽然目前是在把它引入并写在了 / 路由下，但是将来万一改变了一级路由，那整体的 path 都会改变，而使用 name 字段重定向就不存在这个问题，我们只需要注意下各个路由的 name 字段配置不重复即可。

注意，我们上面手动引入了 iconify 图标库中的图标，可能有人会问不是做了 iconify 的自动引入吗？为什么还要手动去引入？其实，组件的自动引入是靠解析识别组件模板中引入的组件再做的匹配，而这里我们没有在组件模板中使用，而是在 JS 中直接使用的，包括我们做项目经常会做的菜单配置，都是只存一个图标名，它是靠我们在运行时通过图标名去匹配组件，这是一个运行时动态的过程，开发时是做不了自动引入的，这类情况我们需要手动引入一下。

已经有菜单了数据了，我们去写菜单 Menu 组件。先理一下思路，通常组件库中会有 Menu 组件，当然 ArcoDesign 也不例外，我们可以直接拿过来封装一层去使用。封装什么呢？虽然我们目前只有一个路由，但是我们在应该要考虑到多级的情况，那其实解决办法就是做一个可以无限递归的菜单组件。
OK，在写菜单组件之前，路由菜单数据还需要处理下，我们写个递归方法拼接一下每个菜单的完整路由，并把每个路由菜单中的 meta 对象压平到菜单里，方便我们后面使用，还是在 src/router 文件夹下的 menuRouter.js 文件，新增一个 menuRouterFormat 方法处理菜单数据并将处理后的数据导出，如下：

```js
export const menuRouter = [
  // ...
]

/**
 * @description 菜单路由数组 format
 * @param { Array } router 路由数组
 * @param { String } parentPath 父级路由 path
 * @return { Array }
 */
export const menuRouterFormat = (router, parentPath) => {
  return router.map(item => {
    // 拼接路由，例：'devtools' -> '/devtools'  'demo' -> '/devtools/demo'
    item.path = parentPath ? `${parentPath}/${item.path}` : `/${item.path}`

    // 存在 children 属性，且 children 数组长度大于 0，开始递归
    if (item.children && item.children.length > 0) {
      item.children = menuRouterFormat(item.children, item.path)
    }

    return Object.assign({}, item, item.meta || {})
  })
}

// 解析后 路由菜单列表
export const menuRouterFormatList = menuRouterFormat([...menuRouter])
```

在 src/layout/components 文件夹下新建 Menu/index.vue 文件：

```vue
<script setup>
import { menuRouterFormatList } from '@/router/menuRouter.js'

// 菜单数据
const menuList = ref(menuRouterFormatList)

const router = useRouter()
// 子菜单点击事件
const onClickMenuItem = key => {
  router.push(key)
}

const route = useRoute()
// 当前选中菜单
const selectedKeys = computed(() => [route.path])
</script>

<template>
  <a-menu
    class="menu"
    auto-open-selected
    :selected-keys="selectedKeys"
    @menuItemClick="onClickMenuItem"
    mode="horizontal"
    :accordion="true"
  >
    <MenuItem v-for="menu of menuList" :key="menu.path" :menu="menu" />
  </a-menu>
</template>

<style scoped>
.menu.arco-menu-horizontal {
  @apply bg-[var(--color-bg-3)];
}
.menu.arco-menu-horizontal :deep(.arco-menu-icon) {
  @apply mr-4px leading-[1.2] flex-none align-inherit;
}
.menu.arco-menu-horizontal :deep(.arco-menu-pop-header) {
  @apply bg-transparent;
}
.menu.arco-menu-horizontal :deep(.arco-menu-pop-header):hover {
  @apply bg-[var(--color-fill-2)];
}
.menu :deep(.arco-menu-overflow-wrap) {
  @apply flex justify-end;
}
</style>
```

上述代码中，我们先导入了之前 `menuRouter.js `中的菜单解析后的数据 `menuRouterFormatList` 对菜单数据进行了一个初始化。

再来看模板，我们用到了 `arcoDesign` 组件库的 `a-menu` 组件。

1. `accordion` 开启手风琴效果；
2. `mode` 属性是设置菜单模式（水平或垂直），我们给它设置成水平即 `horizontal` ；
3. `menuItemClick` 子菜单点击时触发，该回调参数为 `key`；
4. `selected-keys` 选中的菜单项 `key` 数组；
5. `auto-open-selected` 默认展开选中的菜单；

子菜单点击方法中我们直接使用 router.push 传入 key 跳转路由即可。那对于 selectedKeys ，我们直接用计算属性 computed 返回了当前路由对象 route 中 path 属性值组成的数组，这样每次路由改变该方法就会被触发，selectedKeys 数组值就会响应式的改变。key 值即子菜单的唯一标识，下面我们写子菜单组件时会将每个子菜单的 key 设置为菜单对应的路由 path 。

上面我们用到了一个还没有创建的 MenuItem 组件，它其实就是我们的子菜单组件，接下来我们还是在 src/layout/components/Menu 文件夹下新建 MenuItem.vue 文件，内容如下：

```vue
<script setup>
const props = defineProps({
  menu: {
    type: Object,
    required: true
  }
})
const { menu } = toRefs(props)
</script>

<template>
  <template v-if="!menu.children">
    <a-menu-item :key="menu.path">
      <template #icon v-if="menu?.icon">
        <component :is="menu?.icon"></component>
      </template>
      {{ menu.title }}
    </a-menu-item>
  </template>

  <a-sub-menu v-else :key="menu.path" :title="menu.title">
    <template #icon v-if="menu?.icon">
      <component :is="menu?.icon"></component>
    </template>
    <MenuItem
      v-for="menuChild of menu.children"
      :key="menuChild.path"
      :menu="menuChild"
    />
  </a-sub-menu>
</template>

<style scoped></style>
```

把 `Menu` 组件填充到默认布局 `DefaultLayout` 组件下 `Navbar` 组件的中间插槽或者默认插槽中即可：

```vue
<a-layout-header>
  <Navbar>
    <!-- ... -->

    <!-- 默认插槽和center插槽，默认插槽可不加template直接写内容，作用同center插槽 -->
    <template #center>
      <Menu />
    </template>

    <!-- ... -->
  </Navbar>
</a-layout-header>
```

到此默认布局的导航组件就写的差不多了。

#### 4.3.6 页尾组件Footer

页尾区域我们在布局组件中没有设置高度，因为页尾的高度不固定，可能随时会在页尾加个内容啥的。
由于页尾需要展示一些个人信息，所以我们统一把这些数据都放在 config/index.js 中的基础配置对象里

```js
// ...

const configSource = {
  // ...

  // 个人配置
  me: {
    name: 'xianzao',
    // github
    github: 'https://github.com/xianzao/xianzao-vue-tools'
  }
}
```

我们在 `src/components` 文件夹下新建 `Footer.vue` 文件，`Footer` 组件比较简单，暂时也没写太多内容，这里我就不会多描述了，直接看代码吧。

```vue
<script setup>
import { getConfig } from '@/config'
</script>
<template>
  <div class="w-1200px flex justify-between items-center min-h-48px">
    <div class="w-full h-48px flex justify-center items-center">
      <span> Copyright ⓒ 2022</span>
      <a-link :href="getConfig('me.github')" target="_blank">
        {{ getConfig('me.name') }}
      </a-link>
      <a-link href="<https://beian.miit.gov.cn/>" target="_blank">
        {{ getConfig('icp') }}
      </a-link>
    </div>
  </div>
</template>
```

在布局文件中使用一下：
在 DefaultLayout 默认布局组件中的 a-layout-footer 组件标签中使用一下 Footer 组件，同样无需引入直接使用，如下：

```vue
<a-layout-footer>
  <Footer />
</a-layout-footer>
```

#### 4.3.7 首页修改HomePage

打开 src/views/HomePage.vue 文件，清空当前内容，写入下面代码：

```vue
<template>
  <div class="w-full flex justify-center items-center flex-1">
    <div class="w-full h-300px flex justify-center items-center">
      <div
        class="w-150px h-150px rounded-[50%] bg-[var(--color-fill-1)] flex justify-center items-center"
      >
        <icon-ri-hammer-fill class="text-52px" />
      </div>
    </div>
  </div>
</template>
```

### 4.4 边栏布局组件 SidebarLayout

接下来就开始写边栏布局 `SidebarLayout`，这个组件在上文中已经建好了，所以无需再建。

首先我们需要修改下 `src/layout/SwitchIndex.vue` 文件，先把布局组件写死 `SidebarLayout`，如下：

```vue
<script setup></script>

<template>
  <div class="switch-index">
    <!-- <component :is="" /> -->
    <!-- <DefaultLayout /> -->
    <SidebarLayout />
  </div>
</template>

<style scoped></style>
```

接着修改 `src/layout/switch/SidebarLayout.vue` 边栏布局组件如下：

```js
<script setup></script>

<template>
  <div>
    SidebarLayout
    <router-view v-slot="{ Component }">
      <component :is="Component" />
    </router-view>
  </div>
</template>

<style scoped></style>
```

#### 4.4.1 设计样式

![img](https://cdn.nlark.com/yuque/0/2023/png/2340337/1675332168111-da1056b0-eedd-425c-af79-6093d541cfc1.png)其实就是多一个侧边栏，至于侧边栏，其实组件库中也有组件，我们可以直接使用 `ArcoDesign` 组件库中的 `a-layout-sider` 组件即可，修改 `SidebarLayout` 组件，如下：

```vue
<script setup>
// 侧边栏收缩状态
const collapsed = ref(false)

// 侧边栏收缩触发事件
const handleCollapse = (val, type) => {
  const content = type === 'responsive' ? '响应式触发' : '点击触发'
  console.log(`${content}侧边栏，当前状态：${val}`)
  collapsed.value = val
}
</script>

<template>
  <div class="sidebar-layout">
    <a-layout>
      <a-affix>
        <a-layout-header> Navbar </a-layout-header>
      </a-affix>

      <a-layout>
        <a-affix :offsetTop="58">
          <a-layout-sider
            breakpoint="lg"
            :width="220"
            height="calc(100vh-58px)"
            collapsible
            :collapsed="collapsed"
            @collapse="handleCollapse"
          >
            Menu
          </a-layout-sider>
        </a-affix>

        <a-layout>
          <a-layout-content class="min-h-[calc(100vh-58px)]">
            <router-view v-slot="{ Component }">
              <component :is="Component" />
            </router-view>
          </a-layout-content>
          <a-layout-footer> Footer </a-layout-footer>
        </a-layout>
      </a-layout>
    </a-layout>
  </div>
</template>

<style scoped>
.sidebar-layout :deep(.arco-layout-header),
.sidebar-layout :deep(.arco-layout-footer),
.sidebar-layout :deep(.arco-layout-content) {
  @apply text-[var(--color-text-1)] text-14px;
}

.sidebar-layout :deep(.arco-layout-header) {
  @apply w-full h-58px;
  @apply bg-[var(--color-bg-3)]  border-b-[var(--color-border-1)] border-b-solid border-b-width-1px box-border;
}
.sidebar-layout :deep(.arco-layout-content) {
  @apply flex flex-col items-center;
  @apply bg-[var(--color-bg-1)] relative;
}
.sidebar-layout :deep(.arco-layout-footer) {
  @apply w-full flex justify-center items-center;
  @apply border-t-[var(--color-border-1)] border-t-solid border-t-width-1px box-border;
  @apply bg-[var(--color-bg-2)] text-[var(--color-text-1)] text-14px;
}

.sidebar-layout :deep(.arco-layout-sider) {
  @apply h-[calc(100vh-58px)];
}
.sidebar-layout :deep(.arco-layout-sider),
.sidebar-layout :deep(.arco-layout-sider-trigger) {
  @apply border-r-[var(--color-border-1)] border-r-solid border-r-width-1px box-border;
}
</style>
```

接下来我们把之前写的公用组件填充一下：

```vue
<template>
  <div class="sidebar-layout">
    <a-layout>
      <a-affix>
        <a-layout-header>
          <Navbar>
            <template #left> <Logo /> </template>

            <template #right> <Github /> </template>
          </Navbar>
        </a-layout-header>
      </a-affix>

      <a-layout>
        <a-affix :offsetTop="58">
          <a-layout-sider
            breakpoint="lg"
            :width="220"
            height="calc(100vh-58px)"
            collapsible
            :collapsed="collapsed"
            @collapse="handleCollapse"
          >
            Menu
          </a-layout-sider>
        </a-affix>

        <a-layout>
          <a-layout-content class="min-h-[calc(100vh-58px)]">
            <router-view v-slot="{ Component }">
              <component :is="Component" />
            </router-view>
          </a-layout-content>
          <a-layout-footer> <Footer /> </a-layout-footer>
        </a-layout>
      </a-layout>
    </a-layout>
  </div>
</template>
```

其实我们之前写的 Menu 组件还是可以复用的，只需要把菜单的 `mode` 设置成垂直即 `vertical` 就行了。

#### 4.4.2 修改Menu菜单组件

修改 src/layout/components/Menu/index.vue 文件如下：

```js
<script setup>
import { menuRouterFormat, menuRouter } from '@/router/menuRouter.js'

// 新增
const props = defineProps({
  mode: {
    type: String,
    default: 'horizontal'
  }
})
// 菜单模式，horizontal 水平，vertical 垂直
const mode = toRef(props, 'mode')

const menuList = ref(menuRouterFormat(menuRouter))

const router = useRouter()
const onClickMenuItem = key => {
  router.push(key)
}

const route = useRoute()
const selectedKeys = computed(() => [route.path])
</script>
<template>
  <a-menu
    class="menu"
    auto-open-selected
    :selected-keys="selectedKeys"
    @menuItemClick="onClickMenuItem"
    :mode="mode"
    :accordion="true"
  >
    <MenuItem v-for="menu of menuList" :key="menu.path" :menu="menu" />
  </a-menu>
</template>

<style scoped>
/* 没改动，略... */
</style>
```

`Menu` 组件改完了，我们之前写的默认布局不需要改了，因为 `Menu` 目前不传参数默认就是水平菜单，那我们在侧边栏布局中使用一下 `Menu` 组件，修改 `SidebarLayout` 布局文件，在该组件的 `a-layout-sider` 标签下使用 `Menu` 组件如下：

```js
<a-affix :offsetTop="58">
  <a-layout-sider
    breakpoint="lg"
    :width="220"
    height="calc(100vh-58px)"
    collapsible
    :collapsed="collapsed"
    @collapse="handleCollapse"
  >
    <Menu mode="vertical" />
  </a-layout-sider>
</a-affix>
```

#### 4.5 动态切换布局

切换布局的思路文章开头已经说过了，还是老套路，我们先处理一下可切换的布局数据，目前我们就两个布局，接下来我们就用一种相对高级点的方式处理它。

#### 4.5.1 vite中Glob

在`webpack` 中有个 API 叫 `require.context`：

```js
require.context(directory, useSubdirectories, regExp)
```

1. directory ── 表示检索的目录；
2. useSubdirectories ── 表示是否检索子文件夹；
3. regExp ── 匹配文件的正则表达式，一般是文件名；

有经验的同学可能知道，我们在 Vue2 还在使用 webpack 的时候经常会使用 require.context 这个 API 来批量引入组件，那么 Vite 有没有类似的 API 呢？答案是有的，import.meta.glob ，可以参考 [Vite Glob](https://cn.vitejs.dev/guide/features.html#glob-import)。
那接下来我们就用 Vite Glob API 来批量处理布局组件，先解析一下各个布局组件，把他们组成我们想要的一个布局列表数据，当然，用法有很多，这里就当作给大家做个小示范吧。
在 src/layout/switch 文件夹下新建 index.js 文件，写入如下内容：

```js
const modules = import.meta.glob('./*.vue', { eager: true })

let switchLayoutList = []
for (const path in modules) {
  switchLayoutList.push(modules[path].default)
}

export default switchLayoutList
```

上文 `index.js` 文件中我们拿到这些布局组件的 `modules` 后，遍历 `modules` 将每个组件都 `push` 到了 `switchLayoutList` 布局数组列表中并导出，留待后用。

我们在`src/layout/SwitchIndex.vue` 文件中导入 `index.js` 并输出一下 `switchLayoutList` 布局数组，修改如下：

```js
<script setup>
import switchLayoutList from '@/layout/switch/index.js'
console.log(switchLayoutList)
</script>

<template>
  <div class="switch-index">
    <!-- <component :is="" /> -->
    <!-- <DefaultLayout /> -->
    <SidebarLayout />
  </div>
</template>

<style scoped></style>
```

#### 4.5.2 修改布局组件具名并填充布局信息

其实到此我们已经拿到了 `src/layout/switch` 文件夹下的所有可切换布局组件，在 `SidebarLayout` 组件文件中新增如下代码：

```js
<script>
import IconRiLayout5Fill from '~icons/ri/layout-5-fill'
export default {
  name: 'SidebarLayout',
  icon: IconRiLayout5Fill,
  title: '边栏布局'
}
</script>

<script setup>
// ...
</script>

<template>
<!-- ... -->
</template>
```

再写一下默认组件，在 组件中新增如下代码：

```js
<script>
import IconRiLayoutTopFill from '~icons/ri/layout-top-fill'
export default {
  name: 'DefaultLayout',
  icon: IconRiLayoutTopFill,
  title: '默认布局'
}
</script>
```

#### 4.5.3 Pinia共享布局状态

由于将来我们的布局组件信息需要跨页面共享，所以这里就需要用到 `Pinia` 了，`Pinia` 和 `Vuex` 具有相同的功效，是 Vue 的核心存储库，它允许我们跨 组件/页面 共享状态，所以用在这儿很合适，本身 `Pinia` 就是作为下一代 Vuex 产生的，那现在我们使用官方包创建项目都只会询问我们是否安装 `Pinia` 而不是 `Vuex` 了，那 Pinia 同时支持 `OptionsAPI` 和 `CompositionAPI` 两种语法。

初始化项目时我们就已经装了 `Pinia`， `src/stores` 文件夹就是我们的共享状态文件夹，里面有个建项目时创建的 `counter.js `文件，直接删掉即可。

接着，在 `src/stores` 文件夹下创建 `system.js` 文件，`system` 模块即项目的系统配置模块，布局相关的状态数据都放在这里即可：

```js
export const useSystemStore = defineStore('system', () => {
  // 当前可切换布局
  const currentSwitchlayout = shallowRef(null)
  // 可切换布局列表
  const switchLayoutList = shallowRef([])

    return {
      currentSwitchlayout,
      switchLayoutList
    }
})
```

如上，其实用 CompositionAPI 语法写起来和平常在 setup 中没有太大区别。
上面我们创建了当前可切换布局对象 currentSwitchlayout 默认是 null 以及可切换布局列表 switchLayoutList 默认是空数组两个响应式属性。可能大家注意到了，我们这里使用的是 shallowRef 而不是 ref，因为我们把整个布局组件都作为数据源了，如果使用 ref，它会一直递归给布局组件的各个属性做响应式，而这些我们都不需要，太消耗资源，我们只需浅层响应就可以了。
接下来我们还需要在 system 模块中写一个初始化布局的方法：

```js
export const useSystemStore = defineStore('system', () => {
  // 当前可切换布局
  const currentSwitchlayout = shallowRef(null)
  // 可切换布局列表
  const switchLayoutList = shallowRef([])

  // 初始化可切换布局方法
  const initSwitchLayout = list => {
    if (list && list.length > 0) {
      switchLayoutList.value = [...list]

      if (!currentSwitchlayout.value) {
        currentSwitchlayout.value = switchLayoutList.value[0]
      }
    }
  }

  return {
    currentSwitchlayout,
    switchLayoutList,
    initSwitchLayout
  }
})
```

初始化方法接收一个布局列表，就是为 `switchLayoutList` 赋值，然后判断当前布局组件对象 `currentSwitchlayout` 是否有值，没有的话给它一个默认值仅此而已。

那么要在哪里进行布局初始化呢？没错就是 `SwitchIndex` 组件，修改 `src/layout/SwitchIndex.vue` 文件如下：

```js
<script setup>
import switchLayoutList from '@/layout/switch/index.js'
import { useSystemStore } from '@/stores/system'

const systemStore = useSystemStore()

// 初始化布局列表
systemStore.initSwitchLayout(switchLayoutList)
</script>

<template>
  <div class="switch-index">
    <component :is="systemStore.currentSwitchlayout" />
  </div>
</template>

<style scoped></style>
```

如上，我们在 `SwitchIndex` 组件中引入了 `pinia system` 模块方法 `useSystemStore`，此方法返回一个 `systemStore` 对象，即我们 `system` 模块的 `store` 数据对象（就是上面写 `useSystemStore` 方法时 `return` 的那些数据集）。

接着使用布局初始化方法传入我们之前引入的布局组件列表 `switchLayoutList` 给布局组件进行初始化。

其实我们的当前布局对象本身就是布局组件，所以直接在模板中将当前布局组件对象 `currentSwitchlayout` 传入 `component` 组件 `is` 属性中渲染布局即可。

#### 4.5.4 切换布局组件SwitchLayout

切换布局组件还是放在导航条上哈，在 `src/layout/components` 文件夹下新建 `SwitchLayout.vue` 文件：

```vue
<script setup>
import { useSystemStore } from '@/stores/system.js'
const { currentSwitchlayout, switchLayoutList } = storeToRefs(useSystemStore())

// 下拉菜单选中事件
const handleSelect = val => (currentSwitchlayout.value = val)

const { next } = useCycleList(switchLayoutList.value, {
  initialValue: currentSwitchlayout
})
</script>

<template>
  <a-dropdown @select="handleSelect" trigger="hover" class="layout-dropdown">
    <a-button type="text" @click="next()">
      <template #icon>
        <component
          :is="currentSwitchlayout.icon"
          class="text-[var(--color-text-1)] text-16px"
        ></component>
      </template>
    </a-button>
    <template #content>
      <a-doption
        v-for="item in switchLayoutList"
        :key="item.name"
        :value="item"
      >
        <template #icon v-if="currentSwitchlayout.name === item.name">
          <icon-material-symbols-check-small class="text-[var(--color-text-1)] text-14px" />
        </template>
        <template #default>{{ item.title }}</template>
      </a-doption>
    </template>
  </a-dropdown>
</template>

<style scoped>
.layout-dropdown .arco-dropdown-option {
  @apply flex justify-end items-center;
}
</style>
```

至于 `template` 模板内容，我们使用了一个下拉菜单组件，展示到页面上的图标就是当前布局的图标。

还记得我们写布局组件时给每个布局组件都自定义了一个 icon 属性并赋值了一个图标组件吗？这里直接使用 `Vue` 内置的 `component` 组件渲染出来就行。鼠标悬浮到当前布局图标上展示下拉菜单面板，这个面板就遍历一下布局组件列表 `switchLayoutList` 把对应的布局组件名放上去即可，除此之外还给选中的菜单项在下拉菜单中用一个 `iconify` 图标 `material-symbols:check-small` 标注了下（就是个对号图标）。

接下来使用一下 `SwitchLayout` 组件，两个布局组件都需要使用，放在 Navbar 组件右侧插槽中即可。

修改 `DefaultLayout` 组件（只展示了修改处代码）：

```js
<a-layout-header>
  <Navbar>
    <template #left> <Logo /> </template>
    <template #center> <Menu /> </template>

    <template #right>
      <SwitchLayout />
      <Github />
    </template>
  </Navbar>
</a-layout-header>
```

修改 `SidebarLayout` 组件（只展示了修改处代码）：

```vue
<a-layout-header>
  <Navbar>
    <template #left> <Logo /> </template>

    <template #right>
    <SwitchLayout />
    <Github />
    </template>
    </Navbar>
</a-layout-header>
```

### 4.6 Pinia状态持久化

虽然布局做好了，但是我们点击切换布局之后刷新页面会重新走初始化布局流程，刷新一下布局就变回原来的样子了，所以我们还需要给当前布局对象做个持久化。

其实 `Vue3` 中我们完全可以写 `Hooks` 来做一些简单的状态共享，并不一定需要 `Pinia`，之所以还使用 `Pinia`，是因为 `Pinia` 有两个好处：

1. `Pinia` 可以使用 `Vue` 浏览器插件 `Vue Devtools` 去追踪状态变化；
2. `Pinia` 有插件系统，可以使用插件处理一些东西；

那 Pinia 模块状态持久化就可以用插件很便捷的做，这里我们使用一个[开源的状态持久化插件](https://github.com/prazdevs/pinia-plugin-persistedstate)。

#### 4.6.1 安装

```js
pnpm i pinia-plugin-persistedstate

// or

npm i pinia-plugin-persistedstate
```

#### 4.6.2 使用

```js
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)
```

安装好了之后去使用一下此插件，我们是在入口文件 src/main.js 中创建的 Pinia 实例，所以要在这里使用插件，先看下目前的 main.js 文件内容：

```js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import '@/styles/normalize.css'
// 导入Unocss样式
import 'uno.css'

import { getConfig } from '@/config/index'
console.log(getConfig('projectCode'))
console.log(getConfig('projectName'))
console.log(import.meta.env.VITE_APP_ENV)

import App from './App.vue'
import router from './router'

const app = createApp(App)

app.use(createPinia())
app.use(router)

app.mount('#app')
```

把没有用的代码删一删，然后使用一下 `Pinia` 插件，修改 `main.js` 如下：

```js
import { createApp } from 'vue'
import { createPinia } from 'pinia'

// 引入 Pinia 状态持久化插件
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

import '@/styles/normalize.css'
// 导入Unocss样式
import 'uno.css'

import App from './App.vue'
import router from './router'

const app = createApp(App)

// 创建 Pinia 实例
const pinia = createPinia()
// 使用 Pinia 状态持久化插件
pinia.use(piniaPluginPersistedstate)

app.use(pinia)

app.use(router)

app.mount('#app')
```

接下来去 `src/stores/system.js` 文件中做一下配置：

```js
import { getConfig } from '@/config/index'

export const useSystemStore = defineStore(
  'system',
  () => {
    // ...
  },
  // 新增第三个参数
  {
    persist: {
      key: `${getConfig('appCode')}-pinia-system`,
      enabled: true,
      storage: window.localStorage,
      paths: ['currentSwitchlayout']
    }
  }
)
```

如上，我们新增第三个参数对象，该对象中配置 `persist` 属性为 `true` 会默认开启该模块所有状态的持久化，显然我们只需要给模块中的当前布局对象 `currentSwitchlayout` 做持久化就可以了，所以我们需要将 `persist` 属性配置为一个对象，这个对象有如下几个参数：

1. `key` 属性用来配置持久化时缓存数据的 key，默认是模块名；
2. `enabled` 属性代表是否开启持久化；
3. `storage` 属性可以配置如何进行持久化存储，可以写成 `sessionStorage`，默认是使用 `localStorage` ，所以这里我们其实不写也可以；
4. `paths` 属性即配置模块中需要做持久化的状态列表，不写就是默认缓存该模块中的全部状态；
5. `serializer` 此对象可以自定义序列化方法，默认使用 `JSON.stringify/JSON.parse`做序列化；

上面我们的配置是给模块中的 `currentSwitchlayout` 持久化存储到 `localStorage` 中。

然后，修改 `src/stores/system.js`中布局初始化方法如下：

```js
const initSwitchLayout = list => {
  if (list && list.length > 0) {
    switchLayoutList.value = [...list]

    if (!currentSwitchlayout.value) {
      currentSwitchlayout.value = switchLayoutList.value[0]
    } else {
      // 通过name属性找到布局对象并赋值，因为持久化数据中没有组件渲染的render函数
      currentSwitchlayout.value = switchLayoutList.value.find(
        item => item.name === currentSwitchlayout.value.name
      )
    }
  }
}
```

至此，vue实战的基础项目就实现完成了。可以参考[此链接](https://github.com/xianzao/xianzao-vue-tools/tree/master)。

# Vue编译器

https://www.yuque.com/lpldplws/web/abbfgk?singleDoc# 《编译器》 密码：uteo

## 1.课程目标

1. 掌握编译原理的基本思路；
2. 掌握一个简单的编译器的实现；

## 2. 课程大纲

- 什么是编译器；
- 编译器的基本思路；
- 一个简单的编译器的实现；

## 3.什么是编译器

### 3.1. 背景

在babel的[官网](https://babeljs.io/)里，最显著的内容就是：

Babel is a JavaScript compiler

那么什么是所谓的JavaScript compiler？我们应当如何学习和理解compiler？

### 3.2 编译器介绍

compiler也叫编译器，是一种电脑程序，它会将用某种编程语言写成的源代码，转换成另一种编程语言。

从维基百科的定义来看，编译器就是个将当前语言转为其他语言的过程，回到babel上，它所做的事就是语法糖之类的转换，比如ES6/ES7/JSX转为ES5或者其他指定版本，因此称之为compiler也是正确的，换言之，像我们平时开发过程中所谓的其他工具，如：

- Less/Saas
- TypeScript/coffeeScript
- Eslint
- etc...

都可以看到compiler的身影，也是通过这些工具，才使得目前的前端工程化能走入相对的深水区，以下会详细介绍下compiler的实现思路及具体demo，帮助同学们了解compiler的基本实现。

## 4 编译器的基本思路

此处主要讲解compiler的思路

### 4.1 词法分析(Lexical Analysis)

#### 4.1.1 目标

将文本分割成一个个的“token”，例如：init、main、init、x、;、x、=、3、;、}等等。同时它可以去掉一些注释、空格、回车等等无效字符；

#### 4.1.2 生成方式

词法分析生成token的办法有2种：

**1. 使用正则进行词法分析**

需要写大量的正则表达式，正则之间还有冲突需要处理，不容易维护，性能不高，所以正则只适合一些简单的模板语法，真正复杂的语言并不合适。并且有的语言并不一定自带正则引擎。

**2. 使用自动机进行词法分析**

自动机可以很好的生成token；

有穷状态自动机（finite state machine）：在有限个输入的情况下，在这些状态中转移并期望最终达到终止状态。

有穷状态自动机根据确定性可以分为：

“确定有穷状态自动机”（DFA - Deterministic finite automaton）

在输入一个状态时，只得到一个固定的状态。DFA 可以认为是一种特殊的 NFA；

“非确定有穷自动机”（NFA - Non-deterministic finite automaton）

当输入一个字符或者条件得到一个状态机的集合。JavaScript 正则采用的是 NFA 引擎，具体看后文；

### 4.2 语法分析（Syntactic Analysis）

我们日常所说的编译原理就是将一种语言转换为另一种语言。编译原理被称为形式语言，它是一类无需知道太多语言背景、无歧义的语言。而自然语言通常难以处理，主要是因为难以识别语言中哪些是名词哪些是动词哪些是形容词。例如：“进口汽车”这句话，“进口”到底是动词还是形容词？所以我们要解析一门语言，前提是这门语言有严格的语法规定的语言，而定义语言的语法规格称为**文法**。

1956年，乔姆斯基将文法按照规范的严格性分为0型、1型、2型和3型共4中文法，从0到3文法规则是逐渐增加严的。一般的计算机语言是2型，因为0和1型文法定义宽松，将大大增加解析难度、降低解析效率，而3型文法限制又多，不利于语言设计灵活性。2型文法也叫做上下文无关文法（CFG）。

 语法分析的目的就是通过词法分析器拿到的token流 + 结合文法规则，通过一定算法得到一颗抽象语法树（AST）。抽象语法树是非常重要的概念，尤其在前端领域应用很广。典型应用如babel插件，它的原理就是：es6代码 → Babylon.parse → AST → babel-traverse → 新的AST → es5代码。

 从生成AST效率和实现难度上，前人总结主要有2种解析算法：自顶向下的分析方法和自底向上的分析方法。自底向上算法分析文法范围广，但实现难度大。而自顶向下算法实现相对简单，并且能够解析文法的范围也不错，所以一般的compiler都是采用深度优先索引的方式。

### 4.3 代码转换（Transformation）

在得到AST后，我们一般会先将AST转为另一种AST，目的是生成更符合预期的AST，这一步称为代码转换。

代码转换的优势：主要是产生工程上的意义

- 易移植：与机器无关，所以它作为中间语言可以为生成多种不同型号的目标机器码服务；
- 机器无关优化：对中间码进行机器无关优化，利于提高代码质量；
- 层次清晰：将AST映射成中间代码表示，再映射成目标代码的工作分层进行，使编译算法更加清晰 ；

对于一个Compiler而言，在转换阶段通常有两种形式：

同语言的AST转换；

AST转换为新语言的AST；

这里有一种通用的做法是，对我们之前的AST从上至下的解析（称为traversal），然后会有个映射表（称为visitor），把对应的类型做相应的转换。

### 4.4 代码生成（Code Generation）

在实际的代码处理过程中，可能会递归的分析（**recursive**）我们最终生成的AST，然后对于每种type都有个对应的函数处理，当然，这可能是最简单的做法。总之，我们的目标代码会在这一步输出，对于我们的目标语言，它就是HTML了。

### 4.5 完整链路(Compiler)

至此，我们就完成了一个完整的compiler的所有过程：

```js
input => tokenizer => tokens; // 词法分析
tokens => parser => ast; // 语法分析，生成AST
ast => transformer => newAst; // 中间层代码转换
newAst => generator => output; // 生成目标代码
```

## 5. 一个简单的编译器的实现

此处实现一个基础的compiler

### 5.1 前置内容

```js
/**
 * 今天我们要一起写一个编译器。但不仅仅是任何编译器......
 * 超级小的编译器！一个很小的编译器，如果你
 * 删除所有注释，这个文件只有大约 200 行实际代码。
 *
 * 我们将把一些类似语义化代码的函数调用编译成一些类似 C 的函数
 * 函数调用。
 *
 * 如果您不熟悉其中之一。我只是给你一个快速的介绍。
 *
 * 如果我们有两个函数 `add` 和 `subtract` 他们会写成这样：
 *
 * 类似 C
 *
 * 2 + 2 (加 2 2) 加 (2, 2)
 * 4 - 2 (减 4 2) 减 (4, 2)
 * 2 + (4 - 2) (加 2 (减 4 2)) 加 (2, 减 (4, 2))
 *
 *
 * 很好，因为这正是我们要编译的。虽然这
 * 不是完整的 C 语法，它的语法足以
 * 演示现代编译器的许多主要部分。
 */

/**
 * 大多数编译器分为三个主要阶段：解析、转换、
 * 和代码生成
 *
 * 1. *解析* 将原始代码转化为更抽象的代码
 * 代码的表示。
 *
 * 2. *转换* 采用这种抽象表示并进行操作
 * 无论编译器想要什么。
 *
 * 3. *代码生成*采用转换后的代码表示，并
 * 将其转换为新代码。
 */
```

```js
/**
 * 解析
 * --------
 *
 * 解析通常分为两个阶段：词法分析和
 * 句法分析。
 *
 * 1. *词法分析*获取原始代码并将其拆分成这些东西
 * 被称为标记器（或词法分析器）的东西称为标记。
 *
 * Tokens 是一组微小的对象，描述了一个孤立的部分
 * 的语法。它们可以是数字、标签、标点符号、运算符、
 *    任何。
 *
 * 2. *句法分析*获取标记并将它们重新格式化为
 * 描述语法的每个部分及其关系的表示
 *    彼此。这被称为中间表示或
 * 抽象语法树。
 *
 * 抽象语法树，简称 AST，是一个深度嵌套的对象，
 * 以一种既易于使用又能告诉我们很多信息的方式表示代码
 * 信息。
 *
 * 对于以下语法：
 *
 * (加 2 (减 4 2))
 *
 * 令牌可能看起来像这样：
 *
 *   [
 *     { type: 'paren',  value: '('        },
 *     { type: 'name',   value: 'add'      },
 *     { type: 'number', value: '2'        },
 *     { type: 'paren',  value: '('        },
 *     { type: 'name',   value: 'subtract' },
 *     { type: 'number', value: '4'        },
 *     { type: 'number', value: '2'        },
 *     { type: 'paren',  value: ')'        },
 *     { type: 'paren',  value: ')'        },
 *   ]
 *
 * 抽象语法树 (AST) 可能如下所示：
 *
 *   {
 *     type: 'Program',
 *     body: [{
 *       type: 'CallExpression',
 *       name: 'add',
 *       params: [{
 *         type: 'NumberLiteral',
 *         value: '2',
 *       }, {
 *         type: 'CallExpression',
 *         name: 'subtract',
 *         params: [{
 *           type: 'NumberLiteral',
 *           value: '4',
 *         }, {
 *           type: 'NumberLiteral',
 *           value: '2',
 *         }]
 *       }]
 *     }]
 *   }
 */
```

```js

/**
 * 转换
 * --------------
 *
 * 编译器的下一个阶段是转换。再次，这只是
 * 从最后一步获取 AST 并对其进行更改。它可以操纵
 * 使用相同语言的 AST，或者它可以将其翻译成全新的
 * 语。
 *
 * 让我们看看如何转换 AST。
 *
 * 您可能会注意到我们的 AST 中的元素看起来非常相似。
 * 这些对象具有类型属性。这些中的每一个都被称为
 * AST 节点。这些节点在它们上定义了描述一个
 * 树的隔离部分。
 *
 * 我们可以有一个“NumberLiteral”的节点：
 *
*   {
 *     type: 'NumberLiteral',
 *     value: '2',
 *   }
 *
 * Or maybe a node for a "CallExpression":
 *
 *   {
 *     type: 'CallExpression',
 *     name: 'subtract',
 *     params: [...nested nodes go here...],
 *   }
 *
 * 转换 AST 时，我们可以通过以下方式操作节点
 * 添加/删除/替换属性，我们可以添加新节点，删除节点，或者
 * 我们可以不理会现有的 AST 并创建一个全新的基于
 * 在上面。
 *
 * 由于我们的目标是一种新语言，我们将专注于创建一个
 * 特定于目标语言的全新 AST。
 *
 * 遍历
 * ---------
 *
 * 为了浏览所有这些节点，我们需要能够
 * 遍历它们。这个遍历过程会到达 AST 中的每个节点
 * 深度优先。
 *
 *   {
 *     type: 'Program',
 *     body: [{
 *       type: 'CallExpression',
 *       name: 'add',
 *       params: [{
 *         type: 'NumberLiteral',
 *         value: '2'
 *       }, {
 *         type: 'CallExpression',
 *         name: 'subtract',
 *         params: [{
 *           type: 'NumberLiteral',
 *           value: '4'
 *         }, {
 *           type: 'NumberLiteral',
 *           value: '2'
 *         }]
 *       }]
 *     }]
 *   }
 *
 * 所以对于上面的 AST，我们会去：
 *
 * 1. Program - 从 AST 的顶层开始
 * 2. CallExpression (add) - 移动到程序主体的第一个元素
 * 3. NumberLiteral (2) - 移动到 CallExpression 参数的第一个元素
 * 4. CallExpression (subtract) - 移动到 CallExpression 参数的第二个元素
 * 5. NumberLiteral (4) - 移动到 CallExpression 参数的第一个元素
 * 6. NumberLiteral (2) - 移动到 CallExpression 参数的第二个元素
 *
 * 如果我们直接操作这个 AST，而不是创建一个单独的 AST，
 * 我们可能会在这里引入各种抽象。但只是参观
 * 树中的每个节点都足以完成我们正在尝试做的事情。
 *
 * 我使用“访问”这个词的原因是因为有这样的模式
 * 表示对对象结构元素的操作。
*
 * Visitors
 * --------
 *
 * 这里的基本思想是我们将创建一个“访问者”对象，
 * 具有将接受不同节点类型的方法。
 *
 *   var visitor = {
 *     NumberLiteral() {},
 *     CallExpression() {},
 *   };
 *
 * 当我们遍历我们的 AST 时，我们会在任何时候调用这个访问者的方法
 * “输入”一个匹配类型的节点。
 *
 * 为了使它有用，我们还将传递节点和引用
 * 父节点。
 *
 *   var visitor = {
 *     NumberLiteral(node, parent) {},
 *     CallExpression(node, parent) {},
 *   };
 *
 * 但是，也存在在“退出”时调用事物的可能性。想象
 * 我们之前的树形结构以列表形式：
 *
 *   - Program
 *     - CallExpression
 *       - NumberLiteral
 *       - CallExpression
 *         - NumberLiteral
 *         - NumberLiteral
 *
 * 当我们向下遍历时，我们将到达有死胡同的分支。正如我们
 * 完成我们“退出”它的树的每个分支。所以我们顺着树走
 *“进入”每个节点，然后返回我们“退出”。
 *
 *   -> Program (enter)
 *     -> CallExpression (enter)
 *       -> Number Literal (enter)
 *       <- Number Literal (exit)
 *       -> Call Expression (enter)
 *          -> Number Literal (enter)
 *          <- Number Literal (exit)
 *          -> Number Literal (enter)
 *          <- Number Literal (exit)
 *       <- CallExpression (exit)
 *     <- CallExpression (exit)
 *   <- Program (exit)
 *
 * 为了支持这一点，我们的访问者的最终形式将如下所示：
 *
 *   var visitor = {
 *     NumberLiteral: {
 *       enter(node, parent) {},
 *       exit(node, parent) {},
 *     }
 *   };
 */
```

```js
/**
 * 代码生成
 * ---------------
 *
 * 编译器的最后阶段是代码生成。有时编译器会做
 * 与转换重叠的东西，但大部分是代码
 * 生成只是意味着取出我们的 AST 和字符串化代码。
 *
 * 代码生成器有几种不同的工作方式，一些编译器会重用
 * 早期的令牌，其他人将创建一个单独的表示
 *代码，以便他们可以线性打印节点，但据我所知
 * 将使用我们刚刚创建的相同 AST，这是我们将重点关注的内容。
 *
 * 实际上，我们的代码生成器将知道如何“打印”所有不同的
 * AST的节点类型，它会递归调用自己打印嵌套
 * 节点，直到所有内容都打印成一长串代码。
 */

/**
 *就是这样！这就是编译器的所有不同部分。
 *
 * 现在这并不是说每个编译器看起来都和我在这里描述的完全一样。
 * 编译器有许多不同的用途，它们可能需要更多的步骤
 * 我有详细的。
 *
 * 但是现在您应该对大多数编译器的外观有一个大致的高级概念
 * 喜欢。
 *
 * 现在我已经解释了所有这些，你们都可以自己写了
 * 编译器对吗？
 *
 * 开个玩笑，这就是我来帮忙的：P
 *
 * 那么让我们开始吧...
 */
```

### 5.2 词法分析

```js
/**
 * ============================================================================
 *                                   (/^▽^)/
 *                                词法分析！
 * ============================================================================
 */

function tokenizer(input) {
  let current = 0;

  let tokens = [];

  while (current < input.length) {
    let char = input[current];

    if (char === '(') {
      tokens.push({
        type: 'paren',
        value: '(',
      });

      current++;

      continue;
    }

    if (char === ')') {
      tokens.push({
        type: 'paren',
        value: ')',
      });
      current++;
      continue;
    }

    let WHITESPACE = /\s/;
    if (WHITESPACE.test(char)) {
      current++;
      continue;
    }

    let NUMBERS = /[0-9]/;
    if (NUMBERS.test(char)) {
      let value = '';

      while (NUMBERS.test(char)) {
        value += char;
        char = input[++current];
      }

      tokens.push({ type: 'number', value });

      continue;
    }

    if (char === '"') {
      let value = '';

      char = input[++current];

      while (char !== '"') {
        value += char;
        char = input[++current];
      }

      char = input[++current];

      tokens.push({ type: 'string', value });

      continue;
    }

    let LETTERS = /[a-z]/i;
    if (LETTERS.test(char)) {
      let value = '';

      while (LETTERS.test(char)) {
        value += char;
        char = input[++current];
      }

      tokens.push({ type: 'name', value });

      continue;
    }

    throw new TypeError('I dont know what this character is: ' + char);
  }
  return tokens;
}
```

### 5.3 语法分析

```js
/**
 * ============================================================================
 *                                 ヽ/❀o ل͜ o\ﾉ
 *                                THE 解析!!!
 * ============================================================================
 */

function parser(tokens) {
  let current = 0;

  function walk() {
    let token = tokens[current];

    if (token.type === 'number') {
      current++;

      return {
        type: 'NumberLiteral',
        value: token.value,
      };
    }

    if (token.type === 'string') {
      current++;

      return {
        type: 'StringLiteral',
        value: token.value,
      };
    }

    if (token.type === 'paren' && token.value === '(') {
      token = tokens[++current];

      let node = {
        type: 'CallExpression',
        name: token.value,
        params: [],
      };

      token = tokens[++current];

      while (token.type !== 'paren' || (token.type === 'paren' && token.value !== ')')) {
        node.params.push(walk());
        token = tokens[current];
      }

      current++;

      return node;
    }

    throw new TypeError(token.type);
  }

  let ast = {
    type: 'Program',
    body: [],
  };

  while (current < tokens.length) {
    ast.body.push(walk());
  }
  return ast;
}
```

### 5.4 代码转换

```js
/**
 * ============================================================================
 *                                 ⌒(❀>◞౪◟<❀)⌒
 *                              代码转换方法!!!
 * ============================================================================
 */

function traverser(ast, visitor) {
  function traverseArray(array, parent) {
    array.forEach(child => {
      traverseNode(child, parent);
    });
  }

  function traverseNode(node, parent) {
    let methods = visitor[node.type];

    if (methods && methods.enter) {
      methods.enter(node, parent);
    }

    switch (node.type) {
      case 'Program':
        traverseArray(node.body, node);
        break;

      case 'CallExpression':
        traverseArray(node.params, node);
        break;

      case 'NumberLiteral':
      case 'StringLiteral':
        break;

      default:
        throw new TypeError(node.type);
    }

    if (methods && methods.exit) {
      methods.exit(node, parent);
    }
  }

  traverseNode(ast, null);
}

/**
 * ============================================================================
 *                                   ⁽(◍˃̵͈̑ᴗ˂̵͈̑)⁽
 *                              代码转换!!!
 * ============================================================================
 */

/**
 *
 * ----------------------------------------------------------------------------
 *   Original AST                     |   Transformed AST
 * ----------------------------------------------------------------------------
 *   {                                |   {
 *     type: 'Program',               |     type: 'Program',
 *     body: [{                       |     body: [{
 *       type: 'CallExpression',      |       type: 'ExpressionStatement',
 *       name: 'add',                 |       expression: {
 *       params: [{                   |         type: 'CallExpression',
 *         type: 'NumberLiteral',     |         callee: {
 *         value: '2'                 |           type: 'Identifier',
 *       }, {                         |           name: 'add'
 *         type: 'CallExpression',    |         },
 *         name: 'subtract',          |         arguments: [{
 *         params: [{                 |           type: 'NumberLiteral',
 *           type: 'NumberLiteral',   |           value: '2'
 *           value: '4'               |         }, {
 *         }, {                       |           type: 'CallExpression',
 *           type: 'NumberLiteral',   |           callee: {
 *           value: '2'               |             type: 'Identifier',
 *         }]                         |             name: 'subtract'
 *       }]                           |           },
 *     }]                             |           arguments: [{
 *   }                                |             type: 'NumberLiteral',
 *                                    |             value: '4'
 * ---------------------------------- |           }, {
 *                                    |             type: 'NumberLiteral',
 *                                    |             value: '2'
 *                                    |           }]
 *  (sorry the other one is longer.)  |         }
 *                                    |       }
 *                                    |     }]
 *                                    |   }
 * ----------------------------------------------------------------------------
 */

function transformer(ast) {
  let newAst = {
    type: 'Program',
    body: [],
  };

  ast._context = newAst.body;

  traverser(ast, {
    NumberLiteral: {
      enter(node, parent) {
        parent._context.push({
          type: 'NumberLiteral',
          value: node.value,
        });
      },
    },

    StringLiteral: {
      enter(node, parent) {
        parent._context.push({
          type: 'StringLiteral',
          value: node.value,
        });
      },
    },

    CallExpression: {
      enter(node, parent) {
        let expression = {
          type: 'CallExpression',
          callee: {
            type: 'Identifier',
            name: node.name,
          },
          arguments: [],
        };

        node._context = expression.arguments;

        if (parent.type !== 'CallExpression') {
          expression = {
            type: 'ExpressionStatement',
            expression: expression,
          };
        }

        parent._context.push(expression);
      },
    },
  });

  return newAst;
}

```

### 5.5 代码生成

```js
/**
 * ============================================================================
 *                               ヾ（〃＾∇＾）ﾉ♪
 *                            代码生成!!!!
 * ============================================================================
 */

function codeGenerator(node) {
  switch (node.type) {
    case 'Program':
      return node.body.map(codeGenerator).join('\n');

    case 'ExpressionStatement':
      return (
        codeGenerator(node.expression) + ';' // << (...because we like to code the *correct* way)
      );

    case 'CallExpression':
      return codeGenerator(node.callee) + '(' + node.arguments.map(codeGenerator).join(', ') + ')';

    case 'Identifier':
      return node.name;

    case 'NumberLiteral':
      return node.value;

    case 'StringLiteral':
      return '"' + node.value + '"';

    default:
      throw new TypeError(node.type);
  }
}
```

### 5.6 完整流程

```js
/**
 * ============================================================================
 *                                  (۶* ‘ヮ’)۶”
 *                         !!!!!!!!完整流程!!!!!!!!
 * ============================================================================
 */

/**
 *
 *   1. input  => tokenizer   => tokens
 *   2. tokens => parser      => ast
 *   3. ast    => transformer => newAst
 *   4. newAst => generator   => output
 */

function compiler(input) {
  let tokens = tokenizer(input);
  let ast = parser(tokens);
  let newAst = transformer(ast);
  let output = codeGenerator(newAst);

  return output;
}
```

## 6. 附录

- [the super tiny compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)；
- [JavaScript compiler](https://github.com/jacksplwxy/JavaScript-compiler)；

## 7. 课后作业

1. 照着代码，手写一遍compiler的过程；
2. 参考xianzao-cli，自己实现一个自身业务上的cli；

 

#  在Vue3和React中如何实现异步加载 

- Vue3：defineAsyncComponent

- React：Lazy、Suspense

相同点：

1. 都是为了实现在组件异步加载时，通过占位符展示兜底内容，从而让用户有更好的体验；

不同点：

语法结构不同：

1. Vue3：

```js
// 不带选项的异步组件
const asyncModal = defineAsyncComponent(() => import('./Modal.vue'))

// 带选项的异步组件
const asyncModalWithOptions = defineAsyncComponent({
  loader: () => import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  errorComponent: ErrorComponent,
  loadingComponent: LoadingComponent
})
```

2. React：

```js
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

# 用Vue和React实现一个自定义dialog组件

https://www.yuque.com/lpldplws/web/myfkf4?singleDoc# 《配套习题》 密码：oir9

- Vue3：teleport + 自定义Hooks

```js
// hooks/useDOMCreate.ts
import { onUnmounted } from 'vue'

function useDOMCreate(nodeId:string):void {
  const node = document.createElement('div')
  node.id = nodeId
  document.body.appendChild(node)
  onUnmounted(() => {
    document.body.removeChild(node)
  })
}
export default useDOMCreate

//Modal.vue
<template>
  <teleport to="#modal">
    <div class="modal d-block" tabindex="-1" v-if="isVisible">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">{{title}}</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true" @click="onClose">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <slot></slot>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal"  @click="onClose">取消</button>
            <button type="button" class="btn btn-primary"  @click="onConfirm">确定</button>
          </div>
        </div>
      </div>
    </div>
  </teleport>
</template>
<script lang="ts">
import { defineComponent } from 'vue'
import useDOMCreate from '../hooks/useDOMCreate'
export default defineComponent({
  name: 'Modal',
  emits: ['model-close', 'model-confirm'],
  props: {
    title: {
      type: String,
      default: ''
    },
    isVisible: {
      type: Boolean,
      default: false
    }
  },
  setup(props, ctx) {
    useDOMCreate('modal')
    const onClose = () => {
      ctx.emit('model-close')
    }
    const onConfirm = () => {
      ctx.emit('model-confirm')
    }
    return {
      onClose,
      onConfirm
    }
  }
})
</script>

// 使用示例
<template>
  <div class="post-detail-page">
    <button type="button" class="btn btn-danger" @click="handleDelete">删除</button>
    <modal title='是否确认删除？' :isVisible="modalVisible" @model-close="hanldeModalClose" @model-confirm="handleModalConfim">
      <p>确认要删除这篇文章吗？</p>
    </modal>
  </div>
</template>
<script lang="ts">
import { defineComponent, ref } from 'vue'
import Modal from '../components/Modal.vue'

export default defineComponent({
  name: 'post-detail',
  components: { Modal },
  setup() {
    const modalVisible = ref(false)
    const handleDelete = () => {
      modalVisible.value = true
    }
    const hanldeModalClose = () => {
      modalVisible.value = false
    }
    const handleModalConfim = () => {
      modalVisible.value = false
      ...
     / /后续逻辑处理
    }
    return {
      hanldeModalClose,
      handleModalConfim,
      handleDelete,
      modalVisible
    }
  }
})
</script>
```

- React:Portals

```js
// pages/dialog.js
import React, { useState } from 'react';
import { Button } from 'antd';
import PortalDialog from '@/components/PortalDialog';

const DialogPage = () => {
  const [isPortalVisible, setIsPortalVisible] = useState(false);

  const showPortal = () => {
    setIsPortalVisible(true);
  };

  const hidePortal = () => {
    setIsPortalVisible(false);
  };

  return (
    <>
      <Button style={{ marginLeft: '20px' }} onClick={showPortal}>
        Open Dialog（React Portals）
      </Button>
      <PortalDialog visible={isPortalVisible} onHide={hidePortal}>
        <div>dialog-children</div>
      </PortalDialog>
    </>
  );
};

export default DialogPage;


// components/PortalDialog/index.js
import { createPortal } from 'react-dom';
import { Button } from 'antd';
import './style.css';

const PortalDialog = (props) => {
  const { visible, children, onHide } = props;
  return visible
    ? createPortal(
        <div className="portal-sample">
          {children}
          <Button onClick={onHide}>close</Button>
        </div>,
        document.getElementById('dialog-root'),
      )
    : null;
};

export default PortalDialog;
```

 

# Vue3的设计目标是什么？做了哪些优化？

https://www.yuque.com/lpldplws/web/sp3cao?singleDoc# 《配套习题》 密码：kv13

## 1.1 设计目标

 

 

梳理下Vue3之前我们面临的问题：

- 随着功能的增长，复杂组件的代码变得越来越难以维护；

- 缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制；

- 类型推断不够友好；

- bundle的时间太久了；

而 Vue3 经过长达两三年时间的筹备，做出了以下的优化：

- 更小

- 更快

- TypeScript支持

- API设计一致性

- 提高自身可维护性

- 开放更多底层功能

一句话概述，就是更小更快更友好了；

 1.1.1. 更小 

Vue3移除一些不常用的 API；

引入tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了；

 1.1.2. 更快 

主要体现在编译方面：

●diff算法优化；

●静态提升；

●事件监听缓存；

●SSR优化；

 1.1.3. 更友好 

vue3在兼顾vue2的options API的同时还推出了composition API，大大增加了代码的逻辑组织和代码复用能力



我们只需要调用这个函数，即可获取x、y的坐标，完全不用关注实现过程。

试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高。

同时，VUE3是基于typescipt编写的，可以享受到自动的类型定义提示。

 1.2. 优化方案 

vue3从很多层面都做了优化，可以分成三个方面：

●源码；

●性能；

●语法 API；

 1.2.1. 源码 

源码可以从两个层面展开：

●源码管理；

●TypeScript；

 1.2.1.1. 源码管理 

vue3整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到packages目录下面不同的子目录中：

PACKAGES

COMPILER-CORE

COMPILER-DOM

COMPILER-SFC

COMPILER-SSR

REACTIVITY

RUNTIME-CORE

RUNTIME-DOM

RUNTIME-TEST

SERVER-RENDERER

SHARED

SIZE-CHECK

TEMPLATE-EXPLORER

VUE

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1659364259632-33172b4e-bbe3-4c6e-98cd-cc4882737502.png?x-oss-process=image%2Fresize%2Cw_437%2Climit_0)



这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性；

另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue 使用的，这样用户如果只想使用 Vue3的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 Vue；

 1.2.1.2. TypeScript 

Vue3是基于typeScript编写的，提供了更好的类型检查，能支持复杂的类型推导；

 1.2.2. 性能 

vue3是从什么哪些方面对性能进行进一步优化呢？

●体积优化

●编译优化

●数据劫持优化

这里讲述数据劫持：

在vue2中，数据劫持是通过Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除，尽管Vue为了解决这个问题提供了 set和delete实例方法，但是对于用户来说，还是增加了一定的心智负担

同时在面对嵌套层级比较深的情况下，就存在性能问题；

相比之下，vue3是通过proxy监听整个对象，那么对于删除还是监听当然也能监听到，同时Proxy 并不能监听到内部深层次的对象变化，而 Vue3 的处理方式是在getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归。

 1.2.3. 语法 API 

就是composition API，其两大显著的优化：

●优化逻辑组织；

●优化逻辑复用；

 1.2.3.1. 逻辑组织 

一张图，我们可以很直观地感受到 Composition API在逻辑组织方面的优势

OPTIONS

COMPOSITION API

API

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1659364394277-27269e9d-d40d-46fe-9678-35d81251104e.png)



 1.2.3.2. 逻辑复用 

在vue2中，我们是通过mixin实现功能混合，如果多个mixin混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰

而通过composition这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可

同样是上文的获取鼠标位置的例子



组件使用



 2. Vue3.0性能提升主要是通过哪几方面体现的？ 

 2.1. 编译阶段 

回顾Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染

TRIGGER

RE-RENDER

COMPONENT

WATCHER

RENDER

FUNCTION

RENDER

COLLECT

NOTIFY

AS DEPENDENCY

<"TOUCH""

DATA

GETTER

SETTER

VIRTUAL DOM TREE

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1659364576038-a42ce214-215f-4218-817b-b38cb6d8b3bf.png)



试想一下，一个组件结构如下图



可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 diff 和遍历其实都是不需要的，造成性能浪费

因此，Vue3在编译阶段，做了进一步优化。主要有如下：

●diff算法优化；

●静态提升；

●事件监听缓存；

●SSR优化；

 2.1.1. diff算法优化 

Vue3在diff算法中相比Vue2增加了静态标记

关于这个静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较

下图这里，已经标记静态节点的p标签在diff过程中则不会比较，把性能进一步提高

NEW VDOM

OLD VDOM

DIV

DIV

<DIV>

A

<P>'HELLOWORLD'</P>

TEXT:NEWMSG

TEXT:MSG

TEXT:HELLOWORLD

TEXT:HELLOWORLD

FLAG:

FLAG:

<P>{MSG>></P>

</DIV>

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1659364576085-64395f69-9d05-43da-8768-5113b31a226d.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)



关于静态类型枚举如下



 2.1.2. 静态提升 

Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用

这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用



没有做静态提升之前



做了静态提升之后



静态内容_hoisted_1被放置在render 函数外，每次渲染的时候只要取 _hoisted_1 即可

同时 _hoisted_1 被打上了 PatchFlag ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff

 2.1.3. 事件监听缓存 

默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化



没开启事件监听器缓存：



开启事件侦听器缓存后：



上述开启了缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用；

 2.1.4. SSR优化 

当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染



编译后



 2.2. 源码体积 

相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API，再重要的是Tree shanking

任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小



 2.3. 响应式系统 

Vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式；

vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历

●可以监听动态属性的添加；

●可以监听到数组的索引和数组length属性；

●可以监听删除属性；

 3. Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？ 

 3.1. Object.defineProperty 

定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象

 3.1.1. 为什么能实现响应式？ 

通过defineProperty 两个属性，get及set

●get

属性的 getter函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值

●set

属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined

下面通过代码展示：

定义一个响应式函数defineReactive



调用defineReactive，数据发生变化触发update方法，实现数据响应式



在对象存在多个key情况下，需要进行遍历



如果存在嵌套对象的情况，还需要在defineReactive中进行递归



当给key赋值为对象的时候，还需要在set属性中进行递归



上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题

现在对一个对象进行删除与添加属性操作，无法劫持到



当我们对一个数组进行监听的时候，并不那么好使了



可以看到数据的api无法劫持到，从而无法实现数据响应式，

所以在Vue2中，增加了set、delete API，并且对数组api方法进行一个重写

还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题

 3.1.2. 小结 

●检测不到对象属性的添加和删除；

●数组API方法无法监听到；

●需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题；

 3.2. proxy 

Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了

在ES6系列中，我们详细讲解过Proxy的使用，就不再述说了

下面通过代码进行展示：

定义一个响应式方法reactive



测试一下简单数据的操作，发现都能劫持



再测试嵌套对象情况，这时候发现就不那么 OK 了



如果要解决，需要在get之上再进行一层代理



 3.2.1. 小结 

Object.defineProperty只能遍历对象属性进行劫持



Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的



Proxy可以直接监听数组的变化（push、shift、splice）



Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的

正因为defineProperty自身的缺陷，导致Vue2在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外set、delete方法）



Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9

 4. Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？ 

 4.1. Options Api 

Options API，即大家常说的选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑；

如下图：

OPTIONS API

EXPORT DEFAULT

DATA() [

子

RETURN

功能A

功能B

METHODS:

功能

A

功能

B

子,

COMPUTED:

功能

A

},

WATCH:

功能

B

子

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1659365328333-3d51d185-5045-4e80-b9a4-1e667ebfd96a.png?x-oss-process=image%2Fresize%2Cw_446%2Climit_0)



可以看到Options代码编写方式，如果是组件状态，则写在data属性上，如果是方法，则写在methods属性上...

用组件的选项 (data、computed、methods、watch) 组织逻辑在大多数情况下都有效；

然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解；

 4.2. Composition Api 

在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）；

即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API；

FUNCTION

FUNCTION

FUNCTION

UNCTION

FUNCTION

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1659365373744-1ed636f8-89f4-4681-8772-0d6b704b8a2a.png?x-oss-process=image%2Fresize%2Cw_633%2Climit_0)



 4.3. 对比 

下面对Composition Api与Options Api进行两大方面的比较

●逻辑组织；

●逻辑复用；

 4.3.1. 逻辑组织 

 4.3.1.1. Options API 

假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）

HIM SHENTE  SRSTERSTENTENTERSE)

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1659365427846-ba0465ae-d4a1-40c5-a876-f113a0e155de.png)



可以看到，这种碎片化使得理解和维护复杂组件变得困难

选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块；

 4.3.1.2. Compostion API 

Compositon API正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去

下面举个简单例子，将处理count属性相关的代码放在同一个函数了



组件上中使用count



再来一张图进行对比，可以很直观地感受到 Composition API在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可；

OPTIONS

COMPOSITION API

API

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1659365494592-1bbbe3a9-0df8-4348-bd7d-d653bced67fe.png)



 4.3.2. 逻辑复用 

在Vue2中，我们是用过mixin去复用相同的逻辑

下面举个例子，我们会另起一个mixin.js文件



然后在组件中使用



使用单个mixin似乎问题不大，但是当我们一个组件混入大量不同的 mixins的时候



会存在两个非常明显的问题：

●命名冲突；

●数据来源不清晰；

现在通过Compositon API这种方式改写上面的代码：



在组件中使用



可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题。

 4.3. 小结 

●在逻辑组织和逻辑复用方面，Composition API是优于Options API

●因为Composition API几乎是函数，会有更好的类型推断；

●Composition API对 tree-shaking 友好，代码也更容易压缩；

●Composition API中见不到this的使用，减少了this指向不明的情况；

●如果是小型组件，可以继续使用Options API，也是十分友好的；

 5. 说说Vue 3.0中Treeshaking特性？ 

 5.1. 是什么？ 

Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination

简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码

如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去；

而tree shaking则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕

也就是说 ，tree shaking 其实是找出使用的代码

在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到；





JavaScript

复制代码

1

2

3

import Vue from 'vue'

 

Vue.nextTick(() => {})

而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中；





JavaScript

复制代码

1

2

3

import { nextTick, observable } from 'vue'

 

nextTick(() => {})

 5.2. 如何做？ 

Tree shaking是基于ES6模板语法（import与exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量

Tree shaking无非就是做了两件事：

●编译阶段利用ES6 Module判断哪些模块已经加载；

●判断那些模块和变量未被使用或者引用，进而删除对应代码；

 5.3. 作用 

通过Tree shaking，Vue3给我们带来的好处是：

●减少程序体积（更小）；

●减少程序执行时间（更快）；

●便于将来对程序架构进行优化（更友好）；

若有收获，就点个赞吧

# React学习路径

https://www.yuque.com/lpldplws/web/bgn3sl?singleDoc# 《react学习路径》 密码：ei05

## 1. react生态

1. 创建项目

1. 1. CRA(create react app) ：https://github.com/facebook/create-react-app
   2. Vite（2022大热）：https://github.com/vitejs/vite
   3. SSR应用：Next.js：https://github.com/vercel/next.js
   4. 静态站点：Gatsby.js：https://github.com/gatsbyjs/gatsby
   5. 新web 框架：remix：https://github.com/remix-run/remix

1. 状态管理

1. 1. react hooks
   2. redux：https://redux.js.org/
   3. Zusand（本地状态管理）：https://github.com/pmndrs/zustand

1. 远程状态管理

1. 1. React Query（REST API、GraphQL API 都有）：https://github.com/tannerlinsley/react-query
   2. Apollo Client（只有 GraphQL API）：https://www.apollographql.com/docs/react/
   3. RTK Query（结合Redux管理远程数据请求）：https://redux-toolkit.js.org/rtk-query/overview

1. 路由

1. 1. https://reactrouter.com/

1. 样式

1. 1. CSS Modules（CSS in CSS）：https://github.com/css-modules/css-modules
   2. Styled Components（CSS in JS，目前最受欢迎）:https://www.robinwieruch.de/react-styled-components/
   3. Tailwind CSS（Utility-First-CSS）：https://tailwindcss.com/
   4. clsx（条件渲染）：https://github.com/lukeed/clsx

1. 组件库

1. 1. material UI（最流行）：https://mui.com/zh/
   2. Ant Design（国内最流行）：https://ant.design/

1. 动画库

1. 1. React Transition Group
   2. Framer Motion：https://www.framer.com/motion/
   3. react-motion：https://github.com/chenglou/react-motion

1. 可视化图表

1. 1. D3：https://d3js.org/
   2. Recharts：https://recharts.org/zh-CN/
   3. react-chartjs：https://github.com/reactchartjs/react-chartjs-2

1. 表单

1. 1. react hook form：https://react-hook-form.com/

1. 类型检查

1. 1. PropTypes
   2. TS：https://www.typescriptlang.org/

1. 代码风格

1. 1. eslint：https://eslint.org/
   2. prettier：https://github.com/prettier/prettier
   3. Airbnb 代码风格指南：https://keqingrong.cn/blog/2020-05-04-code-style-guide-for-react/
   4. React 代码风格指南：https://www.robinwieruch.de/react-libraries/

1. 身份校验

1. 1. firebase：https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial/
   2. auth0：https://auth0.com/

1. 测试

1. 1. Jest：https://jestjs.io/zh-Hans/

1. 数据处理

1. 1. immutable.js：https://immutable-js.com/
   2. immer：https://github.com/immerjs/immer

1. i18n

1. 1. formatjs：https://github.com/formatjs/formatjs
   2. react-i18next：https://github.com/i18next/react-i18next

1. 富文本编辑

1. 1. draft：https://draftjs.org/
   2. react-quill：https://github.com/zenoamaro/react-quill

1. 时间处理

1. 1. date-fns：https://github.com/date-fns/date-fns
   2. Day.js：https://github.com/iamkun/dayjs

1. 客户端

1. 1. Electron：https://www.electronjs.org/
   2. tauri：https://github.com/tauri-apps/tauri
   3. nwjs：https://nwjs.io/

1. 移动端

1. 1. RN：https://reactnative.dev/

1. 原型设计

1. 1. sketch：https://www.sketch.com/
   2. figma：https://www.figma.com/
   3. zeplin：https://zeplin.io/

1. 文档类

1. 1. storybook：https://storybook.js.org/

1. 其他工具

1. 1. webpack
   2. babel

## 2. 工具类

1. shadowsocks
2. search

1. 1. http://google.com/
   2. https://stackoverflow.com/

1. awesome 系列

1. 1. https://github.com/enaqx/awesome-react

1. github star多的

## 3. 实践类

1. 前后端自己搭建：阿里云 ECS + OSS + mysql
2. blog：GATSBY、GitHub page

## 4. 前沿技术学习

1. 早早聊：https://www.zaozao.run/
2. D2：https://github.com/d2forum
3. Qcon：https://qcon.infoq.cn/2022/beijing
4. JSConf：https://jsconf.com/

# React基础

tauri

https://www.yuque.com/lpldplws/web/lg3g1s?singleDoc# 《React基础》 密码：tv0g

React是一个声明式，高效灵活的构建用户界面的js库,更快响应用户操作的UI库组件

UI=render(data) 单向数据流

## 1.课程目标

1. 入门React，了解常规用法；
2. 掌握面试中React的基础问题；
3. 掌握React学习路线；

## 2. 课程大纲

- React简介
- JSX模板语法
- props & state
- 生命周期
- 事件处理
- 条件渲染
- 列表
- create-react-app
- immutable 及immer

## 3.主要内容

官网地址：https://zh-hans.reactjs.org/

### 3.1 React简介

React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。

ui = render (data) -> 单向数据流

- MVC

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2340337/1647071835190-02b721bb-406d-452f-adb9-3a1af1daf22e.png)

```js
// model
var myapp = {}; // 创建这个应用对象

myapp.Model = function() {
  var val = 0;

  this.add = function(v) {
    if (val < 100) val += v;
  };

  this.sub = function(v) {
    if (val > 0) val -= v;
  };

  this.getVal = function() {
    return val;
  };

  ／* 观察者模式 *／
  var self = this, 
      views = [];

  this.register = function(view) {
    views.push(view);
  };

  this.notify = function() {
    for(var i = 0; i < views.length; i++) {
        views[i].render(self);
    }
  };
};

// view
myapp.View = function(controller) {
  var $num = $('#num'),
      $incBtn = $('#increase'),
      $decBtn = $('#decrease');

  this.render = function(model) {
      $num.text(model.getVal() + 'rmb');
  };

  /*  绑定事件  */
  $incBtn.click(controller.increase);
  $decBtn.click(controller.decrease);
};

// controller
myapp.Controller = function() {
  var model = null,
      view = null;

  this.init = function() {
    /* 初始化Model和View */
    model = new myapp.Model();
    view = new myapp.View(this);

    /* View向Model注册，当Model更新就会去通知View啦 */
    model.register(view);
    model.notify();
  };

  /* 让Model更新数值并通知View更新视图 */
  this.increase = function() {
    model.add(1);
    model.notify();
  };

  this.decrease = function() {
    model.sub(1);
    model.notify();
  };
};

// init
(function() {
  var controller = new myapp.Controller();
  controller.init();
})();
```

- mvvm

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1647072104508-55c6d7e4-d8c5-4f39-afab-def587496cae.png)

### 3.2 JSX模版语法

JSX称为JS的语法扩展，将UI与逻辑层耦合在组件里，用{}标识

因为 JSX 语法上更接近 JS 而不是 HTML，所以使用 camelCase（小驼峰命名）来定义属性的名称；

JSX 里的 class 变成了 [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className)，而 tabindex 则变为 [tabIndex](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex)。

#### 3.2.1 jsx支持表达式

支持JS表达式，变量，方法名

```jsx
// 变量
const name = 'Josh Perez';
const element = <h1>Hello, {name}</h1>;

function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

// 方法
const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);

function getGreeting(user) {
  if (user) {
    return <h1>Hello, {formatName(user)}!</h1>;
  }
  return <h1>Hello, Stranger.</h1>;
}
```

#### 3.2.2 jsx指定属性

```jsx
const element = <img src={user.avatarUrl}></img>;

注意：JSX支持防注入(防止XSS攻击)
const title = response.potentiallyMaliciousInput;  // 此时只是字符串
// 直接使用是安全的： const element = <h1>{title}</h1>;

React 如何预防XSS

// 反射型 XSS

https://xxx.com/search?query=userInput

// 服务器在对此 URL 的响应中回显提供的搜索词：query=123
<p>您搜索的是: 123</p>

// https://xxx.com/search?query=<img src="empty.png" onerror ="alert('xss')">
<p>您搜索的是: <img src="empty.png" onerror ="alert('xss')"></p>
// 如果有用户请求攻击者的 URL ，则攻击者提供的脚本将在用户的浏览器中执行。

  
// 存储型 XSS，存储到目标数据库
// 评论输入，所有访问用户都能看到了
<textarea>
  <img src="empty.png" onerror ="alert('xss')">
</textarea>
  
// 部分源码
for (index = match.index; index < str.length; index++) {
  switch (str.charCodeAt(index)) {
    case 34: // "
      escape = '&quot;';
      break;
    case 38: // &
      escape = '&amp;';
      break;
    case 39: // '
      escape = '&#x27;';
      break;
    case 60: // <
      escape = '&lt;';
      break;
    case 62: // >
      escape = '&gt;';
      break;
    default:
      continue;
  }
}

// 一段恶意代码
<img src="empty.png" onerror ="alert('xss')"> 
//  React 在渲染到浏览器前进行的转义，可以看到对浏览器有特殊含义的字符都被转义了，恶意代码在渲染到 HTML 前都被转成了字符串
&lt;img src=&quot;empty.png&quot; onerror =&quot;alert(&#x27;xss&#x27;)&quot;&gt; 
  
// JSX
const element = (
  <h1 className="greeting">
      Hello, world!
  </h1>
);
  
// 通过 babel 编译后的代码
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
  
// React.createElement() 方法返回的 ReactElement
const element = {
  $$typeof: Symbol('react.element'),
  type: 'h1',
  key: null,
  props: {
    children: 'Hello, world!',
        className: 'greeting'   
  }
  ...
}
 
// 如何模拟一个Children会如何？
const storedData = `{
    "ref":null,
    "type":"body",
    "props":{
        "dangerouslySetInnerHTML":{
            "__html":"<img src=\"empty.png\" onerror =\"alert('xss')\"/>"
        }
    }
}`;
// 转成 JSON
const parsedData = JSON.parse(storedData);
// 将数据渲染到页面
render () {
    return <span> {parsedData} </span>; 
}
  
// $$typeof 是用来标记一个ReactElement的，JSON化后Symbol会丢失，React会报错
```

#### 3.2.3 jsx表示对象

```jsx
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);

// 等同于React.createElement
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);

const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};
```

#### 3.2.4 将JSX渲染为DOM

```jsx
// 使用ReactDOM.render
const element = <h1>Hello, world</h1>;
ReactDOM.render(element, document.getElementById('root'));

// render只能代表当前时刻的状态
// 更新元素 只能再次 ReactDOM.render
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root')); 
}

setInterval(tick, 1000); // 不建议多次render
```

#### 3.2.5. JSX转JS

JSX可以当做语法糖，可以在babel官网中尝试，https://babeljs.io/repl

可以使用官网提供的create-react-app npm run eject 来看babelrc中的配置，主要使用

https://www.babeljs.cn/docs/babel-preset-react

```js
// 安装babel 及react 的依赖
npm install core-js @babel/core @babel/preset-env @babel/preset-react @babel/register babel-loader @babel/plugin-transform-runtime --save-dev

.babelrc
{
    "presets" : [ 
        "@babel/preset-env" ,
        "@babel/preset-es2015",
        "@babel/preset-react"
    ],
    "plugins" : [
        "@babel/plugin-transform-runtime"
    ]
}
```

### 3.3 props及state

组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。

### 3.3.1 组件

- 函数式组件
- Class类组件

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

##### 3.3.1.1 渲染组件

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);

// 自定义组件使用大写字母开头
import React from 'react';

// 正确！组件需要以大写字母开头：
function Hello(props) {
  // 正确！ 这种 <div> 的使用是合法的，因为 div 是一个有效的 HTML 标签：
  return <div>Hello {props.toWhat}</div>;
}

function HelloWorld() {
  // 正确！React 知道 <Hello /> 是一个组件，因为它是大写字母开头的：
  return <Hello toWhat="World" />;
}
```

##### 3.3.1.2 组件的组合与拆分

```jsx
// 页面内多次引用
<div>
  <Welcome name="Sara" />
  <Welcome name="Cahal" />
  <Welcome name="Edite" />
</div>

function Comment(props) {
  return (
    <div className="Comment">
      <div className="UserInfo">
        <img className="Avatar"
          src={props.author.avatarUrl}
          alt={props.author.name}
        />
        <div className="UserInfo-name">
          {props.author.name}
        </div>
      </div>
      <div className="Comment-text">
        {props.text}
      </div>
      <div className="Comment-date">
        {formatDate(props.date)}
      </div>
    </div>
  );
}

// 拆分后为
function Comment(props) {
  return (
    <div className="Comment">
      <UserInfo user={props.author} />
      <div className="Comment-text">
        {props.text}
      </div>
      <div className="Comment-date">
        {formatDate(props.date)}
      </div>
    </div>
  );
}
```

##### 3.3.1.3. 受控组件 与 非受控组件

- 受控组件：对某个组件状态的掌控，它的值是否只能由用户设置，而不能通过代码控制；

在HTML的表单元素中，它们通常自己维护一套state，并随着用户的输入自己进行UI上的更新，这种行为是不被我们程序所管控的。而如果将React里的state属性和表单元素的值建立依赖关系，再通过onChange事件与setState()结合更新state属性，就能达到控制用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做受控组件。

```jsx
// input自身维护的状态，外界无法获取数据
class TestComponent extends React.Component {
  render () {
    return <input name="username" />
  }
}

// 可以设置初始值
class TestComponent extends React.Component {
  constructor (props) {
    super(props);
    this.state = { username: 'test' };
  }
  render () {
    return <input name="username" value={this.state.username} />
  }
}

// 可以读取并设置初始值
class TestComponent extends React.Component {
  constructor (props) {
    super(props);
    this.state = {
      username: "test"
    }
  }
  onChange (e) {
    console.log(e.target.value);
    this.setState({
      username: e.target.value
    })
  }
  render () {
    return <input name="username" value={this.state.username} onChange={(e) => this.onChange(e)} />
  }

```

- 非受控组件：对应的，组件内的状态不由用户控制

```jsx
// 如果不想关心表单元素的值是如何变化的，只想取值，可以使用ref
import React, { Component } from 'react';

export class UnControll extends Component {
  constructor (props) {
    super(props);
    this.inputRef = React.createRef();
  }
  handleSubmit = (e) => {
    console.log('我们可以获得input内的值为', this.inputRef.current.value);
    e.preventDefault();
  }
  render () {
    return (
      <form onSubmit={e => this.handleSubmit(e)}>
        <input defaultValue="lindaidai" ref={this.inputRef} />
        <input type="submit" value="提交" />
      </form>
    )
  }
}
```

#### 3.3.2 props

```jsx
所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。

// 错误，要像纯函数一样幂等
function withdraw(account, amount) {
  account.total -= amount;
}
```

#### 3.3.3 state

```jsx
// 使用props形式
function Clock(props) {
  return (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {props.date.toLocaleTimeString()}.</h2>
    </div>
  );
}

function tick() {
  ReactDOM.render(
    <Clock date={new Date()} />,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);

// 如何避免多次React.DOM render？

// 引用生命周期，根组件保留一个
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

```jsx
1. setState 
构造函数是唯一可以给state赋值的地方
this.setState({comment: 'Hello'});

2. state更新可能是异步的
// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});
// Correct
this.setState(function(state, props) {
  return {
    counter: state.counter + props.increment
  };
});

3. state更新会合并
constructor(props) {
  super(props);
  this.state = {
    posts: [],
    comments: []
  };
}

componentDidMount() {
  fetchPosts().then(response => {
    // 相当于{post: response.posts, ...otherState}
    this.setState({
      posts: response.posts
    });
  });

  fetchComments().then(response => {
    this.setState({
      comments: response.comments
    });
  });
}

4. 单向数据流
state 只在当前的组件里生效，属于组件内的属性，重复实例化相同的组件，内部的内存地址也是不一样的；
例如Clock中计时器都是独立的
```

```jsx
// setState 异步
// 异步目的：batch 处理，性能优化
//1. 合成事件
class App extends Component {
	
	state = { val: 0 }
	
	increment = () => {
		this.setState({ val: this.state.val + 1 })
		console.log(this.state.val) // 输出的是更新前的val --> 0
	}
	
	render() {
		return (
			<div onClick={this.increment}>
				{`Counter is: ${this.state.val}`}
			</div>
		)
	}
}

//2. 生命周期
class App extends Component {
	
	state = { val: 0 }
	
	componentDidMount() {
		this.setState({ val: this.state.val + 1 })
		console.log(this.state.val) // 输出的还是更新前的值 --> 0
	}
	render() {
		return (
			<div>
				{`Counter is: ${this.state.val}`}
			</div>
		)
	}
}

//3. 原生事件
class App extends Component {
	
	state = { val: 0 }
	
	changeValue = () => {
		this.setState({ val: this.state.val + 1 })
		console.log(this.state.val) // 输出的是更新后的值 --> 1
	}
	
	componentDidMount() {
		document.body.addEventListener('click', this.changeValue, false)
	}
	
	render() {
		return (
			<div>
				{`Counter is: ${this.state.val}`}
			</div>
		)
	}
}

//4. setTimeout
class App extends Component {
	
	state = { val: 0 }
	
	componentDidMount() {
		setTimeout(_ => {
			this.setState({ val: this.state.val + 1 })
			console.log(this.state.val) // 输出更新后的值 --> 1
		}, 0)
	}
	
	render() {
		return (
			<div>
				{`Counter is: ${this.state.val}`}
			</div>
		)
	}
}

//5. 批处理
class App extends Component {
	
	state = { val: 0 }
	
	batchUpdates = () => {
		this.setState({ val: this.state.val + 1 })
		this.setState({ val: this.state.val + 1 })
		this.setState({ val: this.state.val + 1 })
	}
	
	render() {
		return (
			<div onClick={this.batchUpdates}>
				{`Counter is ${this.state.val}`} // 1
			</div>
		)
	}
}

// 6. 综合
  componentDidMount() {
    // 生命周期中调用
    this.setState({ val: this.state.val + 1 });
    console.log("lifecycle: " + this.state.val);//lifecycle:0

    setTimeout(() => {
      // setTimeout中调用
      this.setState({ val: this.state.val + 1 });
      console.log("setTimeout: " + this.state.val);//setTimeout:2
    }, 0);

    document.getElementById("div2").addEventListener("click", this.increment2);
  }

  increment = () => {
    // 合成事件中调用
    this.setState({ val: this.state.val + 1 });
    console.log("react event: " + this.state.val);//react event:2
  };

  increment2 = () => {
    // 原生事件中调用
    this.setState({ val: this.state.val + 1 });
    console.log("dom event: " + this.state.val);//dom event:4
  };

  render() {
    return (
      <div className="App">
        <h2>Count: {this.state.val}</h2>
        <div id="div1" onClick={this.increment}> // 点击第一次
          click me and val + 1
        </div>
        <div id="div2">click me and val + 1</div> // 点击第二次
      </div>
    );
  }
}

export default App;
```

1. setState 只在合成事件和生命周期中是“异步”的，在原生事件和 setTimeout 中都是同步的;

2. setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的， 只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”， 当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。

3. setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。

### 3.4 生命周期

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1646656380983-233bbd92-6d70-4131-b4e3-5517eaf93b76.png)

#### 3.4.1. render

是class组件必需的方法

获取最新的 props 和 state

在不修改组件 state 的情况下，每次调用时都返回相同的结果

#### 3.4.2 constructor

如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。

- 通过给 this.state 赋值对象来初始化内部 state。
- 为事件处理函数绑定实例

```jsx
constructor(props) {
  super(props);
  // 不要在这里调用 this.setState()
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}

1. 不要调用 setState()
2. 避免将 props 的值复制给 state
this.state = { color: props.color }; // wrong
```

#### 3.4.3. componentDidMount

会在组件挂载后（插入 DOM 树中）立即调用

依赖于 DOM 节点的初始化应该放在这里，如需通过网络请求获取数据；

可以在此生命周期里加 setState，但发生在浏览器更新屏幕之前，会导致性能问题；

有更新在render阶段的 constructor 中 init State，但有更新可以在此方法时 setState

#### 3.4.4 componentDidUpdate

```jsx
componentDidUpdate(prevProps, prevState, snapshot)
```

会在更新后会被立即调用。首次渲染不会执行此方法。

```jsx
componentDidUpdate(prevProps) {
  // 典型用法（不要忘记比较 props）：加条件判断，不然死循环
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
如果组件实现了 getSnapshotBeforeUpdate() 生命周期，
则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined。
```

如果 shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()。

#### 3.4.5 componentWillUnmount

componentWillUnmount() 会在组件卸载及销毁之前直接调用。例如，清除 timer，取消网络请求；

componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染；

#### 3.4.6 shouldComponentUpdate

```jsx
shouldComponentUpdate(nextProps, nextState)
```

根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。

作为性能优化使用，返回false可以跳过re-render

shouldComponentUpdate() 返回 false，不会调用 UNSAFE_componentWillUpdate()，render() 和 componentDidUpdate()。

#### 3.4.7 getDerivedStateFromProps

（不常用）

是为了取代componentWillReceiveProps 和 componentWillUpdate设置的

根据props的变化改变state，它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。

- 在使用此生命周期时，要注意把传入的 prop 值和之前传入的 prop 进行比较；
- 因为这个生命周期是静态方法，同时要保持它是纯函数，不要产生副作用；

```jsx
static getDerivedStateFromProps(nextProps, prevState) {
    const {type} = nextProps;
    // 当传入的type发生变化的时候，更新state
    if (type !== prevState.type) {
        return {
            type,
        };
    }
    // 否则，对于state不进行任何操作
    return null;
}

Class ColorPicker extends React.Component {
    state = {
        color: '#000000'
    }
    static getDerivedStateFromProps (props, state) {
        if (props.color !== state.color) {
            return {
                color: props.color
            }
        }
        return null
    }
    ... // 选择颜色方法
    render () {
        .... // 显示颜色和选择颜色操作，setState({color: XXX})
    }
}

Class ColorPicker extends React.Component {
    state = {
        color: '#000000',
        prevPropColor: '' // setState 和 forceUpdate也会触发此生命周期，会覆盖
    }
    static getDerivedStateFromProps (props, state) {
        if (props.color !== state.prevPropColor) {
            return {
                color: props.color,
                prevPropColor: props.color
            }
        }
        return null
    }
    ... // 选择颜色方法
    render () {
        .... // 显示颜色和选择颜色操作
    }
}
```

首先看一下概念，这个生命周期是从props中获取state，实际上就是将传入的props映射到state上面。

shouldComponentUpdate(nextProps, nextState)

`getDerivedStateFromProps`是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state

getDerivedStateFromProps exists for only one purpose. It enables a component to update its internal state as the result of changes in props.

根据React官网的描述，它的目的仅仅在于让props能更新到内部的state，所以场景包含两个：

1. 无条件地根据props更新state，只要有传入props，就更新state；
2. 只有props和state不一样才更新state；

##### 3.4.7.1 无条件地根据props更新state，只要有传入props，就更新state

```jsx
class Table extends React.Component {
    state = {
        list: []
    }
    static getDerivedStateFromProps (props, state) {
        return {
            list: props.list
        }
    }
    render () {
        .... // 展示 list
    }
}
```

可以发现如果无条件从props更新state，完全没有必要使用这个声明周期，直接使用props就行

##### 3.4.7.2 只有props和state不一样才更新state

```jsx
Class ColorPicker extends React.Component {
    state = {
        color: '#000000'
    }
    static getDerivedStateFromProps (props, state) {
        if (props.color !== state.color) {
            return {
                color: props.color
            }
        }
        return null
    }
    ... // 选择颜色方法
    render () {
        .... // 显示颜色和选择颜色操作
    }
}
```

但如果有`setState `color的操作，会发现改变不了颜色，因为在 React 16.4^ 的版本中 `setState `和 `forceUpdate` 也会触发这个生命周期，所以内部 state 变化后，又会走 `getDerivedStateFromProps `方法，并把 state 值更新为传入的 prop；

```jsx
Class ColorPicker extends React.Component {
    state = {
        color: '#000000',
        prevPropColor: ''
    }
    static getDerivedStateFromProps (props, state) {
        if (props.color !== state.prevPropColor) {
            return {
                color: props.color
                prevPropColor: props.color
            }
        }
        return null
    }
    ... // 选择颜色方法
    render () {
        .... // 显示颜色和选择颜色操作
    }
}
```

可以通过保存一个之前 prop 值，我们就可以在只有 prop 变化时才去修改 state；

#### 3.4.8 getSnapshotBeforeUpdate

```jsx
getSnapshotBeforeUpdate(prevProps, prevState)
```

getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用；

此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()。

```jsx
class ScrollingList extends React.Component {
  constructor(props) {
    super(props);
    this.listRef = React.createRef();
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 我们是否在 list 中添加新的 items ？
    // 捕获滚动​​位置以便我们稍后调整滚动位置。
    if (prevProps.list.length < this.props.list.length) {
      const list = this.listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，
    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。
    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）
    if (snapshot !== null) {
      const list = this.listRef.current;
      list.scrollTop = list.scrollHeight - snapshot;
    }
  }

  render() {
    return (
      <div ref={this.listRef}>{/* ...contents... */}</div>
    );
  }
}
```

#### 3.4.9. static getDerivedStateFromError

（不常用）

配合Error boundaries使用

此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state；

#### 3.4.10. componentDidCatch

（不常用）

componentDidCatch() 会在“提交”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况；

```jsx
componentDidCatch(error, info)

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染可以显示降级 UI
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // "组件堆栈" 例子:
    //   in ComponentThatThrows (created by App)
    //   in ErrorBoundary (created by App)
    //   in div (created by App)
    //   in App
    logComponentStackToMyService(info.componentStack);
  }

  render() {
    if (this.state.hasError) {
      // 你可以渲染任何自定义的降级 UI
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}
```

#### 3.4.11. UNSAFE_componentWillMount

 （不建议使用）

UNSAFE_componentWillMount() 在挂载之前被调用；

它在 render() 之前调用，因此在此方法中同步调用 setState() 不会生效；

需要的话用componentDidMount替代。

#### 3.4.12. UNSAFE_componentWillReceiveProps

（不建议使用）
UNSAFE_componentWillReceiveProps() 会在已挂载的组件接收新的 props 之前被调用；

如果你需要更新状态以响应 prop 更改（例如，重置它），你可以比较 this.props 和 nextProps 并在此方法中使用 this.setState() 执行 state 转换。

#### 3.4.13. UNSAFE_componentWillUpdate

（不建议使用）

- 当组件收到新的 props 或 state 时，会在渲染之前调用 UNSAFE_componentWillUpdate()；
- 使用此作为在更新发生之前执行准备更新的机会；
- 初始渲染不会调用此方法；

如果 shouldComponentUpdate() 返回 false，则不会调用 UNSAFE_componentWillUpdate()；

### 3.5. 事件处理

#### 3.5.1. 语法格式

1. 在JSX元素上添加事件,通过on*EventType这种内联方式添加,命名采用小驼峰式(camelCase)的形式,而不是纯小写(原生HTML中对DOM元素绑定事件,事件类型是小写的)；
2. 无需调用addEventListener进行事件监听，也无需考虑兼容性，React已经封装好了一些的事件类型属性；
3. 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串；
4. 不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault；

```jsx
// DOM
<button onclick="activateLasers()">
  Activate Lasers
</button>

// React
<button onClick={activateLasers}>
  Activate Lasers
</button>

// JS
<form onsubmit="console.log('You clicked submit.'); return false">
  <button type="submit">Submit</button>
</form>

// React
一般不需要使用 addEventListener 为已创建的 DOM 元素添加监听器；
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
    console.log('You clicked submit.');
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Submit</button>
    </form>
  );
}
```

```jsx
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // 为了在回调中使用 `this`，这个绑定是必不可少的
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      // class 的方法默认不会绑定 this。如果没有绑定 this.handleClick 并把它传入了 onClick，
      // this 的值为 undefined。
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}

ReactDOM.render(
  <Toggle />,
  document.getElementById('root')
);

// 为什么要绑定this
function createElement(dom, params) {
  var domObj = document.createElement(dom);
  domObj.onclick = params.onclick;
  domObj.innerHTML = params.conent;
  return domObj
}
// createElement 的onClick函数是绑定到domObj上的，如果this不显式绑定，不会绑定到Toggle上

// 不显式使用bind
1.  public class fields 语法
class LoggingButton extends React.Component {
  // 此语法确保 `handleClick` 内的 `this` 已被绑定。
  // 注意: 这是 *实验性* 语法。
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}

2. 箭头函数，问题： 每次render都会创建不同的回调函数，如果该回调函数作为props传入子组件，每次子组件都要re-render
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    return (
      <button onClick={() => this.handleClick()}>
			//  <button onClick={this.handleClick().bind(this)}>
        Click me
      </button>
    );
  }
}

3. createReactClass代替
```

#### 3.5.2. 接收参数

1. 事件对象 e 会被作为第二个参数传递；
2. 通过箭头函数的方式，事件对象必须显式的进行传递；
3. 通过 Function.prototype.bind 的方式，事件对象以及更多的参数将会被隐式的进行传递；

```jsx
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
```

### 3.6 条件渲染

#### 3.6.1 if esle渲染

```jsx
class LoginControl extends React.Component {
  constructor(props) {
    super(props);
    this.handleLoginClick = this.handleLoginClick.bind(this);
    this.handleLogoutClick = this.handleLogoutClick.bind(this);
    this.state = {isLoggedIn: false};
  }

  handleLoginClick() {
    this.setState({isLoggedIn: true});
  }

  handleLogoutClick() {
    this.setState({isLoggedIn: false});
  }

  render() {
    const isLoggedIn = this.state.isLoggedIn;
    let button;
    if (isLoggedIn) {
      button = <LogoutButton onClick={this.handleLogoutClick} />;
    } else {
      button = <LoginButton onClick={this.handleLoginClick} />;
    }

    return (
      <div>
        <Greeting isLoggedIn={isLoggedIn} />
        {button}
      </div>
    );
  }
}

ReactDOM.render(
  <LoginControl />,
  document.getElementById('root')
);
```

#### 3.6.2 与运算符 &&

```jsx
function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (
    <div>
      <h1>Hello!</h1>
      {unreadMessages.length > 0 &&
        <h2>
          You have {unreadMessages.length} unread messages.
        </h2>
      }
    </div>
  );
}

const messages = ['React', 'Re: React', 'Re:Re: React'];
ReactDOM.render(
  <Mailbox unreadMessages={messages} />,
  document.getElementById('root')
);

// 返回false的表达式，会跳过元素，但会返回该表达式
render() {
  const count = 0;
  return (
    <div>
      { count && <h1>Messages: {count}</h1>}
    </div>
  );
}
```

#### 3.6.3 三元运算符

```jsx
render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      {isLoggedIn
        ? <LogoutButton onClick={this.handleLogoutClick} />
        : <LoginButton onClick={this.handleLoginClick} />
      }
    </div>
  );
}
```

#### 3.6.4 如何阻止组件渲染

```jsx
function WarningBanner(props) {
  if (!props.warn) {
    return null;
  }

  return (
    <div className="warning">
      Warning!
    </div>
  );
}

class Page extends React.Component {
  constructor(props) {
    super(props);
    this.state = {showWarning: true};
    this.handleToggleClick = this.handleToggleClick.bind(this);
  }

  handleToggleClick() {
    this.setState(state => ({
      showWarning: !state.showWarning
    }));
  }

  render() {
    return (
      <div>
        <WarningBanner warn={this.state.showWarning} />
        <button onClick={this.handleToggleClick}>
          {this.state.showWarning ? 'Hide' : 'Show'}
        </button>
      </div>
    );
  }
}

ReactDOM.render(
  <Page />,
  document.getElementById('root')
);
```

### 3.7 列表

```jsx
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <li key={number.toString()}>
      {number}
    </li>
  );
  
  return (
    <ul>{listItems}</ul>
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);
// 若没有key，会warning a key should be provided for list items
// key可以帮助react diff，最好不用index作为key，会导致性能变差；
// 如果不指定显式的 key 值，默认使用索引用作为列表项目的 key 值；
```

#### 3.7.1 key注意点

```jsx
key要保留在map的遍历元素上

// demo1
function ListItem(props) {
  // 正确！这里不需要指定 key：
  return <li>{props.value}</li>;
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    // 正确！key 应该在数组的上下文中被指定
    <ListItem key={number.toString()} value={number} />
  );
  return (
    <ul>
      {listItems}
    </ul>
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);

// demo2
function Blog(props) {
  const sidebar = (
    <ul>
      {props.posts.map((post) =>
        <li key={post.id}>
          {post.title}
        </li>
      )}
    </ul>
  );
  const content = props.posts.map((post) =>
    <div key={post.id}>
      <h3>{post.title}</h3>
      <p>{post.content}</p>
    </div>
  );
  return (
    <div>
      {sidebar}
      <hr />
      {content}
    </div>
  );
}

const posts = [
  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
  {id: 2, title: 'Installation', content: 'You can install React from npm.'}
];
ReactDOM.render(
  <Blog posts={posts} />,
  document.getElementById('root')
);

// demo3
function NumberList(props) {
  const numbers = props.numbers;
  return (
    <ul>
      {numbers.map((number) =>
        <ListItem key={number.toString()}
                  value={number} />
      )}
    </ul>
  );
}
```

### 3.8. create-react-app

官方地址：https://create-react-app.dev/

github：https://github.com/facebook/create-react-app

create-react-app是一个官方支持的创建React单页应用程序的脚手架。它提供了一个零配置的现代化配置设置。

![img](https://cdn.nlark.com/yuque/0/2022/webp/2340337/1653717365380-a9a3f644-3583-4bda-8d2b-e8589c70c4d5.webp)

### 3.9. immutable 及immer

#### 3.9.1. immutable

官方地址：https://immutable-js.com/

解决的问题：

JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如 `foo={a: 1}; bar=foo; bar.a=2` 你会发现此时 foo.a 也被改成了 2。虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。

##### 3.9.1.1 什么事immutable data

- Immutable Data 就是一旦创建，就不能再被更改的数据；
- 对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象；
- Immutable 实现的原理是 Persistent Data Structure（持久化数据结构）：也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享

![img](https://camo.githubusercontent.com/0b8366dbd9e9298f8f2521d59b6602f65e857aa5256cd7114ea0de3cf169c4ca/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69322f5442317a7a695f4b5858585858637458465858627262384f5658582d3631332d3537352e676966)

#### 3.9.1.2. immutable.js

Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce``find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。

```jsx
// 原来的写法
let foo = {a: {b: 1}};
let bar = foo;
bar.a.b = 2;
console.log(foo.a.b);  // 打印 2
console.log(foo === bar);  //  打印 true

// 使用 immutable.js 后
import Immutable from 'immutable';
foo = Immutable.fromJS({a: {b: 1}});
bar = foo.setIn(['a', 'b'], 2);   // 使用 setIn 赋值
console.log(foo.getIn(['a', 'b']));  // 使用 getIn 取值，打印 1
console.log(foo === bar);  //  打印 false
```

##### 3.9.1.3. immmutable.js 优点

1. 降低了mutable带来的复杂性

   ```jsx
   function touchAndLog(touchFn) {
     let data = { key: 'value' };
     touchFn(data);
     console.log(data.key);
     // 因为不知道touchFn进行了什么操作，所以无法预料，但使用immutable，肯定是value
   }
   ```

2. 节省开支

会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。

```jsx
import { Map} from 'immutable';
let a = Map({
  select: 'users',
  filter: Map({ name: 'Cam' })
})
let b = a.set('select', 'people');

a === b; // false
a.get('filter') === b.get('filter'); // true
```

1. Undo/Redo，Copy/Paste

因为每次数据都是不一样的，所有可以存储在数组里，想回退到哪里就拿出对应数据即可

##### 3.9.1.4. immutable.js缺点

1. 需要学习新的API
2. 容易与原生对象混淆

虽然 Immutable.js 尽量尝试把 API 设计的原生对象类似，有的时候还是很难区别到底是 Immutable 对象还是原生对象，容易混淆操作。

1. Immutable 中的 Map 和 List 虽对应原生 Object 和 Array，但操作非常不同，比如你要用 map.get('key') 而不是 map.key，array.get(0) 而不是 array[0]。另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值；
2. 当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。

下面给出一些办法来避免类似问题发生：

1. 使用TypeScript 这类有静态类型检查的工具；
2. 约定变量命名规则：如所有 Immutable 类型对象以 $$ 开头；
3. 使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用；

##### 3.9.1.5 immutable.is & cursor

- immutable.is

  ```jsx
  // 两个 immutable 对象可以使用 === 来比较，这样是直接比较内存地址，性能最好。
  // 但即使两个对象的值是一样的，也会返回 false：
  
  let map1 = Immutable.Map({a:1, b:1, c:1});
  let map2 = Immutable.Map({a:1, b:1, c:1});
  map1 === map2;             // false
  
  // 为了直接比较对象的值，immutable.js 提供了 Immutable.is 来做『值比较』，结果如下：
  
  Immutable.is(map1, map2);  // true
  Immutable.is 
  // 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。
  // 由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。
  // 这样的算法避免了深度遍历比较，性能非常好。
  ```

- cursor

由于 Immutable 数据一般嵌套非常深，为了便于访问深层数据，Cursor 提供了可以直接访问这个深层数据的引用。

 ```jsx
 import Immutable from 'immutable';
 import Cursor from 'immutable/contrib/cursor';
 
 let data = Immutable.fromJS({ a: { b: { c: 1 } } });
 // 让 cursor 指向 { c: 1 }
 let cursor = Cursor.from(data, ['a', 'b'], newData => {
   // 当 cursor 或其子 cursor 执行 update 时调用
   console.log(newData);
 });
 
 cursor.get('c'); // 1
 cursor = cursor.update('c', x => x + 1);
 cursor.get('c'); // 2
 ```

##### 3.9.1.6. 使用immutable.js优化react

1. React可以使用 shouldComponentUpdate()进行性能优化，但它默认返回 true，即始终会执行 render() 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新；
2. 可以在shouldComponentUpdate 周期里执行deepCopy 和 deepCompare 避免无意义的render，但deepFn也很耗时；

```jsx
import { is } from 'immutable';

shouldComponentUpdate: (nextProps = {}, nextState = {}) => {
  const thisProps = this.props || {}, thisState = this.state || {};

  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||
      Object.keys(thisState).length !== Object.keys(nextState).length) {
    return true;
  }

  for (const key in nextProps) {
    if (!is(thisProps[key], nextProps[key])) {
      return true;
    }
  }

  for (const key in nextState) {
    if (thisState[key] !== nextState[key] && !is(thisState[key], nextState[key])) {
      return true;
    }
  }
  return false;
}
```

#### 3.9.2 immer

官方地址：https://immerjs.github.io/immer/zh-CN/

先来看一个问题

```jsx
let currentState = {
  p: {
    x: [2],
  },
}

// 下列哪些currentState被修改了
// Q1
let o1 = currentState;
o1.p = 1;
o1.p.x = 1;

// Q2
fn(currentState);
function fn(o) {
  o.p1 = 1;
  return o;
};

// Q3
let o3 = {
  ...currentState
};
o3.p.x = 1;

// Q4
let o4 = currentState;
o4.p.x.push(1);

// 结果：都被修改了
```

如何解决引用类型对象被修改？

1. 深度拷贝，但是深拷贝的成本较高，会影响性能；
2. [ImmutableJS](https://github.com/facebook/immutable-js)，非常棒的一个不可变数据结构的库，可以解决上面的问题，但跟 Immer 比起来，ImmutableJS 有两个较大的不足：
   a. 需要使用者学习它的数据结构操作方式，没有 Immer 提供的使用原生对象的操作方式简单、易用；
   b. 它的操作结果需要通过toJS方法才能得到原生对象，这使得在操作一个对象的时候，时刻要主要操作的是原生对象还是 ImmutableJS 的返回结果，稍不注意，就会产生问题；

```jsx
// 如何使用immer解决上述问题

// Q1 Q3
import produce from 'immer';
let o1 = produce(currentState, draft => {
  draft.p.x = 1;
})

// Q2
import produce from 'immer';
fn(currentState);
function fn(o) {
  return produce(o, draft => {
    draft.p1 = 1;
  })
};

// Q4
import produce from 'immer';
let o4 = produce(currentState, draft => {
  draft.p.x.push(1);
})
```

##### 3.9.2.2 概念说明

- currentState：被操作对象的最初状态
- draftState：根据 currentState 生成的草稿状态，它是 currentState 的代理，对 draftState 所做的任何修改都将被记录并用于生成 nextState 。在此过程中，currentState 将不受影响
- nextState：根据 draftState 生成的最终状态
- produce：用来生成 nextState 或 producer 的函数
- producer：通过 produce 生成，用来生产 nextState ，每次执行相同的操作
- recipe：用来操作 draftState 的函数

##### 3.9.2.3 produce的使用

1. produce(currentState, recipe: (draftState) => void | draftState, ?PatchListener): nextState

```jsx
// Q1
let nextState = produce(currentState, (draft) => {

})

currentState === nextState; // true

// Q2
let currentState = {
  a: [],
  p: {
    x: 1
  }
}

let nextState = produce(currentState, (draft) => {
  draft.a.push(2);
})

currentState.a === nextState.a; // false
currentState.p === nextState.p; // true
```

1. a. 对 draftState 的修改都会反应到 nextState;

2. b. Immer 使用的结构是共享的，nextState 在结构上又与 currentState 共享未修改的部分；

immer支持自动冻结：通过produce生产的nextState是被Object.freeze的

```jsx
const currentState = {
  p: {
    x: [2],
  },
};
const nextState = produce(currentState, draftState => {
    draftState.p.x.push(3);
});
console.log(nextState.p.x); // [2, 3]
nextState.p.x = 4;
console.log(nextState.p.x); // [2, 3]
nextState.p.x.push(5); // 报错
```

2. produce(recipe: (draftState) => void | draftState, ?PatchListener)(currentState): nextState

利用高阶函数的特点，提前生成一个producer

```jsx
let producer = produce((draft) => {
  draft.x = 2
});
let nextState = producer(currentState);
```

##### 3.9.2.4 使用immer优化react

```jsx
// 定义state
state = {
  members: [
    {
      name: 'ronffy',
      age: 30
    }
  ]
}

// 如何给member中第一个元素的age+1

// error
this.state.members[0].age++;

// setState
const { members } = this.state;
this.setState({
  members: [
    {
      ...members[0],
      age: members[0].age + 1,
    },
    ...members.slice(1),
  ]
})

// 使用reducer
const reducer = (state, action) => {
  switch (action.type) {
    case 'ADD_AGE':
      const { members } = state;
      return {
        ...state,
        members: [
          {
            ...members[0],
            age: members[0].age + 1,
          },
          ...members.slice(1),
        ]
      }
    default:
      return state
  }
}


// 使用immer
this.setState(produce(draft => {
  draft.members[0].age++;
}))

// 使用immer结合reduce
// 注意： produce 内的 recipe 回调函数的第2个参数与obj对象是指向同一块内存
let obj = {};

let producer = produce((draft, arg) => {
  obj === arg; // true
});
let nextState = producer(currentState, obj);

const reducer = (state, action) => produce(state, draft => {
  switch (action.type) {
    case 'ADD_AGE':
      draft.members[0].age++;
  }
})
```

# React高级用法

https://www.yuque.com/lpldplws/web/bcocaq?singleDoc# 《React高级用法》 密码：acr1

## 1. 课程目标

P6：

1. 1. 会用React写项目，较熟练使用React配套技术栈，有一定实际开发经验；
   2. 能够针对复杂的业务场景制定出较为规范的逻辑架构；

P6+~P7：

1. 1. 基于实际开发场景，搭建配套脚手架，能够基于当前实际开发场景优化架构设计，制定团队规范；
   2. 对前沿技术有足够的敏感度，保证项目的可扩展性与健壮性；
   3. 精通一个框架的底层设计，熟悉多个框架的实际设计及对比；

其他目标：

1. 1. 深入了解React技术栈相关的知识点，知道React生态中发展现状，能够对面试所提的问题举一反三；

## 2.课程大纲

1. 高阶组件的用法及封装
2. Hooks详解
3. 异步组件
4. React 18 新特性

## 3.主要内容

### 3.1. 高阶组件用法及封装

高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。

简单点说，就是组件作为参数，返回值也是组件的函数，它是纯函数，不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。

#### 3.1.1 使用HOC的原因

1. 抽取重复代码，实现组件复用：相同功能组件复用
2. 条件渲染，控制组件的渲染逻辑（渲染劫持）：权限控制。
3. 捕获/劫持被处理组件的生命周期，常见场景：组件渲染性能追踪、日志打点。

#### 3.1.2 HOC实现方式

##### 3.1.2.1 属性代理

使用组合的方式，将组件包装在容器上，依赖父子组件的生命周期关系来；

1. 返回stateless的函数组件
2. 返回class组件

- 操作props

```js
// 可以通过属性代理，拦截父组件传递过来的porps并进行处理。

// 返回一个无状态的函数组件
function HOC(WrappedComponent) {
  const newProps = { type: 'HOC' };
  return props => <WrappedComponent {...props} {...newProps}/>;
}

// 返回一个有状态的 class 组件
function HOC(WrappedComponent) {
  return class extends React.Component {
    render() {
      const newProps = { type: 'HOC' };
      return <WrappedComponent {...this.props} {...newProps}/>;
    }
  };
}
```

- 抽象state

```js
// 通过属性代理无法直接操作原组件的state，可以通过props和cb抽象state
function HOC(WrappedComponent) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        name: '',
      };
      this.onChange = this.onChange.bind(this);
    }
    
    onChange = (event) => {
      this.setState({
        name: event.target.value,
      })
    }
    
    render() {
      const newProps = {
        name: {
          value: this.state.name,
          onChange: this.onChange,
        },
      };
      return <WrappedComponent {...this.props} {...newProps} />;
    }
  };
}

// 使用
@HOC
class Example extends Component {
  render() {
    return <input name="name" {...this.props.name} />;
  }
}
```

- 通过props实现条件渲染

```js
// 通过props来控制是否渲染及传入数据
import * as React from 'react';

function HOC (WrappedComponent) {
  return (props) => (
  <div>
    {
      props.isShow ? (
        <WrappedComponent
          {...props}
        />
      ) : <div>暂无数据</div>
    }
  </div>
  );
}

export default HOC;
```

- 其他元素wrapper传入的组件

```js
function withBackgroundColor(WrappedComponent) {
  return class extends React.Component {
    render() {
      return (
        <div style={{ backgroundColor: '#ccc' }}>
            <WrappedComponent {...this.props} {...newProps} />
        </div>
      );
    }
  };
}
```

##### 3.1.2.2 反向继承

使用一个函数接受一个组件作为参数传入，并返回一个继承了该传入组件的类组件，且在返回组件的 render() 方法中返回 super.render() 方法

```js
const HOC = (WrappedComponent) => {
  return class extends WrappedComponent {
    render() {
      return super.render();
    }
  }
}
```

1. 允许HOC通过this访问到原组件，可以直接读取和操作原组件的state/ref等；
2. 可以通过super.render()获取传入组件的render，可以有选择的渲染劫持；
3. 劫持原组件生命周期方法

```js
function HOC(WrappedComponent){
  const didMount = WrappedComponent.prototype.componentDidMount;
  
  // 继承了传入组件
  return class HOC extends WrappedComponent {
    async componentDidMount(){
      // 劫持 WrappedComponent 组件的生命周期
      if (didMount) {
        await didMount.apply(this);
      }
      ...
    }

    render(){
      //使用 super 调用传入组件的 render 方法
      return super.render();
    }
  }
}
```

- 读取/操作原组件的state

```js
function HOC(WrappedComponent){
  const didMount = WrappedComponent.prototype.componentDidMount;
  // 继承了传入组件
  return class HOC extends WrappedComponent {
    async componentDidMount(){
      if (didMount) {
        await didMount.apply(this);
      }
      // 将 state 中的 number 值修改成 2
      this.setState({ number: 2 });
    }

    render(){
      //使用 super 调用传入组件的 render 方法
      return super.render();
    }
  }
}
```

- 条件渲染

```js
const HOC = (WrappedComponent) =>
  class extends WrappedComponent {
    render() {
      if (this.props.isRender) {
        return super.render();
      } else {
        return <div>暂无数据</div>;
      }
    }
  }
```

- 修改react树

```js
// 修改返回render结果
function HigherOrderComponent(WrappedComponent) {
  return class extends WrappedComponent {
    render() {
      const tree = super.render();
      const newProps = {};
      if (tree && tree.type === 'input') {
        newProps.value = 'something here';
      }
      const props = {
        ...tree.props,
        ...newProps,
      };
      const newTree = React.cloneElement(tree, props, tree.props.children);
      return newTree;
    }
  };
}
```

#### 3.1.3 属性代理和反向继承对比

1. 属性代理：从“组合”角度出发，有利于从外部操作wrappedComp，可以操作props，或者在wrappedComp 外加一些拦截器（如条件渲染等）；
2. 反向继承：从“继承”角度出发，从内部操作wrappedComp，可以操作组件内部的state，生命周期和render等，功能能加强大；

#### 3.1.4 举个例子

- 页面复用（属性代理）

```jsx
// views/PageA.js
import React from 'react';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';

class PageA extends React.Component {
  state = {
    movieList: [],
  }
  /* ... */
  async componentDidMount() {
    const movieList = await fetchMovieListByType('comedy');
    this.setState({
      movieList,
    });
  }
  
  render() {
    return <MovieList data={this.state.movieList} emptyTips="暂无喜剧"/>
  }
}
export default PageA;


// views/PageB.js
import React from 'react';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';

class PageB extends React.Component {
  state = {
    movieList: [],
  }
  // ...
  async componentDidMount() {
    const movieList = await fetchMovieListByType('action');
    this.setState({
      movieList,
    });
  }
  render() {
    return <MovieList data={this.state.movieList} emptyTips="暂无动作片"/>
  }
}
export default PageB;


// 冗余代码过多
// HOC
import React from 'react';

const withFetchingHOC = (WrappedComponent, fetchingMethod, defaultProps) => {
  return class extends React.Component {
    async componentDidMount() {
      const data = await fetchingMethod();
      this.setState({
        data,
      });
    }
    
    render() {
      return (
        <WrappedComponent 
          data={this.state.data} 
          {...defaultProps} 
          {...this.props} 
        />
      );
    }
  }
}

// 使用：
// views/PageA.js
import React from 'react';
import withFetchingHOC from '../hoc/withFetchingHOC';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';

const defaultProps = {emptyTips: '暂无喜剧'}

export default withFetchingHOC(MovieList, fetchMovieListByType('comedy'), defaultProps);

// views/PageB.js
import React from 'react';
import withFetchingHOC from '../hoc/withFetchingHOC';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';

const defaultProps = {emptyTips: '暂无动作片'}

export default withFetchingHOC(MovieList, fetchMovieListByType('action'), defaultProps);;

// views/PageOthers.js
import React from 'react';
import withFetchingHOC from '../hoc/withFetchingHOC';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';
const defaultProps = {...}
export default withFetchingHOC(MovieList, fetchMovieListByType('some-other-type'), defaultProps);
```

更符合 里氏代换原则(Liskov Substitution Principle LSP)，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为

- 权限控制（属性代理）

```jsx
import React from 'react';
import { whiteListAuth } from '../lib/utils'; // 鉴权方法

function AuthWrapper(WrappedComponent) {
  return class AuthWrappedComponent extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        permissionDenied: -1,
      };
    }
    
    async componentDidMount() {
      try {
        await whiteListAuth(); // 请求鉴权接口
        this.setState({
          permissionDenied: 0,
        });
      } catch (err) {
        this.setState({
          permissionDenied: 1,
        });
      }
    }
    
    render() {
      if (this.state.permissionDenied === -1) {
        return null; // 鉴权接口请求未完成
      }
      if (this.state.permissionDenied) {
        return <div>功能即将上线，敬请期待~</div>;
      }
      return <WrappedComponent {...this.props} />;
    }
  }
}

export default AuthWrapper;
```

- 组件渲染性能(反向继承)

如何计算一个组件render期间的渲染耗时？

```jsx
import React from 'react';
// Home 组件
class Home extends React.Component {
  render () {
    return (<h1>Hello World.</h1>);
  }
}

// HOC
function withTiming (WrappedComponent) {
  let start, end;

  return class extends WrappedComponent {
    constructor (props) {
      super(props);
      start = 0;
      end = 0;
    }
    componentWillMount () {
      if (super.componentWillMount) {
        super.componentWillMount();
      }
      start = +Date.now();
    }
    componentDidMount () {
      if (super.componentDidMount) {
        super.componentDidMount();
      }
      end = +Date.now();
      console.error(`${WrappedComponent.name} 组件渲染时间为 ${end - start} ms`);
    }
    render () {
      return super.render();
    }
  };
}

export default withTiming(Home);
```

#### 3.1.5 HOC缺点

- 黑盒问题，增加理解成本
- 属性冲突
- HOC 可以劫持 props，存在相同名称的 props，则存在覆盖问题在不遵守约定的情况下也可能造成冲突，而且 react 并不会报错。

```jsx
function Login (props){
    return <div>{props.user}</div>
}

function HOCAddUserName(WrappedComponent){
    return class extends Component{
        render(){
            return <WrappedComponent user='写死的user名称'/>
        }
    }
}

function HOCAddAnotherUserName(WrappedComponent){
       return class extends Component{
        render(){
            return <WrappedComponent user='写死另一个的user名称'/>
        }
    }
}

const TwoHoc=HOCAddAnotherUserName(HOCAddUserName(Login)) //生效的是HOCAddUserName
```

#### Function 里面用error boundary

```jsx
function Catch (Wrapcomponent,errorHandler){
    return class extends Component {
         state={
             error:undefined
         }
    }
    static getDerivedStateFromError(error){
        return {error}
    }
    
    componentDidCatch(error){
        errorHandler&&errorHandler(error)
    }
    render(){
        return WrapComponent(this.props,this.state.error)
    }
}
```

### 3.2 hooks详解

Hooks是react16.8以后新增的钩子API；

目的：增加代码的可复用性，逻辑性，弥补无状态组件没有生命周期，没有数据管理状态state的缺陷。

为什么要使用Hooks？

1. 开发友好，可扩展性强，抽离公共的方法或组件，Hook 使你在无需修改组件结构的情况下复用状态逻辑；
2. 函数式编程，将组件中相互关联的部分根据业务逻辑拆分成更小的函数；
3. class更多作为语法糖，没有稳定的提案，且在开发过程中会出现不必要的优化点，Hooks无需学习复杂的函数式或响应式编程技术；

官网react hooks介绍：https://zh-hans.reactjs.org/docs/hooks-intro.html

#### 3.2.1 常见Hooks

##### 3.2.1.1 useState

```js
const [number, setNumber] = useState(0);
```

1. setState支持stateless组件有自己的state；
2. 入参：具体值或一个函数；
3. 返回值：数组，第一项是state值，第二项负责派发数据更新，组件渲染；

注意：setState会让组件重新执行，所以一般需要配合useMemo或useCallback；

```js
const DemoState = (props) => {
   /* number为此时state读取值 ，setNumber为派发更新的函数 */
   const [number, setNumber] = useState(0) /* 0为初始值 */
   return (
     <div>
       <span>{ number }</span>
       <button onClick={ ()=> {
         setNumber(number + 1)
         console.log(number) /* 这里的number是不能够即使改变的，返回0  */
         }}
        />
     </div>
    )
}
// 当更新函数之后，state的值是不能即时改变的，只有当下一次上下文执行的时候，state值才随之改变

——————————————————————————————————————————

const a =1 
const DemoState = (props) => {
   /*  useState 第一个参数如果是函数 则处理复杂的逻辑，返回值为初始值 */
   let [number, setNumber] = useState(()=>{
      // number
      return a === 1 ? 1 : 2
   }) /* 1为初始值 */
   return (<div>
       <span>{ number }</span>
       <button onClick={ ()=>setNumber(number+1) } ></button>
   </div>)
}
```

##### 3.1.1.2 useEffect

1. 使用条件：当组件init、dom render完成、操纵dom、请求数据（如componentDidMount）等；
2. 不限制条件，组件每次更新都会触发useEffect --> componentDidUpdate 与 componentwillreceiveprops；
3. useEffect 第一个参数为处理事件，第二个参数接收数组，为限定条件，当数组变化时触发事件，为[]只在组件初始化时触发；
4. useEffect第一个参数有返回时，一般用来消除副作用（如去除定时器、事件绑定等）；

```js
* 模拟数据交互 */
function getUserInfo(a)
  return new Promise((resolve)=>{
    setTimeout(()=>{ 
       resolve({
           name:a,
           age:16,
       }) 
    },500)
  })
}

const Demo = ({ a }) => {
  const [ userMessage , setUserMessage ] = useState({})
  const [number, setNumber] = useState(0)
  
  const div= useRef()
  
  const handleResize =()=>{}

  useEffect(()=>{
     getUserInfo(a).then(res=>{
         setUserMessage(res)
     })
     console.log(div.current) /* div */
      window.addEventListener('resize', handleResize)
  /* 
     只有当props->a和state->number改变的时候 ,useEffect副作用函数重新执行 ，
     如果此时数组为空[]，证明函数只有在初始化的时候执行一次相当于componentDidMount
  */
  },[ a ,number ])

  return (<div ref={div} >
      <span>{ userMessage.name }</span>
      <span>{ userMessage.age }</span>
      <div onClick={ ()=> setNumber(1) } >{ number }</div>
  </div>)
}


————————————————————————————————————————————————
const Demo = ({ a }) => {
    const handleResize =()=>{}
    useEffect(()=>{
       const timer = setInterval(()=>console.log(666),1000)
       window.addEventListener('resize', handleResize)
      
       /* 此函数用于清除副作用 */
       return function(){
           clearInterval(timer) 
           window.removeEventListener('resize', handleResize)
       }
    },[ a ])
    return (<div></div>)
}
```

注意：useEffect无法直接使用async await，

```js
// Bad
useEffect(async ()=>{
  /* 请求数据 */
  const res = await getUserInfo(payload)
},[ a ,number ])
————————————————————————————————————————————————

useEffect(() => {
  // declare the async data fetching function
  const fetchData = async () => {
    const data = await fetch('https://xxx.com');
    const json = await data.json();
    return json;
  }

  // call the function
  const result = fetchData()
    .catch(console.error);

  // ❌ 无效
  setData(result);
}, [])

// 改进版
useEffect(() => {
  const fetchData = async () => {
    const data = await fetch('https://xxx.com');
    const json = await response.json();

    setData(json);
  }

  // call the function
  fetchData()
    // make sure to catch any error
    .catch(console.error);;
}, [])
```

##### 3.2.1.3. useLayoutEffect

 

渲染更新之前的 useEffect

useEffect： 组件更新挂载完成 -> 浏览器dom 绘制完成 -> 执行useEffect回调 ；

useLayoutEffect ： 组件更新挂载完成 -> 执行useLayoutEffect回调-> 浏览器dom 绘制完成；

渲染组件

1. useEffect：闪动；

2. useLayoutEffect：卡顿；

```js
const DemoUseLayoutEffect = () => {
  const target = useRef()
  useLayoutEffect(() => {
      /*我们需要在dom绘制之前，移动dom到制定位置*/
      const { x ,y } = getPositon() /* 获取要移动的 x,y坐标 */
      animate(target.current,{ x,y })
  }, []);
  return (
    <div >
      <span ref={ target } className="animate"></span>
    </div>
  )
}
```

##### 3.2.1.4 useRef

用来获取元素、缓存数据；

入参可以作为初始值

```js
// 获取元素
const DemoUseRef = ()=>{
  const dom= useRef(null)
  const handerSubmit = ()=>{
    /*  <div >表单组件</div>  dom 节点 */
    console.log(dom.current)
  }
  return <div>
    <div ref={dom} >表单组件</div>
    <button onClick={()=>handerSubmit()} >提交</button> 
  </div>
}

// 缓存数据，小技巧
// 不同于useState，useRef改变值不会使comp re-render
const currenRef = useRef(InitialData)
currenRef.current = newValue
```

##### 3.2.1.5 useConext

用来获取父级组件传递过来的context值，这个当前值就是最近的父级组件 Provider 的value；

从parent comp获取ctx方式；

1. useContext(Context)；
2. Context.Consumer；

```js
/* 用useContext方式 */
const DemoContext = ()=> {
  const value = useContext(Context);
  /* my name is aaa */
  return <div> my name is { value.name }</div>
}

/* 用Context.Consumer 方式 */
const DemoContext1 = ()=>{
  return <Context.Consumer>
    {/*  my name is aaa  */}
    { (value)=> <div> my name is { value.name }</div> }
  </Context.Consumer>
}

export default ()=>{
  return <div>
    <Context.Provider value={{ name:'aaa' }} >
      <DemoContext />
      <DemoContext1 />
    </Context.Provider>
  </div>
}
```

##### 3.2.1.6. useReducer

入参：

1. 第一个为函数，可以视为reducer，包括state 和 action，返回值为根据action的不同而改变后的state；
2. 第二个为state的初始值；

出参：

1. 第一个更新后的state值；
2. 第二个是派发更新的dispatch函数；执行dispatch会导致组件re-render；（另一个是useState）

```js
const DemoUseReducer = ()=>{
  /* number为更新后的state值,  dispatchNumbner 为当前的派发函数 */
  const [ number , dispatchNumbner ] = useReducer((state, action) => {
    const { payload , name  } = action
    /* return的值为新的state */
    switch(name) {
     case 'a':
         return state + 1
     case 'b':
         return state - 1 
     case 'c':
       return payload       
    }
    return state
   }, 0)
   return <div>
      当前值：{ number }
      { /* 派发更新 */ }
      <button onClick={()=>dispatchNumbner({ name: 'a' })} >增加</button>
      <button onClick={()=>dispatchNumbner({ name: 'b' })} >减少</button>
      <button onClick={()=>dispatchNumbner({ name: 'c' , payload:666 })} >赋值</button>
      { /* 把dispatch 和 state 传递给子组件  */ }
      <MyChildren  dispatch={ dispatchNumbner } State={{ number }} />
   </div>
}
```

业务中经常将 useReducer+useContext 代替Redux

##### 3.2.1.7 useMemo

用来根据useMemo的第二个参数deps（数组）判定是否满足当前的限定条件来决定是否执行第一个cb；

```js
// selectList 不更新时，不会重新渲染，减少不必要的循环渲染
useMemo(() => (
  <div>{
    selectList.map((i, v) => (
      <span
        className={style.listSpan}
        key={v} >
        {i.patentName} 
      </span>
    ))}
  </div>
), [selectList])

————————————————————————————————————————————————————
// listshow, cacheSelectList 不更新时，不会重新渲染子组件
useMemo(() => (
  <Modal
    width={'70%'}
    visible={listshow}
    footer={[
      <Button key="back" >取消</Button>,
      <Button
          key="submit"
          type="primary"
       >
          确定
      </Button>
    ]}
  > 
    { /* 减少了PatentTable组件的渲染 */ }
    <PatentTable
      getList={getList}
      selectList={selectList}
      cacheSelectList={cacheSelectList}
      setCacheSelectList={setCacheSelectList}
    />
  </Modal>
 ), [listshow, cacheSelectList])
 ————————————————————————————————————————————————————
 
 // 减少组件更新导致函数重新声明
 const DemoUseMemo = () => {
  /* 用useMemo 包裹之后的log函数可以避免了每次组件更新再重新声明 ，可以限制上下文的执行 */
  const newLog = useMemo(() => {
    const log = () => {
      console.log(123)
    }
    return log
  }, [])
  return <div onClick={()=> newLog() } ></div>
}

————————————————————————————————————————————————————
// 如果没有加相关的更新条件，是获取不到更新之后的state的值的
const DemoUseMemo = () => {
  const [ number ,setNumber ] = useState(0)
  const newLog = useMemo(() => {
    const log = () => {
      /* 点击span之后 打印出来的number 不是实时更新的number值 */
      console.log(number)
    }
    return log
    /* [] 没有 number */  
  }, [])
  return <div>
    <div onClick={() => newLog()} >打印</div>
    <span onClick={ () => setNumber( number + 1 )  } >增加</span>
  </div>
}
```

##### 3.2.1.8 useCallback

useMemo返回cb的运行结果；

useCallback返回cb的函数；

```js
import React, { useState, useCallback } from 'react'

function Button(props) {
  const { handleClick, children } = props;
  console.log('Button -> render');
  return (
      <button onClick={handleClick}>{children}</button>
  )
}

const MemoizedButton = React.memo(Button);

export default function Index() {
  const [clickCount, increaseCount] = useState(0);

  const handleClick = () => {
      console.log('handleClick');
      increaseCount(clickCount + 1);
  }
  return (
      <div>
          <p>{clickCount}</p>
          <MemoizedButton handleClick={handleClick}>Click</MemoizedButton>
      </div>
  )
}

// MemoizedButton还是重新渲染了
// Index组件state发生变化，导致组件重新渲染；
// 每次渲染导致重新创建内部函数handleClick ，
// 进而导致子组件Button也重新渲染。

import React, { useState, useCallback } from 'react'

function Button(props) {
  const { handleClick, children } = props;
  console.log('Button -> render');
  return (
      <button onClick={handleClick}>{children}</button>
  )
}

const MemoizedButton = React.memo(Button);

export default function Index() {
  const [clickCount, increaseCount] = useState(0);
  // 这里使用了`useCallback`
  const handleClick = useCallback(() => {
      console.log('handleClick');
      increaseCount(clickCount + 1);
  }, [])

  return (
      <div>
          <p>{clickCount}</p>
          <MemoizedButton handleClick={handleClick}>Click</MemoizedButton>
      </div>
  )
}
```

#### 3.2.2 Hooks实战

##### 3.2.2.1 所有依赖都必须放在依赖数组中么？

useEffect 中，默认有个共识： useEffect 中使用到外部变量，都应该放到第二个数组参数中。

```js
// 当props.count 和 count 变化时，上报数据
function Demo(props) {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');
  const [a, setA] = useState('');
  
  useEffect(() => {
    monitor(props.count, count, text, a);
  }, [props.count, count]);
  
  return (
    <div>
      <button
        onClick={() => setCount(count => count + 1)}
      >
        click
      </button>
      <input value={text} onChange={e => setText(e.target.value)} />
      <input value={a} onChange={e => setA(e.target.value)} />
    </div>
  )
}
```

此时，text 和 a 变量没有放在dps 数组中

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976346957-7870c08c-7450-4e5f-80f7-dd9a46a02ed2.png)

如果把text 和 a 也引入deps中，当text 和 a改变时，也触发了函数执行

Solution：

1. 不要使用 eslint-plugin-react-hooks 插件，或者可以选择性忽略该插件的警告；
2. 只有一种情况，需要把变量放到 deps 数组中，那就是当该变量变化时，需要触发 useEffect 函数执行。而不是因为 useEffect 中用到了这个变量！

##### 3.2.2.2 尽量不要用useCallback

1. useCallback 大部分场景没有提升性能
2.  useCallback让代码可读性变差

```js
Example 1
const someFunc = useCallback(()=> {
   doSomething();
}, []);
return <ExpensiveComponent func={someFunc} />

const ExpensiveComponent = ({ func }) => {
  return (
    <div onClick={func}>
     hello
    </div>
  )
}

// 必须用React.memo wrapper 住子组件，才能避免在参数不变的情况下，不重复渲染
// 所以一般项目中不建议使用useCallback
const ExpensiveComponent = React.memo(({ func }) => {
  return (
    <div onClick={func}>
     hello
    </div>
  )
}

// Example 2
const someFuncA = useCallback((d, g, x, y)=> {
   doSomething(a, b, c, d, g, x, y);
}, [a, b, c]);

const someFuncB = useCallback(()=> {
   someFuncA(d, g, x, y);
}, [someFuncA, d, g, x, y]);

useEffect(()=>{
  someFuncB();
}, [someFuncB]);

// 依赖层层传递，最终要找到哪些出发了useEffect执行，所以直接引用就好
const someFuncA = (d, g, x, y)=> {
   doSomething(a, b, c, d, g, x, y);
};

const someFuncB = ()=> {
   someFuncA(d, g, x, y);
};

useEffect(()=>{
  someFuncB();
}, [...]);
```

##### 3.2.2.3. useMemo建议适当使用

在deps不变，且非简单的基础类型运算的情况下建议使用

```js
// 没有使用 useMemo
const memoizedValue = computeExpensiveValue(a, b);
// 使用 useMemo
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

// 如果没有使用 useMemo，computeExpensiveValue 会在每一次渲染的时候执行;
// 如果使用了 useMemo，只有在 a 和 b 变化时，才会执行一次 computeExpensiveValue。

const a = 1;
const b = 2;
const c = useMemo(()=> a + b, [a, b]);
const c = a + b; // 内存消耗少
```

##### 3.2.2.4 updateState的正确使用姿势

1. 能用其他状态计算出来就不用单独声明状态。一个 state 必须不能通过其它 state/props 直接计算出来，否则就不用定义 state

2. 保证数据源唯一，在项目中同一个数据，保证只存储在一个地方

3. useState 适当合并

```js
// Example 1
const SomeComponent = (props) => {
  const [source, setSource] = useState([
      {type: 'done', value: 1},
      {type: 'doing', value: 2},
  ])
  const [doneSource, setDoneSource] = useState([])
  const [doingSource, setDoingSource] = useState([])
  useEffect(() => {
    setDoingSource(source.filter(item => item.type === 'doing'))
    setDoneSource(source.filter(item => item.type === 'done'))
  }, [source])
  return (
    <div>
       .....
    </div>
  )
}

const SomeComponent = (props) => {
  const [source, setSource] = useState([
      {type: 'done', value: 1},
      {type: 'doing', value: 2},
    ])
  const doneSource = useMemo(()=> source.filter(item => item.type === 'done'), [source]);
  const doingSource = useMemo(()=> source.filter(item => item.type === 'doing'), [source]);
  return (
    <div>
       .....
    </div>
  )
}

// 避免props层层传递，在CR中很难看清楚

// Example 2
function SearchBox({ data }) {
  const [searchKey, setSearchKey] = useState(getQuery('key'));
  
  const handleSearchChange = e => {
    const key = e.target.value;
    setSearchKey(key);
    history.push(`/movie-list?key=${key}`);
  }
  
  return (
    <input
      value={searchKey}
      placeholder="Search..."
      onChange={handleSearchChange}
    />
  );
}

function SearchBox({ data }) {
  const searchKey = parse(localtion.search)?.key;
  
  const handleSearchChange = e => {
    const key = e.target.value;
    history.push(`/movie-list?key=${key}`);
  }
  
  return (
    <input
      value={searchKey}
      placeholder="Search..."
      onChange={handleSearchChange}
    />
  );
}

// url params 和 state重复了

// Example 3
const [firstName, setFirstName] = useState();
const [lastName, setLastName] = useState();
const [school, setSchool] = useState();
const [age, setAge] = useState();
const [address, setAddress] = useState();
const [weather, setWeather] = useState();
const [room, setRoom] = useState();

const [userInfo, setUserInfo] = useState({
  firstName,
  lastName,
  school,
  age,
  address
});
const [weather, setWeather] = useState();
const [room, setRoom] = useState();

// 更新一个时
setUserInfo(s=> ({
  ...s,
  fristName,
}))
```

#### 3.2.3. 自定义Hooks

注意：自定义Hooks本质上还是实现一个函数，关键在于实现逻辑
一般实现效果如：

```js
const [ a[, b, c...] ] = useXXX(arg1[, arg2, ...])
```

##### 3.2.3.1 setTitle hook

```js
import { useEffect } from 'react'

const useTitle = (title) => {
  useEffect(() => {
    document.title = title
  }, [])

  return
}

export default useTitle

const App = () => {
  useTitle('new title')
  return <div>home</div>
}
```

##### 3.2.3.2 update hook

```js
import { useState } from 'react'

const useUpdate = () => {
  const [, setFlag] = useState()
  const update = () => {
    setFlag(Date.now())
  }
  return update
}

export default useUpdate

// 实际使用
const App = (props) => {
  // ...
  const update = useUpdate()
  return <div>
    {Date.now()}
    <div><button onClick={update}>update</button></div>
  </div>
}
```

##### 3.2.3.3 useScroll hooks

```js
import { useState, useEffect } from 'react'

const useScroll = (scrollRef) => {
  const [pos, setPos] = useState([0,0])

  useEffect(() => {
    function handleScroll(e){
      setPos([scrollRef.current.scrollLeft, scrollRef.current.scrollTop])
    }
    scrollRef.current.addEventListener('scroll', handleScroll)
    return () => {
      scrollRef.current.removeEventListener('scroll', handleScroll)
    }
  }, [])
  
  return pos
}

export default useScroll

// 用法
import React, { useRef } from 'react'
import { useScroll } from 'hooks'

const Home = (props) => {
  const scrollRef = useRef(null)
  const [x, y] = useScroll(scrollRef)

  return <div>
      <div ref={scrollRef}>
        <div className="innerBox"></div>
      </div>
      <div>{ x }, { y }</div>
    </div>
}
```

#### 3.2.4 Hooks vs HOC

1. Hook最典型的就是取代掉生命周期中大多数的功能，可以把更相关的逻辑放在一起，而非零散在各个生命周期方法中；
2.  高阶组件可以将外部的属性功能到一个基础 Component 中，更多作为扩展能力的插件（如 react-swipeable-views中的 autoPlay 高阶组件，通过注入状态化的 props 的方式对组件进行功能扩展，而不是直接将代码写在主库中）；
3. Hook 的写法可以让代码更加紧凑，更适合做 Controller 或者需要内聚的相关逻辑，一般与目标组件内强依赖，HOC更强调对原先组件能力的扩展；
4. 目前 Hook 还处于相对早期阶段（React 16.8.0 才正式发布Hook 稳定版本），一些第三方的库可能还暂时无法兼容 Hook；

### 3.3 异步组件

随着项目的增长，代码包也会随之增长，尤其是在引入第三方的库的情况下，要避免因体积过大导致加载时间过长。

React16.6中，引入了 React.lazy 和 React.Suspense 两个API，再配合动态 import() 语法就可以实现组件代码打包分割和异步加载。

传统模式：渲染组件-> 请求数据 -> 再渲染组件

异步模式：请求数据-> 渲染组件；

```js
// demo
import React, { lazy, Suspense } from 'react';
// lazy 和 Suspense 配套使用，react原生支持代码分割
const About = lazy(() => import(/* webpackChunkName: "about" */'./About'));
class App extends React.Component {
  render() {
    return (
      <div className="App">
        <h1>App</h1>
        <Suspense fallback={<div>loading</div>}>
          <About />
        </Suspense>
      </div>
    );
  }
}
export default App;
```

#### 3.3.1 前置基础

1. 动态import

相对于静态import的 `import XX from XXX`，动态import指在运行时加载

```js
import('./test.js').then(test => {
    // ...
});
// 可见，是实现了Promsie规范的，回调函数为返回的模块
```

1. 错误边界

React V 16中引入，部分UI的JS错误不会导致整个应用崩溃；

错误边界是一种 React 组件，错误边界在 渲染期间、生命周期方法和整个组件树的构造函数 中捕获错误，且会渲染出备用UI而不是崩溃的组件。

```jsx
// comp ErrorBoundary 
import React from 'react'

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染能够显示降级后的 UI
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    // 你同样可以将错误日志上报给服务器
    console.log(error, errorInfo)
  }
  render() {
    if (this.state.hasError) {
        // 你可以自定义降级后的 UI 并渲染
        return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
export default ErrorBoundary

// comp App
import React, from 'react';
import ErrorBoundary from './ErrorBoundary'
class App extends React.Component {
  state = {
      count: 1
  }
  render() {
    const { count } = this.state
    if (count === 3) {
        throw new Error('I crashed!');
    }
    return (
      <ErrorBoundary>
        <h1>App</h1>
        <p>{count}</p>
        <button onClick={() => this.setState({ count: count + 1 })}>add</button>
      </ErrorBoundary>
    )
  }
}
export default App;
```

#### 3.3.2 手写异步组件

Suspense组件需要等待异步组件加载完成再渲染异步组件的内容。

1. lazy wrapper住异步组件，React第一次加载组件的时候，异步组件会发起请求，并且抛出异常，终止渲染；
2. Suspense里有componentDidCatch生命周期函数，异步组件抛出异常会触发这个函数，然后改变状态使其渲染fallback参数传入的组件；
3. 异步组件的请求成功返回之后，Suspense组件再次改变状态使其渲染正常子组件（即异步组件）；

```jsx
// comp About
const About = lazy(() => new Promise(resolve => {
  setTimeout(() => {
    resolve({
      default: <div>component content</div>
    })
  }, 1000)
}))

// comp Suspense
import React from 'react'
class Suspense extends React.PureComponent {
  /**
   * isRender 异步组件是否就绪，可以渲染
   */
  state = {
    isRender: true
  }
  componentDidCatch(e) {
    this.setState({ isRender: false })
    e.promise.then(() => {
      /* 数据请求后，渲染真实组件 */
      this.setState({ isRender: true })
    })
  }
  render() {
    const { fallback, children } = this.props
    const { isRender } = this.state
    return isRender ? children : fallback
  }
}

export default Suspense

// comp lazy
import React, { useEffect } from 'react'
export function lazy(fn) {
  const fetcher = {
    status: 'pending',
    result: null,
    promise: null,
  }
  return function MyComponent() {
    const getDataPromise = fn()
    fetcher.promise = getDataPromise
    getDataPromise.then(res => {
      fetcher.status = 'resolved'
      fetcher.result = res.default
    })
    useEffect(() => {
      if (fetcher.status === 'pending') {
          throw fetcher
      }
    }, [])
    if (fetcher.status === 'resolved') {
      return fetcher.result
    }
    return null
  }
}

// 实现的效果与React支持内容保持一致
import React, {Suspese, lazy} from 'react'

const About= lazy(() => { import('../About') });

class App extends React.Component {
  render() {
    /**
     * 1. 使用 React.Lazy 和 import() 来引入组件
     * 2. 使用<React.Suspense></React.Suspense>来做异步组件的父组件，并使用 fallback 来实现组件未加载完成时展示信息
     * 3. fallback 可以传入html，也可以自行封装一个统一的提示组件
     */
    return (
      <div>
        <Suspense
          fallback={
            <Loading />
          }
        >
          <About />
        </Suspense>
      </div>
    )
  }
}
export default ReactComp;
```

### 3.4 React18新特性

2021.11.15 React 18 升级到了beat版本，当前 17.0.2

发布节奏：

- 库的 Alpha 版本：当天可用
- 公开的 Beta 版：至少几个月
- RC 版本：至少在 Beta 版发布后的几周
- 正式版：至少在 RC 版本发布之后的几周

主要改动包括：

1. Automatic batching（自动批量更新）
2. startTransition
3. 支持 React.lazy 的SSR架构
4. Concurrent Mode （并发渲染、可选）

#### 3.4.1 Automatic batching

将多个状态更新合并成一个重新渲染以取得更好的性能的一种优化方式；

1. V18前

默认不batching的scene:

1. promise；
2. setTimeout；
3. 原生事件处理（native event handlers）；

```jsx
function App() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  function handleClick() {
    setCount(c => c + 1); // Does not re-render yet
    setFlag(f => !f); // Does not re-render yet
    // React will only re-render once at the end (that's batching!)
  }

  return (
    <div>
      <button onClick={handleClick}>Next</button>
      <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
    </div>
  );
}

————————————————————————————————————————————————

function App() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  function handleClick() {
    fetchSomething().then(() => {
      // React 17 and earlier does NOT batch these because
      // they run *after* the event in a callback, not *during* it
      setCount(c => c + 1); // Causes a re-render
      setFlag(f => !f); // Causes a re-render
    });
  }

  return (
    <div>
      <button onClick={handleClick}>Next</button>
      <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
    </div>
  );
}
```

2. v18

​	所有更新自动batching

```jsx
function App() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  function handleClick() {
    fetchSomething().then(() => {
      // React 18 and later DOES batch these:
      setCount(c => c + 1);
      setFlag(f => !f);
      // React will only re-render once at the end (that's batching!)
    });
  }

  return (
    <div>
      <button onClick={handleClick}>Next</button>
      <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
    </div>
  );
}
```

若不想batching?

```jsx
import { flushSync } from 'react-dom'; // Note: react-dom, not react

function handleClick() {
  flushSync(() => {
    setCounter(c => c + 1);
  });
  // React has updated the DOM by now
  flushSync(() => {
    setFlag(f => !f);
  });
  // React has updated the DOM by now
}
```

batching 对hooks及class的影响

```jsx
handleClick = () => {
  setTimeout(() => {
    this.setState(({ count }) => ({ count: count + 1 }));
 		// V18前 { count: 1, flag: false }
    // V18中 { count: 0, flag: false }，除非使用flushSync
    console.log(this.state);

    this.setState(({ flag }) => ({ flag: !flag }));
  });
};


// 在一些react库中，如react-dom， unstable_batchedUpdates 实现类似功能
import { unstable_batchedUpdates } from 'react-dom';

unstable_batchedUpdates(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
});
```

#### 3.4.2 startTransition

可以让我们的页面在多数据更新里保持响应。这个API通过标记某些更新为"transitions"，来提高用户交互；

实际：可以让我们的页面在展示时时刻保持re-render；

Example：我们更新input的value的同时用这个value去更新了一个有30000个item的list。然而这种多数据更新让页面无法及时响应，也让用户输入或者其他用户交互感觉很慢。

Solution：

```jsx
// 紧急的更新：展示用户的输入 
setInputValue(e.target.value); 
 
// 非紧急的更新： 展示结果 
setContent(e.target.value); 
```

V18前：update的优先级一样；

V18：支持优先级手动设置；

```jsx
import { startTransition } from 'react';

// Urgent: Show what was typed
setInputValue(input);

// Mark any state updates inside as transitions
startTransition(() => {
  // Transition: Show the results
  setSearchQuery(input);
});

// 等同于
先setInputValue(e.target.value) 后执行 setContent(e.target.value); 
```

react中的upate：

- Urgent updates：reflect direct interaction, like typing, clicking, pressing, and so on；
- Transition updates：transition the UI from one view to another；

* 误区

1. 与setTimeout的区别
   	直接看起来结果类似：

```jsx
// debounce 和 throttle 经常使用
// Show what you typed
setInputValue(input);

// Show the results
setTimeout(() => {
  setSearchQuery(input);
}, 0);
```

区别：

1. 1. startTransition不会被放到下一次event loop，是同步立即执行的，这也就意味着，比timeout update更早，低端机体验明显;

使用场景

1. slow rendering：re-render需要耗费大量的工作量；
2. slow network：需要较长时间等待response的情况；

#### 3.4.3 支持React.lazy的ssr架构

SSR场景

react的SSR（server side render）

1. server：获取数据；
2. server：组装返回带有HTML的接口；
3. client：加载 JavaScript；
4. client：hydration，将客户端的JS与服务端的HTML结合；

- V18前：按序执行；
- V18：支持拆解应用为独立单元，不影响其他模块；

正常加载界面

<img src="https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976346932-bc6e620f-1333-44e4-a3e5-1e1dbd3830fa.png" alt="img" style="zoom:50%;" />

不使用SSR界面，带个loading

<img src="https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976346915-60354f9a-d390-4219-b185-7c28550cd369.png" alt="img" style="zoom:50%;" />

使用SSR

<img src="https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976346944-179c0ca0-f780-4963-ae3c-fe444e727f28.png" alt="img" style="zoom:50%;" />

hydration后

<img src="https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976346935-3eb17305-da08-4c21-b91a-c3c123ec3c8e.png" alt="img" style="zoom:50%;" />

SSR问题

1. server：获取数据； --> 按序执行，必须在服务端返回所有HTML；
2. client：加载 JavaScript； --> 必须JS加载完成；
3. client：hydration，将客户端的JS与服务端的HTML结合； --> hydrate后才能交互；

流式 HTML&选择性hydrate

1. 流式HTML
2. client进行选择性的 hydration：<Suspense>

```jsx
<Layout>
  <NavBar />
  <Sidebar />
  <RightPane>
    <Post />
    <Suspense fallback={<Spinner />}> // 假设HTML加载很慢，分批
      <Comments />
    </Suspense>
  </RightPane>
</Layout>
————————————————————————————————————————————————
// HTML返回过来在加载
<div hidden id="comments">
  <!-- Comments -->
  <p>First comment</p>
  <p>Second comment</p>
</div>
<script>
  // This implementation is slightly simplified
  document.getElementById('sections-spinner').replaceChildren(
    document.getElementById('comments')
  );
</script>
```

<img src="https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976347792-c772a553-0e84-4723-a094-1c06be64839d.png" alt="img" style="zoom:50%;" /><img src="https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976349091-d6ef0cfb-717b-4c39-9bbe-83351f51daf9.png" alt="img" style="zoom:50%;" />

1. JS选择性加载

```jsx
import { lazy } from 'react';

const Comments = lazy(() => import('./Comments.js'));

// ...

<Suspense fallback={<Spinner />}>
  <Comments />
</Suspense>
```

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976350368-04b7fc43-104d-401b-a2da-904deba5283f.png)<img src="https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976351265-705ce1db-1c4c-4ad8-9c89-a152f7c28002.png" alt="img" style="zoom:50%;" />

2. hydration 之前要求交互

<img src="https://cdn.nlark.com/yuque/0/2022/png/2340337/1644976351427-4cbf4d55-4720-4566-853a-6a2041d23e84.png" alt="img" style="zoom:50%;" />

记录操作行为，并优先执行Urgent comp的hydration；

#### 3.4.4. Concurrent Mode（并发模式）

 

Concurrent Mode（以下简称CM）

什么是 CM 和 suspense？

在2019年 react conf提出了实验性的版本来支持CM 和 Suspense（可以理解为等待代码加载，且指定加载界面）

- CM：

​	可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。

​	阻塞渲染：如UI update，需要先执行对应视图操作，如更新DOM；

solution：

adebounce：输入完成后响应，输入时不会更新；

bthrottle：功率低场景卡顿；

可中断渲染（CM）：

aCPU-bound update： (例如创建新的 DOM 节点和运行组件中的代码)：中断当前渲染，切换更高优先级；

bIO-bound update： (例如从网络加载代码或数据)：response前先在内存进行渲染；

-  suspense

​	以声明的方式来“等待”任何内容，包括数据

```jsx
const resource = fetchProfileData();

function ProfilePage() {
  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails />
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline />
      </Suspense>
    </Suspense>
  );
}

function ProfileDetails() {
  // 尝试读取用户信息，尽管该数据可能尚未加载
  const user = resource.user.read();
  return <h1>{user.name}</h1>;
}

function ProfileTimeline() {
  // 尝试读取博文信息，尽管该部分数据可能尚未加载
  const posts = resource.posts.read();
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.text}</li>
      ))}
    </ul>
  );
}
```

*误区：Suspense 不是一个数据请求的库，而是一个机制。这个机制是用来给数据请求库向 React 通信说明某个组件正在读取的数据当前仍不可用

- 什么不是suspense

1. 1. 不是数据获取方式；
   2. 不是一个可以直接用于数据获取的客户端；
   3. 它不使数据获取与视图层代码耦合；

- Suspense 可以做什么

1. 1. 能让数据获取库与 React 紧密整合；
   2. 能让你有针对性地安排加载状态的展示；
   3. 能够消除 race conditions

DEMO：

目前fetch data方式：

● Fetch-on-render（渲染之后获取数据，如：在 useEffect 中 fetch）

```jsx
// 在函数组件中：
useEffect(() => {
  fetchSomething();
}, []);

// 或者，在 class 组件里：
componentDidMount() {
  fetchSomething();
}
————————————————————————————————————————————————

function ProfilePage() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser().then(u => setUser(u));
  }, []);

  if (user === null) {
    return <p>Loading profile...</p>;
  }
  return (
    <>
      <h1>{user.name}</h1>
      <ProfileTimeline />
    </>
  );
}

function ProfileTimeline() {
  const [posts, setPosts] = useState(null);

  useEffect(() => {
    fetchPosts().then(p => setPosts(p));
  }, []);

  if (posts === null) {
    return <h2>Loading posts...</h2>;
  }
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.text}</li>
      ))}
    </ul>
  );
}

// 结果：只有在fetch user 后才会fetch post，请求被串行发出
```

- Fetch-then-render（接收到全部数据之后渲染，如：不使用 Suspense 的 Relay）

```jsx
function fetchProfileData() {
  return Promise.all([
    fetchUser(),
    fetchPosts()
  ]).then(([user, posts]) => {
    return {user, posts};
  })
}
————————————————————————————————————————————————

// 尽早开始获取数据
const promise = fetchProfileData();

function ProfilePage() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState(null);

  useEffect(() => {
    promise.then(data => {
      setUser(data.user);
      setPosts(data.posts);
    });
  }, []);

  if (user === null) {
    return <p>Loading profile...</p>;
  }
  return (
    <>
      <h1>{user.name}</h1>
      <ProfileTimeline posts={posts} />
    </>
  );
}

// 子组件不再触发数据请求
function ProfileTimeline({ posts }) {
  if (posts === null) {
    return <h2>Loading posts...</h2>;
  }
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.text}</li>
      ))}
    </ul>
  );
}

// fetch 完 user 和 post 后再render
```

- Render-as-you-fetch（获取数据之后渲染，如：使用了 Suspense 的 Relay）

```jsx
同 Fetch-then-render 区别：
fetch-then-render：  开始获取数据 -> 结束获取数据 -> 开始渲染
render-as-you-fetch：开始获取数据 -> 开始渲染 -> 结束获取数据

————————————————————————————————————————————————

// 这不是一个 Promise。这是一个支持 Suspense 的特殊对象。
const resource = fetchProfileData();

function ProfilePage() {
  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails />
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline />
      </Suspense>
    </Suspense>
  );
}

function ProfileDetails() {
  // 尝试读取用户信息，尽管信息可能未加载完毕
  const user = resource.user.read();
  return <h1>{user.name}</h1>;
}

function ProfileTimeline() {
  // 尝试读取博文数据，尽管数据可能未加载完毕
  const posts = resource.posts.read();
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.text}</li>
      ))}
    </ul>
  );
}

// 一开始fetch data, 渲染 ProfileDetails 和 ProfileTimeline
// 依次渲染可渲染comp，没有可渲染comp，此时fallback，渲染h1

```

注意点：

- suspense要求尽早获取数据

```jsx
// 一早就开始数据获取，在渲染之前！
const resource = fetchProfileData();

// ...

function ProfileDetails() {
  // 尝试读取用户信息
  const user = resource.user.read();
  return <h1>{user.name}</h1>;
}

// 若无法保证在init时fetch data，而不是组件render后fetch data，可以根据props获取数据
// 开始获取数据，越快越好
const initialResource = fetchProfileData(0);

function App() {
  const [resource, setResource] = useState(initialResource);
  return (
    <>
      <button onClick={() => {
        const nextUserId = getNextId(resource.userId);
        // 再次获取数据：用户点击时
        setResource(fetchProfileData(nextUserId));
      }}>
        Next
      </button>
      <ProfilePage resource={resource} />
    </>
  );
}
```

- 如何解决race condition

```jsx
// useEffect race condition
function ProfilePage({ id }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser(id).then(u => setUser(u));
  }, [id]);

  if (user === null) {
    return <p>Loading profile...</p>;
  }
  return (
    <>
      <h1>{user.name}</h1>
      <ProfileTimeline id={id} />
    </>
  );
}

function ProfileTimeline({ id }) {
  const [posts, setPosts] = useState(null);

  useEffect(() => {
    fetchPosts(id).then(p => setPosts(p));
  }, [id]);

  if (posts === null) {
    return <h2>Loading posts...</h2>;
  }
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.text}</li>
      ))}
    </ul>
  );
}

// race condition: 快速切换时，某个ProfileTimeline fetch 请求延时过高后，旧的response会覆盖新的state

————————————————————————————————————————————————
// suspense，开始获取数据 -> 开始渲染 -> 结束获取数据，获取完数据，立马setState

const initialResource = fetchProfileData(0);

function App() {
  const [resource, setResource] = useState(initialResource);
  return (
    <>
      <button onClick={() => {
        const nextUserId = getNextId(resource.userId);
        setResource(fetchProfileData(nextUserId));
      }}>
        Next
      </button>
      <ProfilePage resource={resource} />
    </>
  );
}

function ProfilePage({ resource }) {
  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails resource={resource} />
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline resource={resource} />
      </Suspense>
    </Suspense>
  );
}

function ProfileDetails({ resource }) {
  const user = resource.user.read();
  return <h1>{user.name}</h1>;
}

function ProfileTimeline({ resource }) {
  const posts = resource.posts.read();
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.text}</li>
      ))}
    </ul>
  );
}

// 原因：
// hooks里，setState需要在合理的时间设置；
// suspense里，获取完数据，立马setState
```

为什么没有在V18中加上 CM 和 suspense ？

1. 虽然React 18没有将Concurrent Mode（以下简称CM）列为版本18升级的核心特性，但也将其作为可选项集成在18版本中，为什么不作为必选项？

A：

1. 1. CM和suspense更适合针对库作者，日常应用的开发者更多的可以作为借鉴；
   2. react当前核心会放在迁移和解决兼容性的问题；

- - Fragments、Context、Hook开箱即用
  - concurrent得引入新的语义

```jsx
// legacy 模式：最常见的版本
ReactDOM.render(<App />, rootNode)
// blocking 模式：作为从legacy迁移到cm的版本
ReactDOM.createBlockingRoot(rootNode).render(<App />)
// concurrent 模式：后续CM上stable版本后作为默认方式 
ReactDOM.createRoot(rootNode).render(<App />)
```

1. 

1.为什么能够在半天内完成V18的升级

1. a. React团队对于opt-in（可选）做了足够的兼容，如果不用CM的特性，是不会触发CM的，相当于React团队为你做了兜底；「concurrent rendering will only be enabled for updates triggered by one of the new features.」；

2. b.18引入了新的Root API ReactDOM.createRoot 来与旧的 ReactDOM.render区分，使用旧的API会继续在legacy mode （可以理解为传统模式）下运行，用新 API，就会跑在 "Concurrency opt-in" roots 下；

# react路由

https://www.yuque.com/lpldplws/web/bcagsz?singleDoc# 《React路由详解》 密码：hmp3

## 1. 课程目标

1. 学习业界内RouterV6的实现原理，达到手写Router的水平；
2. 学习React Router V6原理与源码，知其然且知其所以然，达到源码的水平；

## 2. 课程大纲

- React Router 使用用法
- 手写一个简单的react-router
- React Router 原理解析
- React Router 源码解析

## 3. 主要内容

### 3.1. React Router使用用法

React Router官网地址：https://reactrouter.com/

React Router中文Gitbook：https://react-guide.github.io/react-router-cn/

#### 3.1.1. React Router 功能介绍

React Router 是React生态库之一，是可以在CSR和SSR环境下，为了React而设计的路由库

- 客户端：React环境
- 服务端：node、RN

以最新版V6为例：

##### 3.1.1.1. 安装介绍

1. 基本安装

npm：npm install react-router-dom@6

yarn：yarn add react-router-dom@6

2. create react app 安装 

```js
// src/index.js
import * as React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";

const root = ReactDOM.createRoot(
  document.getElementById("root")
);
root.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

// src/App.js
import * as React from "react";
import { Routes, Route, Link } from "react-router-dom";
import "./App.css";

function App() {
  return (
    <div className="App">
      <h1>Welcome to React Router!</h1>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="about" element={<About />} />
      </Routes>
    </div>
  );
}

// App.js
function Home() {
  return (
    <>
      <main>
        <h2>Welcome to the homepage!</h2>
        <p>You can do this, I believe in you.</p>
      </main>
      <nav>
        <Link to="/about">About</Link>
      </nav>
    </>
  );
}

function About() {
  return (
    <>
      <main>
        <h2>Who are we?</h2>
        <p>
          That feels like an existential question, don't you
          think?
        </p>
      </main>
      <nav>
        <Link to="/">Home</Link>
      </nav>
    </>
  );
}
```

3. webpack安装

   ```js
   import {
     BrowserRouter,
     Routes,
     Route,
   } from "react-router-dom";
   
   function App() {
     return (
       <BrowserRouter>
         <div>
           <h1>Hello, React Router!</h1>
           <Routes>
             <Route path="/" element={<Home />} />
           </Routes>
         </div>
       </BrowserRouter>
     );
   }
   ```

4. html script 安装

   不建议使用：以上在业务代码中都建议使用，但使用<script>不建议，因为会加载所有的组件集合，没法使用如webpack的按需加载

```js
  <!-- Other HTML for your app goes here -->

  <!-- The node we will use to put our app in the document -->
  <div id="root"></div>

  <!-- Note: When deploying to production, replace "development.js"
       with "production.min.js" in each of the following tags -->

  <!-- Load React and React DOM -->
  <!-- See https://reactjs.org/docs/add-react-to-a-website.html to learn more -->
  <script src="https://unpkg.com/react@>=16.8/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@>=16.8/umd/react-dom.development.js" crossorigin></script>

  <!-- Load history -->
  <script src="https://unpkg.com/history@5/umd/history.development.js" crossorigin></script>

  <!-- Load React Router and React Router DOM -->
  <script src="https://unpkg.com/react-router@6/umd/react-router.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-router-dom@6/umd/react-router-dom.development.js" crossorigin></script>

  <!-- A simple example app -->
  <script>
  var e = React.createElement;
  var Router = ReactRouterDOM.BrowserRouter;
  var Routes = ReactRouterDOM.Routes;
  var Route = ReactRouterDOM.Route;

  ReactDOM.render(
    (
      e(Router, null, (
        e(Routes, null, (
          e(Route, {
            element: e('div', null, 'Hello, React Router!')
          })
        ))
      ))
    ),
    document.getElementById('root')
  );
  </script>

</body>
```

##### 3.1.1.2 基本用法

- 配置路由

```js
import ReactDOM from "react-dom/client";
import {
  BrowserRouter,
  Routes,
  Route,
} from "react-router-dom";
// import your route components too

const root = ReactDOM.createRoot(
  document.getElementById("root")
);
root.render(
  <BrowserRouter>
    <Routes>
      <Route path="/" element={<App />}>
        <Route index element={<Home />} />
        <Route path="teams" element={<Teams />}>
          <Route path=":teamId" element={<Team />} />
          <Route path="new" element={<NewTeamForm />} />
          <Route index element={<LeagueStandings />} />
        </Route>
      </Route>
    </Routes>
  </BrowserRouter>
);
```

在先前版本的React Router中，针对多个匹配到的router，我们需要声明出具体的匹配逻辑，但V6相对更“智能”

- teams/111：匹配<Team />
- teams.new：匹配下面的<NewTeamForm />

```js
<Route path="teams/:teamId" element={<Team />} />
<Route path="teams/new" element={<NewTeamForm />} />
```

- Navigation/Link

我们可以使用以上两种方式修改url

```js
// Link
import { Link } from "react-router-dom";

function Home() {
  return (
    <div>
      <h1>Home</h1>
      <nav>
        <Link to="/">Home</Link> |{" "}
        <Link to="about">About</Link>
      </nav>
    </div>
  );
}

// useNavigate，更多用于JS操作后跳转使用
import { useNavigate } from "react-router-dom";

function Invoices() {
  let navigate = useNavigate();
  return (
    <div>
      <NewInvoiceForm
        onSubmit={async (event) => {
          let newInvoice = await createInvoice(
            event.target
          );
          navigate(`/invoices/${newInvoice.id}`);
        }}
      />
    </div>
  );
}
```

- 使用url的路径参数，常用于匹配path 参数后fetch数据

```js
import { Routes, Route, useParams } from "react-router-dom";

function App() {
  return (
    <Routes>
      <Route
        path="invoices/:invoiceId"
        element={<Invoice />}
      />
    </Routes>
  );
}

function Invoice() {
  let params = useParams();
  return <h1>Invoice {params.invoiceId}</h1>;
}

// example
function Invoice() {
  let { invoiceId } = useParams();
  let invoice = useFakeFetch(`/api/invoices/${invoiceId}`);
  return invoice ? (
    <div>
      <h1>{invoice.customerName}</h1>
    </div>
  ) : (
    <Loading />
  );
}
```

- 嵌套路由

路由路径 匹配 url路径

```js
function App() {
  return (
    <Routes>
      <Route path="invoices" element={<Invoices />}>
        <Route path=":invoiceId" element={<Invoice />} />
        <Route path="sent" element={<SentInvoices />} />
      </Route>
    </Routes>
  );
}
```

以上提供三种路由

- "/invoices"

- "/invoices/sent"
- "/invoices/:invoiceId"

```js
// /invoices/sent
<App>
  <Invoices>
    <SentInvoices />
  </Invoices>
</App>

// /invoices/123
<App>
  <Invoices>
    <Invoice />
  </Invoices>
</App>

// 父router中子router可以用<Outlet>表示
import { Routes, Route, Outlet } from "react-router-dom";

function App() {
  return (
    <Routes>
      <Route path="invoices" element={<Invoices />}>
        <Route path=":invoiceId" element={<Invoice />} />
        <Route path="sent" element={<SentInvoices />} />
      </Route>
    </Routes>
  );
}

function Invoices() {
  return (
    <div>
      <h1>Invoices</h1>
      <Outlet /> // 匹配对应的<Invoice /> 或者 <SentInvoices />
    </div>
  );
}

function Invoice() {
  let { invoiceId } = useParams();
  return <h1>Invoice {invoiceId}</h1>;
}

function SentInvoices() {
  return <h1>Sent Invoices</h1>;
}

// 在跟router中添加Link 跳转
import {
  Routes,
  Route,
  Link,
  Outlet,
} from "react-router-dom";

function App() {
  return (
    <Routes>
      <Route path="/" element={<Layout />}>
        <Route path="invoices" element={<Invoices />} />
        <Route path="dashboard" element={<Dashboard />} />
      </Route>
    </Routes>
  );
}

function Layout() {
  return (
    <div>
      <h1>Welcome to the app!</h1>
      <nav>
        <Link to="invoices">Invoices</Link> |{" "}
        <Link to="dashboard">Dashboard</Link>
      </nav>
      <div className="content">
        <Outlet />
      </div>
    </div>
  );
}

function Invoices() {
  return <h1>Invoices</h1>;
}

function Dashboard() {
  return <h1>Dashboard</h1>;
}
```

- Index routes

```js
function App() {
  return (
    <Routes>
      <Route path="/" element={<Layout />}>
        <Route index element={<Activity />} />
        <Route path="invoices" element={<Invoices />} />
        <Route path="activity" element={<Activity />} />
      </Route>
    </Routes>
  );
}

function Layout() {
  return (
    <div>
      <GlobalNav />
      <main>
        <Outlet />
      </main>
    </div>
  );
}

// 如果是 "/"
<App>
  <Layout>
    <Activity />
  </Layout>
</App>
```

- relative  links

link to 指向的是相同级别的路由

```js
import {
  Routes,
  Route,
  Link,
  Outlet,
} from "react-router-dom";

function Home() {
  return <h1>Home</h1>;
}

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <nav>
        <Link to="invoices">Invoices</Link> // /dashboard/invoices
        <Link to="team">Team</Link> // dashboard/team
      </nav>
      <hr />
      <Outlet />
    </div>
  );
}

function Invoices() {
  return <h1>Invoices</h1>;
}

function Team() {
  return <h1>Team</h1>;
}

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="dashboard" element={<Dashboard />}>
        <Route path="invoices" element={<Invoices />} />
        <Route path="team" element={<Team />} />
      </Route>
    </Routes>
  );
}
```

- 兜底routes

```js
function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="dashboard" element={<Dashboard />} />
      <Route path="*" element={<NotFound />} />
    </Routes>
  );
}
```

- 多个routes集成在一个组件

```js
function App() {
  return (
    <div>
      <Sidebar>
        <Routes>
          <Route path="/" element={<MainNav />} />
          <Route
            path="dashboard"
            element={<DashboardNav />}
          />
        </Routes>
      </Sidebar>

      <MainContent>
        <Routes>
          <Route path="/" element={<Home />}>
            <Route path="about" element={<About />} />
            <Route path="support" element={<Support />} />
          </Route>
          <Route path="dashboard" element={<Dashboard />}>
            <Route path="invoices" element={<Invoices />} />
            <Route path="team" element={<Team />} />
          </Route>
          <Route path="*" element={<NotFound />} />
        </Routes>
      </MainContent>
    </div>
  );
}
```

- 后代中使用Routes

```js
function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="dashboard/*" element={<Dashboard />} />
    </Routes>
  );
}

function Dashboard() {
  return (
    <div>
      <p>Look, more routes!</p>
      <Routes>
        <Route path="/" element={<DashboardGraphs />} /> // dashboard
        <Route path="invoices" element={<InvoiceList />} /> // /dashboard/invoices
      </Routes>
    </div>
  );
}
```

##### 3.1.1.3 升级到v6的一些问题汇总

1. 为什么withRouter没了

withRouter用处

将一个组件包裹进Route里面, 然后react-router的三个对象history, location, match就会被放进这个组件的props属性中，可以实现对应的功能

```js
import React from 'react'
import './nav.css'
import {
    NavLink,
    withRouter
} from "react-router-dom"

class Nav extends React.Component{
    handleClick = () => {
        // Route 的 三个对象将会被放进来, 对象里面的方法可以被调用
        console.log(this.props);
    }
    render() {
        return (
            <div className={'nav'}>
                <span className={'logo'} onClick={this.handleClick}>掘土社区</span>
                <li><NavLink to="/" exact>首页</NavLink></li>
                <li><NavLink to="/activities">动态</NavLink></li>
                <li><NavLink to="/topic">话题</NavLink></li>
                <li><NavLink to="/login">登录</NavLink></li>
            </div>
        );
    }
}

// 导出的是 withRouter(Nav) 函数执行
export default withRouter(Nav)
```

React Router的V6中，更多的使用hooks语法，而withRouter的用法更多的用在Class组件里，只要可以将类组件转为函数组件即可：

```js
import {
  useLocation,
  useNavigate,
  useParams,
} from "react-router-dom";

function withRouter(Component) {
  function ComponentWithRouterProp(props) {
    let location = useLocation();
    let navigate = useNavigate();
    let params = useParams();
    return (
      <Component
        {...props}
        router={{ location, navigate, params }}
      />
    );
  }

  return ComponentWithRouterProp;
}
```

2. 在V6以下的版本里，支持<Route component>和<Route render>，为什么V6中只支持<Route element>?

1. a. 参考React 中Suspense的用法，<Suspense fallback={<Spinner />}>，传入的是React 元素，而非组件，可以将props更容易的传入到对应的元素内（社区推荐）

2. b. 可以隐式的传递props到元素内

3. c. V6以下形式的包版本体积过大

```js
// V6以下
<Route path=":userId" component={Profile} />
  
<Route
  path=":userId"
  render={routeProps => (
    <Profile routeProps={routeProps} animate={true} />
  )}
/>

<Route
  path=":userId"
  children={({ match }) => (
    match ? (
      <Profile match={match} animate={true} />
    ) : (
      <NotFound />
    )
  )}
/>

// V6
<Route path=":userId" element={<Profile />} />

<Route path=":userId" element={<Profile animate={true} />} />

function Profile({ animate }) {
  // 使用hooks，在元素定义内处理逻辑
  let params = useParams();
  let location = useLocation();
}
```

3. 如何在树形结构里嵌套路由

```js
// V6以下
<Switch>
  <Route path="/users" component={Users} />
</Switch>;

// and now deeper in the tree
function Users() {
  return (
    <div>
      <h1>Users</h1>
      <Switch>
        <Route path="/users/account" component={Account} />
      </Switch>
    </div>
  );
}

// V6
// somewhere up the tree
<Routes>
  <Route path="/users/*" element={<Users />} />
</Routes>;

// and now deeper in the tree
function Users() {
  return (
    <div>
      <h1>Users</h1>
      <Routes>
        <Route path="account" element={<Account />} />
      </Routes>
    </div>
  );
}
```

4. 为什么取消正则路由
   1. a. 正则路由为V6版本的路由排序带来很多问题，比如，如果定义一个正则的优先级？

   2. b. 正则路由占据了React Router近1/3的体积

   3. c. 正则路由能表达的，V6版本都支持

```js
// V5
function App() {
  return (
    <Switch>
      <Route path={/(en|es|fr)/} component={Lang} />
    </Switch>
  );
}

function Lang({ params }) {
  let lang = params[0];
  let translations = I81n[lang];
  // ...
}

// V6
function App() {
  return (
    <Routes>
      <Route path="en" element={<Lang lang="en" />} />
      <Route path="es" element={<Lang lang="es" />} />
      <Route path="fr" element={<Lang lang="fr" />} />
    </Routes>
  );
}

function Lang({ lang }) {
  let translations = I81n[lang];
  // ...
}

// V5
function App() {
  return (
    <Switch>
      <Route path={/users\/(\d+)/} component={User} />
    </Switch>
  );
}

function User({ params }) {
  let id = params[0];
  // ...
}

// V6
function App() {
  return (
    <Routes>
      <Route path="/users/:id" element={<ValidateUser />} />
      <Route path="/users/*" element={<NotFound />} />
    </Routes>
  );
}

function ValidateUser() {
  let params = useParams();
  let userId = params.id.match(/\d+/);
  if (!userId) {
    return <NotFound />;
  }
  return <User id={params.userId} />;
}

function User(props) {
  let id = props.id;
  // ...
}
```

#### 3.1.2 React Router Api

API详情请参考：https://reactrouter.com/docs/en/v6/routers/browser-router

1. routers

1. 1. browserRouter：浏览器router，web开发首选；
   2. hashRouter：在不能使用browserRouter时使用，常见SPA的B端项目
   3. HistoryRouter：使用history库作为入参，这允许您在非 React context中使用history实例作为全局变量，标记为unstable_HistoryRouter，后续可能会被修改，不建议直接引用，可以从react-router中引入不建议使用；
   4. MemoryRouter：不依赖于外界（如 browserRouter的 history 堆栈），常用于测试用例；
   5. NativeRouter：RN环境下使用的router，不作过多介绍；
   6. Router：可以视为所有其他router的基类；
   7. StaticRouter：node环境下使用的router，不作过多介绍；

2. components

1. 1. Link：在react-router-dom中，Link被渲染为有真实href的<a />，同时，Link to 支持相对路径路由；
   2. Link（RN）：不作过多介绍；
   3. NavLink：有“active”标的Link，尝被用于导航栏等场景；
   4. Navigate：可以理解为被useNavigate包裹的组件，作用通Link类似；
   5. Outlet：类似slot，向下传递route；
   6. Routes & Route：URL变化时，Routes匹配出最符合要求的Routes渲染；

3. Hooks

1. 1. useHref：被用作返回Link to 指定的URL；
   2. useInRouterContext ：返回是否在<Router>的context中；
   3. useLinkClickHandler：在使用自定义<Link>后返回点击事件；
   4. useLinkPressHandler：类似useLinkClickHandler，用于RN；
   5. useLocation：返回当前的location对象；
   6. useMatch：返回当前path匹配到的route；
   7. useNavigate：类似于Navigate，显示声明使用；
   8. useNavigationType：pop、push、replace；
   9. useOutlet；获取此route层级的子router元素；
   10. useOutletContext：用于向子route传递context；
   11. useParams：匹配当前路由path；
   12. useResolvedPath：返回当前路径的完整路径名，主要用于相对子route中；
   13. useRoutes：等同于<Routes>，但要接收object形式；
   14. useSearchParams：用于查询和修改location 中query字段；
   15. useSearchParams（RN）：RN中使用；

4. utilities：

1. 1. createRoutesFromChildren ：将<Route>转为route object形式；
   2. createSearchParams：类似useSearchParams；
   3. generatePath：将通配符和动态路由和参数转为真实path；
   4. Location：用于hostory router，声明Location的interface；
   5. matchPath：类似useMatch，返回匹配到的route path；
   6. matchRoutes：返回匹配到的route 对象；
   7. renderMatches：返回matchRoutes的react元素；
   8. resolvePath：将Link to的值转为带有绝对路径的真实的path对象；

最后，看一下实际运行的代码案例：

1. 基础：https://stackblitz.com/edit/github-agqlf5?file=src%2FApp.jsx

### 3.2 手写一个简单的react-router

1. SPA（单页应用）

单页面应用的特点是:只会在首次加载的时候，向服务器请求资源以加载页面，后续跳转页面是不会再向服务器请求资源，并且不会重新加载页面，会以切换组件重新渲染来达到页面跳转的目的

1. 页面刷新的场景

1. 1. 在js中发起页面跳转，改变浏览器的url
   2. 用户通过点击浏览器的前进或后退按钮发生页面跳转
   3. 用户修改浏览器url导致重新加载页面

2. History API（对访问页面堆栈的操作）：可以修改浏览器的url，但是不会重新加载页面

1. 1. pushState: 创建一个新的url，并跳转至该url；
   2. replaceState：修改当前url；
   3. back：返回后一个url；
   4. forward：返回前一个url；
   5. go：跳转到指定页面的url；（在调用go方法时，如果没有传参则会与调用location.reload()一样，会重新加载页面）

3. 监听用户点击浏览器前进和后退按钮

1. 1. 通过监听popstate实现；
   2. 调用 history.pushState() 或者 history.replaceState() 不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法)，此外，a 标签的锚点也会触发该事件；

参考：

- window.history API：https://developer.mozilla.org/zh-CN/docs/Web/API/History
- window.location API：https://developer.mozilla.org/zh-CN/docs/Web/API/Location

#### 3.2.2 实现一个BrowserRouter

```js
// browserRouter
function BrowserRouter(props) {
  const RouterContext = createContext();
  const HistoryContext = createContext();

   const [path, setPath] = useState(() => {
     // 首次渲染，获取到对应的路由
     const {pathname} = window.location;
     return pathname || '/';
   });
  
    useEffect(() => {
    // 监听用户点击浏览器的前进，后退按钮跳转页面
    window.addEventListener('popstate', handlePopstate);

    return () => {
      window.removeEventListener('popstate', handlePopstate);
    }
  }, []);
  
  const handlePopstate = function(event) {
    const {pathname} = window.location;
    setPath(pathname);
  }
  
  // 点击ui跳转页面
  const push = function(path) {
    setPath(path);
    window.history.pushState({path}, null, path);
  }

  const goBack = function() {
    window.history.go(-1);
  }

  return (
   <RouterContext.Provider value={path}>
      <HistoryContext.Provider value={{
        push,
        goBack
      }}>
        {props.children}
      </HistoryContext.Provider>
    </RouterContext.Provider>
  );
}

export default BrowserRouter;

// Route
export function Route(props) {
  const {component: Component, path: componentPath} = props;
  
  return (
    <RouterContext.Consumer>
      {(path) => {
        return componentPath === path ? <Component /> : null;
      }}
    </RouterContext.Consumer>
  );
}


// 为什么不使用useContext？
// 因为每当路由变化时，我们都需要重新渲染一个对应的组件，需要监听path的变化
```

#### 3.2.3 实现一个HashRouter

```js
import {useEffect, useState} from 'react';
import RouterContext from './routerContext';
import HistoryContext from './historyContext';

// 自定义HashRouter
function HashRouter(props) {
  const [path, setPath] = useState(() => {
    const {hash} = window.location;
    if(hash) {
      return hash.slice(1);
    }
    return '/#/';
  });

  useEffect(() => {
    // 监听用户点击浏览器的前进，后退按钮跳转页面
    window.addEventListener('hashchange', handlePopstate);
    
    return () => {
      window.removeEventListener('hashchange', handlePopstate);
    }
  }, []);

  const handlePopstate = function(event) {
    const {hash} = window.location;
    setPath(hash.slice(1));
  }

  //history Api: https://developer.mozilla.org/zh-CN/docs/Web/API/History_API

  // 点击ui跳转页面
  const push = function(path) {
    window.location.hash = path;
  }

  const goBack = function() {
    window.history.go(-1);
  }

  return (
    <RouterContext.Provider value={path}>
      <HistoryContext.Provider value={{
        push,
        goBack
      }}>
        {props.children}
      </HistoryContext.Provider>
    </RouterContext.Provider>
  );
}

export default HashRouter;

// Route
export function Route(props) {
  const {component: Component, path: componentPath} = props;
  
  return (
    <RouterContext.Consumer>
      {(path) => {
        return componentPath === path ? <Component /> : null;
      }}
    </RouterContext.Consumer>
  );
}
```

### 3.3 React Router原理解析

核心功能：

1. 订阅和操作history堆栈
2. 将 URL 与router匹配
3. 渲染与router相匹配的UI

#### 3.3.1 概念定义

- URL：地址栏中的URL；
- Location：由React Router基于浏览器内置的window.location对象封装而成的特定对象，它代表“用户在哪里”，基本代表了URL；
- Location State：不在URL中，但代表了Location的状态；
- History Stack：随着用户操作导航，浏览器会保留location的堆栈，可以通过返回前进按钮操作；
- Client Side Routing (CSR) ：一个纯 HTML 文档可以通过history stack来链接到其他文档，CSR使我的能够操作浏览器历史堆栈，而无需向服务器发出文档请求；
- History：一个object，它允许 React Router 订阅 URL 中的更改，并提供 API 以编程方式操作浏览器历史堆栈；
- History Action ：包括POP, PUSH, 或者 REPLACE

- - push：将新的入口添加到history stack（点击链接或者navigation）
  - replace：代替当前的堆栈信息，而不是新push
  - pop：当用户点击后推或者前进按钮

- Segment ：/ 字符之间的 URL 或 path pattern部分。例如，“/users/123”有两个segment；
- Path Pattern：看起来像 URL，但可以具有用于将 URL 与路由匹配的特殊字符，例如动态段 ("/users/:userId") 或通配符 ("/docs/*")。它们不是 URL，它们是 React Router 将匹配的模式。
- Dynamic Segment：动态的path pattern，例如，/users/:userId 将会匹配 /user/123；
- URL Params ： 动态段匹配的 URL 的解析值；
- Router ：使所有其他组件和hooks工作的有状态的最高层的组件；
- Route Config：将当前路径进行匹配，通过排序和匹配创建一个树状的routes对象；
- Route：通常具有 { path, element } 或 <Route path element> 的路由元素。path是 pattern。当路径模式与当前 URL 匹配时展示；
- Route Element： 也就是 <Route>，<Routes> 读取该元素的 props 以创建路由；
- Nested Routes： 因为路由可以有子路由，并且每个路由通过segment定义 URL 的一部分，所以单个 URL 可以匹配树的嵌套“分支”中的多个路由。这可以通过outlet、relative links等实现自动布局嵌套；
- Relative links：不以 / 开头的链接，继承渲染它们的最近路径。在无需知道和构建整个路径的情况下，就可以实现更深层的url macth；
- Match：当路由匹配 URL 时保存信息的对象，例如匹配的 url params和path name；
- Matches：与当前位置匹配的路由数组，此结构用于nested routes；
- Parent Route：带有子路由的父路由节点；
- Outlet： 匹配match中的下一个匹配项的组件；
- Index Route ：当没有path时，在父路由的outlet中匹配；
- Layout Route： 专门用于在特定布局内对子路由进行分组；

#### 3.3.2 history 和location

React Router 的前提是：它必须能够订阅浏览器history stack中的更改；

浏览器在用户浏览时维护自己的历史堆栈。这就是后退和前进按钮的工作方式。在传统网站（没有 JavaScript 的 HTML 文档）中，每次用户单击链接、提交表单或单击后退和前进按钮时，浏览器都会向服务器发出请求。

例如，假设用户：

- 点击 /dashboard的链接；
- 点击 /accounts 的链接；
- 点击 /customers/123 的链接；
- 点击后退按钮；
- 点击指向 /dashboard 的链接；

history stack是如何的？

- /dashboard
- /dashboard, /accounts
- /dashboard, /accounts, /customers/123

1. /dashboard, /accounts, /customers/123
2. /dashboard, /accounts, /dashboard

##### 3.3.2.1 history object

通过客户端路由(CSR)，我们可以通过代码操纵浏览器历史记录栈。

例如，我们可以写一些这样的代码来改变URL，而不需要浏览器向服务器发出请求的默认行为

```js
<a
  href="/contact"
  onClick={(event) => {
    // 阻止默认事件
    event.preventDefault();
    // push 并将 URL转想/contact
    window.history.pushState({}, undefined, "/contact");
  }}
/>
```

以上代码会修改URL，但不会渲染任何UI的变化，我们需要监听变化，并通过代码修改页面UI

```js
window.addEventListener("popstate", () => {
  // URL changed!
});
```

但此类事件只在点击前进后退按钮才生效，对window.history.pushState 或者 window.history.replaceState无效

因此，React Router使用history对象来监听事件的变化，如POP, PUSH, 或者REPLACE

```js
let history = createBrowserHistory();
history.listen(({ location, action }) => {
  // this is called whenever new locations come in
  // the action is POP, PUSH, or REPLACE
});
```

在开发环境中，我们不需要关系history object，这些在React Router底层实现了，React Router提供监听history stack的变化，最终在URL变化时更新其状态，并重新渲染。

##### 3.3.2.2 Location

React Router 声明了自己的location模块，大致为

```js
{
  pathname: "/bbq/pig-pickins",
  search: "?campaign=instagram",
  hash: "#menu",
  state: null,
  key: "aefz24ie"
}
```

pathname、search、hash大致同window.location一致，三者拼接起来等同于URL

```js
location.pathname + location.search + location.hash;
// /bbq/pig-pickins?campaign=instagram#menu
```

注意：我们可以使用urlSearchParams来获取对应的search内容

```js
// given a location like this:
let location = {
  pathname: "/bbq/pig-pickins",
  search: "?campaign=instagram&popular=true",
  hash: "",
  state: null,
  key: "aefz24ie",
};

// we can turn the location.search into URLSearchParams
let params = new URLSearchParams(location.search);
params.get("campaign"); // "instagram"
params.get("popular"); // "true"
params.toString(); // "campaign=instagram&popular=true",
```

- location state

You may have wondered why the window.history.pushState() API is called "push state". State? Aren't we just changing the [URL](https://reactrouter.com/docs/en/v6/getting-started/concepts#url)? Shouldn't it be history.push? Well, we weren't in the room when the API was designed, so we're not sure why "state" was the focus, but it is a cool feature of browsers nonetheless.

```js
// 通过pushState注入堆栈，goback()时，退出一层堆栈
window.history.pushState("look ma!", undefined, "/contact");
window.history.state; // "look ma!"
// user clicks back
window.history.state; // undefined
// user clicks forward
window.history.state; // "look ma!"
```

可以将location.state 当做跟URL变动而变动的属性，只是一般用于开发者使用

在React Router中，我们可以通过Link 或者Navigate 来设置state，并使用useLocation获取state

```js
<Link to="/pins/123" state={{ fromDashboard: true }} />;

let navigate = useNavigate();
navigate("/users/123", { state: partialUser });

let location = useLocation();
location.state;
```

- location key

  一般用于定位滚动距离，或者客户端数据缓存等，因为每个堆栈都有唯一的key值，可以通过Map或者localStorage来标识指定的堆栈信息。

```js
// 根据location.key缓存数据

let cache = new Map();

function useFakeFetch(URL) {
  let location = useLocation();
  let cacheKey = location.key + URL;
  let cached = cache.get(cacheKey);

  let [data, setData] = useState(() => {
    // initialize from the cache
    return cached || null;
  });

  let [state, setState] = useState(() => {
    // avoid the fetch if cached
    return cached ? "done" : "loading";
  });

  useEffect(() => {
    if (state === "loading") {
      let controller = new AbortController();
      fetch(URL, { signal: controller.signal })
        .then((res) => res.json())
        .then((data) => {
          if (controller.signal.aborted) return;
          // set the cache
          cache.set(cacheKey, data);
          setData(data);
        });
      return () => controller.abort();
    }
  }, [state, cacheKey]);

  useEffect(() => {
    setState("loading");
  }, [URL]);

  return data;
}
```

#### 3.3.3 匹配

在初始渲染时，当历史堆栈发生变化时，React Router 会将位置与您的路由配置进行匹配，以提供一组要渲染的匹配项

```js
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path=":teamId/edit" element={<EditTeam />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
  <Route element={<PageLayout />}>
    <Route path="/privacy" element={<Privacy />} />
    <Route path="/tos" element={<Tos />} />
  </Route>
  <Route path="contact-us" element={<Contact />} />
</Routes>

// 对应的routes，可以使用 useRoutes(routesGoHere)获取
let routes = [
  {
    element: <App />,
    path: "/",
    children: [
      {
        index: true,
        element: <Home />,
      },
      {
        path: "teams",
        element: <Teams />,
        children: [
          {
            index: true,
            element: <LeagueStandings />,
          },
          {
            path: ":teamId",
            element: <Team />,
          },
          {
            path: ":teamId/edit",
            element: <EditTeam />,
          },
          {
            path: "new",
            element: <NewTeamForm />,
          },
        ],
      },
    ],
  },
  {
    element: <PageLayout />,
    children: [
      {
        element: <Privacy />,
        path: "/privacy",
      },
      {
        element: <Tos />,
        path: "/tos",
      },
    ],
  },
  {
    element: <Contact />,
    path: "/contact-us",
  },
];

```

- 匹配参数 & routes 排序

上述路由config为

```js
[
  "/",
  "/teams",
  "/teams/:teamId",
  "/teams/:teamId/edit",
  "/teams/new",
  "/privacy",
  "/tos",
  "/contact-us",
];
```

/teams/:teamId 可以匹配 /teams/123 或者 /teams/aaa

针对 / teams/new，有 "/teams/:teamId"、 "/teams/new", 匹配，V6支持相对智能的匹配，在匹配时，React Router 会根据所有的segment、静态segment、动态segment、通配符模式等进行排序，并选择最具体的匹配项

- 路由匹配

```js
<Route path=":teamId" element={<Team/>}/>
  
等价于

{
  pathname: "/teams/firebirds", // 匹配出与此路由匹配的URL部分
  params: {
    teamId: "firebirds" // 用来存储对应关系
  },
  route: {
    element: <Team />,
    path: ":teamId"
  }
}
```

因为routes是树状结构，因此，一个单一的URL可以匹配所有的树中的“分支”

```js
/teams/firebirds

// 针对下列路由
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path=":teamId/edit" element={<EditTeam />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
  <Route element={<PageLayout />}>
    <Route path="/privacy" element={<Privacy />} />
    <Route path="/tos" element={<Tos />} />
  </Route>
  <Route path="contact-us" element={<Contact />} />
</Routes>

// 匹配出的routes为：
[
  {
    pathname: "/",
    params: null,
    route: {
      element: <App />,
      path: "/",
    },
  },
  {
    pathname: "/teams",
    params: null,
    route: {
      element: <Teams />,
      path: "teams",
    },
  },
  {
    pathname: "/teams/firebirds",
    params: {
      teamId: "firebirds",
    },
    route: {
      element: <Team />,
      path: ":teamId",
    },
  },
];
```

#### 3.3.4 渲染

<Routes>将把位置与你的路由配置相匹配，得到一组匹配的内容，然后像这样呈现一个React元素树。

```js
// 假设代码为

const root = ReactDOM.createRoot(
  document.getElementById("root")
);
root.render(
  <BrowserRouter>
    <Routes>
      <Route path="/" element={<App />}>
        <Route index element={<Home />} />
        <Route path="teams" element={<Teams />}>
          <Route path=":teamId" element={<Team />} />
          <Route path="new" element={<NewTeamForm />} />
          <Route index element={<LeagueStandings />} />
        </Route>
      </Route>
      <Route element={<PageLayout />}>
        <Route path="/privacy" element={<Privacy />} />
        <Route path="/tos" element={<Tos />} />
      </Route>
      <Route path="contact-us" element={<Contact />} />
    </Routes>
  </BrowserRouter>
);

// 匹配 /teams/firebirds

<App>
  <Teams>
    <Team />
  </Teams>
</App>
```

- outlets

很像slot,<outlet>应该在父路由元素中使用以呈现子路由元素，以此让嵌套的子路由展示，当匹配到子路由的路径后，会展示或不展示

```js
function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>

      {/* This element will render either <DashboardMessages> when the URL is
          "/messages", <DashboardTasks> at "/tasks", or null if it is "/"
      */}
      <Outlet />
    </div>
  );
}

function App() {
  return (
    <Routes>
      <Route path="/" element={<Dashboard />}>
        <Route
          path="messages"
          element={<DashboardMessages />}
        />
        <Route path="tasks" element={<DashboardTasks />} />
      </Route>
    </Routes>
  );
}
```

- index  routes

```js
// /teams/firebirds
<Route path="teams" element={<Teams />}>
  <Route path=":teamId" element={<Team />} />
  <Route path="new" element={<NewTeamForm />} />
  <Route index element={<LeagueStandings />} />
</Route>

<App>
  <Teams>
    <Team />
  </Teams>
</App>

// /teams
<App>
  <Teams>
    <LeagueStandings />
  </Teams>
</App>

```

index routes会将父route的outlet渲染出来，一般会在持久化导航的父路由节点上展示默认的子路由信息

- layout routes

```js
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path=":teamId/edit" element={<EditTeam />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
  <Route element={<PageLayout />}>
    <Route path="/privacy" element={<Privacy />} />
    <Route path="/tos" element={<Tos />} />
  </Route>
  <Route path="contact-us" element={<Contact />} />
</Routes>
```

加入要匹配/privacy，会匹配到的结果为：

```js
<App>
  <PageLayout>
    <Privacy />
  </PageLayout>
</App>
```

实际上，layout routes（布局路由），本身不参与匹配，但其子route参与，如果不这样实现，上述代码会很冗余

```js
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path=":teamId/edit" element={<EditTeam />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
  <Route
    path="/privacy"
    element={
      <PageLayout>
        <Privacy />
      </PageLayout>
    }
  />
  <Route
    path="/tos"
    element={
      <PageLayout>
        <Tos />
      </PageLayout>
    }
  />
  <Route path="contact-us" element={<Contact />} />
</Routes>
```

#### 3.3.5 导航函数

可以使用useNavigate方法

```js
let navigate = useNavigate();
useEffect(() => {
  setTimeout(() => {
    navigate("/logout");
  }, 30000);
}, []);
```

要注意，不要随意使用navigate，这样会增加程序的复杂性

```js
<li onClick={() => navigate("/somewhere")} />
// 使用 <Link to="sonewhere" />
```

#### 3.3.6 数据获取

```js
let location = useLocation();
let urlParams = useParams();
let [urlSearchParams] = useSearchParams();
```

### 3.4 React Router源码解析

React Router github：https://github.com/remix-run/react-router

React Router基于monorepo的架构（指在一个项目仓库(repo)中管理多个模块/包(package)）

- react-router：React Router的核心基本功能，为react-router-dom 和 react-router-native服务；
- react-router-dom：在web应用使用React Router的方法；
- react-router-native：在RN中使用React Router的方法；
- react-router-dom-v5-compat：V5迁移至V6的垫片；

本次主要讲解react-router核心库

#### 3.4.1 react-router

与运行环境无关，几乎所有与运行平台无关的方法、组件和hooks都是在这里定义的

- index.ts: 入口文件，且标识了三个不安全的api,要使用的话，不要单独从lib/context.ts引入，要从react-router的入口文件引入（虽然一般开发中用不到）

```js
/** @internal */
export {
  NavigationContext as UNSAFE_NavigationContext,
  LocationContext as UNSAFE_LocationContext,
  RouteContext as UNSAFE_RouteContext,
};
```

##### 3.4.1.1 router

Router在react-router内部主要用于提供全局的路由导航对象（一般由history库提供）以及当前的路由导航状态，在项目中使用时一般是必须并且唯一的，不过一般不会直接使用，更多会使用已经封装好路由导航对象的BrowserRouter(react-router-dom包引入)、HashRouter(react-router-dom包引入)和MemoryRouter(react-router包引入)

- router context

  ```js
  import React from 'react'
  import type {
    History,
    Location,
  } from "history";
  import {
    Action as NavigationType,
  } from "history";
  
  // 只包含，go、push、replace、createHref 四个方法的 History 对象，用于在 react-router 中进行路由跳转
  export type Navigator = Pick<History, "go" | "push" | "replace" | "createHref">;
  
  interface NavigationContextObject {
    basename: string;
    navigator: Navigator;
    static: boolean;
  }
  
  /**
   * 内部含有 navigator 对象的全局上下文，官方不推荐在外直接使用
   */
  const NavigationContext = React.createContext<NavigationContextObject>(null!);
  
  
  interface LocationContextObject {
    location: Location;
    navigationType: NavigationType;
  }
  /**
   * 内部含有当前 location 与 action 的 type，一般用于在内部获取当前 location，官方不推荐在外直接使用
   */
  const LocationContext = React.createContext<LocationContextObject>(null!);
  
  // 这是官方对于上面两个 context 的导出，可以看到都是被定义为不安全的，并且可能会有着重大更改，强烈不建议使用
  /** @internal */
  export {
    NavigationContext as UNSAFE_NavigationContext,
    LocationContext as UNSAFE_LocationContext,
  };
  ```

- Hooks：基于LocationConext的三个hooks

- - useInRouterContext

- - useNavigationType
  - useLocation

- ```tsx
  /**
  * 断言方法
  */
  function invariant(cond: any, message: string): asserts cond {
    if (!cond) throw new Error(message);
  }
  
  /**
  * 判断当前组件是否在一个 Router 中
  */
  export function useInRouterContext(): boolean {
    return React.useContext(LocationContext) != null;
  }
  /**
  * 获取当前的跳转的 action type
  */
  export function useNavigationType(): NavigationType {
    return React.useContext(LocationContext).navigationType;
  }
  /**
  * 获取当前跳转的 location
  */
  export function useLocation(): Location {
    // useLocation 必须在 Router 提供的上下文中使用
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useLocation() may be used only in the context of a <Router> component.`
    );
    
    return React.useContext(LocationContext).location;
  }
  ```

- 定义Router组件

  传入context与外部传入的location

```tsx
// 接上面，这里额外还从 history 中引入了 parsePath 方法
import {
  parsePath
} from "history";

export interface RouterProps {
  // 路由前缀
  basename?: string;
  children?: React.ReactNode;
  // 必传，当前 location
  /*
      interface Location {
            pathname: string;
            search: string;
            hash: string;
            state: any;
            key: string;
      }
  */
  location: Partial<Location> | string;
  // 当前路由跳转的类型，有 POP，PUSH 与 REPLACE 三种
  navigationType?: NavigationType;
  // 必传，history 中的导航对象，我们可以在这里传入统一外部的 history
  navigator: Navigator;
  // 是否为静态路由（ssr）
  static?: boolean;
}

/**
 * 提供渲染 Route 的上下文，但是一般不直接使用这个组件，会包装在 BrowserRouter 等二次封装的路由中
 * 整个应用程序应该只有一个 Router
 * Router 的作用就是格式化传入的原始 location 并渲染全局上下文 NavigationContext、LocationContext
 */
export function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = NavigationType.Pop,
  navigator,
  static: staticProp = false
}: RouterProps): React.ReactElement | null {
  // 断言，Router 不能在其余 Router 内部，否则抛出错误
  invariant(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>.` +
      ` You should never have more than one in your app.`
  );
  // 格式化 basename，去掉 url 中多余的 /，比如 /a//b 改为 /a/b
  let basename = normalizePathname(basenameProp);
  // 全局的导航上下文信息，包括路由前缀，导航对象等
  let navigationContext = React.useMemo(
    () => ({ basename, navigator, static: staticProp }),
    [basename, navigator, staticProp]
  );

  // 转换 location，传入 string 将转换为对象
  if (typeof locationProp === "string") {
    // parsePath 用于将 locationProp 转换为 Path 对象，都是 history 库引入的
    /*
        interface Path {
              pathname: string;
              search: string;
              hash: string;
        }
    */
    locationProp = parsePath(locationProp);
  }

  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;

  // 经过抽离 base 后的真正的 location，如果抽离 base 失败返回 null
  let location = React.useMemo(() => {
    // stripBasename 用于去除 pathname 前面 basename 部分
    let trailingPathname = stripBasename(pathname, basename);

    if (trailingPathname == null) {
      return null;
    }

    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);

  if (location == null) {
    return null;
  }

  return (
    // 唯一传入 location 的地方
    <NavigationContext.Provider value={navigationContext}>
      <LocationContext.Provider
        children={children}
        value={{ location, navigationType }}
      />
    </NavigationContext.Provider>
  );
}
  
// 格式化方法
/**
 * 格式化 pathname
 * @param pathname
 * @returns
 */
const normalizePathname = (pathname: string): string =>
  pathname.replace(/\/+$/, "").replace(/^\/*/, "/");

/**
 *
 * 抽离 basename，获取纯粹的 path，如果没有匹配到则返回 null
 * @param pathname
 * @param basename
 * @returns
 */
function stripBasename(pathname: string, basename: string): string | null {
  if (basename === "/") return pathname;

  // 如果 basename 与 pathname 不匹配，返回 null
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }

  // 上面只验证了是否 pathname 包含 basename，这里还需要验证包含 basename 后第一个字母是否为 /，不为 / 证明并不是该 basename 下的路径，返回 null
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }

  // 返回去除掉 basename 的 path
  return pathname.slice(basename.length) || "/";
}
```

- memory router 封装

其实就是将history库与我们声明的Router组件绑定起来，当history.listen监听到路由改变后重新设置当前的location与action。

```tsx
import type { InitialEntry, MemoryHistory } from 'history';
import { createMemoryHistory } from 'history';

export interface MemoryRouterProps {
  // 路由前缀
  basename?: string;
  children?: React.ReactNode;
  // 与 createMemoryHistory 返回的 history 对象参数相对应，代表的是自定义的页面栈与索引
  initialEntries?: InitialEntry[];
  initialIndex?: number;
}

/**
 * react-router 里面只有 MemoryRouter，其余的 router 在 react-router-dom 里
 */
export function MemoryRouter({
  basename,
  children,
  initialEntries,
  initialIndex
}: MemoryRouterProps): React.ReactElement {
  // history 对象的引用
  let historyRef = React.useRef<MemoryHistory>();
  if (historyRef.current == null) {
    // 创建 memoryHistory
    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });
  }

  let history = historyRef.current;
  let [state, setState] = React.useState({
    action: history.action,
    location: history.location
  });

  // 监听 history 改变，改变后重新 setState
  React.useLayoutEffect(() => history.listen(setState), [history]);

  // 简单的初始化并将相应状态与 React 绑定
  return (
    <Router
      basename={basename}
      children={children}
      location={state.location}
      navigationType={state.action}
      navigator={history}
    />
  );
}
```

- 总结：

  a. Router组件是react-router应用中必不可少的，一般直接写在应用最外层，它提供了一系列关于路由跳转和状态的上下文属性和方法

  b. 一般不会直接使用Router组件，而是使用react-router内部提供的高阶Router组件，而这些高阶组件实际上就是将history库中提供的导航对象与Router组件连接起来，进而控制应用的导航状态

##### 3.4.1.2 route

列个例子

```jsx
import { render } from "react-dom";
import {
  BrowserRouter,
  Routes,
  Route
} from "react-router-dom";
// 这几个页面不用管它
import App from "./App";
import Expenses from "./routes/expenses";
import Invoices from "./routes/invoices";

const rootElement = document.getElementById("root");
render(
  <BrowserRouter>
    <Routes>
      <Route path="/" element={<App />} />
      <Route path="/expenses" element={<Expenses />} />
      <Route path="/invoices" element={<Invoices />} />
    </Routes>
  </BrowserRouter>,
  rootElement
);
```

- props

route在react-router中只是提供命令式的路由配置方式

```tsx
// Route 有三种 props 类型，这里先了解内部参数的含义，下面会细讲
export interface PathRouteProps {
  caseSensitive?: boolean;
  // children 代表子路由
  children?: React.ReactNode;
  element?: React.ReactNode | null;
  index?: false;
  path: string;
}

export interface LayoutRouteProps {
  children?: React.ReactNode;
  element?: React.ReactNode | null;
}

export interface IndexRouteProps {
  element?: React.ReactNode | null;
  index: true;
}

/**
 * Route 组件内部没有进行任何操作，仅仅只是定义 props，而我们就是为了使用它的 props
 */
export function Route(
  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps
): React.ReactElement | null {
  // 这里可以看出 Route 不能够被渲染出来，渲染会直接抛出错误，证明 Router 拿到 Route 后也不会在内部操作
  invariant(
    false,
    `A <Route> is only ever to be used as the child of <Routes> element, ` +
      `never rendered directly. Please wrap your <Route> in a <Routes>.`
  );
}
```

- 总结

  a. Route可以被看做一个挂载用户传入参数的对象，它不会在页面中渲染，而是会被Routes接受并解析

##### 3.4.1.3 routes

```tsx
export interface RoutesProps {
  children?: React.ReactNode;
  // 用户传入的 location 对象，一般不传，默认用当前浏览器的 location
  location?: Partial<Location> | string;
}

/**
 * 所有的 Route 都需要 Routes 包裹，用于渲染 Route（拿到 Route 的 props 的值，不渲染真实的 DOM 节点）
 */
export function Routes({
  children,
  location
}: RoutesProps): React.ReactElement | null {
  return useRoutes(createRoutesFromChildren(children), location);
}
```

- createRoutesFromChildren

```tsx
// 路由配置对象
export interface RouteObject {
  // 路由 path 是否匹配大小写
  caseSensitive?: boolean;
  // 子路由
  children?: RouteObject[];
  // 要渲染的组件
  element?: React.ReactNode;
  // 是否是索引路由
  index?: boolean;
  path?: string;
}

/**
 * 将 Route 组件转换为 route 对象，提供给 useRoutes 使用
 */
export function createRoutesFromChildren(
  children: React.ReactNode
): RouteObject[] {
  let routes: RouteObject[] = [];

  // 内部逻辑很简单，就是递归遍历 children，获取 <Route /> props 上的所有信息，然后格式化后推入 routes 数组中
  React.Children.forEach(children, element => {
    if (!React.isValidElement(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }

    // 空节点，忽略掉继续往下遍历
    if (element.type === React.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(
        routes,
        createRoutesFromChildren(element.props.children)
      );
      return;
    }

    // 不要传入其它组件，只能传 Route
    invariant(
      element.type === Route,
      `[${
        typeof element.type === "string" ? element.type : element.type.name
      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    );

    let route: RouteObject = {
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path
    };

    // 递归
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children);
    }

    routes.push(route);
  });

  return routes;
}
```

- useRoutes:声明式配置路由，下面详细介绍

- 总结

  a. react-router在路由定义时包含两种方式

  - 指令式：<routes><route></route></routes>，指令式内部也是声明式形式
  - 声明式：useRoutes

  b. Routes与Route强绑定，有Routes则必定要传入且只能传入Route

##### 3.4.1.4 useRoutes

假如我们代码里使用

```jsx
import { useRoutes } from "react-router-dom";

// 此时 App 返回的就是已经渲染好的路由元素了
function App() {
  let element = useRoutes([
    {
      path: "/",
      element: <Dashboard />,
      children: [
        {
          path: "/messages",
          element: <DashboardMessages />
        },
        { path: "/tasks", element: <DashboardTasks /> }
      ]
    },
    { path: "/team", element: <AboutPage /> }
  ]);

  return element;
}
```

- RouteContext

```tsx
/**
 * 动态参数的定义
 */
export type Params<Key extends string = string> = {
  readonly [key in Key]: string | undefined;
};

export interface RouteMatch<ParamKey extends string = string> {
  // params 参数，比如 :id 等
  params: Params<ParamKey>;
  // 匹配到的 pathname
  pathname: string;
  /**
   * 子路由匹配之前的路径 url，这里可以把它看做是只要以 /* 结尾路径（这是父路由的路径）中 /* 之前的部分
   */
  pathnameBase: string;
  // 定义的路由对象
  route: RouteObject;
}

interface RouteContextObject {
  // 一个 ReactElement，内部包含有所有子路由组成的聚合组件，其实 Outlet 组件内部就是它
  outlet: React.ReactElement | null;
  // 一个成功匹配到的路由数组，索引从小到大层级依次变深
  matches: RouteMatch[];
}
/**
 * 包含全部匹配到的路由，官方不推荐在外直接使用
 */
const RouteContext = React.createContext<RouteContextObject>({
  outlet: null,
  matches: []
});

/** @internal */
export {
  RouteContext as UNSAFE_RouteContext
};
```

- 拆解useRoutes

```tsx
/**
 * 1.该 hooks 不是只调用一次，每次重新匹配到路由时就会重新调用渲染新的 element
 * 2.当多次调用 useRoutes 时需要解决内置的 route 上下文问题，继承外层的匹配结果
 * 3.内部通过计算所有的 routes 与当前的 location 关系，经过路径权重计算，得到 matches 数组，然后将 matches 数组重新渲染为嵌套结构的组件
 */
export function useRoutes(
  routes: RouteObject[],
  locationArg?: Partial<Location> | string
): React.ReactElement | null {
  // useRoutes 必须最外层有 Router 包裹，不然报错
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`
  );

  // 1.当此 useRoutes 为第一层级的路由定义时，matches 为空数组（默认值）
  // 2.当该 hooks 在一个已经调用了 useRoutes 的渲染环境中渲染时，matches 含有值（也就是有 Routes 的上下文环境嵌套）
  let { matches: parentMatches } = React.useContext(RouteContext);
  // 最后 match 到的 route（深度最深），该 route 将作为父 route，我们后续的 routes 都是其子级
  let routeMatch = parentMatches[parentMatches.length - 1];
  // 下面是父级 route 的参数，我们会基于以下参数操作，如果项目中只在一个地方调用了 useRoutes，一般都会是默认值
  let parentParams = routeMatch ? routeMatch.params : {};
  // 父路由的完整 pathname，比如路由设置为 /foo/*，当前导航是 /foo/1，那么 parentPathname 就是 /foo/1
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  // 同上面的 parentPathname，不过是 /* 前的部分，也就是 /foo
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  // 获取上下文环境中的 location
  let locationFromContext = useLocation();

  // 判断是否手动传入了 location，否则用默认上下文的 location
  let location;
  if (locationArg) {
    // 格式化为 Path 对象
    let parsedLocationArg =
      typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    // 如果传入了 location，判断是否与父级路由匹配（作为子路由存在）
    invariant(
      parentPathnameBase === "/" ||
        parsedLocationArg.pathname?.startsWith(parentPathnameBase),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, ` +
        `the location pathname must begin with the portion of the URL pathname that was ` +
        `matched by all parent routes. The current pathname base is "${parentPathnameBase}" ` +
        `but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
    );

    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }

  let pathname = location.pathname || "/";
  // 剩余的 pathname，整体 pathname 减掉父级已经匹配的 pathname，才是本次 routes 要匹配的 pathname（适用于 parentMatches 匹配不为空的情况）
  let remainingPathname =
    parentPathnameBase === "/"
      ? pathname
      : pathname.slice(parentPathnameBase.length) || "/";
  // 匹配当前路径，注意是移除了 parentPathname 的相关路径后的匹配
  
  // 通过传入的 routes 配置项与当前的路径，匹配对应渲染的路由
  let matches = matchRoutes(routes, { pathname: remainingPathname });

  // 参数为当前匹配到的 matches 路由数组和外层 useRoutes 的 matches 路由数组
  // 返回的是 React.Element，渲染所有的 matches 对象
  return _renderMatches(
    // 没有 matches 会返回 null
    matches &&
      matches.map(match =>
        // 合并外层调用 useRoutes 得到的参数，内部的 Route 会有外层 Route（其实这也叫父 Route） 的所有匹配属性。
        Object.assign({}, match, {
          params: Object.assign({}, parentParams, match.params),
          // joinPaths 函数用于合并字符串
          pathname: joinPaths([parentPathnameBase, match.pathname]),
          pathnameBase:
            match.pathnameBase === "/"
              ? parentPathnameBase
              : joinPaths([parentPathnameBase, match.pathnameBase])
        })
      ),
    // 外层 parentMatches 部分，最后会一起加入最终 matches 参数中
    parentMatches
  );
}

/**
 * 将多个 path 合并为一个
 * @param paths path 数组
 * @returns
 */
const joinPaths = (paths: string[]): string =>
  paths.join("/").replace(/\/\/+/g, "/");
```

- 总结： 

  a. 获取上下文中调用useRoutes后的信息，如果证明此次调用时作为子路由使用的，需要合并父路由的匹配信息；

  b. 移除父路由已经匹配完毕的pathname前缀后，调用matchRoutes与当前传入的routes配置相匹配，返回匹配到的matches数组；

  c. 调用_renderMatches方法，渲染上一步得倒的matches数组;

也就对应着：路由上下文解析阶段，路由匹配阶段(matchRoutes),路由渲染阶段(_renderMatches)

- matchRoutes

  ```tsx
  /**
   * 通过 routes 与 location 得到 matches 数组
   */
  export function matchRoutes(
    // 用户传入的 routes 对象
    routes: RouteObject[],
    // 当前匹配到的 location，注意这在 useRoutes 内部是先有过处理的
    locationArg: Partial<Location> | string,
    // 这个参数在 useRoutes 内部是没有用到的，但是该方法是对外暴露的，用户可以使用这个参数来添加统一的路径前缀
    basename = "/"
  ): RouteMatch[] | null {
    // 先格式化为 Path 对象
    let location =
      typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  
    // 之前提到过，抽离 basename，获取纯粹的 pathname
    let pathname = stripBasename(location.pathname || "/", basename);
    
    // basename 匹配失败，返回 null
    if (pathname == null) {
      return null;
    }
  
    // 1.扁平化 routes，将树状的 routes 对象根据 path 扁平为一维数组，同时包含当前路由的权重值
    let branches = flattenRoutes(routes);
    // 2.传入扁平化后的数组，根据内部匹配到的权重排序
    rankRouteBranches(branches);
  
    let matches = null;
    // 3.这里就是权重比较完成后的解析顺序，权重高的在前面，先进行匹配，然后是权重低的匹配
    // branches 中有一个匹配到了就终止循环，或者全都没有匹配到
    for (let i = 0; matches == null && i < branches.length; ++i)   {
      // 遍历扁平化的 routes，查看每个 branch 的路径匹配规则是否能匹配到 pathname
      matches = matchRouteBranch(branches[i], pathname);
    }
  
    return matches;
  }
  ```

- 主要方面：

  a. flattenRoutes: 扁平化

  b. rankRouteBranches：排序

  c. matchRouteBranch：路由匹配

  - flattenRoutes:将树形结构转为一维数组

    ```tsx
    // 保存在 branch 中的路由信息，后续路由匹配时会用到
    interface RouteMeta {
      /**
       * 路由的相对路径（刨除与父路由重复部分）
       */
      relativePath: string;
      caseSensitive: boolean;
      /**
       * 用户在 routes 数组中定义的索引位置（相对其兄弟 route 而言）
       */
      childrenIndex: number;
      route: RouteObject;
    }
    
    // 扁平化的路由对象，包含当前路由对象对应的完整 path，权重得分与用于匹配的路由信息
    interface RouteBranch {
      /**
       * 完整的 path（合并了父路由的，下面会引入相对路由的概念）
       */
      path: string;
      /**
       * 权重，用于排序
       */
      score: number;
      /**
       * 路径 meta，依次为从父级到子级的路径规则，最后一个是路由自己
       */
      routesMeta: RouteMeta[];
    }
    
    /**
     * 扁平化路由，会将所有路由扁平为一个数组，用于比较权重
     * @param routes 第一次在外部调用只需要传入该值，用于转换的 routes 数组
     * @param branches
     * @param parentsMeta
     * @param parentPath
     * @returns
     */
    function flattenRoutes(
      routes: RouteObject[],
      // 除了 routes，下面三个都是递归的时候使用的
      branches: RouteBranch[] = [],
      parentsMeta: RouteMeta[] = [],
      parentPath = ""
    ): RouteBranch[] {
      routes.forEach((route, index) => {
        // 当前 branch 管理的 route meta
        let meta: RouteMeta = {
          // 只保存相对路径，这里的值下面会进行处理
          relativePath: route.path || "",
          caseSensitive: route.caseSensitive === true,
          // index 是用户给出的 routes 顺序，会一定程度影响 branch 的排序（当为同一层级 route 时）
          childrenIndex: index,
          // 当前 route 对象
          route
        };
    
        // 如果 route 以 / 开头，那么它应该完全包含父 route 的 path，否则报错
        if (meta.relativePath.startsWith("/")) {
          invariant(
            meta.relativePath.startsWith(parentPath),
            `Absolute route path "${meta.relativePath}" nested under path ` +
              `"${parentPath}" is not valid. An absolute child route path ` +
              `must start with the combined path of all its parent routes.`
          );
    
          // 把父路由前缀去除，只要相对路径
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
    
        // 完整的 path，合并了父路由的 path
        let path = joinPaths([parentPath, meta.relativePath]);
        // 第一次使用 parentsMeta 为空数组，从外到内依次推入 meta 到该数组中
        let routesMeta = parentsMeta.concat(meta);
    
        // 开始递归
        if (route.children && route.children.length > 0) {
          // 如果是 index route，报错，因为 index route 不能有 children
          invariant(
            route.index !== true,
            `Index routes must not have child routes. Please remove ` +
              `all child routes from route path "${path}".`
          );
    
          flattenRoutes(route.children, branches, routesMeta, path);
        }
    
        // 没有路径的路由（之前提到过的布局路由）不参与路由匹配，除非它是索引路由
        /* 
          注意：递归是在前面进行的，也就是说布局路由的子路由是会参与匹配的
          而子路由会有布局路由的路由信息，这也是布局路由能正常渲染的原因。
        */
        if (route.path == null && !route.index) {
          return;
        }
    
        // routesMeta，包含父 route 到自己的全部 meta 信息
        // computeScore 是计算权值的方法，我们后面再说
        branches.push({ path, score: computeScore(path, route.index), routesMeta });
      });
    
      return branches;
    }
    ```

  - rankRouteBranches

    ```tsx
    // 动态路由权重，比如 /foo/:id
    const dynamicSegmentValue = 3;
    // 索引路由权重，也就是加了 index 为 true 属性的路由
    const indexRouteValue = 2;
    // 空路由权重，当一段路径值为空时匹配，只有最后的路径以 / 结尾才会用到它
    const emptySegmentValue = 1;
    // 静态路由权重
    const staticSegmentValue = 10;
    // 路由通配符权重，为负的，代表当我们写 * 时实际会降低权重
    const splatPenalty = -2;
    
    // 判断是否有动态参数，比如 :id 等
    const paramRe = /^:\w+$/;
    // 判断是否为 *
    const isSplat = (s: string) => s === "*";
    
    /**
     * 计算路由权值，根据权值大小匹配路由
     * 静态值 > params 动态参数
     * @param path 完整的路由路径，不是相对路径
     * @param index
     * @returns
     */
    function computeScore(path: string, index: boolean | undefined): number {
      let segments = path.split("/");
      // 初始化权重值，有几段路径就是几，路径多的初始权值高
      let initialScore = segments.length;
      // 有一个 * 权重减 2
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
    
      // 用户传了 index，index 是布尔值，代表 IndexRouter，权重 +2
      if (index) {
        initialScore += indexRouteValue;
      }
    
      // 在过滤出非 * 的部分
      return segments
        .filter(s => !isSplat(s))
        .reduce(
          (score, segment) =>
            score +
            // 如果有动态参数
            (paramRe.test(segment)
              ? // 动态参数权重 3
                dynamicSegmentValue
              : segment === ""
              ? // 空值权重为 1，这个其实只有一种情况，path 最后面多一个 /，比如 /foo 与 /foo/ 的区别
                emptySegmentValue
              : // 静态值权重最高为 10
                staticSegmentValue),
          initialScore
        );
    }
    
    /**
     * 排序，比较权重值
     * @param branches
     */
    function rankRouteBranches(branches: RouteBranch[]): void {
      branches.sort((a, b) =>
        a.score !== b.score
          // 排序，权值大的在前面
          ? b.score - a.score
          : // 如果 a.score === b.score
            compareIndexes(
              // routesMeta 是一个从最外层路由到子路由的数组
              // childrenIndex 是按照 routes 中 route 传入的顺序传值的，写在后面的 index 更大（注意是同级）
              a.routesMeta.map(meta => meta.childrenIndex),
              b.routesMeta.map(meta => meta.childrenIndex)
            )
      );
    }
    
    
    /**
     * 比较子 route 的 index，判断是否为兄弟 route，如果不是则返回 0，比较没有意义，不做任何操作
     * @param a
     * @param b
     * @returns
     */
    function compareIndexes(a: number[], b: number[]): number {
      // 是否为兄弟 route
      let siblings =
        // 这里是比较除了最后一个 route 的 path，需要全部一致才是兄弟 route
        a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
    
      return siblings
        ? 
          // 如果是兄弟节点，按照传入的顺序排序 a.length - 1 和 b.length - 1 是相等的，只是内部的值不同
          a[a.length - 1] - b[b.length - 1]
        : 
          // 只比较兄弟节点，如果不是兄弟节点，则权重相同
          0;
    }
    ```

  - matchRouteBranch

  ```tsx
  /**
   * 通过 branch 和当前的 pathname 得到真正的 matches 数组
   * @param branch
   * @param routesArg
   * @param pathname
   * @returns
   */
  function matchRouteBranch<ParamKey extends string = string>(
    branch: RouteBranch,
    pathname: string
  ): RouteMatch<ParamKey>[] | null {
    let { routesMeta } = branch;
  
    // 初始化匹配到的值
    let matchedParams = {};
    let matchedPathname = "/";
    // 最终的 matches 数组
    let matches: RouteMatch[] = [];
    // 遍历 routesMeta 数组，最后一项是自己的 route，前面是 parentRoute
    for (let i = 0; i < routesMeta.length; ++i) {
      let meta = routesMeta[i];
      // 是否为最后一个 route
      let end = i === routesMeta.length - 1;
      // pathname 匹配过父 route 后的剩余的路径名
      let remainingPathname =
        matchedPathname === "/"
          ? pathname
          : pathname.slice(matchedPathname.length) || "/";
      // 使用的相对路径规则匹配剩余的值
      let match = matchPath(
        // 在匹配时只有最后一个 route 的 end 才会是 true，其余都是 false，这里的 end 意味路径最末尾的 /
        { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
        remainingPathname
      );
  
      // 没匹配上，直接返回 null，整个 route 都匹配失败
      if (!match) return null;
  
      // 匹配上了合并 params，注意这里是改变的 matchedParams，所以所有 route 的 params 都是同一个
      Object.assign(matchedParams, match.params);
  
      let route = meta.route;
  
      // 匹配上了就把路径再补全
      matches.push({
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match.pathname]),
        pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
        route
      });
  
      // 更改 matchedPathname，已经匹配上的 pathname 前缀，用作后续子 route 的循环
      if (match.pathnameBase !== "/") {
        matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
      }
    }
  
    return matches;
  }
  ```

- _renderMatches

  ![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1653642757557-b4892d92-ac95-4d3a-bc26-63bdc9d88633.png)

```tsx
/**
 * 其实就是渲染 RouteContext.Provider 组件（包括多个嵌套的 Provider）
 */
function _renderMatches(
  matches: RouteMatch[] | null,
  // 如果在已有 match 的 route 内部调用，会合并父 context 的 match
  parentMatches: RouteMatch[] = []
): React.ReactElement | null {
  if (matches == null) return null;

  // 生成 outlet 组件，注意这里是从后往前 reduce，所以索引在前的 match 是最外层，也就是父路由对应的 match 是最外层
  /**
   *  可以看到 outlet 是通过不断递归生成的组件，最外层的 outlet 递归层数最多，包含有所有的内层组件，
   *  所以我们在外层使用的 <Outlet /> 是包含有所有子组件的聚合组件
   * */
  return matches.reduceRight((outlet, match, index) => {
    return (
      <RouteContext.Provider
        // 如果有 element 就渲染 element，如果没有填写 element，则默认是 <Outlet />，继续渲染内嵌的 <Route />
        children={
          match.route.element !== undefined ? match.route.element : <Outlet />
        }
        // 代表当前 RouteContext 匹配到的值，matches 并不是全局状态一致的，会根据层级不同展示不同的值，最后一个层级是完全的 matches，这也是之前提到过的不要在外部使用 RouteContext 的原因
        value={{
          outlet,
          matches: parentMatches.concat(matches.slice(0, index + 1))
        }}
      />
    );
    // 最内层的 outlet 为 null，也就是最后的子路由
  }, null as React.ReactElement | null);
}
```

- 总结

  a. useRoutes是react-router中核心，用户不管是直接使用useRoutes还是用Routes与Route组件结合最终都会转换为它。该hook拥有三个阶段：路由上下文解析阶段、路由匹配阶段、路由渲染阶段；

  b. useRoutes在上下文解析阶段会解析在外层是否已经调用过useRoutes，如果调用过会先获取外层的上下文数据，最后将外层数据与用户传入的routes数组结合，生成最终结果；

  c. useRoutes在匹配阶段会将传入的routes与当前的location（可手动传入，但内部会做校验）做一层匹配，通过对route中声明的path的权重计算，拿到当前pathname所能匹配到的最佳matches数组，索引从小到大层数关系从外到内；

  d. useRoutes在渲染阶段会将matches数组渲染为一个聚合的React Element，该元素整体是许多 RouteContext.Provider的嵌套，从外到内依次是【父 => 子 => 孙子】这样的关系，每个 Provider包含两个值，与该级别对应的matches数组（最后的元素时该级别的route自身）与outlet元素，outlet元素就是嵌套RouteContext.Provider存放的地方，每个RouteContext.Provider的children就是route的element属性；

  e. 每次使用outlet实际上都是渲染的内置的路由关系（如果当前route没有element属性，则默认渲染outlet，这也是为什么可以直接写不带element的<Route/>组件嵌套的原因），我们可以在当前级别route的element中任意地方使用outlet来渲染子路由;

##### 3.4.1.5 Navigate

```tsx
// useNavigate 返回的 navigate 函数定义，可以传入 to 或者传入数字控制浏览器页面栈的显示
export interface NavigateFunction {
  (to: To, options?: NavigateOptions): void;
  (delta: number): void;
}

export interface NavigateOptions {
  // 是否替换当前栈
  replace?: boolean;
  // 当前导航的 state
  state?: any;
}

/**
 * 返回的 navigate 函数可以传和文件夹相同的路径规则
 */
export function useNavigate(): NavigateFunction {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`
  );
  
  // Router 提供的 navigator，本质是 history 对象
  let { basename, navigator } = React.useContext(NavigationContext);
  // 当前路由层级的 matches 对象（我们在前面说了，不同的 RouteContext.Provider 层级不同该值不同）
  let { matches } = React.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();

  // 依次匹配到的子路由之前的路径（/* 之前）
  let routePathnamesJson = JSON.stringify(
    matches.map(match => match.pathnameBase)
  );

  // 是否已经初始化完毕（useEffect），这里是要让页面不要在一渲染的时候就跳转，应该在 useEffect 后才能跳转，也就是说如果一渲染就要跳转页面应该写在 useEffect 中
  let activeRef = React.useRef(false);
  React.useEffect(() => {
    activeRef.current = true;
  });

  // 返回的跳转函数
  let navigate: NavigateFunction = React.useCallback(
    (to: To | number, options: NavigateOptions = {}) => {
      if (!activeRef.current) return;

      // 如果是数字
      if (typeof to === "number") {
        navigator.go(to);
        return;
      }

      // 实际路径的获取，这个方法比较复杂，我们下面单独说
      let path = resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname
      );

      // 有 basename，加上 basename
      if (basename !== "/") {
        path.pathname = joinPaths([basename, path.pathname]);
      }

      (!!options.replace ? navigator.replace : navigator.push)(
        path,
        options.state
      );
    },
    [basename, navigator, routePathnamesJson, locationPathname]
  );

  return navigate;
}

import type { To } from 'history';

export interface NavigateProps {
  // To 从 history 中引入
  /*
    export declare type To = string | PartialPath;
  */
  to: To;
  replace?: boolean;
  state?: any;
}

/**
 * 组件式导航，当页面渲染后立刻调用 navigate 方法，很简单的封装
 */
export function Navigate({ to, replace, state }: NavigateProps): null {
  // 必须在 Router 上下文中
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    `<Navigate> may be used only in the context of a <Router> component.`
  );

  let navigate = useNavigate();
  React.useEffect(() => {
    navigate(to, { replace, state });
  });

  return null;
}
```

- 总结：Navigate内部还是调用的useNavigate，而useNavigate内部则是对用户传入的路径做处理，获取到最终的路径值，再传递给NavigationContext提供navigator对象；

#### 3.4.2 react-router-dom

主要介绍在react-router-dom中引用的BrowserRouter 、 hashRouter 以及 historyRouter

BrowserRouter 和 HashRouter的区别，是区分链接还是hash，从history库中取到

```tsx
import { createBrowserHistory, createHashHistory } from "history";
```

##### 3.4.2.1 BrowserRouter

```tsx
export interface BrowserRouterProps {
  basename?: string;
  children?: React.ReactNode;
  window?: Window;
}

/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */
export function BrowserRouter({
  basename,
  children,
  window,
}: BrowserRouterProps) {
  let historyRef = React.useRef<BrowserHistory>();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({ window });
  }

  let history = historyRef.current;
  let [state, setState] = React.useState({
    action: history.action,
    location: history.location,
  });

  React.useLayoutEffect(() => history.listen(setState), [history]);

  return (
    <Router
      basename={basename}
      children={children}
      location={state.location}
      navigationType={state.action}
      navigator={history}
    />
  );
}
```

##### 3.4.2.2 hashRouter

```tsx
export interface HashRouterProps {
  basename?: string;
  children?: React.ReactNode;
  window?: Window;
}

/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */
export function HashRouter({ basename, children, window }: HashRouterProps) {
  let historyRef = React.useRef<HashHistory>();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({ window });
  }

  let history = historyRef.current;
  let [state, setState] = React.useState({
    action: history.action,
    location: history.location,
  });

  React.useLayoutEffect(() => history.listen(setState), [history]);

  return (
    <Router
      basename={basename}
      children={children}
      location={state.location}
      navigationType={state.action}
      navigator={history}
    />
  );
}
```

##### 3.4.2.3 HistoryRouter

```tsx
export interface HistoryRouterProps {
  basename?: string;
  children?: React.ReactNode;
  history: History;
}

/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */
function HistoryRouter({ basename, children, history }: HistoryRouterProps) {
  const [state, setState] = React.useState({
    action: history.action,
    location: history.location,
  });

  React.useLayoutEffect(() => history.listen(setState), [history]);

  return (
    <Router
      basename={basename}
      children={children}
      location={state.location}
      navigationType={state.action}
      navigator={history}
    />
  );
}

if (__DEV__) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}

export { HistoryRouter as unstable_HistoryRouter };
```

## 4. 学习react-router的依赖库--history库

https://www.yuque.com/lpldplws/web/yr5hmd?singleDoc# 《配套习题》 密码：fggd

地址：https://github.com/remix-run/history

react-router v6 相比 v5 的api 有着很大的变动，代码包体积也减少了一半多（20k => 8k），源码行数缩减到了 1600 行，基本可以当做reafactor了一遍，下面主要讲解其依赖的history库究竟完成了什么样的功能

### 4.1 定义

The history library lets you easily manage session history anywhere JavaScript runs. A history object abstracts away the differences in various environments and provides a minimal API that lets you manage the history stack, navigate, and persist state between sessions.

history库可让您在 JavaScript 运行的任何地方轻松管理会话历史记录。history 实例基于环境中的差异，抽象出了一个最小的 API，让您可以管理历史堆栈、导航和保持会话之间的状态。

1. createBrowserHistory：基于浏览器history对象最新 api；

2. createHashHistory：基于浏览器 url 的 hash 参数；

3. createMemoryHistory：基于内存栈，不依赖任何平台；

上面三种方法创建的history对象在react-router中作为三种主要路由的导航器使用：

- BrowserRouter对应createBrowserHistory，由react-router-dom提供

- HashRouter对应createHashHistory，由react-router-dom提供

- MemoryRouter对应createMemoryHistory，由react-router提供，主要用于react-native等基于内存的路由系统

react-router-native是MemoryRouter 换了层皮

```tsx
export interface NativeRouterProps extends MemoryRouterProps {}

/**
 * NativeRouter 就是 react-router 里的 MemoryRouter，使用内存做导航
 * A <Router> that runs on React Native.
 */
export function NativeRouter(props: NativeRouterProps) {
  return <MemoryRouter {...props} />;
}
```

StaticRouter 用于SSR，不依赖history，只对props进行校验

```tsx
import { StaticRouter } from 'react-router-dom/server'
```

### 4.2 路由切换时Action

history定义了三类action：

```tsx
export enum Action {
  Pop = 'POP',
  Push = 'PUSH',
  Replace = 'REPLACE'
}

```

### 4.3 抽象Path与Location

在一次url跳转中，history抽象了两层：Path 和 Location

#### 4.3.1 Path

```tsx
// 下面三个分别是对 url 的 path，query 与 hash 部分的类型别名
export type Pathname = string;
export type Search = string;
export type Hash = string;

// 一次跳转 url 对应的对象
export interface Path {
  pathname: Pathname;
  search: Search;
  hash: Hash;
}

/**
 *  pathname + search + hash 创建完整 url
 */
export function createPath({
  pathname = '/',
  search = '',
  hash = ''
}: Partial<Path>) {
  if (search && search !== '?')
    pathname += search.charAt(0) === '?' ? search : '?' + search;
  if (hash && hash !== '#')
    pathname += hash.charAt(0) === '#' ? hash : '#' + hash;
  return pathname;
}

/**
 * 解析 url，将其转换为 Path 对象
 */
export function parsePath(path: string): Partial<Path> {
  let parsedPath: Partial<Path> = {};

  if (path) {
    let hashIndex = path.indexOf('#');
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }

    let searchIndex = path.indexOf('?');
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }

    if (path) {
      parsedPath.pathname = path;
    }
  }

  return parsedPath;
}
```

#### 4.3.2 Location

记录url变化时上下文（state）以及唯一值key

```ts
// 唯一字符串，与每次跳转的 location 匹配
export type Key = string;

// 路由跳转抽象化的导航对象
export interface Location extends Path {
  // 与当前 location 关联的 state 值，可以是任意手动传入的值
  state: unknown;
  // 当前 location 的唯一 key，一般都是自动生成
  key: Key;
}

/**
 * 创建唯一 key
 */
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
```

### 4.4 学习History对象

createBrowserHistory、createHashHistory 以及 createMemoryHistory是基于一个基类的History创建的

#### 4.4.1 base history

一个基类的history包含：

- action（跳转行为）、location（导航对象）
- utils：createHref：将history定义的Path转为url

```ts
history.createHref({
    pathname: '/home',
    search: 'the=query',
    hash:'hash'
}) // 输出: /home?the=query#hash
```

- 路由的跳转方法：push、replace、go、back与forward

```ts
// 将一个新的历史导航推入历史栈，并且移动当前指针到该历史导航
history.push('/home');
// 将当前的路由使用新传入的历史导航替换
history.replace('/home');

// 此方法可以传入一个 Path 对象，同时也可以接收第二个参数 state，可用于保存在内存中的历史导航上下文信息
history.push({
  pathname: '/home',
  search: '?the=query'
}, {
  some: state
});

// replace 方法同上
history.replace({
  pathname: '/home',
  search: '?the=query'
}, {
  some: state
});

// 返回上一个历史导航
history.go(-1);
history.back();

// 去往下一个历史导航
history.go(1);
history.forward();
```

- 路由监听方法：listen、block
  - history.listen：类似后置守卫，在跳转后监听
  - history.block：类似前置钩子，跳转前监听；

- ```ts
  // 开始监听路由跳转
  let unlisten = history.listen(({ action, location }) => {
    // The current location changed.
  });
  
  // 取消监听
  unlisten();
  
  // 开始阻止路由跳转
  let unblock = history.block(({ action, location, retry }) => {
    // retry 方法可以让我们重新进入被阻止跳转的路由
    // 取消监听，如果想要 retry 生效，必须要在先取消掉所有 block 监听，否则 retry 后依然会被拦截然后进入 block 监听中
    unblock();
    retry();
  });
  ```

- History对象的接口定义

```ts
// listen 回调的参数，包含有更新的行为 Action 和 Location 对象
export interface Update {
  action: Action; // 上面提到的 Action
  location: Location; // 上面提到的 Location
}

// 监听函数 listener 的定义
export interface Listener {
  (update: Update): void;
}


// block 回调的参数，除了包含有 listen 回调参数的所有值外还有一个 retry 方法
// 如果阻止了页面跳转（blocker 监听），可以使用 retry 重新进入页面
export interface Transition extends Update {
  /**
   * 重新进入被 block 的页面
   */
  retry(): void;
}

/**
 * 页面跳转失败后拿到的 Transition 对象
 */
export interface Blocker {
  (tx: Transition): void;
}

// 跳转链接，可以是完整的 url，也可以是 Path 对象
export type To = string | Partial<Path>;

export interface History {
  // 最后一次浏览器跳转的行为，可变
  readonly action: Action;

  // 挂载有当前的 location 可变
  readonly location: Location;

  // 工具方法，把 to 对象转化为 url 字符串，其实内部就是对之前提到的 createPath 函数的封装
  createHref(to: To): string;

  // 推入一个新的路由到路由栈中
  push(to: To, state?: any): void;
  // 替换当前路由
  replace(to: To, state?: any): void;
  // 将当前路由指向路由栈中第 delta 个位置的路由
  go(delta: number): void;
  // 将当前路由指向当前路由的前一个路由
  back(): void;
  // 将当前路由指向当前路由的后一个路由
  forward(): void;

  // 页面跳转后触发，相当于后置钩子
  listen(listener: Listener): () => void;

  // 也是监听器，但是会阻止页面跳转，相当于前置钩子，注意只能拦截当前 history 对象的钩子，也就是说如果 history 对象不同，是不能够拦截到的
  block(blocker: Blocker): () => void;
}
```

#### 4.4.2 History对象的创建

- createBrowserHistory

用于给用户提供的创建基于浏览器 history API 的History对象，适用于绝大多数现代浏览器（除了少部分不支持 HTML5 新加入的 history API 的浏览器，也就是浏览器的history对象需要具有pushState、replaceState和state等属性和方法），同时在生产环境需要服务端的重定向配置才能正常使用；

- createHashHistory

用于给用户提供基于浏览器 url hash 值的History对象，一般来说使用这种方式可以兼容几乎所有的浏览器，但是考虑到目前浏览器的发展，在5.x版本内部其实同createBrowserHistory，也是使用最新的 history API 实现路由跳转的（如果你确实需要兼容旧版本浏览器，应该选择使用4.x版本），同时由于浏览器不会将 url 的 hash 值发送到服务端，前端发送的路由 url 都是一致的，就不用服务端做额外配置了；

- createMemoryHistory

用于给用户提供基于内存系统的History对象，适用于所有可以运行 JavaScript 的环境（包括 Node），内部的路由系统完全由用户支配

```ts
export interface BrowserHistory extends History {}
export interface HashHistory extends History {}
export interface MemoryHistory extends History {
  readonly index: number;
}
```

- BrowserHistory与HashHistory的类型就是我们之前提到的History对象的类型；
- MemoryHistory还有一个index属性，因为是基于内存的路由系统，所以我们可以清楚知道当前路由在历史栈中的位置，这个属性就是告诉用户目前的内存历史栈索引的；
- createBrowserHistory

```tsx
// 可以传入指定的 window 对象作为参数，默认为当前 window 对象
export type BrowserHistoryOptions = { window?: Window };

export function createBrowserHistory(
  options: BrowserHistoryOptions = {}
): BrowserHistory {
  let { window = document.defaultView! } = options;
  // 拿到浏览器的 history 对象，后续会基于此对象封装方法
  let globalHistory = window.history;
  // 初始化 action 与 location
  let action = Action.Pop;
  let [index, location] = getIndexAndLocation(); // 获取当前路由的 index 和 location

  // 省略其余代码
  
  let history: BrowserHistory = {
    get action() {
      return action;
    },
    get location() {
      return location;
    },
    createHref,
    push,
    replace,
    go,
    back() {
      go(-1);
    },
    forward() {
      go(1);
    },
    listen(listener) {
       // 省略其余代码
    },
    block(blocker) {
       // 省略其余代码
    }
  };

  return history;
}
```

- createHashHistory

```tsx
// 这里同 BrowserRouter
export type HashHistoryOptions = { window?: Window };

export function createHashHistory(
options: HashHistoryOptions = {}
): HashHistory {
  let { window = document.defaultView! } = options;
       // 浏览器本身就有 history 对象，只是 HTML5 新加入了几个有关 state 的 api
       let globalHistory = window.history;
       let action = Action.Pop;
       let [index, location] = getIndexAndLocation();
  
  // 省略其余代码
  
  let history: HashHistory = {
    get action() {
      return action;
    },
    get location() {
      return location;
    },
    createHref,
    push,
    replace,
    go,
    back() {
      go(-1);
    },
    forward() {
      go(1);
    },
    listen(listener) {
      // 省略其余代码
    },
    block(blocker) {
      // 省略其余代码
    }
  };
  
  return history;
}
```

- createMemoryHistory

```ts
// 这里与 BrowserRouter 和 HashRouter 相比有略微不同，因为没有浏览器的参与，所以我们需要模拟历史栈
// 用户提供的描述历史栈的对象
export type InitialEntry = string | Partial<Location>;// 上面提到的 Location 

// 因为不是真实的路由，所以不需要 window 对象，取而代之的是
export type MemoryHistoryOptions = {
  // 初始化的历史栈
  initialEntries?: InitialEntry[];
  // 初始化的 index
  initialIndex?: number;
};


// 判断上下限值
function clamp(n: number, lowerBound: number, upperBound: number) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}

export function createMemoryHistory(
  options: MemoryHistoryOptions = {}
): MemoryHistory {
  let { initialEntries = ['/'], initialIndex } = options;
  // 将用户传入的 initialEntries 转换为包含 Location 对象数组，会在之后用到
  let entries: Location[] = initialEntries.map((entry) => {
    // readOnly 就是调用 Object.freeze 冻结对象，这里做了个开发模式的封装，遇到都可以直接跳过
    let location = readOnly<Location>({
      pathname: '/',
      search: '',
      hash: '',
      state: null,
      key: createKey(),
      ...(typeof entry === 'string' ? parsePath(entry) : entry)
    });
    return location;
  });
  // 这里的 location 与 index 的获取方式不同了，是直接从初始化的 entries 中取的
  let action = Action.Pop;
  let location = entries[index];
  // clamp 函数用于取上下限值，如果 没有传 initialIndex 默认索引为最后一个 location
  // 这这里调用是为了规范初始化的 initialIndex 的值
  let index = clamp(
    initialIndex == null ? entries.length - 1 : initialIndex,
    0,
    entries.length - 1
  );

  // 省略其余代码
  let history: MemoryHistory = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return location;
    },
    createHref,
    push,
    replace,
    go,
    back() {
      go(-1);
    },
    forward() {
      go(1);
    },
    listen(listener) {
       // 省略其余代码
    },
    block(blocker) {
       // 省略其余代码
    }
  };

  return history;
}
```

##### 4.4.2.1 action、location与index

除了createMemoryHistory，其余两个方法的index和location都是通过getIndexAndLocation()获取的。下面是getIndexAndLocation()方法的内部逻辑：

- createBrowserHistory

```ts
export function createBrowserHistory(
  options: BrowserHistoryOptions = {}
): BrowserHistory {
  let { window = document.defaultView! } = options;
  let globalHistory = window.history;

  /**
   * 拿到当前的 state 的 idx 和 location 对象
   */
  function getIndexAndLocation(): [number, Location] {
    let { pathname, search, hash } = window.location;
    // 获取当前浏览器的 state
    let state = globalHistory.state || {};
    // 可以看到下面很多属性都是保存到了 history api 的 state 中
    return [
      state.idx,
      readOnly<Location>({
        pathname,
        search,
        hash,
        state: state.usr || null,
        key: state.key || 'default'
      })
    ];
  }
  let action = Action.Pop;
  let [index, location] = getIndexAndLocation();
  
  // 初始化 index
  if (index == null) {
    index = 0;
    // 调用的是 history api 提供的 replaceState 方法传入 index，这里只是初始化浏览器中保存的 state，没有改变 url
    globalHistory.replaceState({ ...globalHistory.state, idx: index }, '');
  }

  //...

  let history: BrowserHistory = {
    get action() {
      return action;
    },
    get location() {
      return location;
    }
    // ...
  };

  return history;
}
```

- createHashHistory

```ts
export function createHashHistory(
  options: HashHistoryOptions = {}
): HashHistory {
  let { window = document.defaultView! } = options;
  let globalHistory = window.history;

 function getIndexAndLocation(): [number, Location] {
    // 注意这里和 browserHistory 不同了，拿的是 hash，其余逻辑是一样的
    // parsePath 方法前面有讲到过，解析 url 为 Path 对象
    let {
      pathname = '/',
      search = '',
      hash = ''
    } = parsePath(window.location.hash.substr(1));
    let state = globalHistory.state || {};
    return [
      state.idx,
      readOnly<Location>({
        pathname,
        search,
        hash,
        state: state.usr || null,
        key: state.key || 'default'
      })
    ];
  }

  let action = Action.Pop;
  let [index, location] = getIndexAndLocation();

 if (index == null) {
    index = 0;
    globalHistory.replaceState({ ...globalHistory.state, idx: index }, '');
  }
  //...

  let history: HashHistory = {
    get action() {
      return action;
    },
    get location() {
      return location;
    }
    // ...
  };

  return history;
}
```

##### 4.4.2.2 createHref

主要用于将history内部定义的To对象（type To = string | Partial<Path>）转回为 url 字符串

- createBrowserHistory

```ts
export function createBrowserHistory(
  options: BrowserHistoryOptions = {}
): BrowserHistory {
   // ...
   // BrowserHistory 只需要简单判断一下类型就可以了
  function createHref(to: To) {
    return typeof to === 'string' ? to : createPath(to); // createPath见上文
  }
  // ...
  let history: BrowserHistory = {
      // ...
      createHref
      // ...
  }
  return history
}
```

- createHashHistory

```ts
export function createHashHistory(
  options: HashHistoryOptions = {}
): HashHistory {
   // ...
   /**
   * 查看是否有 base 标签，如果有则取 base 的 url（不是从 base 标签获取，是从 window.location.href 获取）
   */
  function getBaseHref() {
    let base = document.querySelector('base');
    let href = '';

    if (base && base.getAttribute('href')) {
      let url = window.location.href;
      let hashIndex = url.indexOf('#');
      // 拿到去除了 # 的 url
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }

    return href;
  }
  // HashHistory 需要额外拿到当前页面的 base url
  function createHref(to: To) {
    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));
  }

  // ...

  let history: HashHistory = {
      // ...
      createHref
      // ...
  }
  return history
}
```

- createMemoryHistory

```ts
export function createMemoryHistory(
  options: MemoryHistoryOptions = {}
): MemoryHistory {
   // ...
   // 同 BrowserHistory
  function createHref(to: To) {
    return typeof to === 'string' ? to : createPath(to);
  }
  // ...

  let history: MemoryHistory = {
      // ...
      createHref
      // ...
  }
  return history
}
```

##### 4.4.2.3 listen

本质上是事件的发布订阅模式

```ts
/**
 * 事件对象
 */
type Events<F> = {
  length: number;
  push: (fn: F) => () => void;
  call: (arg: any) => void;
};

/**
 * 内置的发布订阅事件模型
 */
function createEvents<F extends Function>(): Events<F> {
  let handlers: F[] = [];

  return {
    get length() {
      return handlers.length;
    },
    // push 时返回对应的 clear 语句
    push(fn: F) {
      handlers.push(fn);
      return function () {
        handlers = handlers.filter((handler) => handler !== fn);
      };
    },
    call(arg) {
      handlers.forEach((fn) => fn && fn(arg));
    }
  };
}

export interface Update {
  action: Action;
  location: Location;
}
// Listener 类型在之前有提到过，可以往回看看
export interface Listener {
  (update: Update): void;
}

export function createBrowserHistory(
  options: BrowserHistoryOptions = {}
): BrowserHistory {
  // ...
  let listeners = createEvents<Listener>();
  // ...
  let history: BrowserHistory = {
    // ...
    listen(listener) {
      return listeners.push(listener);
    },
    // ...
  };

  return history;
}

export function createHashHistory(
  options: HashHistoryOptions = {}
): HashHistory {
  // ...
  let listeners = createEvents<Listener>();
  // ...
  let history: HashHistory = {
    // ...
    listen(listener) {
      return listeners.push(listener);
    },
    // ...
  };

  return history;
}

export function createMemoryHistory(
  options: MemoryHistoryOptions = {}
): MemoryHistory {
  // ...
  let listeners = createEvents<Listener>();
  // ...
  let history: MemoryHistory = {
    // ...
    listen(listener) {
      return listeners.push(listener);
    },
    // ...
  };

  return history;
}
```

##### 4.4.2.5 block

与listen类似，只是BrowserHistory和HashHistory内部额外对于浏览器的beforeunload事件做了监听

```ts
export interface Update {
  action: Action;
  location: Location;
}
export interface Transition extends Update {
  retry(): void;
}

// Blocker 我们之前也提到过
export interface Blocker {
  (tx: Transition): void;
}

const BeforeUnloadEventType = 'beforeunload';

export function createBrowserHistory(
  options: BrowserHistoryOptions = {}
): BrowserHistory {
  // ...
  let blockers = createEvents<Blocker>();
  // ...
  let history: BrowserHistory = {
    // ...
    block(blocker) {
      let unblock = blockers.push(blocker);

      // 当我们需要监听跳转失败时才加入，并且只需要一个事件来阻止页面关闭
      if (blockers.length === 1) {
        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }

      return function () {
        unblock();
        // 当没有 blocker 监听时应该删除 beforeunload 事件的监听
        if (!blockers.length) {
          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
    // ...
  };

  return history;
}

export function createHashHistory(
  options: HashHistoryOptions = {}
): HashHistory {
  // ...
  let blockers = createEvents<Blocker>();
  // ...
  let history: HashHistory = {
    // ...
    block(blocker) {
      let unblock = blockers.push(blocker);

      if (blockers.length === 1) {
        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }

      return function () {
        unblock();
        if (!blockers.length) {
          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
    // ...
  };
  return history;
}

// MemoryHistory 这里同 listen 方法一样
export function createMemoryHistory(
  options: MemoryHistoryOptions = {}
): MemoryHistory {
  // ...
  let blockers = createEvents<Blocker>();
  // ...
  let history: MemoryHistory = {
    // ...
    // 这里就没有监听浏览器的 beforeunload 事件了
    block(blocker) {
      return blockers.push(blocker);
    }
    // ...
  };

  return history;
}
```

##### 4.4.2.5 push & replace

push和replace除了需要封装将新的导航推入到历史栈的功能外，还需要同时改变当前的action与location，并且判断并调用相应的监听方法

- createBrowserHistory 和 createHasHistory

```ts
function push(to: To, state?: any) {
    let nextAction = Action.Push;
    let nextLocation = getNextLocation(to, state);

    /**
     * 重新执行 push 操作
     */
    function retry() {
      push(to, state);
    }

    // 当没有 block 监听时 allowTx 返回 true，否则都是返回 false，不会推送新的导航
    if (allowTx(nextAction, nextLocation, retry)) {
      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);

      // try...catch 是因为 ios 限制最多调用 100 次 pushState 方法，否则会报错
      try {
        globalHistory.pushState(historyState, '', url);
      } catch (error) {
        // push 失败后就没有 state 了，直接使用 href 跳转
        window.location.assign(url);
      }

      applyTx(nextAction);
    }
}

function replace(to: To, state?: any) {
    let nextAction = Action.Replace;
    let nextLocation = getNextLocation(to, state);
    function retry() {
      replace(to, state);
    }

    // 同 push 函数，否则不会替换新的导航
    if (allowTx(nextAction, nextLocation, retry)) {
      let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);

      globalHistory.replaceState(historyState, '', url);

      applyTx(nextAction);
    }
}
```

- createMemoryHistory

```ts
function push(to: To, state?: any) {
  let nextAction = Action.Push;
  let nextLocation = getNextLocation(to, state);
  function retry() {
    push(to, state);
  }

  if (allowTx(nextAction, nextLocation, retry)) {
    // 修改 index 与 entries 历史栈数组
    index += 1;
    // 添加一个新的 location，删除原来 index 往后的栈堆
    entries.splice(index, entries.length, nextLocation);
    applyTx(nextAction, nextLocation);
  }
}

function replace(to: To, state?: any) {
  let nextAction = Action.Replace;
  let nextLocation = getNextLocation(to, state);
  function retry() {
    replace(to, state);
  }

  if (allowTx(nextAction, nextLocation, retry)) {
    // 覆盖掉原来的 location
    entries[index] = nextLocation;
    applyTx(nextAction, nextLocation);
  }
}
```

##### 4.4.2.6 浏览器popstate事件

在浏览器环境下，除了手动调用 history.push 与 history.replace 外，用户还可以通过浏览器的前进和后退按钮改变导航历史，这样的行为在history中则对应着Action的POP，同时浏览器也提供了对应的事件popstate，需要在createBrowserHistory和createHashHistory 事件下处理

```ts
const HashChangeEventType = 'hashchange';
const PopStateEventType = 'popstate';

export function createBrowserHistory(
  options: BrowserHistoryOptions = {}
): BrowserHistory {
   //...

  let blockedPopTx: Transition | null = null;
  /**
   * 事件监听回调函数
   * 如果设置了 blocker 的监听器，该函数会执行两次，第一次是跳回到原来的页面，第二次是执行 blockers 的所有回调
   * 这个函数用于监听浏览器的前进后退，因为我们封装的 push 函数已经被我们拦截了
   */
  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      let nextAction = Action.Pop;
      let [nextIndex, nextLocation] = getIndexAndLocation();

      // 如果有前置钩子
      if (blockers.length) {
        if (nextIndex != null) {
          // 计算跳转层数
          let delta = index - nextIndex;
          if (delta) {
            // Revert the POP
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              // 恢复页面栈，也就是 nextIndex 的页面栈
              retry() {
                go(delta * -1);
              }
            };
            // 跳转回去（index 原本的页面栈）
            go(delta);
          }
        } else {
          // asset
          // nextIndex 如果为 null 会进入该分支打警告信息，这里就先不管它
        }
      } else {
        // 改变当前 action，调用所有的 listener
        applyTx(nextAction);
      }
    }
  }

  // 可以看到在创建 History 对象的时候就进行监听了
  window.addEventListener(PopStateEventType, handlePop);
  //...
}


export function createHashHistory(
  options: HashHistoryOptions = {}
): HashHistory {
   //...

  // 下面和 createBrowserHistory 一样
  let blockedPopTx: Transition | null = null;
  function handlePop() {
    //...
  }
  
    
  // 下面额外监听了 hashchange 事件
  window.addEventListener(PopStateEventType, handlePop);
  // 低版本兼容，监听 hashchange 事件
  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event
  window.addEventListener(HashChangeEventType, () => {
    let [, nextLocation] = getIndexAndLocation();

    // 如果支持 popstate 事件这里就会相等，因为会先执行 popstate 的回调
    if (createPath(nextLocation) !== createPath(location)) {
      handlePop();
    }
  });
  //...
}
```

##### 4.4.2.7 go、back、forward

- createBrowserHistory 与 createHashHistory 

```ts
export function createBrowserHistory(
  options: BrowserHistoryOptions = {}
): BrowserHistory {
  // ...
  function go(delta: number) {
    globalHistory.go(delta);
  }
  // ...
  let history: BrowserHistory = {
    go,
    back() {
      go(-1);
    },
    forward() {
      go(1);
    },
    // ...
  };

  return history;
}

export function createHashHistory(
  options: HashHistoryOptions = {}
): HashHistory {
  // ...
  function go(delta: number) {
    globalHistory.go(delta);
  }
  // ...
  let history: HashHistory = {
    go,
    back() {
      go(-1);
    },
    forward() {
      go(1);
    },
    // ...
  };

  return history;
}
```

- createMemoryHistory

```ts
export function createMemoryHistory(
  options: MemoryHistoryOptions = {}
): HashHistory {
  // ...
  function go(delta: number) {
    // 跳转到原来的 location
    let nextIndex = clamp(index + delta, 0, entries.length - 1);
    let nextAction = Action.Pop;
    let nextLocation = entries[nextIndex];
    function retry() {
      go(delta);
    }

    if (allowTx(nextAction, nextLocation, retry)) {
      index = nextIndex;
      applyTx(nextAction, nextLocation);
    }
  }
  // ...
  let history: MemoryHistory = {
    go,
    back() {
      go(-1);
    },
    forward() {
      go(1);
    },
    // ...
  };

  return history;
}
```

# React SSR & 同构

https://www.yuque.com/lpldplws/web/qbadd9?singleDoc# 《React SSR & 同构》 密码：wg39

https://www.gatsbyjs.com/     --ssr

https://www.npmjs.com/package/xianzao-ui

https://github.com/xianzao/xianzao-ui

## 1. 课程目标

1. 掌握CSR与SSR的区别，掌握SSR的基本用法；
2. 学会在React中如何使用SSR；
3. 实战中掌握SSR里，router、redux、api的封装；

## 2. 课程大纲

1. SSR定义
2. SSR由来
3. 服务端渲染的利弊
4. 同构
5. SSR实战

## 3.SSR 定义

页面的渲染流程：

1. 浏览器通过请求得到一个HTML文本
2. 渲染进程解析HTML文本，构建DOM树
3. 解析HTML的同时，如果遇到内联样式或者样式脚本，则下载并构建样式规则（stytle rules），若遇到JavaScript脚本，则会下载执行脚本。
4. DOM树和样式规则构建完成之后，渲染进程将两者合并成渲染树（render tree）
5. 渲染进程开始对渲染树进行布局，生成布局树（layout tree）
6. 渲染进程对布局树进行绘制，生成绘制记录
7. 渲染进程的对布局树进行分层，分别栅格化每一层，并得到合成帧
8. 渲染进程将合成帧信息发送给GPU进程显示到页面中

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1658411852170-3f0d3576-b151-42e5-95da-9572124b6fd6.png)



可以看到，页面的渲染其实就是浏览器将HTML文本转化为页面帧的过程。而如今我们大部分WEB应用都是使用 JavaScript 框架（Vue、React、Angular）进行页面渲染的，也就是说，在执行 JavaScript 脚本的时候，HTML页面已经开始解析并且构建DOM树了，JavaScript 脚本只是动态的改变 DOM 树的结构，使得页面成为希望成为的样子，这种渲染方式叫动态渲染，也可以叫客户端渲染（client side rende）；

那么什么是服务端渲染（server side render）？顾名思义，服务端渲染就是在浏览器请求页面URL的时候，服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中。这个服务端组装HTML的过程，叫做服务端渲染；

![img](https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20200731165404271.png)

## 4.SSR由来

### 4.1 web1.0

在没有AJAX的时候，也就是web1.0时代，几乎所有应用都是服务端渲染（此时服务器渲染非现在的服务器渲染），那个时候的页面渲染大概是这样的，浏览器请求页面URL，然后服务器接收到请求之后，到数据库查询数据，将数据丢到后端的组件模板（php、asp、jsp等）中，并渲染成HTML片段，接着服务器在组装这些HTML片段，组成一个完整的HTML，最后返回给浏览器，这个时候，浏览器已经拿到了一个完整的被服务器动态组装出来的HTML文本，然后将HTML渲染到页面中，过程没有任何JavaScript代码的参与。

[![img](https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20200731115513579.png)](https://raw.githubusercontent.com/yacan8/blog/master/images/服务端渲染原理/image-20200731115513579.png)

### 4.2 客户端渲染

在WEB1.0时代，服务端渲染看起来是一个当时的最好的渲染方式，但是随着业务的日益复杂和后续AJAX的出现，也渐渐开始暴露出了WEB1.0服务器渲染的缺点。

- 每次更新页面的一小的模块，都需要重新请求一次页面，重新查一次数据库，重新组装一次HTML
- 前端JavaScript代码和后端（jsp、php、jsp）代码混杂在一起，使得日益复杂的WEB应用难以维护

而且那个时候，根本就没有前端工程师这一职位，前端js的活一般都由后端同学 jQuery 一把梭。但是随着前端页面渐渐地复杂了之后，后端开始发现js好麻烦，虽然很简单，但是坑太多了，于是让公司招聘了一些专门写js的人，也就是前端，这个时候，前后端的鄙视链就出现了，后端鄙视前端，因为后端觉得js太简单，无非就是写写页面的特效（JS），切切图（CSS），根本算不上是真正的程序员。

随之 nodejs 的出现，前端看到了翻身的契机，为了摆脱后端的指指点点，前端开启了一场前后端分离的运动，希望可以脱离后端独立发展。前后端分离，表面上看上去是代码分离，实际上是为了前后端人员分离，也就是前后端分家，前端不再归属于后端团队。

前后端分离之后，网页开始被当成了独立的应用程序（SPA，Single Page Application），前端团队接管了所有页面渲染的事，后端团队只负责提供所有数据查询与处理的API，大体流程是这样的：首先浏览器请求URL，前端服务器直接返回一个空的静态HTML文件（不需要任何查数据库和模板组装），这个HTML文件中加载了很多渲染页面需要的 JavaScript 脚本和 CSS 样式表，浏览器拿到 HTML 文件后开始加载脚本和样式表，并且执行脚本，这个时候脚本请求后端服务提供的API，获取数据，获取完成后将数据通过JavaScript脚本动态的将数据渲染到页面中，完成页面显示。

[![img](https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20200731142605631.png)](https://raw.githubusercontent.com/yacan8/blog/master/images/服务端渲染原理/image-20200731142605631.png)

这一个前后端分离的渲染模式，也就是客户端渲染（CSR）。

### 4.3 服务端渲染

随着单页应用（SPA）的发展，程序员们渐渐发现 SEO（Search Engine Optimazition，即搜索引擎优化）出了问题，而且随着应用的复杂化，JavaScript 脚本也不断的臃肿起来，使得首屏渲染相比于 Web1.0时候的服务端渲染，也慢了不少。

自己选的路，跪着也要走下去。于是前端团队选择了使用 nodejs 在服务器进行页面的渲染，进而再次出现了服务端渲染。大体流程与客户端渲染有些相似，首先是浏览器请求URL，前端服务器接收到URL请求之后，根据不同的URL，前端服务器向后端服务器请求数据，请求完成后，前端服务器会组装一个携带了具体数据的HTML文本，并且返回给浏览器，浏览器得到HTML之后开始渲染页面，同时，浏览器加载并执行 JavaScript 脚本，给页面上的元素绑定事件，让页面变得可交互，当用户与浏览器页面进行交互，如跳转到下一个页面时，浏览器会执行 JavaScript 脚本，向后端服务器请求数据，获取完数据之后再次执行 JavaScript 代码动态渲染页面。

[![img](https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20200731172929911.png)](https://raw.githubusercontent.com/yacan8/blog/master/images/服务端渲染原理/image-20200731172929911.png)

## 5. 服务端渲染的利弊

相比于客户端渲染，服务端渲染有什么优势？

### 5.1. 好处

- 利于SEO

有利于SEO，其实就是有利于爬虫来爬你的页面，然后在别人使用搜索引擎搜索相关的内容时，你的网页排行能靠得更前，这样你的流量就有越高。那为什么服务端渲染更利于爬虫爬你的页面呢？其实，爬虫也分低级爬虫和高级爬虫。

- - 低级爬虫：只请求URL，URL返回的HTML是什么内容就爬什么内容。
  - 高级爬虫：请求URL，加载并执行JavaScript脚本渲染页面，爬JavaScript渲染后的内容。

也就是说，低级爬虫对客户端渲染的页面来说，简直无能为力，因为返回的HTML是一个空壳，它需要执行 JavaScript 脚本之后才会渲染真正的页面。而目前像百度、谷歌、微软等公司，有一部分年代老旧的爬虫还属于低级爬虫，使用服务端渲染，对这些低级爬虫更加友好一些。

- 白屏时间更短

相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。

[![img](https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20200731165404271.png?date=1677586921182)

### 5.2. 缺点 

并不是所有的WEB应用都必须使用SSR，这需要开发者自己来权衡，因为服务端渲染会带来以下问题：

- 代码复杂度增加。为了实现服务端渲染，应用代码中需要兼容服务端和客户端两种运行情况，而一部分依赖的外部扩展库却只能在客户端运行，需要对其进行特殊处理，才能在服务器渲染应用程序中运行。

- 需要更多的服务器负载均衡。由于服务器增加了渲染HTML的需求，使得原本只需要输出静态资源文件的nodejs服务，新增了数据获取的IO和渲染HTML的CPU占用，如果流量突然暴增，有可能导致服务器down机，因此需要使用响应的缓存策略和准备相应的服务器负载。

- 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。

# 6.同构

在服务端渲染中，有两种页面渲染的方式：

- 前端服务器通过请求后端服务器获取数据并组装 HTML 返回给浏览器，浏览器直接解析 HTML 后渲染页面

- 浏览器在交互过程中，请求新的数据并动态更新渲染页面

这两种渲染方式有一个不同点就是，一个是在服务端中组装 html 的，一个是在客户端中组装 html 的，运行环境是不一样的。所谓同构，就是让一份代码，既可以在服务端中执行，也可以在客户端中执行，并且执行的效果都是一样的，都是完成这个 html 的组装，正确的显示页面。也就是说，一份代码，既可以客户端渲染，也可以服务端渲染。

![img](https://raw.githubusercontent.com/yacan8/blog/master/images/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/image-20200731175841011.png?date=1677587030193)

## 7. SSR实战 

完成同构SPA的SSR应用

1. 基本功能

2. router

3. redux

4. api

# React组件库设计

https://www.yuque.com/lpldplws/web/fab8hw?singleDoc# 《React组件库设计》 密码：iol1

## 1.课程目标

P6~P6+：

1. 学习React组件库设计原理；
2. 掌握常见组件库架构设计分析；

P7~P7+：

1. 能够结合业务从0~1完成组件库开发搭建；
2. 熟悉现有市场上组件库方案，能够结合业务完成组件库的落地；

## 2. 课程大纲

- 项目初始化；
- 开发调试；
- 编译打包；
- 标准化发布流程；

## 3. 主要内容

### 3.1 项目初始化

主要安装项目依赖文件

### 3.1.1 初始化npm包

```ts
mkdir xianzao-ui

cd xianzao-ui

npm init --y // 默认跳过或者自定义完成初始化
```

#### 3.1.2 代码规范

多人项目里代码规范是，基于时间原因，直接使用现成的 [@umijs/fabric](https://github.com/umijs/fabric) 的配置。

```ts
npm i @umijs/fabric prettier -D // 因为@umijs/fabric没有将prettier作为依赖 所以我们需要手动安装
```

如果不想使用这套规范，可以自定义配置

- [EditorConfig](https://editorconfig.org/)：不同编辑器和IDE之间定义和维护一致的代码风格；.editorconfig；

```bash
# http://editorconfig.org
root = true

[*]
charset = utf-8
end_of_line = lf
indent_size = 2
indent_style = space
insert_final_newline = true
max_line_length = 80
trim_trailing_whitespace = true

[*.md]
max_line_length = 0
```

- [ESlint](https://github.com/eslint/eslint)：代码检查工具； .eslintrc.js；

ESLint 是一个Javascript Linter，帮助我们规范代码质量，提高团队开发效率。

社区比较知名的代码规范，eslint 配合这些代码规范，能够检测出代码潜在问题，从而提高代码质量。

- [standardjs](https://standardjs.com/readme-zhcn.html)
- [airbnb](https://github.com/airbnb/javascript)

```bash
module.exports = {
  env: {
    browser: true,
    es6: true,
    node: true,
  },
  parser: "babel-eslint", // 解析器
  extends: [], // 扩展
  plugins: [], // 插件
  globals: {
    Atomics: "readonly",
    SharedArrayBuffer: "readonly",
  },
  parserOptions: {
    ecmaVersion: 2018,
    sourceType: "module",
  },
  rules: {},
};
```

- [prettier](https://prettier.io/docs/en/)：一个 Opinionated 的代码格式化工具； .prettierrc；

eslint 虽然能帮助我们提高代码质量，但并不能完全统一编码风格，因为这些代码规范的重点并不在代码风格上，虽然有一定的限制。prettier 是一个能够统一团队编码风格的工具，能够极大的提高团队执行效率，统一的编码风格能很好的保证代码的可读性。

```bash
{
  "quotes": true,
  "semi": true,
  "tabWidth": 2
}
```

- [husky](https://github.com/typicode/husky/)：一个让配置 git hooks 变得更简单的工具； .huskyrc；

原理：husky会根据 package.json里的配置，在.git/hooks目录生成的 hook 脚本（如果你已经自定义了一个hook脚本，husky不会覆盖它）；

```bash
{
  "hooks": {
    "pre-commit": "lint-staged"
  }
}
```

- [lint-staged](https://github.com/okonet/lint-staged)：只对 git 中变更的文件进行 lint 操作；.lintstagedrc；

针对暂存的 git 文件运行 linters，不要让不符合规则的代码溜进代码库。lint-staged总是将 所有暂存文件的列表传递给任务，忽略任何文件都应该在任务本身中配置，比如：.prettierignore / .eslintignore 。lint-stage 总是配合 husky一起使用。

```bash
{
  "src/**/*.js": [
    "eslint --fix",
    "prettier --write",
    "git add"
  ]
}
```

#### 3.1.3 commit lint

进行pre-commit代码规范检测；

```bash
npm i husky lint-staged -D
```

```ts
"lint-staged": {
  "src/**/*.ts?(x)": [
    "prettier --write",
    "eslint --fix",
    "git add"
  ],
  "src/**/*.less": [
    "stylelint --syntax less --fix",
    "git add"
  ]
},
"husky": {
  "hooks": {
    "pre-commit": "lint-staged"
  }
}
```

进行`commit message`检测：

```bash
npm i @commitlint/cli @commitlint/config-conventional commitizen cz-conventional-changelog -D
```

- [commintlint](https://commitlint.js.org/#/)：结合git commit 完成commit message的标准校验；

新增`.commitlintrc.js`写入以下内容：

```bash
module.exports = { extends: ['@commitlint/config-conventional'] };
```

- `commitizen` `cz-conventional-changelog`可以用来生成标准的changeLog；

```bash
"scripts": {
  "commit": "git-cz",
},
"husky": {
  "hooks": {
    "commit-msg": "commitlint -E HUSKY_GIT_PARAMS",
    "pre-commit": "lint-staged"
  }
},
"config": {
  "commitizen": {
    "path": "cz-conventional-changelog"
  }
}
```

后续就可以使用`npm run commit`生成标准的changeLog了；

可以git init初始化git项目

#### 3.1.4 typescript



https://react.iamkasong.com/

https://www.yuque.com/lpldplws/atomml/tmbe7ykqmslqszhe?singleDoc# 《JavaScript高级用法(1/2)》 密码：bwxh
https://www.yuque.com/lpldplws/atomml/os260aysmxgeyhhm?singleDoc# 《JavaScript高级用法(2/2)》 密码：ih4c

（建议有时间的同学可以精读一下，对理解JS有很大的帮助）：http://es5.github.io/#x8.7

https://www.yuque.com/lpldplws/atomml/dh5rlaq0xygdkok5?singleDoc# 《浏览器事件模型&请求》 密码：qnyz

https://www.yuque.com/lpldplws/atomml/my01zht47ol0dh2u?singleDoc# 《JavaScript的垃圾回收和内存泄漏》 密码：kb86

https://www.yuque.com/lpldplws/atomml/xnudhigbps5in504?singleDoc# 《JavaScript的运行机制》 密码：zglx

https://www.yuque.com/lpldplws/atomml/gtn6hvlf3fh1gl6e?singleDoc# 《前端异步处理规范及应用》 密码：cdik

https://www.yuque.com/lpldplws/web/dn72m7?singleDoc# 《Vue基础用法》 密码：xrw9
https://www.yuque.com/lpldplws/web/ck0csfxciuzol315?singleDoc# 《Vue高级用法》 密码：tczl
https://www.yuque.com/lpldplws/web/hadz6f?singleDoc# 《Vue2源码解析（1/2）》 密码：mq90
https://www.yuque.com/lpldplws/web/xx3ygi?singleDoc# 《Vue2源码解析（2/2）》 密码：ya0n
https://www.yuque.com/lpldplws/web/gdw840?singleDoc# 《Vue3新特性&源码解析（1/3）》 密码：mmo8
https://www.yuque.com/lpldplws/web/myfkf4?singleDoc# 《配套习题》 密码：oir9
https://www.yuque.com/lpldplws/web/gmptis?singleDoc# 《Vue3新特性&源码解析（2/3）》 密码：qke4
https://www.yuque.com/lpldplws/web/ty5nga?singleDoc# 《Vue3新特性&源码解析（3/3）》 密码：apwp
https://www.yuque.com/lpldplws/web/sp3cao?singleDoc# 《配套习题》 密码：kv13

https://github.com/XiNiHa/streaming-ssr-showcase 流式渲染的例子

https://www.yuque.com/lpldplws/web/xhqomd?singleDoc# 《前端模块化》 密码：xnou

https://www.yuque.com/lpldplws/web/xpzv1mgsqh7s7b0a?singleDoc# 《函数式编程》 密码：hcu6

https://www.yuque.com/lpldplws/web/lg3g1s?singleDoc# 《React基础》 密码：tv0g
https://www.yuque.com/lpldplws/web/ai228r?singleDoc# 《配套习题》 密码：xnvm
https://www.yuque.com/lpldplws/web/bcocaq?singleDoc# 《React高级用法》 密码：acr1
https://www.yuque.com/lpldplws/web/agvv1m?singleDoc# 《配套习题》 密码：ex5l

https://2022.stateofjs.com/zh-hans/

https://www.yuque.com/lpldplws/web/apczyp?singleDoc# 《React核心源码解析（1/2）》 密码：iwfp
https://www.yuque.com/lpldplws/web/oqnqc7?singleDoc# 《React核心源码解析（2/2）》 密码：xmq3
https://www.yuque.com/lpldplws/web/tmbe7ykqmslqszhe?singleDoc# 《JavaScript高级用法(1/2)》 密码：bwxh

# React核心源码解析（1/2）

https://www.yuque.com/lpldplws/web/apczyp?singleDoc# 《React核心源码解析（1/2）》 密码：iwfp

## 1. 课程目标

P6+~P7：

1. 学习React设计原理，掌握React源码架构、约定及其实现的思路；
2. 掌握React 核心模块源码及设计；

P7+~P8：

1. 熟练掌握React源码设计模型，能够基于现有React框架设计周边库；
2. 熟练掌握React生态，能够从0~1完整地实现React技术栈的前端架构设计；

## 2. 课程大纲

- 理念篇

- - React理念

- - - 新老React架构对比
    - Fiber架构详解

- - 前置知识

- - - 源码文件结构
    - 深入理解JSX

- 架构篇

- - render阶段

- - - 流程概览
    - beginWork
    - completeWork

- - commit阶段

- - - 流程概览
    - before mutation
    - mutation
    - layout

## 3. 主要内容

### 3.1. 理念篇

#### 3.1.1. React理念

##### 3.1.1.1. React理念介绍

我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。

ui = render (data) -> 单向数据流

如何提升页面响应交互？

- CPU卡顿：大量计算操作导致的性能问题
- IO卡顿：网络请求延时的，无法快速响应

1. CPU卡顿

- 在浏览器刷新频率为60HZ的情况下（即1000ms / 60HZ = 16.6ms）浏览器刷新一次
- 浏览器里JS线程与GUI线程是互斥的，不可同时执行，所以JS脚本和浏览器的render、painting不能同时执行，所以执行顺序为：`JS脚本执行 ->样式布局 ->样式绘制`，JS执行时间超过16.6ms，就不会执行render与painting了

```jsx
// index.js
import ReactDOM from "react-dom";

import App from "./App";

const rootElement = document.getElementById("root");

// ReactDOM.render(<App />, rootElement);
ReactDOM.createRoot(rootElement).render(<App />);

// APP.js
import "./styles.css";

export default function App() {
  const len = 3000;

  return (
    <ul>
      {Array(len)
        .fill(0)
        .map((_, i) => (
          <li>{i}</li>
        ))}
    </ul>
  );
}
```

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654241941632-b1abf063-ba5e-4717-953e-603893c41a70.png)

React 是如何解决这个问题的？

在浏览器每一帧的时间中，预留一些时间给JS线程，React利用这部分时间更新组件（预留的初始时间是5ms）。

https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119

时间切片：把更新过程碎片化，把一个耗时长的任务分成很多小片。执行非阻塞渲染，基于优先级应用更新以及在后台预渲染内容。

在开启concurrent mode后

```jsx
// 通过使用ReactDOM.unstable_createRoot开启Concurrent Mode
// ReactDOM.render(<App/>, rootEl);  
ReactDOM.createRoot(rootEl).render(<App/>);
```

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654241950573-502aa9e4-711d-4f9f-a619-66ad602f02b2.png)

开启时间切片后，React长尾任务会被切到每一帧任务里，执行时间在5ms左右，就可以保障rendering与painting时间了

1. IO卡顿

假设页面加载，是否展示loading

停留时间长：显示loading，加载完成后隐藏

停留时间短：不显示loading，用户无感知，不然loading闪一下

- Suspense：https://17.reactjs.org/docs/concurrent-mode-suspense.html
- useDeferredValue：https://17.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue

demo：

1. suspense & useDeferedValue

https://codesandbox.io/s/u6o2q?file=/src/index.js

2. CM模式会牺牲列表的更新速度，提升输入时的相应速度，重于交互

https://codesandbox.io/s/koyz664q35?file=/src/Clock.js

总结：快速响应 -> 同步的长尾更新转为可中断的异步更新

##### 3.1.1.2. 新老React架构对比

React15：

- Reconciler（协调器）—— 负责找出变化的组件
- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

Reconciler：

https://zh-hans.reactjs.org/docs/codebase-overview.html#reconcilers

在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等API触发更新。

每当有更新发生时，Reconciler会做如下工作：

1. 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM
2. 将虚拟DOM和上次更新时的虚拟DOM对比
3. 通过对比找出本次更新中变化的虚拟DOM
4. 通知Renderer将变化的虚拟DOM渲染到页面上

Renderer：

https://zh-hans.reactjs.org/docs/codebase-overview.html#renderers

由于React支持跨平台，所以不同平台有不同的Renderer。我们前端最熟悉的是负责在浏览器环境渲染的Renderer —— ReactDOM。

除此之外，还有：

ReactNative：渲染App原生组件

ReactArt：渲染到Canvas, SVG 或 VML (IE8)

在每次更新发生时，Renderer接到Reconciler通知，将变化的组件渲染在当前宿主环境。

React 15架构的缺点

在Reconciler中，mount的组件会调用[mountComponent](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498)，update的组件会调用[updateComponent](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877)。这两个方法会递归更新子组件

递归的缺点：

1. 当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿
2. React 15不支持用可中断的异步更新代替同步的更新

demo：

https://codesandbox.io/s/fervent-sutherland-pf7sg?file=/src/App.js

正常：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654243825493-5c3864f5-9741-4d16-8b9e-6ec219e0b4d6.png)

加入同步更新中断

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654243831828-17210451-ef06-4669-88b5-99cf8b40072d.png)

React16：

- Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler
- Reconciler（协调器）—— 负责找出变化的组件
- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

Scheduler（调度器）：

需要一种机制，当浏览器有剩余时间时通知我们，从而完成任务调度。

部分浏览器已经实现了这个API，这就是[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)。但是由于以下因素，React放弃使用：

- 浏览器兼容性
- 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低

基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。下节课详解

Reconciler（协调器）

我们知道，在React15中Reconciler是递归处理虚拟DOM的。让我们看看[React16的Reconciler](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673)

```jsx
// 更新工作从递归变成了可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。

/** @noinline */
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```

Q：如何处理中断更新时DOM渲染不完全？

在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记

标记类型详情：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js

```jsx
export const Placement = /*             */ 0b0000000000010;
export const Update = /*                */ 0b0000000000100;
export const PlacementAndUpdate = /*    */ 0b0000000000110;
export const Deletion = /*              */ 0b0000000001000;
```

整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。

详细官方介绍：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js

Renderer（渲染器）

Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。



![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654243951117-a981b06c-7873-46bd-b759-7e65843973ee.png)

其中红框中的步骤随时可能由于以下原因被中断：

- 有其他更高优任务需要先更新
- 当前帧没有剩余时间

由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM

同时，由于Scheduler和Reconciler都是平台无关的，所以React为他们分别单独发布了一个包

##### 3.1.1.3. Fiber架构详解

fiber的核心思路：在react中遵循代数效应（algebraic effects）

代数效应是函数式编程中的一个概念，用于将副作用从函数调用中分离。

```jsx
function getTotalPicNum(user1, user2) {
  const picNum1 = getPicNum(user1);
  const picNum2 = getPicNum(user2);

  return picNum1 + picNum2;
}
```

假设getPickNum需要异步请求：async await？

- 破坏了上下文的一致性，需要调用它的函数也时async

假如有一个类似的try...catch语法 ------try...handle、perform、resume

```jsx
function getPicNum(name) {
  const picNum = perform name;
  return picNum;
}

try {
  getTotalPicNum('xianzao', 'houwan');
} handle (who) {
  switch (who) {
    case 'xianzao':
      resume with 230;
    case 'houwan':
      resume with 122;
    default:
      resume with 0;
  }
}
```

代数效应：将副作用（例子中为请求图片数量）从函数逻辑中分离，使函数关注点保持纯粹，也就是不用关心是同步还是异步

Example：Hooks，不用关心useState中state是如何保存变化的，我们只需要使用即可

Q：为什么不使用generator？

- 类似async，会影响上下文；
- generator的执行状态时上下文关联的

```jsx
function* doWork(A, B, C) {
  var x = doExpensiveWorkA(A);
  yield;
  var y = x + doExpensiveWorkB(B);
  yield;
  var z = y + doExpensiveWorkC(C);
  return z;
}
```

- 单一任务中断执行：ok；
- 中间有高优先级的任务：但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成doExpensiveWorkA与doExpensiveWorkB计算出x与y。此时B组件接收到一个高优更新，由于Generator执行的中间状态是上下文关联的，所以计算y时无法复用之前已经计算出的x，需要重新计算；
- 使用全局变量保存之前的中间状态，引入新的复杂度；

React Fiber

1. 定义：React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。
2. 功能：

1. - 作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler；

2. - 作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息；

3. - 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）；

react fiber node定义

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117

```jsx
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // Instance，静态节点的数据结构属性
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber，用来链接其他fiber节点形成的fiber树
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  // 作为动态的工作单元的属性
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  this.effectTag = NoEffect;
  this.subtreeTag = NoSubtreeEffect;
  this.deletions = null;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  // 作为调度优先级的属性
  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  // 指向该fiber在另一次更新时对应的fiber
  this.alternate = null;

  if (enableProfilerTimer) {
    // Note: The following is done to avoid a v8 performance cliff.
    //
    // Initializing the fields below to smis and later updating them with
    // double values will cause Fibers to end up having separate shapes.
    // This behavior/bug has something to do with Object.preventExtension().
    // Fortunately this only impacts DEV builds.
    // Unfortunately it makes React unusably slow for some applications.
    // To work around this, initialize the fields below with doubles.
    //
    // Learn more about this here:
    // https://github.com/facebook/react/issues/14365
    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN;

    // It's okay to replace the initial doubles with smis after initialization.
    // This won't trigger the performance cliff mentioned above,
    // and it simplifies other profiler code (including DevTools).
    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }

  if (__DEV__) {
    // This isn't directly used but is handy for debugging internals:
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugNeedsRemount = false;
    this._debugHookTypes = null;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}
```

- 架构层面

```jsx
// 指向父级Fiber节点
this.return = null;
// 指向子Fiber节点
this.child = null;
// 指向右边第一个兄弟Fiber节点
this.sibling = null;

表示的组件结构
function App() {
  return (
    <div>
      i am
      <span>xianzao</span>
    </div>
  )
}
```

Q：为什么指向的父节点是return而不是parent？

因为作为一个工作单元，return指节点执行完completeWork后会返回的下一个节点。子Fiber节点及其兄弟节点完成工作后会返回其父级节点，所以用return指代父级节点

- 作为静态数据结构

```jsx
// Fiber对应组件的类型 Function/Class...
this.tag = tag;
// key属性
this.key = key;
// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹
this.elementType = null;
// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class
this.type = null;
// Fiber对应的真实DOM节点
this.stateNode = null;
```

- 作为动态工作单元

记录更新相关的信息，主要是updateQueue

Q：React Fiber 如何更新DOM？

使用“双缓存”

在内存中绘制当前的fiber dom，绘制完毕后直接替换上一帧的fiber dom，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况

在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber，正在内存中构建的Fiber树称为workInProgress Fiber，两者通过alternate连接

```jsx
currentFiber.alternate === workInProgressFiber;
workInProgressFiber.alternate === currentFiber;
```

React应用的根节点通过current指针指向不同的fiber dom切换，当update时，workInProgressFiber rende完成后会跟currentFiber 替换，下一次更新会将当前currentFiber（上一次的workInProgressFiber）替换

```jsx
function App() {
  const [num, add] = useState(0);
  return (
    <p onClick={() => add(num + 1)}>{num}</p>
  )
}

ReactDOM.render(<App/>, document.getElementById('root'));
```

- mount

1. 首次执行ReactDOM.render会创建fiberRootNode（源码中叫fiberRoot）和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是<App/>所在组件树的根节点；

1. - 区分fiberRootNode与rootFiber：因为在应用中我们可以多次调用ReactDOM.render渲染不同的组件树，他们会拥有不同的rootFiber。但是整个应用的根节点只有一个，那就是fiberRootNode；

2. - fiberRootNode的current会指向当前页面上已渲染内容对应Fiber树，即current Fiber；

3. - 因为是首次渲染，此时页面还没有挂在所有的DOM，所以rootFiber还没有子fiber dom

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654246932925-a3077892-422b-4042-bb63-ae38ff20c0ed.png)

2. render阶段，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为workInProgress Fiber；

1. - 在构建workInProgress Fiber树时会尝试复用current Fiber树中已有的Fiber节点内的属性（后续的diff），在首屏渲染时只有rootFiber存在对应的current fiber（即rootFiber.alternate）

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654247085437-cb8992a3-6b3e-48ad-ad2d-75782d5354a8.png)

3. alternate阶段：此时workInProgress fiber已经构建完成，fiberRootNode的current指向了workInProgress fiber

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654247148286-081629a7-e562-47ba-a8f7-cc3779d5bc60.png)

- update

1. 假设p元素更新，这会开启一次新的render阶段并构建一棵新的workInProgress Fiber 树，且会尽可能服用显有的current Fiber

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654247218297-94d56084-ed60-4406-94ac-1f9dea875e45.png)

2. alternate阶段

workInProgress fiber在更换完后，fiberRootNode的current指针更换·

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654247301806-06a53627-d10b-437a-a443-af336015c7d1.png)

#### 3.1.2. 前置知识

##### 3.1.2.1. 源码文件结构

github地址：https://github.com/facebook/react

```javascript
根目录
├── fixtures        # 包含一些给贡献者准备的小型 React 测试项目
├── packages        # 包含元数据（比如 package.json）和 React 仓库中所有 package 的源码（子目录 src）
├── scripts         # 各种工具链的脚本，比如git、jest、eslint等
```

主要内容在packages中

- react：

- - 地址：https://github.com/facebook/react/tree/main/packages/react
  - 内容：全局React API，如React.createElement、React.Component等

- scheduler：

- - 地址：https://github.com/facebook/react/tree/main/packages/scheduler
  - 内容：scheduler实现

- Shared：

- - 地址：https://github.com/facebook/react/tree/main/packages/shared
  - 内容：其他模块中公用的方法和全局变量

- Render相关

```javascript
- react-art
- react-dom                 # 注意这同时是DOM和SSR（服务端渲染）的入口
- react-native-renderer
- react-noop-renderer       # 用于debug fiber（后面会介绍fiber）
- react-test-renderer
```

- 实验性文件

```javascript
- react-server        # 创建自定义SSR流
- react-client        # 创建自定义的client
- react-fetch         # 用于数据请求
- react-interactions  # 用于测试交互相关的内部特性，比如React的事件模型
- react-reconciler    # Reconciler的实现，你可以用他构建自己的Renderer
```

- 辅助包

```javascript
- react-is       # 用于测试组件是否是某类型
- react-client   # 创建自定义的流
- react-fetch    # 用于数据请求
- react-refresh  # “热重载”的React官方实现
```

- react-reconciler（核心关注点）
- 地址：https://github.com/facebook/react/tree/main/packages/react-reconciler
- 内容：React16核心更新内容

##### 3.1.2.3. 深入理解JSX

Q：

- JSX和Fiber节点是同一个东西么？
- React Component、React Element是同一个东西么，他们和JSX有什么关系？

JSX在编译时会被Babel编译为React.createElement方法，这也是为什么要引入`import React from 'react';`的原因

- React.createELement

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactElement.js#L348

```javascript
export function createElement(type, config, children) {
  let propName;

  const props = {};

  let key = null;
  let ref = null;
  let self = null;
  let source = null;

  if (config != null) {
    // 将 config 处理后赋值给 props
    // ...省略
  }

  const childrenLength = arguments.length - 2;
  // 处理 children，会被赋值给props.children
  // ...省略

  // 处理 defaultProps
  // ...省略

  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
}

const ReactElement = function(type, key, ref, self, source, owner, props) {
  const element = {
    // 标记这是个 React Element
    $$typeof: REACT_ELEMENT_TYPE,

    type: type,
    key: key,
    ref: ref,
    props: props,
    _owner: owner,
  };

  return element;
};
```

在全局API isValidElement里，通过$$typeof判断为REACT_ELEMENT_TYPE即为react元素，所以JSX返回的结构也是react element

```jsx
export function isValidElement(object) {
  return (
    typeof object === 'object' &&
    object !== null &&
    object.$$typeof === REACT_ELEMENT_TYPE
  );
}
```

- React Component

Q：如何判断组件为class或者function组件

Example：https://codesandbox.io/s/jsx-type-blpuo?file=/src/index.js

ClassComponent对应的Element的type字段为AppClass自身。

FunctionComponent对应的Element的type字段为AppFunc自身。

且无法根据引用类型区分

```javascript
AppClass instanceof Function === true;
AppFunc instanceof Function === true;
```

实际上，React根据classComponent原型上的isReactComponent判断是否为ClassComponent

```javascript
ClassComponent.prototype.isReactComponent; // {}
FunctionComponent.prototype.isReactComponent; // undefined
```

- JSX与Fiber节点的关系

- - JSX是一种描述当前组件内容的数据结构，他不包含组件schedule、reconcile、render所需的相关信息

- - - 比如如下信息就不包括在JSX中：组件在更新中的优先级、组件的state、组件被打上的用于Renderer的标记

- - Fiber更多地是一种更新机制

- - - 在组件mount时，Reconciler根据JSX描述的组件内容生成组件对应的Fiber节点
    - 在update时，Reconciler将JSX与Fiber节点保存的数据对比，生成组件对应的Fiber节点，并根据对比结果为Fiber节点打上标记

### 3.2. 架构篇

#### 3.2.1. render阶段

内容：Fiber节点是如何被创建并构建成render树的

##### 3.2.1.1. 流程概览

在render的阶段中，根据是同步还是异步，执行performSyncWorkOnRoot 和 performConcurrentWorkOnRoot

```jsx
// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

区别：是否调用shouldYield。如果当前浏览器帧没有剩余时间，shouldYield会中止循环，直到浏览器有空闲时间后再继续遍历

说明：

- `workInProgress`代表当前已创建的`workInProgress fiber`；
- `performUnitOfWork`方法会创建下一个Fiber节点并赋值给`workInProgress`，并将`workInProgress`与已创建的Fiber节点连接起来构成Fiber树；

虽然fiber reconciler是从stack reconciler重构而来，但都是通过遍历的方式实现可中断的异步递归

1. 递

首先从`rootFiber`开始向下深度优先遍历。为遍历到的每个Fiber节点调用[beginWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)（下面详细讲）；

- 该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来；
- 当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段；

2. 归

在“归”阶段会调用[completeWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)（下面详细讲)处理Fiber节点。

- 当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段；
- 如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段；

“递”和“归”阶段会交错执行直到“归”到rootFiber

```jsx
function App() {
  return (
    <div>
      i am
      <span>text</span>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById("root"));
```

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654251357680-2c8c8590-fea6-4048-b7a4-8e97b35afe5d.png)

```javascript
1. rootFiber beginWork
2. App Fiber beginWork
3. div Fiber beginWork
4. "i am" Fiber beginWork
5. "i am" Fiber completeWork
6. span Fiber beginWork
7. span Fiber completeWork
8. div Fiber completeWork
9. App Fiber completeWork
10. rootFiber completeWork

// 没有叶子节点是因为React针对只有单一文本子节点的Fiber节点做了性能优化

// 递归的格式
function performUnitOfWork(fiber) {
  // 执行beginWork

  if (fiber.child) {
    performUnitOfWork(fiber.child);
  }

  // 执行completeWork

  if (fiber.sibling) {
    performUnitOfWork(fiber.sibling);
  }
}
```

#### 3.2.1.2. beginWork

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075

beginWork的工作是传入当前Fiber节点，创建子Fiber节点

- 入参

```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // ...省略函数体
}
```

- current：当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate
- workInProgress：当前组件对应的Fiber节点
- renderLanes：优先级相关，后面讲

可以根据current!==null，判断组件时mount还是update

- mount：首次渲染，当前组件的fiber节点为null；
- update：之前已经mount，fiber节点不为null；

基于此原因，beginWork的工作可以分为两部分：

- update时：如果current存在，在满足一定条件时可以复用current节点，（diff）这样就能克隆current.child作为workInProgress.child，而不需要新建workInProgress.child；
- mount时：除fiberRootNode以外，current === null。会根据fiber.tag不同，创建不同类型的子Fiber节点；

```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {

  // update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）
  if (current !== null) {
    // ...省略

    // 复用current
    return bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes,
    );
  } else {
    didReceiveUpdate = false;
  }

  // mount时：根据tag不同，创建不同的子Fiber节点
  switch (workInProgress.tag) {
    case IndeterminateComponent: 
      // ...省略
    case LazyComponent: 
      // ...省略
    case FunctionComponent: 
      // ...省略
    case ClassComponent: 
      // ...省略
    case HostRoot:
      // ...省略
    case HostComponent:
      // ...省略
    case HostText:
      // ...省略
    // ...省略其他类型
  }
}
```

- update时

- - didReceiveUpdate = false：不需要新建fiber，可以直接复用
  - !includesSomeLane(renderLanes, updateLanes)，即当前Fiber节点优先级不够（后面讲）

```javascript
if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      didReceiveUpdate = true;
    } else if (!includesSomeLane(renderLanes, updateLanes)) {
      didReceiveUpdate = false;
      switch (workInProgress.tag) {
        // 省略处理
      }
      return bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderLanes,
      );
    } else {
      didReceiveUpdate = false;
    }
  } else {
    didReceiveUpdate = false;
  }
```

- mount时

- - 根据fiber.tag不同，进入不同逻辑的fiber创建
  - 官网地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js
  - 对于常见的组件（FunctionComponent、ClassComponent），会执行reconcileChildren

```javascript
// mount时：根据tag不同，创建不同的Fiber节点
switch (workInProgress.tag) {
  case IndeterminateComponent: 
    // ...省略
  case LazyComponent: 
    // ...省略
  case FunctionComponent: 
    // ...省略
  case ClassComponent: 
    // ...省略
  case HostRoot:
    // ...省略
  case HostComponent:
    // ...省略
  case HostText:
    // ...省略
  // ...省略其他类型
}
```

- reconcileChildren

- - mount组件：创建新的子Fiber节点；
  - update组件：将当前组件与该组件在上次更新时对应的Fiber节点比较（Diff），将比较的结果生成新Fiber节点；

```javascript
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes
) {
  if (current === null) {
    // 对于mount的组件
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // 对于update的组件
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```

- mountChildFibers & reconcileChildFibers

- - 都会生成新的fiber节点返回给workInProgress.child，作为本次beginWork的返回值，在下次performUnitOfWork执行时workInProgress的入参

- effectTag

- - render阶段的工作是在内存中进行，当工作结束后会通知Renderer需要执行的DOM操作。要执行DOM操作的具体类型就保存在fiber.effectTag中

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654252870881-4b6a0db3-1c92-4fb6-a761-aa4d75b9cec8.png)

##### 3.2.1.3. completeWork

- 作用：针对不同的fiber.tag调用不同的处理逻辑
- 地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L673

```javascript
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      return null;
    case ClassComponent: {
      // ...省略
      return null;
    }
    case HostRoot: {
      // ...省略
      updateHostContainer(workInProgress);
      return null;
    }
    case HostComponent: {
      // ...省略
      return null;
    }
  // ...省略
```

- 判断update时我们还需要考虑workInProgress.stateNode != null ?（即该Fiber节点是否存在对应的DOM节点）

```javascript
case HostComponent: {
  popHostContext(workInProgress);
  const rootContainerInstance = getRootHostContainer();
  const type = workInProgress.type;

  if (current !== null && workInProgress.stateNode != null) {
    // update的情况
    // ...省略
  } else {
    // mount的情况
    // ...省略
  }
  return null;
}
```

- update

当update时，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如：

- - onClick、onChange等回调函数的注册
  - 处理style prop
  - 处理DANGEROUSLY_SET_INNER_HTML prop
  - 处理children prop

```javascript
if (current !== null && workInProgress.stateNode != null) {
  // update的情况
  updateHostComponent(
    current,
    workInProgress,
    type,
    newProps,
    rootContainerInstance,
  );
}
```

- - updateHostComponent git地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L225

- - 在updateHostComponent内部，被处理完的props会被赋值给workInProgress.updateQueue，并最终会在commit阶段被渲染在页面上，其中updatePayload为数组形式，他的偶数索引的值为变化的prop key，奇数索引的值为变化的prop value

```javascript
workInProgress.updateQueue = (updatePayload: any);
```

- mount时

- - 为Fiber节点生成对应的DOM节点
  - 将子孙DOM节点插入刚生成的DOM节点中
  - 与update逻辑中的updateHostComponent类似的处理props的过程

```javascript
// mount的情况

// ...省略服务端渲染相关逻辑

const currentHostContext = getHostContext();
// 为fiber创建对应DOM节点
const instance = createInstance(
    type,
    newProps,
    rootContainerInstance,
    currentHostContext,
    workInProgress,
  );
// 将子孙DOM节点插入刚生成的DOM节点中
appendAllChildren(instance, workInProgress, false, false);
// DOM节点赋值给fiber.stateNode
workInProgress.stateNode = instance;

// 与update逻辑中的updateHostComponent类似的处理props的过程
if (
  finalizeInitialChildren(
    instance,
    type,
    newProps,
    rootContainerInstance,
    currentHostContext,
  )
) {
  markUpdate(workInProgress);
}
```

- effectList

Q：作为DOM操作的依据，commit阶段需要找到所有有effectTag的Fiber节点并依次执行effectTag对应操作。难道需要在commit阶段再遍历一次Fiber树寻找effectTag !== null的Fiber节点么？

completeWork在上层函数completeUnitOfWork上维护了一个单向链表

effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。

类似appendAllChildren，在“归”阶段，所有有effectTag的Fiber节点都会被追加在effectList中，最终形成一条以rootFiber.firstEffect为起点的单向链表。

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1744

```javascript
                      nextEffect         nextEffect
rootFiber.firstEffect -----------> fiber -----------> fiber
```

- 最后

在performSyncWorkOnRoot函数中fiberRootNode被传递给commitRoot方法，开启commit阶段工作流程。

```javascript
commitRoot(root);
```

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654253478313-a71f1a18-fe86-44d3-b615-ae56bf8a693f.png)

#### 3.2.2. commit阶段

##### 3.2.2.1. 流程概览

```javascript
commitRoot(root);
```

在rootFiber.firstEffect上保存了一条需要执行副作用的Fiber节点的单向链表effectList，这些Fiber节点的updateQueue中保存了变化的props

这些副作用对应的DOM操作在commit阶段执行。

源码地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2001

除此之外，一些生命周期钩子（比如componentDidXXX）、hook（比如useEffect）需要在commit阶段执行。

commit阶段的主要工作（即Renderer的工作流程）分为三部分：

1. before mutation阶段（执行DOM操作前）
2. mutation阶段（执行DOM操作）
3. layout阶段（执行DOM操作后）

- before mutation

```javascript
do {
    // 触发useEffect回调与其他同步任务。由于这些任务可能触发新的渲染，所以这里要一直遍历执行直到没有任务
    flushPassiveEffects();
  } while (rootWithPendingPassiveEffects !== null);

  // root指 fiberRootNode
  // root.finishedWork指当前应用的rootFiber
  const finishedWork = root.finishedWork;

  // 凡是变量名带lane的都是优先级相关
  const lanes = root.finishedLanes;
  if (finishedWork === null) {
    return null;
  }
  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  // 重置Scheduler绑定的回调函数
  root.callbackNode = null;
  root.callbackId = NoLanes;

  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
  // 重置优先级相关变量
  markRootFinished(root, remainingLanes);

  // 清除已完成的discrete updates，例如：用户鼠标点击触发的更新。
  if (rootsWithPendingDiscreteUpdates !== null) {
    if (
      !hasDiscreteLanes(remainingLanes) &&
      rootsWithPendingDiscreteUpdates.has(root)
    ) {
      rootsWithPendingDiscreteUpdates.delete(root);
    }
  }

  // 重置全局变量
  if (root === workInProgressRoot) {
    workInProgressRoot = null;
    workInProgress = null;
    workInProgressRootRenderLanes = NoLanes;
  } else {
  }

  // 将effectList赋值给firstEffect
  // 由于每个fiber的effectList只包含他的子孙节点
  // 所以根节点如果有effectTag则不会被包含进来
  // 所以这里将有effectTag的根节点插入到effectList尾部
  // 这样才能保证有effect的fiber都在effectList中
  let firstEffect;
  if (finishedWork.effectTag > PerformedWork) {
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // 根节点没有effectTag
    firstEffect = finishedWork.firstEffect;
  }
```

before mutation之前主要做一些变量赋值，状态重置的工作。

- layout

主要包括三点内容：

1. useEffect相关的处理：后面详细讲
2. 性能追踪相关：代码里有很多和interaction相关的变量。他们都和追踪React渲染时间、性能相关，在[Profiler API](https://zh-hans.reactjs.org/docs/profiler.html)和[DevTool](https://github.com/facebook/react-devtools/pull/1069)中使用，你可以在这里看到[interaction的定义](https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16#overview)
3. 在commit阶段会触发一些生命周期钩子（如 componentDidXXX）和hook（如useLayoutEffect、useEffect）。

在这些回调方法中可能触发新的更新，新的更新会开启新的render-commit流程。

##### 3.2.2.2. before mutation（执行DOM前）

遍历effectList并调用commitBeforeMutationEffects函数处理。

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2104-L2127

```javascript
// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级
const previousLanePriority = getCurrentUpdateLanePriority();
setCurrentUpdateLanePriority(SyncLanePriority);

// 将当前上下文标记为CommitContext，作为commit阶段的标志
const prevExecutionContext = executionContext;
executionContext |= CommitContext;

// 处理focus状态
focusedInstanceHandle = prepareForCommit(root.containerInfo);
shouldFireAfterActiveInstanceBlur = false;

// beforeMutation阶段的主函数
commitBeforeMutationEffects(finishedWork);

focusedInstanceHandle = null;
```

主要讲下 commitBeforeMutationEffects

```javascript
function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    const current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      // ...focus blur相关
    }

    const effectTag = nextEffect.effectTag;

    // 调用getSnapshotBeforeUpdate
    if ((effectTag & Snapshot) !== NoEffect) {
      commitBeforeMutationEffectOnFiber(current, nextEffect);
    }

    // 调度useEffect
    if ((effectTag & Passive) !== NoEffect) {
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalSchedulerPriority, () => {
          flushPassiveEffects();
          return null;
        });
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
```

1. 处理DOM节点渲染、删除后的autoFocus、blur等操作；
2. 调用getSnapshotBeforeUpdate
3. 调度 useEffect

- 调用getSnapshotBeforeUpdate

commitBeforeMutationEffectOnFiber是commitBeforeMutationLifeCycles的别名，在该方法内会调用getSnapshotBeforeUpdate。

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L222

因为在V16版本后，componentWillXXX钩子为UNSAFE_，所以，React提供了替代的生命周期钩子getSnapshotBeforeUpdate，getSnapshotBeforeUpdate是在commit阶段内的before mutation阶段调用的，由于commit阶段是同步的，所以不会遇到多次调用的问题

Q：为什么从Reactv16开始，componentWillXXX钩子前增加了UNSAFE_前缀？

从React15升级为React16后，源码改动如此之大，说React被重构可能更贴切些。

正是由于变动如此之大，使得一些特性在新旧版本React中表现不一致

为了让开发者能平稳从旧版本迁移到新版本，React推出了三个模式：

- legacy模式 -- 通过ReactDOM.render创建的应用会开启该模式。这是当前React使用的方式。这个模式可能不支持一些新功能。
- blocking模式 -- 通过ReactDOM.createBlockingRoot创建的应用会开启该模式。开启部分concurrent模式特性，作为迁移到concurrent模式的第一步。
- concurrent模式 -- 通过ReactDOM.createRoot创建的应用会开启该模式。面向未来的开发模式。

但是在从legacy迁移到concurrent模式时，可中断的异步更新还替代了同步更新

在Stack Reconciler重构为Fiber Reconciler后，render阶段的任务可能中断/重新开始，对应的组件在render阶段的生命周期钩子（即componentWillXXX）可能触发多次。

这种行为和Reactv15不一致，所以标记为UNSAFE_。

- componentWillMount -- componentDidMount
- componentWillRecieveProps -- getDerivedStateFromProps
- componentWillUpdate -- getDerivedStateFromProps

在React更新里，每次发起更新都会创建一个Update对象，同一组件的多个Update，会以链表的形式保存在updateQueue中。

- update

```javascript
const update: Update<*> = {
  // ...省略当前不需要关注的字段
  lane, // 表示调度优先级
  payload: null, // 更新挂载的数据，对于this.setState创建的更新，payload为this.setState的传参
  next: null // 与其他update形成链表
};
```

- updateQueue

```javascript
const queue: UpdateQueue<State> = {
    baseState: fiber.memoizedState, // 更新基于哪个state开始
    firstBaseUpdate: null,  // 更新开始和结束的update
    lastBaseUpdate: null,
    shared: { 
      pending: null, // 更新的单个或多个update形成的链表
    },
    // 其他参数省略...
};

// baseUpdate + shared.pending会作为本次更新需要执行的Update
```

假设，某个组件updateQueue 存在4个update，数字代表优先级

```javascript
baseState = '';

A1 - B2 - C1 - D2

// 为了保证更新的连贯性，第一个被跳过的update（B）和后面的update会作为第二次渲染的baseUpdate
// 为BCD
// 首次渲染后
baseState: ''
Updates: [A1, C1]
Result state: 'AC'

// 第二次渲染，B在第一次渲染时被跳过，所以在他之后的C造成的渲
// 染结果不会体现在第二次渲染的baseState中。所以baseState为A而不是上次渲染的Result state AC
// 。这也是为了保证更新的连贯性
baseState: 'A'  // 为了保证一致性，C不在        
Updates: [B2, C1, D2]  
Result state: 'ABCD'

// Updates里出现了两次C
```

- 调度useEffect

```javascript
// 调度useEffect
if ((effectTag & Passive) !== NoEffect) {
  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalSchedulerPriority, () => { // scheduler提供，调度优先级的回调
      // 触发useEffect
      flushPassiveEffects(); // 具体见后文hooks
      return null;
    });
  }
}
```

在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList，就是会遍历rootWithPendingPassiveEffects（即effectList）执行effect回调函数。

Q：为什么要异步调度：

https://zh-hans.reactjs.org/docs/hooks-reference.html#timing-of-effects

与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。

防止同步执行时阻塞浏览器渲染

##### 3.2.2.3. mutation（执行DOM中）

类似 before mutation，mutation遍历effectList执行函数。这里执行的是commitMutationEffects。

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2091

```javascript
nextEffect = firstEffect;
do {
  try {
      commitMutationEffects(root, renderPriorityLevel);
    } catch (error) {
      invariant(nextEffect !== null, 'Should be working on an effect.');
      captureCommitPhaseError(nextEffect, error);
      nextEffect = nextEffect.nextEffect;
    }
} while (nextEffect !== null);
function commitMutationEffects(root: FiberRoot, renderPriorityLevel) {
  // 遍历effectList
  while (nextEffect !== null) {

    const effectTag = nextEffect.effectTag;

    // 根据 ContentReset effectTag重置文字节点
    if (effectTag & ContentReset) {
      commitResetTextContent(nextEffect);
    }

    // 更新ref
    if (effectTag & Ref) {
      const current = nextEffect.alternate;
      if (current !== null) {
        commitDetachRef(current);
      }
    }

    // 根据 effectTag 分别处理
    const primaryEffectTag =
      effectTag & (Placement | Update | Deletion | Hydrating);
    switch (primaryEffectTag) {
      // 插入DOM
      case Placement: {
        commitPlacement(nextEffect);
        nextEffect.effectTag &= ~Placement;
        break;
      }
      // 插入DOM 并 更新DOM
      case PlacementAndUpdate: {
        // 插入
        commitPlacement(nextEffect);

        nextEffect.effectTag &= ~Placement;

        // 更新
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      // SSR
      case Hydrating: {
        nextEffect.effectTag &= ~Hydrating;
        break;
      }
      // SSR
      case HydratingAndUpdate: {
        nextEffect.effectTag &= ~Hydrating;

        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      // 更新DOM
      case Update: {
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      // 删除DOM
      case Deletion: {
        commitDeletion(root, nextEffect, renderPriorityLevel);
        break;
      }
    }

    nextEffect = nextEffect.nextEffect;
  }
}
```

执行内容：

1. 根据ContentReset effectTag重置文字节点
2. 更新ref
3. 根据effectTag分别处理，其中effectTag包括(Placement | Update | Deletion | Hydrating)，hydrate是SSR，不考虑

- placement effect：插入DOM

调用：commitPlacement

地址：https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1156

实现内容：

1. 获取父DOM节点，其中finishedWork为传入的Fiber节点。

```javascript
const parentFiber = getHostParentFiber(finishedWork);
// 父级DOM节点
const parentStateNode = parentFiber.stateNode;
```

2. 获取fiber节点的DOM兄弟节点

```javascript
const before = getHostSibling(finishedWork);
```

3. 根据DOM的兄弟节点是否存在调用parentNode.insertBefore 或者 parentNode.appendChild，插入DOM

```javascript
// parentStateNode是否是rootFiber
if (isContainer) {
  insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
} else {
  insertOrAppendPlacementNode(finishedWork, before, parent);
}
```

Q：渲染DOM中时间复杂度最高的操作是？

getHostSibling（获取兄弟DOM节点）

当在同一个父Fiber节点下依次执行多个插入操作，getHostSibling算法的复杂度为指数级。

这是由于Fiber节点不只包括HostComponent，所以Fiber树和渲染的DOM树节点并不是一一对应的。要从Fiber节点找到DOM节点很可能跨层级遍历

```javascript
function Item() {
  return <li><li>;
}

function App() {
  return (
    <div>
      <Item/>
    </div>
  )
}

ReactDOM.render(<App/>, document.getElementById('root'));

// Fiber树
          child      child      child       child
rootFiber -----> App -----> div -----> Item -----> li

// DOM树
#root ---> div ---> li

// 在div的子节点Item前加一个p
function App() {
  return (
    <div>
      <p></p>
      <Item/>
    </div>
  )
}

// Fiber树
          child      child      child
rootFiber -----> App -----> div -----> p 
                                       | sibling       child
                                       | -------> Item -----> li 
// DOM树
#root ---> div ---> p
             |
               ---> li

// 此时dom中p的兄弟节点是li
// fiber中fiberP的兄弟节点是fiberItem，fiberItem的子节点才是li
```

- update effect

调用的方法为commitWork，他会根据Fiber.tag分别处理。

地址：https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1441

主要关注：FunctionComponent和HostComponent

1. FunctionComponent mutation

当fiber.tag为FunctionComponent，会调用commitHookEffectListUnmount。该方法会遍历effectList，执行所有useLayoutEffect hook的销毁函数

地址：https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L314

2. HostComponent mutation

当fiber.tag为HostComponent，会调用commitUpdate。

地址：https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMHostConfig.js#L423

最终会在[updateDOMProperties](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMComponent.js#L378)中将render阶段 completeWork中为Fiber节点赋值的updateQueue对应的内容渲染在页面上。

```javascript
for (let i = 0; i < updatePayload.length; i += 2) {
  const propKey = updatePayload[i];
  const propValue = updatePayload[i + 1];

  // 处理 style
  if (propKey === STYLE) {
    setValueForStyles(domElement, propValue);
  // 处理 DANGEROUSLY_SET_INNER_HTML
  } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
    setInnerHTML(domElement, propValue);
  // 处理 children
  } else if (propKey === CHILDREN) {
    setTextContent(domElement, propValue);
  } else {
  // 处理剩余 props
    setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
  }
}
```

- deletion effect

当Fiber节点含有Deletion effectTag，意味着该Fiber节点对应的DOM节点需要从页面中删除。调用的方法为commitDeletion。

地址：https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1421

1. 递归调用Fiber节点及其子孙Fiber节点中fiber.tag为ClassComponent的componentWillUnmount生命周期钩子，从页面移除Fiber节点对应DOM节点
2. 解绑ref
3. 调度useEffect的销毁函数

##### 3.2.2.4. layout（执行DOM后）

之所以称为layout，因为该阶段的代码都是在DOM渲染完成（mutation阶段完成）后执行的。该阶段触发的生命周期钩子和hook可以直接访问到已经改变后的DOM，即该阶段是可以参与DOM layout的阶段

- layout阶段也是遍历effectList

```javascript
root.current = finishedWork;

nextEffect = firstEffect;
do {
  try {
    commitLayoutEffects(root, lanes);
  } catch (error) {
    invariant(nextEffect !== null, "Should be working on an effect.");
    captureCommitPhaseError(nextEffect, error);
    nextEffect = nextEffect.nextEffect;
  }
} while (nextEffect !== null);

nextEffect = null;
```

- commitLayoutEffects

地址：https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2302

```javascript
function commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {
  while (nextEffect !== null) {
    const effectTag = nextEffect.effectTag;

    // 调用生命周期钩子和hook
    if (effectTag & (Update | Callback)) {
      const current = nextEffect.alternate;
      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);
    }

    // 赋值ref
    if (effectTag & Ref) {
      commitAttachRef(nextEffect);
    }

    nextEffect = nextEffect.nextEffect;
  }
}
```

1. commitLayoutEffectOnFiber（调用生命周期钩子和hook相关操作）
2. commitAttachRef（赋值 ref）

- commitLayoutEffectOnFiber

地址：https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L459

1. 对于ClassComponent

1. - 通过current === null?区分是mount还是update，调用componentDidMount 或者componentDidUpdate

2. - 触发状态更新的this.setState如果赋值了第二个参数回调函数，也会在此时调用

```javascript
this.setState({ xxx: 1 }, () => {   console.log("i am update~"); }); 
```

2. 对于FunctionComponent及相关类型（如ForwardRef、React.memo或者HOC），他会调用useLayoutEffect hook的回调函数，调度useEffect的销毁与回调函数

```javascript
 switch (finishedWork.tag) {
    // 以下都是FunctionComponent及相关类型
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block: {
      // 执行useLayoutEffect的回调函数
      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);
      // 调度useEffect的销毁函数与回调函数
      schedulePassiveEffects(finishedWork);
      return;
    }
```

- commitAttachRef

获取DOM实例，更新Ref

```javascript
function commitAttachRef(finishedWork: Fiber) {
  const ref = finishedWork.ref;
  if (ref !== null) {
    const instance = finishedWork.stateNode;

    // 获取DOM实例
    let instanceToUse;
    switch (finishedWork.tag) {
      case HostComponent:
        instanceToUse = getPublicInstance(instance);
        break;
      default:
        instanceToUse = instance;
    }

    if (typeof ref === "function") {
      // 如果ref是函数形式，调用回调函数
      ref(instanceToUse);
    } else {
      // 如果ref是ref实例形式，赋值ref.current
      ref.current = instanceToUse;
    }
  }
}
```

- current fiber切换

```javascript
root.current = finishedWork;
```

因为双缓存策略，workInProgress Fiber树在commit阶段完成渲染后会变为current Fiber树。这行代码的作用就是切换fiberRootNode指向的current Fiber树。

Q：双缓存切换执行时间

mutation阶段结束后，layout阶段开始前

所以

1. componentWillUnmount在mutation阶段执行。此时current Fiber树还指向前一次更新的Fiber树，在生命周期钩子内获取的DOM还是更新前的；
2. componentDidMount和componentDidUpdate会在layout阶段执行。此时current Fiber树已经指向更新后的Fiber树，在生命周期钩子内获取的DOM就是更新后的；

# **React核心源码解析（2/2)**

https://www.yuque.com/lpldplws/web/oqnqc7?singleDoc# 《React核心源码解析（2/2）》 密码：xmq3

## 1. 课程目标

 

P6+~P7：

1. 学习React设计原理，掌握React源码架构、约定及其实现的思路；

2. 掌握React 核心模块源码及设计；

P7+~P8：

1. 熟练掌握React源码设计模型，能够基于现有React框架设计周边库；

2. 熟练掌握React生态，能够从0~1完整地实现React技术栈的前端架构设计；

## 2.课程大纲

- 实现

  - Diff算法
    - 概览
    - 单节点Diff
    - 多节点Diff

  - 状态更新
    - 流程概览
    - update
    - 深入理解优先级
    - ReactDOM.render
    - this.setState

  - Hooks
    - 极简Hooks实现
    - Hooks数据结构
    - useState与useReducer
    - useEffect
    - useRef
    - useMemo与useCallback

  - Concurrent Mode
    - 概览
    - Scheduler原理及实现
    - lane模型

 

## 3.实现篇 

### 3.1 Diff算法

#### 3.1.1 概览

 

在render阶段，对于update的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就是俗称的Diff算法），将比较的结果生成新Fiber节点。

官网对diff算法的介绍：https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm

1. 不同类型的元素：React拆卸原有的树，生成新的树

```jsx
<div>
  <Counter />
</div>

<span>
  <Counter />
</span>
```

a. 卸载时：

- DOM节点销毁；

- 执行componentWilUnmount()；

b. 新建时：

- 执行UNSAFE_componentWillMount()，然后执行componentDidMount()；

2. 同一类型的元素：

```jsx
<div className="before" title="stuff" />
<div className="after" title="stuff" />
  
<div style={{color: 'red', fontWeight: 'bold'}} />
<div style={{color: 'green', fontWeight: 'bold'}} />
```

a. 保留DOM节点，仅对比更新有改变的属性

3. 对比同类型的组件元素：

a. 组件更新时，组件实例保持不变，保证state不变，更新组件的props以保证与新的元素一致，调用UNSAFE_componentWillReceiveProps()、UNSAFE_componentWillUpdate() 以及 componentDidUpdate() 方法；

b. 调用render，执行diff

- React 同时遍历两个子元素的列表；当产生差异时，生成一个 mutation
  - 在子元素列表结尾新增

```jsx
<ul>
  <li>first</li>
  <li>second</li>
</ul>

<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li> // 只需要新增元素即可
</ul>
```

- 在子元素列表头部新增

```jsx
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

// 销毁子元素列表，新建新的子元素列表，有性能问题
<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

c. 使用keys：直接比较key值定位，所以key传index也会有性能问题

```jsx
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

d. 官网总结：

1. 该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。在实践中，我们没有遇到这类问题；
2. Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失；

结合render和commit阶段，一个DOM节点最多有4个节点与之相关：

1. current Fiber。如果该DOM节点已在页面中，current Fiber代表该DOM节点对应的Fiber节点；

2. workInProgress Fiber。如果该DOM节点将在本次更新中渲染到页面中，workInProgress Fiber代表该DOM节点对应的Fiber节点；

3. DOM节点本身；

4. JSX对象。即ClassComponent的render方法的返回结果，或FunctionComponent的调用结果。JSX对象中包含描述DOM节点的信息；

diff算法：对比1 4 生成2

##### 3.1.1.1. Diff的瓶颈及处理方法 

 

diff操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n^3)，其中n是树中元素的数量；如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂；

为了降低算法复杂度，React的diff会预设三个限制：

1. 只对同级元素进行diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React会忽略；

2. 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点；

3. 开发者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定；

 

##### 3.1.1.2. Diff是如何实现的 

Diff的入口函数是reconcileChildFibers：会根据newChild（即JSX对象）类型调用不同的处理函数

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1280

```jsx
// 根据newChild类型选择不同diff函数处理
function reconcileChildFibers(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
): Fiber | null {

  const isObject = typeof newChild === 'object' && newChild !== null;

  if (isObject) {
    // object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        // 调用 reconcileSingleElement 处理
      // // ...省略其他case
    }
  }

  if (typeof newChild === 'string' || typeof newChild === 'number') {
    // 调用 reconcileSingleTextNode 处理
    // ...省略
  }

  if (isArray(newChild)) {
    // 调用 reconcileChildrenArray 处理
    // ...省略
  }

  // 一些其他情况调用处理函数
  // ...省略

  // 以上都没有命中，删除节点
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

根据同级的节点数量将Diff分为两类：

1. 当newChild类型为object、number、string，代表同级只有一个节点

2. 当newChild类型为Array，同级有多个节点

#### 3.1.2 单节点Diff

 

以类型为object为例，执行reconcileSingleElement

```jsx
  const isObject = typeof newChild === 'object' && newChild !== null;

  if (isObject) {
    // 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        // 调用 reconcileSingleElement 处理
      // ...其他case
    }
  }
```

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1141

执行流程：

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654362006150-b0eb5467-cac3-4cd8-aef4-3e0bd87b3c93.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)



```jsx
function reconcileSingleElement(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  element: ReactElement
): Fiber {
  const key = element.key;
  let child = currentFirstChild;
  
  // 首先判断是否存在对应DOM节点
  while (child !== null) {
    // 上一次更新存在DOM节点，接下来判断是否可复用

    // 首先比较key是否相同
    if (child.key === key) {

      // key相同，接下来比较type是否相同

      switch (child.tag) {
        // ...省略case
        
        default: {
          if (child.elementType === element.type) {
            // type相同则表示可以复用
            // 返回复用的fiber
            return existing;
          }
          
          // type不同则跳出switch
          break;
        }
      }
      // 代码执行到这里代表：key相同但是type不同
      // 将该fiber及其兄弟fiber标记为删除
      deleteRemainingChildren(returnFiber, child);
      break;
    } else {
      // key不同，将该fiber标记为删除
      deleteChild(returnFiber, child);
    }
    child = child.sibling;
  }

  // 创建新Fiber，并返回 ...省略
}
```

1. 先判断key是否相同，如果key相同则判断type是否相同，只有都相同时一个DOM节点才能复用；

2. 删除逻辑：

- 当child !== null且key相同且type不同时执行deleteRemainingChildren将child及其兄弟fiber都标记删除；

- 当child !== null且key不同时仅将child标记删除；

```jsx
// current fiber
ul > li li li
// JSX
ul > p
```

需要根据第一个li与p是否相同判断

1. key相同type不同，当前fiber和后续sibling fiber删除；

2. key不同，type也不同，删除当前fiber，前往下一个sibling fiber；

Example：

```jsx
// 更新前
<div>a</div>
// 更新后
<p>a</p>

// key为null，一致，但type不同，不能复用

// 更新前
<div key="xxx">a</div>
// 更新后
<div key="ooo">a</div>

// key不同，不需要看type，不能复用

// 更新前
<div key="xxx">a</div>
// 更新后
<p key="ooo"a</p>

// key不同，不需要看type，不能复用

// 更新前
<div key="xxx">a</div>
// 更新后
<div key="xxx">b</div>

// key type都相同，props中children不同，更新子元素
```

#### 3.1.3 多节点Diff

 

对于多节点的functionComponent，reconcileChildFibers的newChild参数类型为Array，执行reconcileChildrenArray

```jsx
if (isArray(newChild)) {
    // 调用 reconcileChildrenArray 处理
    // ...省略
}
```

##### 3.1.3.1. 概览 

 

同级多个节点的diff，归纳为：

1. 节点更新

```jsx
// 更新前
<ul>
  <li key="0" className="before">0<li>
  <li key="1">1<li>
</ul>

// 更新后 情况1 —— 节点属性变化
<ul>
  <li key="0" className="after">0<li>
  <li key="1">1<li>
</ul>

// 更新后 情况2 —— 节点类型更新
<ul>
  <div key="0">0</div>
  <li key="1">1<li>
</ul>
```

2. 节点新增或减少

```jsx
// 更新前
<ul>
  <li key="0">0<li>
  <li key="1">1<li>
</ul>

// 更新后 情况1 —— 新增节点
<ul>
  <li key="0">0<li>
  <li key="1">1<li>
  <li key="2">2<li>
</ul>

// 更新后 情况2 —— 删除节点
<ul>
  <li key="1">1<li>
</ul>
```

3. 节点位置变化

```jsx
// 更新前
<ul>
  <li key="0">0<li>
  <li key="1">1<li>
</ul>

// 更新后
<ul>
  <li key="1">1<li>
  <li key="0">0<li>
</ul>
```

##### 3.1.3.2 Diff思路

1. 针对节点更新
   - 新增：执行新增逻辑
   - 删除：执行删除逻辑
   - 更新：执行更新逻辑

前提：操作优先级一样，但实际开发中，React团队发现，相较于新增和删除，更新组件发生的频率更高。所以Diff会优先判断当前节点是否属于更新。

Q：同级比较能否使用双指针算法提高遍历速度？

不可以

待更新对象为JSX，其中newChildren为数组格式，但current fiber 是链表格式，同级的fiber节点是由sibling指针形成的单链表，不支持双指针遍历；

newChildren[0]与fiber比较，newChildren[1]与fiber.sibling比较 
无法针对数组和链表进行比较，所以不可行

react团队提供的思路：2轮遍历

1. 处理 更新 的节点；

2. 处理非 更新 的节点；

 

##### 3.1.3.3. 第一轮遍历 

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L818

1. let i = 0，遍历newChildren，将newChildren[i]与oldFiber比较，判断DOM节点是否可复用；

2. 如果可复用，i++，继续比较newChildren[i]与oldFiber.sibling，可以复用则继续遍历；

3. 如果不可复用，分两种情况：

- key不同导致不可复用，立即跳出整个遍历，第一轮遍历结束；

- key相同type不同导致不可复用，会将oldFiber标记为DELETION，并继续遍历；

4. 如果newChildren遍历完（即 i === newChildren.length - 1 ）或者oldFiber遍历完（即oldFiber.sibling === null），跳出遍历，第一轮遍历结束；

其中，3 4可以完成当前遍历

3：此时newChildren没有遍历完，oldFiber也没有遍历完

```jsx
// 更新前
<li key="0">0</li>
<li key="1">1</li>
<li key="2">2</li>
            
// 更新后
<li key="0">0</li>
<li key="2">1</li>
<li key="1">2</li>

// 第一个节点可复用，遍历到key === 2的节点发现key改变，不可复用
// 跳出遍历，等待第二轮遍历处理

// oldFiber: key === 1、key === 2未遍历
// newChildren剩下key === 2、key === 1未遍历
```

4：可能newChildren遍历完，或oldFiber遍历完，或他们同时遍历完

```jsx
// 更新前
<li key="0" className="a">0</li>
<li key="1" className="b">1</li>
            
// 更新后 情况1 —— newChildren与oldFiber都遍历完
<li key="0" className="aa">0</li>
<li key="1" className="bb">1</li>
            
// 更新后 情况2 —— newChildren没遍历完，oldFiber遍历完
// newChildren剩下 key==="2" 未遍历
<li key="0" className="aa">0</li>
<li key="1" className="bb">1</li>
<li key="2" className="cc">2</li>
            
// 更新后 情况3 —— newChildren遍历完，oldFiber没遍历完
// oldFiber剩下 key==="1" 未遍历
<li key="0" className="aa">0</li>
```

##### 3.1.3.4. 第二轮遍历 

 

1. newChildren 和 oldFiber 同时遍历完

不需要第二轮的遍历，直接进行 update，diff结束；

2. newChildren没遍历完，oldFiber遍历完

已有的DOM节点都对比结束，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的newChildren为生成的workInProgress fiber依次标记Placement；

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L869

3. newChildren遍历完，oldFiber没遍历完

本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的oldFiber，依次标记Deletion；

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L863

4. newChildren与oldFiber都没遍历完

意味着有节点更新了位置

##### 3.1.3.5. 如何处理更新后的节点 

 

由于有节点改变了位置，所以不能再用位置索引i对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢--key

为了快速的找到key对应的oldFiber，我们将所有还未处理的oldFiber存入以key为key，oldFiber为value的Map中。

```jsx
const existingChildren = mapRemainingChildren(returnFiber, oldFiber); 
```

接下来遍历剩余的newChildren，通过newChildren[i].key就能在existingChildren中找到key相同的oldFiber

##### 3.1.3.6. 标记节点是否移动 

 

如何判断节点是否移动？参照物是什么？

我们的参照物是：最后一个可复用的节点在oldFiber中的位置索引（用变量lastPlacedIndex表示）。

本次更新中节点是按newChildren的顺序排列。在遍历newChildren过程中，每个遍历到的可复用节点一定是当前遍历到的所有可复用节点中最靠右的那个，即一定在lastPlacedIndex对应的可复用的节点在本次更新中位置的后面；

所以只需要比较遍历到的可复用节点在上次更新时是否也在lastPlacedIndex对应的oldFiber后面，就能知道两次更新中这两个节点的相对位置改变没有；

我们用变量oldIndex表示遍历到的可复用节点在oldFiber中的位置索引。如果oldIndex < lastPlacedIndex，代表本次更新该节点需要向右移动；

lastPlacedIndex初始为0，每遍历一个可复用的节点，如果oldIndex >= lastPlacedIndex，则lastPlacedIndex = oldIndex；

 

##### 3.1.3.7. Demo 

每个字母代表一个节点，字母的值代表节点的key

demo 1

```jsx
// 之前
abcd

// 之后
acdb

===第一轮遍历开始===
a（之后）vs a（之前）  
key不变，可复用
此时 a 对应的oldFiber（之前的a）在之前的数组（abcd）中索引为0
所以 lastPlacedIndex = 0;

继续第一轮遍历...

c（之后）vs b（之前）  
key改变，不能复用，跳出第一轮遍历
此时 lastPlacedIndex === 0;
===第一轮遍历结束===

===第二轮遍历开始===
newChildren === cdb，没用完，不需要执行删除旧节点
oldFiber === bcd，没用完，不需要执行插入新节点

将剩余oldFiber（bcd）保存为map

// 当前oldFiber：bcd
// 当前newChildren：cdb

继续遍历剩余newChildren

key === c 在 oldFiber中存在
const oldIndex = c（之前）.index;
此时 oldIndex === 2;  // 之前节点为 abcd，所以c.index === 2
比较 oldIndex 与 lastPlacedIndex;

如果 oldIndex >= lastPlacedIndex 代表该可复用节点不需要移动
并将 lastPlacedIndex = oldIndex;
如果 oldIndex < lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动

在例子中，oldIndex 2 > lastPlacedIndex 0，
则 lastPlacedIndex = 2;
c节点位置不变

继续遍历剩余newChildren

// 当前oldFiber：bd
// 当前newChildren：db

key === d 在 oldFiber中存在
const oldIndex = d（之前）.index;
oldIndex 3 > lastPlacedIndex 2 // 之前节点为 abcd，所以d.index === 3
则 lastPlacedIndex = 3;
d节点位置不变

继续遍历剩余newChildren

// 当前oldFiber：b
// 当前newChildren：b

key === b 在 oldFiber中存在
const oldIndex = b（之前）.index;
oldIndex 1 < lastPlacedIndex 3 // 之前节点为 abcd，所以b.index === 1
则 b节点需要向右移动
===第二轮遍历结束===

最终acd 3个节点都没有移动，b节点被标记为移动
```

demo 2

```jsx
// 之前
abcd

// 之后
dabc

===第一轮遍历开始===
d（之后）vs a（之前）  
key改变，不能复用，跳出遍历
===第一轮遍历结束===

===第二轮遍历开始===
newChildren === dabc，没用完，不需要执行删除旧节点
oldFiber === abcd，没用完，不需要执行插入新节点

将剩余oldFiber（abcd）保存为map

继续遍历剩余newChildren

// 当前oldFiber：abcd
// 当前newChildren dabc

key === d 在 oldFiber中存在
const oldIndex = d（之前）.index;
此时 oldIndex === 3; // 之前节点为 abcd，所以d.index === 3
比较 oldIndex 与 lastPlacedIndex;
oldIndex 3 > lastPlacedIndex 0
则 lastPlacedIndex = 3;
d节点位置不变

继续遍历剩余newChildren

// 当前oldFiber：abc
// 当前newChildren abc

key === a 在 oldFiber中存在
const oldIndex = a（之前）.index; // 之前节点为 abcd，所以a.index === 0
此时 oldIndex === 0;
比较 oldIndex 与 lastPlacedIndex;
oldIndex 0 < lastPlacedIndex 3
则 a节点需要向右移动

继续遍历剩余newChildren

// 当前oldFiber：bc
// 当前newChildren bc

key === b 在 oldFiber中存在
const oldIndex = b（之前）.index; // 之前节点为 abcd，所以b.index === 1
此时 oldIndex === 1;
比较 oldIndex 与 lastPlacedIndex;
oldIndex 1 < lastPlacedIndex 3
则 b节点需要向右移动

继续遍历剩余newChildren

// 当前oldFiber：c
// 当前newChildren c

key === c 在 oldFiber中存在
const oldIndex = c（之前）.index; // 之前节点为 abcd，所以c.index === 2
此时 oldIndex === 2;
比较 oldIndex 与 lastPlacedIndex;
oldIndex 2 < lastPlacedIndex 3
则 c节点需要向右移动

===第二轮遍历结束===
```

所以，尽量减少节点从后面移动到前面的操作

1. abcd -> acdb：b移动到最右边

2. abcd -> dabc：abc移动到最右边

### 3.2 状态更新

#### 3.2.1 概览

 

梳理下几个关键的节点：

1. render阶段的开始

开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新，render结束完后会进入commit

2. commit阶段的开始

开始于commitRoot方法的调用。其中rootFiber会作为传参

此时，状态为

```js
触发状态更新（根据场景调用不同方法）

    |
    |
    v

    ？

    |
    |
    v

render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）

    |
    |
    v

commit阶段（`commitRoot`）
```

##### 3.2.1.1. 创建Update对象(后面核心讲解) 

在react里，触发状态更新的操作包括：

- ReactDOM.render

- this.setState

- this.forceUpdate

- useState

- useReducer

Q：如何在调用场景不同的情况下，接入同一套状态管理机制？

在每次状态更新，都会创建保存一个更新状态相关的对象，称为Update，在render的beginwork中会根据Update得到新的state

 

##### 3.2.1.2. 从fiber到root 

render阶段是从rootFiber开始向下遍历。那么如何从触发状态更新的fiber得到rootFiber呢？

调用markUpdateLaneFromFiberToRoot方法。

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L636

该方法做的工作可以概括为：从触发状态更新的fiber一直向上遍历到rootFiber，并返回rootFiber。

 

##### 3.2.1.3. 调度更新 

现在有一个rootFiber，该rootFiber对应的Fiber树中某个Fiber节点包含一个Update。

接下来通知Scheduler根据更新的优先级，决定以同步还是异步的方式调度本次更新。

这里调用的方法是ensureRootIsScheduled

地址：https://github.com/facebook/react/blob/b6df4417c79c11cfb44f965fab55b573882b1d54/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L602

ensureRootIsScheduled核心代码：

```jsx
if (newCallbackPriority === SyncLanePriority) {
  // 任务已经过期，需要同步执行render阶段
  newCallbackNode = scheduleSyncCallback(
    performSyncWorkOnRoot.bind(null, root)
  );
} else {
  // 根据任务优先级异步执行render阶段
  var schedulerPriorityLevel = lanePriorityToSchedulerPriority(
    newCallbackPriority
  );
  newCallbackNode = scheduleCallback(
    schedulerPriorityLevel,
    performConcurrentWorkOnRoot.bind(null, root)
  );
}
```

至此，状态更新的流程已经通了

```jsx
触发状态更新（根据场景调用不同方法）

    |
    |
    v

创建Update对象（后面详解）

    |
    |
    v

从fiber到root（`markUpdateLaneFromFiberToRoot`）

    |
    |
    v

调度更新（`ensureRootIsScheduled`）

    |
    |
    v

render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）

    |
    |
    v

commit阶段（`commitRoot`）
```

 

#### 3.2.2 Update

##### 3.2.2.1 Update思路

 

 

通过代码版本控制类比

1. 同步更新

在没有代码版本控制前，我们在代码中逐步叠加功能。一切看起来井然有序，直到我们遇到了一个紧急线上bug（红色节点）

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654365326803-5b943e35-c7b1-4642-94cd-b163460cf368.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)



如果要修改，需要先将之前的代码提交；

所有通过ReactDOM.render创建的应用都是通过类似的方式更新状态，没有优先级，高优先级需要排在其他更新的后面

2. 并发更新

如果有了代码版本控制，需要发布urgent变更，暂存当前已有的修改，在master上直接修复

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654365436582-ce20378e-ebad-490f-a00b-418cf8223c48.png?x-oss-process=image%2Fresize%2Cw_1170%2Climit_0)



修复后使用 git rebase 和分支连接，当前开发的分支是基于修复bug的最新的master分支

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654365542205-6bcb4575-aeaa-49a8-8528-c8cd14e2c071.png?x-oss-process=image%2Fresize%2Cw_1034%2Climit_0)



在React中，通过ReactDOM.createBlockingRoot和ReactDOM.createRoot创建的应用会采用并发的方式更新状态；

高优更新（红色节点）中断正在进行中的低优更新（蓝色节点），先完成render - commit流程；

待高优更新完成后，低优更新基于高优更新的结果重新更新；

##### 3.2.2.2. Update的分类 

 

| 触发方法         | 组件              |
| ---------------- | ----------------- |
| ReactDOM.render  | HostRoot          |
| this.setState    | ClassComponent    |
| this.forceUpdate | ClassComponent    |
| useState         | FunctionComponent |
| useReducer       | FunctionComponent |

共有三种组件支持Update：HostRoot 、ClassComponent、FunctionComponent，其中，ClassComponent与HostRoot共用一套Update结构，FunctionComponent单独使用一种Update结构

虽然他们的结构不同，但是工作机制与工作流程大体相同。在本节我们介绍前一种Update，FunctionComponent对应的Update在后面讲解

 

##### 3.2.2.3. Update结构 

ClassComponent与HostRoot（即rootFiber.tag对应类型）共用同一种Update结构

```jsx
const update: Update<*> = {
  eventTime,
  lane,
  suspenseConfig,
  tag: UpdateState,
  payload: null,
  callback: null,

  next: null,
};
```

- eventTime：任务时间，通过performance.now()获取的毫秒数；

- lane：优先级相关字段；

- suspenseConfig：Suspense相关；

- tag：更新的类型，包括UpdateState | ReplaceState | ForceUpdate | CaptureUpdate；

- payload：更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参；

- callback：commit layout中支持的回调函数。

- next：与其他Update连接形成链表。

 

##### 3.2.2.4. Update与Fiber联系 

Fiber节点组成Fiber树，页面中最多同时存在两棵Fiber树：

- 代表当前页面状态的current Fiber树

- 代表正在render阶段的workInProgress Fiber树

类似Fiber节点组成Fiber树，Fiber节点上的多个Update会组成链表并被包含在fiber.updateQueue中。

Q：什么情况下，一个Fiber节点会有多个Update

```jsx
onClick() {
  this.setState({
    a: 1
  })

  this.setState({
    b: 2
  })
}
```

Fiber节点最多同时存在两个updateQueue：

- current fiber保存的updateQueue即current updateQueue

- workInProgress fiber保存的updateQueue即workInProgress updateQueue

在commit阶段完成页面渲染后，workInProgress Fiber树变为current Fiber树，workInProgress Fiber树内Fiber节点的updateQueue就变成current updateQueue

 

##### 3.2.2.5. updateQueue 

updateQueue有三种类型，其中针对HostComponent的类型在completeWork里讲过。

剩下两种类型和Update的两种类型对应

ClassComponent与HostRoot使用的UpdateQueue结构如下：

```jsx
const queue: UpdateQueue<State> = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
    },
    effects: null,
  };
```

- baseState：本次更新前该Fiber节点的state，Update基于该state计算更新后的state，可以将baseState类比心智模型中的master分支；

- firstBaseUpdate与lastBaseUpdate：本次更新前该Fiber节点已保存的Update。以链表形式存在，链表头为firstBaseUpdate，链表尾为lastBaseUpdate。之所以在更新产生前该Fiber节点内就存在Update，是由于某些Update优先级较低所以在上次render阶段由Update计算state时被跳过，可以将baseUpdate类比心智模型中执行git rebase基于的commit（节点D）；

- shared.pending：触发更新时，产生的Update会保存在shared.pending中形成单向环状链表。当由Update计算state时这个环会被剪开并连接在lastBaseUpdate后面，可以将shared.pending类比心智模型中本次需要提交的commit（节点ABC）。

- effects：数组。保存update.callback !== null的Update；

 

##### 3.2.2.6. demo 

假设有一个fiber刚经历commit阶段完成渲染。

该fiber上有两个由于优先级过低所以在上次的render阶段并没有处理的Update。他们会成为下次更新的baseUpdate。

我们称其为u1和u2，其中u1.next === u2。

```jsx
fiber.updateQueue.firstBaseUpdate === u1;
fiber.updateQueue.lastBaseUpdate === u2;
u1.next === u2;
```

我们用-->表示链表的指向：

```jsx
fiber.updateQueue.baseUpdate: u1 --> u2
```

现在我们在fiber上触发两次状态更新，这会先后产生两个新的Update，我们称为u3和u4。

每个 update 都会插入到 updateQueue 队列上

当插入u3后：

```jsx
fiber.updateQueue.shared.pending === u3;
u3.next === u3;
```

shared.pending的环状链表，用图表示为：

```jsx
fiber.updateQueue.shared.pending:   u3 ─────┐ 
                                     ^      |                                    
                                     └──────┘
```

接着插入u4之后：

```jsx
fiber.updateQueue.shared.pending = u4;
u4.next === u3;
u3.next === u4;
```

shared.pending是环状链表，用图表示为：

```jsx
fiber.updateQueue.shared.pending:   u4 ──> u3
                                     ^      |                                    
                                     └──────┘
```

shared.pending 会保证始终指向最后一个插入的update

更新调度完成后进入render阶段

此时shared.pending的环被剪开并连接在updateQueue.lastBaseUpdate后面：

```jsx
fiber.updateQueue.baseUpdate: u1 --> u2 --> u3 --> u4
```

接下来遍历updateQueue.baseUpdate链表，以fiber.updateQueue.baseState为初始state，依次与遍历到的每个Update计算并产生新的state；

在遍历时如果有优先级低的Update会被跳过；

当遍历完成后获得的state，就是该Fiber节点在本次更新的state

state的变化在render阶段产生与上次更新不同的JSX对象，通过Diff算法产生effectTag，在commit阶段渲染在页面上，同时，渲染完成后workInProgress Fiber树变为current Fiber树，整个更新流程结束。

 

#### 3.2.3. 深入理解优先级

 

 

 

 

##### 3.2.3.1. 什么是优先级

状态更新由用户交互产生，用户心里对交互执行顺序有个预期。React根据人机交互研究的结果中用户对交互的预期顺序为交互产生的状态更新赋予不同优先级

- 生命周期方法：同步执行；

- 受控的用户输入：比如输入框内输入文字，同步执行；

- 交互事件：比如动画，高优先级执行；

- 其他：比如数据请求，低优先级执行；

 

##### 3.2.3.2. 如何调度优先级

React会调用Scheduler提供的方法runWithPriority，该方法接收一个优先级常量与一个回调函数作为参数。回调函数会以优先级高低为顺序排列在一个定时器中并在合适的时间触发。

unstable_runWithPriority地址：https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/Scheduler.js#L217

scheduler优先级常量定义地址：

https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/SchedulerPriorities.js

##### 3.2.3.3. demo 

 

![img](https://cdn.nlark.com/yuque/0/2022/png/2340337/1654367776393-be18e2a6-7451-4b1a-a41f-12cef056b0c7.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)



以上有两个Update。我们将“关闭黑夜模式”产生的Update称为u1，输入字母“I”产生的Update称为u2

其中u1先触发并进入render阶段。其优先级较低，执行时间较长。此时：

```jsx
fiber.updateQueue = {
  baseState: {
    blackTheme: true,
    text: 'H'
  },
  firstBaseUpdate: null,
  lastBaseUpdate: null
  shared: {
    pending: u1
  },
  effects: null
};
```

在u1完成render阶段前用户通过键盘输入字母“I”，产生了u2。u2属于受控的用户输入，优先级高于u1，于是中断u1产生的render阶段。

```jsx
fiber.updateQueue.shared.pending === u2 ----> u1
                                     ^        |
                                     |________|
// 即
u2.next === u1;
u1.next === u2;
```

其中u2优先级高于u1。

接下来进入u2产生的render阶段。

在processUpdateQueue方法中，shared.pending环状链表会被剪开并拼接在baseUpdate后面。

需要明确一点，shared.pending指向最后一个pending的update，所以实际执行时update的顺序为：

```jsx
u1 -- u2
```

接下来遍历baseUpdate，处理优先级合适的Update（这一次处理的是更高优的u2）；

由于u2不是baseUpdate中的第一个update，在其之前的u1由于优先级不够被跳过；

update之间可能有依赖关系，所以被跳过的update及其后面所有update会成为下次更新的baseUpdate。（即u1 -- u2）;

最终u2完成render - commit阶段；

此时：

```jsx
fiber.updateQueue = {
  baseState: {
    blackTheme: true,
    text: 'HI'
  },
  firstBaseUpdate: u1,
  lastBaseUpdate: u2
  shared: {
    pending: null
  },
  effects: null
};
```

在commit阶段结尾会再调度一次更新。在该次更新中会基于baseState中firstBaseUpdate保存的u1，开启一次新的render阶段。

最终结果：

```jsx
fiber.updateQueue = {
  baseState: {
    blackTheme: false,
    text: 'HI'
  },
  firstBaseUpdate: null,
  lastBaseUpdate: null
  shared: {
    pending: null
  },
  effects: null
};
```

可以看到，u2执行了2次，相对应的render阶段的生命周期 componentWillXXX也会执行2次，这就是为什么这些生命周期会被标记为unsafe_；

Q：render阶段可能会被中断，如何保证updateQueue中的Update不会丢失？

在render阶段，shared.pending的环被剪开并连接在updateQueue.lastBaseUpdate后面。

实际上shared.pending会被同时连接在workInProgress updateQueue.lastBaseUpdate与current updateQueue.lastBaseUpdate后面。

当render阶段被中断后重新开始时，会基于current updateQueue克隆出workInProgress updateQueue。由于current updateQueue.lastBaseUpdate已经保存了上一次的Update，所以不会丢失

当commit阶段完成渲染，由于workInProgress updateQueue.lastBaseUpdate中保存了上一次的Update，所以 workInProgress Fiber树变成current Fiber树后也不会造成Update丢失

Q：如何保证状态依赖的连续性？

当某个Update由于优先级低而被跳过时，保存在baseUpdate中的不仅是该Update，还包括链表中该Update之后的所有Update。

考虑如下例子：

```jsx
baseState: ''
shared.pending: A1 --> B2 --> C1 --> D2
```

其中字母代表该Update要在页面插入的字母，数字代表优先级，值越低优先级越高。

第一次render，优先级为1。

```jsx
baseState: ''
baseUpdate: null
render阶段使用的Update: [A1, C1]
memoizedState: 'AC'
```

其中B2由于优先级为2，低于当前优先级，所以他及其后面的所有Update会被保存在baseUpdate中作为下次更新的Update（即B2 C1 D2）。

这么做是为了保持状态的前后依赖顺序。

第二次render，优先级为2。

```jsx
baseState: 'A'
baseUpdate: B2 --> C1 --> D2
render阶段使用的Update: [B2, C1, D2]
memoizedState: 'ABCD'
```

此时，React能保证最终的状态一定和用户触发的交互一致，但是中间过程状态无法保证

 

#### 3.2.4. ReactDOM.render 

首次执行ReactDOM.render会创建fiberRootNode和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是要渲染组件所在组件树的根节点

```jsx
// container指ReactDOM.render的第二个参数（即应用挂载的DOM节点）
root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
  container,
  forceHydrate,
);
fiberRoot = root._internalRoot;
```

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-dom/src/client/ReactDOMLegacy.js#L193

legacyCreateRootFromDOMContainer方法内部会调用createFiberRoot方法完成fiberRootNode和rootFiber的创建以及关联。并初始化updateQueue

```jsx
export function createFiberRoot(
  containerInfo: any,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
): FiberRoot {
  // 创建fiberRootNode
  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);
  
  // 创建rootFiber
  const uninitializedFiber = createHostRootFiber(tag);

  // 连接rootFiber与fiberRootNode
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  // 初始化updateQueue
  initializeUpdateQueue(uninitializedFiber);

  return root;
}
```

##### 3.2.4.1. 创建Update 

 

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberReconciler.new.js#L255

```jsx
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): Lane {
  // ...省略与逻辑不相关代码

  // 创建update
  const update = createUpdate(eventTime, lane, suspenseConfig);
  
  // update.payload为需要挂载在根节点的组件
  update.payload = {element};

  // callback为ReactDOM.render的第三个参数 —— 回调函数
  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    update.callback = callback;
  }

  // 将生成的update加入updateQueue
  enqueueUpdate(current, update);
  // 调度更新
  scheduleUpdateOnFiber(current, lane, eventTime);

  // ...省略与逻辑不相关代码
}
```

所以完整流程为：

```jsx
创建fiberRootNode、rootFiber、updateQueue（`legacyCreateRootFromDOMContainer`）

    |
    |
    v

创建Update对象（`updateContainer`）

    |
    |
    v

从fiber到root（`markUpdateLaneFromFiberToRoot`）

    |
    |
    v

调度更新（`ensureRootIsScheduled`）

    |
    |
    v

render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）

    |
    |
    v

commit阶段（`commitRoot`）
```

##### 3.2.4.2. React其他入口函数 

 

当前React共有三种模式：

- legacy，这是当前React使用的方式。当前没有计划删除本模式，但是这个模式可能不支持一些新功能；

- blocking，开启部分concurrent模式特性的中间模式。目前正在实验中。作为迁移到concurrent模式的第一个步骤；

- concurrent，面向未来的开发模式。我们之前讲的任务中断/任务优先级都是针对concurrent模式；

支持的程度为：

|                                                              | legacy 模式 | blocking 模式 | concurrent 模式 |
| ------------------------------------------------------------ | ----------- | ------------- | --------------- |
| [String Refs](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs) | ✅           | 🚫**           | 🚫**             |
| [Legacy Context](https://zh-hans.reactjs.org/docs/legacy-context.html) | ✅           | 🚫**           | 🚫**             |
| [findDOMNode](https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage) | ✅           | 🚫**           | 🚫**             |
| [Suspense](https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly) | ✅           | ✅             | ✅               |
| [SuspenseList](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspenselist) | 🚫           | ✅             | ✅               |
| Suspense SSR + Hydration                                     | 🚫           | ✅             | ✅               |
| Progressive Hydration                                        | 🚫           | ✅             | ✅               |
| Selective Hydration                                          | 🚫           | 🚫             | ✅               |
| Cooperative Multitasking                                     | 🚫           | 🚫             | ✅               |
| Automatic batching of multiple setStates                     | 🚫*          | ✅             | ✅               |
| [Priority-based Rendering](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state) | 🚫           | 🚫             | ✅               |
| [Interruptible Prerendering](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#interruptible-rendering) | 🚫           | 🚫             | ✅               |
| [useTransition](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#transitions) | 🚫           | 🚫             | ✅               |
| [useDeferredValue](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#deferring-a-value) | 🚫           | 🚫             | ✅               |
| [Suspense Reveal "Train"](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspense-reveal-train) | 🚫           | 🚫             | ✅               |

模式的变化影响整个应用的工作方式，所以无法只针对某个组件开启不同模式

基于此原因，可以通过不同的入口函数开启不同模式：

- legacy -- ReactDOM.render(<App />, rootNode)

- blocking -- ReactDOM.createBlockingRoot(rootNode).render(<App />)

- concurrent -- ReactDOM.createRoot(rootNode).render(<App />)

你可以在[这里](https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes)看到React团队解释为什么会有这么多模式

#### 3.2.5. this.setState 

this.setState 会调用this.updater.enqueueSetState

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactBaseClasses.js#L57

```jsx
Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
```

enqueueSetState就是我们从创建update到调度update

```jsx
enqueueSetState(inst, payload, callback) {
  // 通过组件实例获取对应fiber
  const fiber = getInstance(inst);

  const eventTime = requestEventTime();
  const suspenseConfig = requestCurrentSuspenseConfig();

  // 获取优先级
  const lane = requestUpdateLane(fiber, suspenseConfig);

  // 创建update
  const update = createUpdate(eventTime, lane, suspenseConfig);

  update.payload = payload;

  // 赋值回调函数
  if (callback !== undefined && callback !== null) {
    update.callback = callback;
  }

  // 将update插入updateQueue
  enqueueUpdate(fiber, update);
  // 调度update
  scheduleUpdateOnFiber(fiber, lane, eventTime);
}
```

##### 3.2.5.1. this.forceUpdate 

 

在this.updater上，除了enqueueSetState外，还存在enqueueForceUpdate，在this.forceUpdate时调用；

```jsx
enqueueForceUpdate(inst, callback) {
    const fiber = getInstance(inst);
    const eventTime = requestEventTime();
    const suspenseConfig = requestCurrentSuspenseConfig();
    const lane = requestUpdateLane(fiber, suspenseConfig);

    const update = createUpdate(eventTime, lane, suspenseConfig);

    // 赋值tag为ForceUpdate
    update.tag = ForceUpdate;

    if (callback !== undefined && callback !== null) {
      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
};
```

此时，当某次更新含有tag为ForceUpdate的Update，那么当前ClassComponent不会受其他性能优化手段（shouldComponentUpdate|PureComponent）影响，一定会更新。

### 3.3. Hooks

#### 3.3.1. 极简Hooks实现

```jsx
function App() {
  const [num, updateNum] = useState(0);

  return <p onClick={() => updateNum(num => num + 1)}>{num}</p>;
}
```

1. 通过一些途径产生更新，更新会造成组件render--updateNum；

2. 组件render时useState返回的num为更新后的结果；

其中步骤1的更新可以分为mount和update：

1. 调用ReactDOM.render会产生mount的更新，更新内容为useState的initialValue（即0）。

2. 点击p标签触发updateNum会产生一次update的更新，更新内容为num => num + 1。

 

##### 3.3.1.1. 更新是什么

通过一些途径产生更新，更新会造成组件render

```jsx
const update = {
  // 更新执行的函数
  action,
  // 与同一个Hook的其他更新形成链表
  next: null
}
```

##### 3.3.1.2 update的数据结构 

加入有多个update，如何组合起来

```jsx
// 之前
return <p onClick={() => updateNum(num => num + 1)}>{num}</p>;

// 之后
return <p onClick={() => {
  updateNum(num => num + 1);
  updateNum(num => num + 1);
  updateNum(num => num + 1);
}}>{num}</p>;
```

通过环形单向链表

调用updateNum实际上是dispatchAction.bind(null, hook.queue)

```jsx
function dispatchAction(queue, action) {
  // 创建update
  const update = {
    action,
    next: null
  }

  // 环状单向链表操作
  if (queue.pending === null) {
    update.next = update;
  } else {
    update.next = queue.pending.next;
    queue.pending.next = update;
  }
  queue.pending = update;

  // 模拟React开始调度更新
  schedule();
}
```

demo：

当产生第一个update（我们叫他u0），此时queue.pending === null。

update.next = update;即u0.next = u0，他会和自己首尾相连形成单向环状链表。

然后queue.pending = update;即queue.pending = u0

```js
queue.pending = u0 ----->
                ^       |
                |       |
                ---------
```

当产生第二个update（我们叫他u1），update.next = queue.pending.next;，此时queue.pending.next === u0， 即u1.next = u0。

queue.pending.next = update;，即u0.next = u1。

然后queue.pending = update;即queue.pending = u1

```js
queue.pending = u1 ---> u0   
                ^       |
                |       |
                ---------
```

queue.pending始终指向最后一个插入的update

##### 3.3.1.3. 状态如何保存 

 

更新产生的update对象会保存在queue中。

不同于ClassComponent的实例可以存储数据

对于FunctionComponent，queue存储对应的fiber中。

```jsx
// App组件对应的fiber对象
const fiber = {
  // 保存该FunctionComponent对应的Hooks链表
  memoizedState: null,
  // 指向App函数
  stateNode: App
};
```

##### 3.3.1.4. Hooks数据结构 

 

```jsx
hook = {
  // 保存update的queue，即上文介绍的queue
  queue: {
    pending: null
  },
  // 保存hook对应的state
  memoizedState: initialState,
  // 与下一个Hook连接形成单向无环链表
  next: null
}
```

Q：update与hook的关系

每个useState对应一个hook对象。

调用const [num, updateNum] = useState(0);时updateNum（即上文介绍的dispatchAction）产生的update保存在useState对应的hook.queue中

##### 3.3.1.5. 模拟react调度更新流程 

1. 实现通过操作产生更新，更新造成组件render

```js
function dispatchAction(queue, action) {
  // ...创建update
  
  // ...环状单向链表操作

  // 模拟React开始调度更新
  schedule();
}

// 模拟调度
// 首次render时是mount
isMount = true;

function schedule() {
  // 更新前将workInProgressHook重置为fiber保存的第一个Hook
  workInProgressHook = fiber.memoizedState;
  // 触发组件render
  fiber.stateNode();
  // 组件首次render为mount，以后再触发的更新为update
  isMount = false;
}

// 每当遇到下一个useState，我们移动workInProgressHook的指针
workInProgressHook = workInProgressHook.next;
// 保证了每次组件render时useState的调用顺序及数量保持一致
// 可以通过workInProgressHook找到当前useState对应的hook对象。
```

##### 3.3.1.6 计算state

2. 组件render时，useState返回的值为更新后的结果，即一个完整的useState

 ```js
 function useState(initialState) {
   // 当前useState使用的hook会被赋值该该变量
   let hook;
 
   if (isMount) {
     hook = {
       queue: {
         pending: null
       },
       memoizedState: initialState,
       next: null
     }
 
     // 将hook插入fiber.memoizedState链表末尾
     if (!fiber.memoizedState) {
       fiber.memoizedState = hook;
     } else {
       workInProgressHook.next = hook;
     }
     // 移动workInProgressHook指针
     workInProgressHook = hook;
   } else {
     // update时找到对应hook
     hook = workInProgressHook;
     // 移动workInProgressHook指针
     workInProgressHook = workInProgressHook.next;
   }
 
   let baseState = hook.memoizedState;
   if (hook.queue.pending) {
     // 获取update环状单向链表中第一个update
     let firstUpdate = hook.queue.pending.next;
   
     do {
       // 执行update action
       const action = firstUpdate.action;
       baseState = action(baseState);
       firstUpdate = firstUpdate.next;
   
       // 最后一个update执行完后跳出循环
     } while (firstUpdate !== hook.queue.pending.next)
   
     // 清空queue.pending
     hook.queue.pending = null;
   }
   hook.memoizedState = baseState;
 
   return [baseState, dispatchAction.bind(null, hook.queue)];
 }
 ```

####  3.3.2. Hooks数据结构 

#####  3.3.2.1. dispatcher 

上文中，useState使用isMount区分mount和update

在真实的Hooks中，组件mount时的hook与update时的hook来源于不同的对象，这类对象在源码中被称为dispatcher

```js
// mount时的Dispatcher
const HooksDispatcherOnMount: Dispatcher = {
  useCallback: mountCallback,
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: mountImperativeHandle,
  useLayoutEffect: mountLayoutEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState,
  // ...省略
};

// update时的Dispatcher
const HooksDispatcherOnUpdate: Dispatcher = {
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState,
  // ...省略
};
```

mount时调用的hook和update时调用的hook其实是两个不同的函数。

在FunctionComponent render前，会根据FunctionComponent对应fiber的以下条件区分mount与update

```js
current === null || current.memoizedState === null
```

并将不同情况对应的dispatcher赋值给全局变量ReactCurrentDispatcher的current属性

```js
ReactCurrentDispatcher.current =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;  
```

地址：https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L409

#####  3.3.2.2. dispatch异常场景 

```js
useEffect(() => {
  useState(0);
})
```

实际上，ReactCurrentDispatcher.current已经指向ContextOnlyDispatcher，所以调用useState实际会调用throwInvalidHookError，直接抛出异常

```js
export const ContextOnlyDispatcher: Dispatcher = {
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  // ...省略
```

地址：https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L458

#####  3.3.2.3. Hook数据结构 

```js
const hook: Hook = {
  memoizedState: null,

  baseState: null,
  baseQueue: null,
  queue: null,

  next: null,
};
```

除了memoizedState，其余与updateQueue一致

- useState：对于const [state, updateState] = useState(initialState)，memoizedState保存state的值

- useReducer：对于const [state, dispatch] = useReducer(reducer, {});，memoizedState保存state的值

- useEffect：memoizedState保存包含useEffect回调函数、依赖项等的链表数据结构effect。effect链表同时会保存在fiber.updateQueue中

- useRef：对于useRef(1)，memoizedState保存{current: 1}

- useMemo：对于useMemo(callback, [depA])，memoizedState保存[callback(), depA]

- useCallback：对于useCallback(callback, [depA])，memoizedState保存[callback, depA]。与useMemo的区别是，useCallback保存的是callback函数本身，而useMemo保存的是callback函数的执行结果

有些hook是没有memoizedState的，比如：

- useContext

####  3.3.3. useState与useReducer 

useState和useReducer是Redux作者加入React后的一个核心贡献：将Redux的思想带入到React里

本质来说，useState只是预置了reducer的useReducer

#####  3.3.3.1. 概览 

```js
function App() {
  const [state, dispatch] = useReducer(reducer, {a: 1});

  const [num, updateNum] = useState(0);
  
  return (
    <div>
      <button onClick={() => dispatch({type: 'a'})}>{state.a}</button>  
      <button onClick={() => updateNum(num => num + 1)}>{num}</button>  
    </div>
  )
}
```

- 声明阶段即App调用时，会依次执行useReducer与useState方法

- 调用阶段即点击按钮后，dispatch或updateNum被调用时

#####  3.3.3.2. 声明阶段 

当FunctionComponent进入render阶段的beginWork时，会调用[renderWithHooks](https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1419)方法

该方法内部会执行FunctionComponent对应函数（即fiber.type）

```js
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
```

#####  3.3.3.2.1. mount时 

mount时，useReducer会调用[mountReducer](https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L638)，useState会调用[mountState](https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1143)

```js
function mountState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
  // 创建并返回当前的hook
  const hook = mountWorkInProgressHook();

  // ...赋值初始state

  // 创建queue
  const queue = (hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: (initialState: any),
  });

  // ...创建dispatch
  return [hook.memoizedState, dispatch];
}

function mountReducer<S, I, A>(
  reducer: (S, A) => S,
  initialArg: I,
  init?: I => S,
): [S, Dispatch<A>] {
  // 创建并返回当前的hook
  const hook = mountWorkInProgressHook();

  // ...赋值初始state

  // 创建queue
  const queue = (hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: (initialState: any),
  });

  // ...创建dispatch
  return [hook.memoizedState, dispatch];
}
```

其中，mountWorkInProgressHook对应创建并返回对应的Hook，以上两个hooks的区别：

queue参数的lastRenderedReducer字段

```js
const queue = (hook.queue = {
  pending: null,
  // 保存dispatchAction.bind()的值
  dispatch: null,
  // 上一次render时使用的reducer
  lastRenderedReducer: reducer,
  // 上一次render时的state
  lastRenderedState: (initialState: any),
});
```

useReducer的lastRenderedReducer为传入的reducer参数。useState的lastRenderedReducer为basicStateReducer，basicStateReducer如下：

```js
function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {
  return typeof action === 'function' ? action(state) : action;
}
```

######  3.3.3.2.2. update时 

在update时，useReducer和useState调用的是同一个函数 updateReducer

地址：https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L665

```js
// 找到对应的hook，根据update计算该hook的新state并返回
function updateReducer<S, I, A>(
  reducer: (S, A) => S,
  initialArg: I,
  init?: I => S,
): [S, Dispatch<A>] {
  // 获取当前hook
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  
  queue.lastRenderedReducer = reducer;

  // ...同update与updateQueue类似的更新逻辑

  const dispatch: Dispatch<A> = (queue.dispatch: any);
  return [hook.memoizedState, dispatch];
}
```

#####  3.3.3.3. 调用阶段 

调用阶段会执行[dispatchAction](https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1662)，此时该FunctionComponent对应的fiber以及hook.queue已经通过调用bind方法预先作为参数传入

```js
// 创建update，将update加入queue.pending中，并开启调度。

function dispatchAction(fiber, queue, action) {

  // ...创建update
  var update = {
    eventTime: eventTime,
    lane: lane,
    suspenseConfig: suspenseConfig,
    action: action,
    eagerReducer: null,
    eagerState: null,
    next: null
  }; 

  // ...将update加入queue.pending
  
  var alternate = fiber.alternate;

  if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
    // render阶段触发的更新
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  } else {
    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
      // ...fiber的updateQueue为空，优化路径
    }

    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
}
```

####  3.3.4. useEffect 

参考commit阶段时useEffect工作流

在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。

#####  3.3.4.1. flushPassiveEffectsImpl 

flushPassiveEffects内部会设置优先级，并执行flushPassiveEffectsImpl

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2458

flushPassiveEffectsImpl主要做三件事：

- 调用该useEffect在上一次render时的销毁函数；

- 调用该useEffect在本次render时的回调函数；

- 如果存在同步任务，不需要等待下次事件循环的宏任务，提前执行；

这里主要关注前两件事：

######  3.3.4.1.1. 销毁函数的执行 

useEffect的执行需要保证所有组件useEffect的销毁函数必须都执行完后才能执行任意一个组件的useEffect的回调函数。

这是因为多个组件间可能共用同一个ref。

如果不是按照“全部销毁”再“全部执行”的顺序，那么在某个组件useEffect的销毁函数中修改的ref.current可能影响另一个组件useEffect的回调函数中的同一个ref的current属性。

在useLayoutEffect中也有同样的问题，所以他们都遵循“全部销毁”再“全部执行”的顺序。

所以，会遍历并执行所有useEffect的销毁函数

```js
// pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect
const unmountEffects = pendingPassiveHookEffectsUnmount;
  pendingPassiveHookEffectsUnmount = [];
  for (let i = 0; i < unmountEffects.length; i += 2) {
    const effect = ((unmountEffects[i]: any): HookEffect);
    const fiber = ((unmountEffects[i + 1]: any): Fiber);
    const destroy = effect.destroy;
    effect.destroy = undefined;

    if (typeof destroy === 'function') {
      // 销毁函数存在则执行
      try {
        destroy();
      } catch (error) {
        captureCommitPhaseError(fiber, error);
      }
    }
  }
```

其中pendingPassiveHookEffectsUnmount数组的索引i保存需要销毁的effect，i+1保存该effect对应的fiber

######  3.3.4.1.2. 回调函数的执行 

遍历数组，执行对应effect的回调函数。

```js
// pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect
const mountEffects = pendingPassiveHookEffectsMount;
pendingPassiveHookEffectsMount = [];
for (let i = 0; i < mountEffects.length; i += 2) {
  const effect = ((mountEffects[i]: any): HookEffect);
  const fiber = ((mountEffects[i + 1]: any): Fiber);
  
  try {
    const create = effect.create;
   effect.destroy = create();
  } catch (error) {
    captureCommitPhaseError(fiber, error);
  }
}
```

####  3.3.5. useRef 

ref是reference（引用）的缩写。在React中，我们习惯用ref保存DOM。

对于useRef(1)，memoizedState保存{current: 1}

#####  3.3.5.1. useRef的两个状态 

在mount和update时对应了两个dispatcher

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.old.js#L1208-L1221

```js
function mountRef<T>(initialValue: T): {|current: T|} {
  // 获取当前useRef hook
  const hook = mountWorkInProgressHook();
  // 创建ref
  const ref = {current: initialValue};
  hook.memoizedState = ref;
  return ref;
}

function updateRef<T>(initialValue: T): {|current: T|} {
  // 获取当前useRef hook
  const hook = updateWorkInProgressHook();
  // 返回保存的数据
  return hook.memoizedState;
}
```

useRef仅仅是返回一个包含current属性的对象，可以看React.createRef，证明了ref在mount时只有current属性

```js
export function createRef(): RefObject {
  const refObject = {
    current: null,
  };
  return refObject;
}
```

#####  3.3.5.2. Ref工作流程 

在React中，HostComponent、ClassComponent、ForwardRef可以赋值ref属性。

```js
// HostComponent
<div ref={domRef}></div>
// ClassComponent / ForwardRef
<App ref={cpnRef} />
```

其中，ForwardRef只是将ref作为第二个参数传递下去，不会进入ref的工作流程。

因为HostComponent在commit阶段的mutation阶段执行DOM操作。

所以，对应ref的更新也是发生在mutation阶段。

同时，mutation阶段执行DOM操作的依据为effectTag。

所以，对于HostComponent、ClassComponent如果包含ref操作，那么也会赋值相应的effectTag。

```js
// ...
export const Placement = /*                    */ 0b0000000000000010;
export const Update = /*                       */ 0b0000000000000100;
export const Deletion = /*                     */ 0b0000000000001000;
export const Ref = /*                          */ 0b0000000010000000;
// ...
```

所以，ref的工作流程可以分为两部分：

1. render阶段为含有ref属性的fiber添加Ref effectTag

2. commit阶段为包含Ref effectTag的fiber执行对应操作

#####  3.3.5.3. render阶段 

在render阶段的beginWork与completeWork中有个同名方法markRef用于为含有ref属性的fiber增加Ref effectTag

```js
// beginWork的markRef
function markRef(current: Fiber | null, workInProgress: Fiber) {
  const ref = workInProgress.ref;
  if (
    (current === null && ref !== null) ||
    (current !== null && current.ref !== ref)
  ) {
    // Schedule a Ref effect
    workInProgress.effectTag |= Ref;
  }
}
// completeWork的markRef
function markRef(workInProgress: Fiber) {
  workInProgress.effectTag |= Ref;
}
```

markRef在beginWork地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L693

在completeWork地址：

https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L153

在beginWork中，如下两处调用了markRef：

- updateClassComponent内的[finishClassComponent](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L958)，对应ClassComponent；

注意 ClassComponent 即使 shouldComponentUpdate 为false该组件也会调用markRef

- [updateHostComponent](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L1156)，对应HostComponent；

在completeWork中，如下两处调用了markRef：

- completeWork中的[HostComponent](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L728)类型

- completeWork中的[ScopeComponent](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L1278)类型

[ ](https://github.com/facebook/react/pull/16587)

总结下组件对应fiber被赋值Ref effectTag需要满足的条件：

- fiber类型为HostComponent、ClassComponent

- 对于mount，workInProgress.ref !== null，即存在ref属性

- 对于update，current.ref !== workInProgress.ref，即ref属性改变

#####  3.3.5.4. commit阶段 

在commit阶段的mutation阶段中，对于ref属性改变的情况，需要先移除之前的ref。

地址：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2342

```js
function commitMutationEffects(root: FiberRoot, renderPriorityLevel) {
  while (nextEffect !== null) {

    const effectTag = nextEffect.effectTag;
    // ...

    if (effectTag & Ref) {
      const current = nextEffect.alternate;
      if (current !== null) {
        // 移除之前的ref
        commitDetachRef(current);
      }
    }
    // ...
  }
  // ...
  
  function commitDetachRef(current: Fiber) {
    const currentRef = current.ref;
    if (currentRef !== null) {
      if (typeof currentRef === 'function') {
        // function类型ref，调用他，传参为null
        currentRef(null);
      } else {
        // 对象类型ref，current赋值为null
        currentRef.current = null;
      }
    }
  }
```

接下来进入ref的赋值阶段，commitLayoutEffect会执行commitAttachRef（赋值ref）

```js
function commitAttachRef(finishedWork: Fiber) {
  const ref = finishedWork.ref;
  if (ref !== null) {
    // 获取ref属性对应的Component实例
    const instance = finishedWork.stateNode;
    let instanceToUse;
    switch (finishedWork.tag) {
      case HostComponent:
        instanceToUse = getPublicInstance(instance);
        break;
      default:
        instanceToUse = instance;
    }

    // 赋值ref
    if (typeof ref === 'function') {
      ref(instanceToUse);
    } else {
      ref.current = instanceToUse;
    }
  }
}
```

####  3.3.6. useMemo与useCallback 

#####  3.3.6.1. mount 

```js
function mountMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null,
): T {
  // 创建并返回当前hook
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  // 计算value
  const nextValue = nextCreate();
  // 将value与deps保存在hook.memoizedState
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // 创建并返回当前hook
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  // 将value与deps保存在hook.memoizedState
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

- mountMemo会将回调函数(nextCreate)的执行结果作为value保存

- mountCallback会将回调函数作为value保存

#####  3.3.6.2. update 

```js
function updateMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null,
): T {
  // 返回当前hook
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;

  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps: Array<mixed> | null = prevState[1];
      // 判断update前后value是否变化
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        // 未变化
        return prevState[0];
      }
    }
  }
  // 变化，重新计算value
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // 返回当前hook
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;

  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps: Array<mixed> | null = prevState[1];
      // 判断update前后value是否变化
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        // 未变化
        return prevState[0];
      }
    }
  }

  // 变化，将新的callback作为value
  hook.memoizedState = [callback, nextDeps];
  return callback;
```

对于update，这两个hook的唯一区别也是是回调函数本身还是回调函数的执行结果作为value。

###  3.4. Concurrent Mode 

####  3.4.1. 概览 

Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。

Concurrent Mode是React16年重构 Fiber架构 的源动力，也是React未来的发展方向。

#####  3.4.1.1. 底层架构--fiber架构 

Concurrent Mode最关键的一点是：实现异步可中断的更新。

Fiber架构的意义在于，他将单个组件作为工作单元，使以组件为粒度的“异步可中断的更新”成为可能。

#####  3.4.1.2. 架构的驱动力--Scheduler 

当同步运行Fiber架构（通过ReactDOM.render），则Fiber架构与V15并无区别。

但是当我们配合时间切片，就能根据宿主环境性能，为每个工作单元分配一个可运行时间，实现“异步可中断的更新”

#####  3.4.1.3. 架构运行策略--lane 

基于当前的架构，当一次更新在运行过程中被中断，过段时间再继续运行，这就是“异步可中断的更新”；

当一次更新在运行过程中被中断，转而重新开始一次新的更新，我们可以说：后一次更新打断了前一次更新；

这就是优先级的概念：后一次更新的优先级更高，就会打断正在进行的前一次更新。

多个优先级之间如何互相打断？优先级能否升降？本次更新应该赋予什么优先级？

这就需要一个模型控制不同优先级之间的关系与行为，也就是lane

#####  3.4.1.4. 上层实现 

从源码层面讲，Concurrent Mode是一套可控的“多优先级更新架构”，落地的上层实现包括：

1. batchUpdates

2. Suspense

3. useDeferredValue

####  3.4.2. scheduler原理及实现 

scheduler实现功能：

1. 时间切片

2. 优先级调度

#####  3.4.2.1. 时间切片原理 

时间切片的本质是模拟实现[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)

requestIdleCallback是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的。

```js
一个task(宏任务) -- 
队列中全部job(微任务) -- 
requestAnimationFrame -- 
浏览器重排/重绘 -- 
requestIdleCallback
```

除去“浏览器重排/重绘”，下图是浏览器一帧中可以用于执行JS的时机。

一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback 

requestIdleCallback是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的。

浏览器并没有提供其他API能够在同样的时机（浏览器重排/重绘后）调用以模拟其实现。

唯一能精准控制调用时机的API是requestAnimationFrame，他能让我们在“浏览器重排/重绘”之前执行JS。

这也是为什么我们通常用这个API实现JS动画 —— 这是浏览器渲染前的最后时机，所以动画能快速被渲染。

所以，Scheduler的时间切片功能是通过task（宏任务）实现的。

- setTimeout：最常见

- [MessageChannel](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel)：执行时机比setTimeout更早

所以Scheduler将需要被执行的回调函数作为MessageChannel的回调执行。如果当前宿主环境不支持MessageChannel，则使用setTimeout

- setTimeout：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L47-L55

- MessageChannel：https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L228-L234

在React的render阶段，开启Concurrent Mode时，每次遍历前，都会通过Scheduler提供的shouldYield方法判断是否需要中断遍历，使浏览器有时间渲染：

```js
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

在Schdeduler中，为任务分配的初始剩余时间为5ms，但随着应用运行，会通过fps动态调整分配给任务的可执行时间。

```js
 forceFrameRate = function(fps) {
    if (fps < 0 || fps > 125) {
      // Using console['error'] to evade Babel and ESLint
      console['error'](
        'forceFrameRate takes a positive int between 0 and 125, ' +
          'forcing frame rates higher than 125 fps is not unsupported',
      );
      return;
    }
    if (fps > 0) {
      yieldInterval = Math.floor(1000 / fps);
    } else {
      // reset the framerate
      yieldInterval = 5;
    }
  };
```

这也解释了为什么在设置Concurrent Mode后每个任务的执行时间大体都是多于5ms的一小段时间 —— 每个时间切片被设定为5ms，任务本身再执行一小段时间，所以整体时间是多于5ms的时间

#####  3.4.2.2. 优先级调度 

Scheduler是独立于React的包，对外暴露了一个方法[unstable_runWithPriority](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/Scheduler.js#L217-L237)。

这个方法接受一个优先级与一个回调函数，在回调函数内部调用获取优先级的方法都会取得第一个参数对应的优先级：

```js
function unstable_runWithPriority(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
    case LowPriority:
    case IdlePriority:
      break;
    default:
      priorityLevel = NormalPriority;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}
```

一共有5种优先级

```js
// Times out immediately
var IMMEDIATE_PRIORITY_TIMEOUT = -1;
// Eventually times out
var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000;
// Never times out
var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
```

####  3.4.3. lane模型 

lane模型就是react优先级的机制，可以用来

- 可以表示优先级的不同

- 可能同时存在几个同优先级的更新，所以还得能表示批的概念

- 方便进行优先级相关计算

#####  3.4.3.1. 表示优先级不同 

lane模型使用31位的二进制表示31条赛道，位数越小的优先级越高，某些相邻的位拥有相同优先级。

```js
export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;

export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
export const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;

export const InputDiscreteHydrationLane: Lane = /*      */ 0b0000000000000000000000000000100;
const InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011000;

const InputContinuousHydrationLane: Lane = /*           */ 0b0000000000000000000000000100000;
const InputContinuousLanes: Lanes = /*                  */ 0b0000000000000000000000011000000;

export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000100000000;
export const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111000000000;

const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000001000000000000;
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111110000000000000;

const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;

export const SomeRetryLane: Lanes = /*                  */ 0b0000010000000000000000000000000;

export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;

const NonIdleLanes = /*                                 */ 0b0000111111111111111111111111111;

export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
const IdleLanes: Lanes = /*                             */ 0b0110000000000000000000000000000;

export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
```

同步优先级占用的位数为第一位

```js
export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
```

##### 3.4.3.2 表示“批”的概念

```js
const InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011000;
export const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111000000000;
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111110000000000000;
```

其中的某些变量占了多个位，这就是批

其中InputDiscreteLanes是“用户交互”触发更新会拥有的优先级范围。

DefaultLanes是“请求数据返回后触发更新”拥有的优先级范围。

TransitionLanes是Suspense、useTransition、useDeferredValue拥有的优先级范围。

这其中有个细节，越低优先级的lanes占用的位越多。比如InputDiscreteLanes占了2个位，TransitionLanes占了9个位。

原因在于：越低优先级的更新越容易被打断，导致积压下来，所以需要更多的位。相反，最高优的同步更新的SyncLane不需要多余的lanes

 3.4.3.3. 方便进行优先级相关计算 

使用位运算符

```js
// 判断a b是否有交集
export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {
  return (a & b) !== NoLanes;
}

// 计算b这个lanes是否是a对应的lanes的子集，只需要判断a与b按位与的结果是否为b：
export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane) {
  return (set & subset) === subset;
}

// 将两个lane或lanes的位合并只需要执行按位或操作：
export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
  return a | b;
}
```

# React源码

react理念

卡顿：

1. cpu卡顿：大量计算操作
2. IO 卡顿: 网络请求导致的卡顿

- JSX和 fiber的区别

JSX是渲染在页面的一种视图数据结构

Fiber 是双缓存的结构，是用户来作为更新机制的判断逻辑

Jsx->js->VDOM->fiber

1. render：fiber是如何被创建，并且传给renderer ，异步,对应着scheduler和reconciler

2. commit:接收effect,全部指向，进行对应的更新，同步,对应着render

### render

- beginWork：开始接收第一个fiber节点，并找到所有的fiber节点
- completeWork: 收录effect，并且维护一个effect队列

### commit

 effect队列，去执行对应的vdom的操作

1. effectList: 维护的fiber节点的单向链表
2. updateQueue: 里面每个fiber所含有的更新的内容

- before mutation：DOM更新之前
- mutation：DOM更新中的阶段
- layout：DOM更新后的阶段

return child sibling单向链表

2轮遍历

第一轮：

1. 遍历JSX newChildren newChildren[i] 和oldFiber对比，判断是否可以复用

2. 可以复用 i++  newChildren[i] oldFiber是否可以复用
3. 不能复用
   1. key不同，直接跳出遍历，进入到第二轮遍历
   2. key相同 type不同，oldFiber DELETION继续遍历

4. newChildren 遍历完成 oldFiber遍历完成

第二轮：

newChildren oldFiber

1. newChildren oldFiber同时遍历完成，update
2. newChildren没有遍历完，oldFiber遍历完成，新增节点Placement
3. newChildren遍历完，oldFiber遍历完，DELETION
4. newChildren和oldFiber都没有遍历完，节点位置发生变化

https://react.iamkasong.com/img/beginWork.png

# node 

## 1节

- node能干什么？
- npm 的一些规则和原理
- 包规则和原理

## 2节

- cjs 的原理
- 常见的node API
- node 事件循环。

## node 基础

一开始就做前端。
前端的编程，更倾向于是一种“声明式”的编程。
本质 - web 是一个“状态机”。

```vue
<template>
    <div>
        <h1>{{msg}}</h1>
        <ul v-if="dataList && (dataList instanceof Array) && dataList.length > 0">
            <li v-for="item of dataList" :key="item.id"> {{item.val}}</li>
        </ul>
    </div>
</template>

<script>
export default {
    data() {
        return {
            msg: 'hello',
            dataList: []
        }
    },
    methods: {
        apiGetData() {
            this.msg = "loading...";
            getData().then(res => {
                this.dataList = res.list;
                this.msg = "loaded"
            })
        }
    }
}
</script>

```

本质上，是一个状态编程，声明好了我的结构，明确了状态的流转，保证每一个状态都是可预测的。

### 命令式编程

function()
input -> process -> output 
IPO.

```java
class Test {
    public static void main(String[] args) {
        // TODO ...
    }
}
```

node ./index.js

## node 简介

### node 是什么？

> node.js 是一个 JS 的服务端运行环境。基于 V8，在 JS 语言规范的基础上，封装了一些服务端的runtime，让我们能够简单地实现非常多的功能。

### node 的历史

- 2008年 js 就是一个浏览器脚本。

LAMP / XAMP

- linux/windows + Apache + MySQL + php (thinkPhp, CI, DEDECMS);
  MEAN
- mongoDB + express + angular + node.js  2014年。

### node 可以做什么?

npm run start 的时候，运行了 node.

- 跨平台开发: PC, web, H5, RN, weex
- 后端开发: API, RPC, BFF
- 前端开发:
- 工具开发: 脚本，脚手架，命令行

### node 分类举例

压缩： UglifJS, JSmin
依赖： npm, bower, pnpm, yarn
模块： commonjs
构建： gulp, grunt, webpack
模板： jade, handlebars
跨端： electron, tauri

### node 的问题

`new Thread()`

- 单线程很脆弱， 可以通过 cluster / pm2
- node 对 mongoDB, MySQL, redis 
- 对 neo4j, tigergraph
- 安全问题

### node 和浏览器的区别

- node 环境中，是没有 `dom`, `bom`的，同样的，浏览器也没有 `fs`, `path`这些模块；
- 事件循环的区别
- `cjs` 和 `esm`
  - commonjs 本质是一个规范。node 率先实现了它
  - node 的实现方式(1-2节课内会讲) readFile 浏览器不行。
  - export import 异步请求。


## npm 规范

### node 的安装

- nvm 
  - 当我们需要多个版本 node 的时候，我们可以使用 nvm 去切换
- nrm
  - 用于设置 node 的镜像源
- npm
  - 包管理

### npm 的目标

- 给你和你的团队，带来最好的开源库和依赖。
  gem - ruby
  maven - java
  pip - python 

npm - node 
**中心式管理**

和 npm 有什么区别？

D:/.r/repository/org/java/apache/spring/spring-framework/2.2.0
D:/.r/repository/org/java/apache/spring/spring-framework/2.2.1
D:/.r/repository/org/java/apache/spring/spring-framework/2.2.2

如果说，我的电脑，磁盘也不大，我想要集中管理，像java 这样，咋整？

### npm 项目创建

#### npm install 发生了什么？

【见图3】

#### npm 缓存

`npm config get cache`
`yarn cache dir`

### npm 和 yarn 和 pnpm

- npm 还是 v3 的时候，是没有 lock 文件的，这时候，yarn 很牛逼
  - yarn.lock 的机制，保证了包的确定性
  - 采用了模块扁平安装模式 *
  - 请求排队，使网络性能更优秀
  - 采用了缓存机制，实现了离线模式。
    - `npm config get cache`
    - `yarn cache dir`
- 在命令行上的区别
- npm - rebuild
- yarn - why pack autoclean license import 
  synp -- yarn.lock 转成 package-lock.json

##### pnpm:

1. 通过硬链接，将全局的 store，链接在项目的 node_modules/.pnpm 文件中；
2. 再通过软链接构建组织依赖关系。

#### npm ci

是一个专门为了 ci 环境中使用的安装命令。

- 项目必须有 lock 文件
- 完全根据 lock 文件安装 - 同 5.0.x
- 会先删掉已有的 node_modules
- 一次性所有，不能 npm ci xxx
- 如果 package.json 和 lock 冲突，直接 throw Error

##### 使用场景

一般会在 ci 环境中使用，更稳定，更快。

#### npm dedupe 

自动地帮你去分析包依赖的关系，然后进行扁平化安装。

### dependencies

1. dependencies 表示项目的依赖。这些都是线上环境的代码组成部分。
   1. 当你的这个库被下载的时候，dependencies 下面的模块，也会被下载。

2. devDependencies 表示开发依赖。不会自动下载，常见的有 webpack, 各种 loader, plugin. jest 这些，eslint 这些。

3. peerDependencies 表示同版本依赖
   1. 比如，我们写一个基于 react 的组件，我们要不要自己下载 react 呢？
      1. 我不能单独运行，我需要你的工程具有 peerDependencies
      2. 我自己不想下载(react)，你要用我的这个库，你就自己下 react.

4. bundledDependencies

```json
{
    "bundledDependencies": [
        "Bundle1", "Bundle2"
    ]
}
```

5. optionalDependencies



## commonjs 实现

14:00 开始

### 模块化

由架构师，和开发人员决定的。对外通信的接口。

```js
function foo() {
    var bar = 1;
    var baz = 2;
}

```

1. 早期

```js
var student = {
    name: 'luyi',
    getStore: function() {
        return '60'
    }
}

student.name;
student.getStore;
```

2. 闭包的出现

```js
(function(global) {

    var name = 'luyi';
    function getStore() {
        // $.x.x
    };
    global.student = { name, getStore }

})(window)

```

3. 解决依赖的问题。

```js
(function(global, $) {

    var name = 'luyi';
    function getStore() {
        // $.x.x
    };
    global.student = { name, getStore }

})(window， jquery)

```

```js
var module = {
    exports: {

    }
};

(function(module, exports, require) {

    const $ = require('../juery.min.js')

    var name = 'luyi';
    function getStore() {
        // $.x.x
    };
    module.exports = { name, getStore }

})

(module, module.exports, require)


```

## node api

### Buffer 

浏览器中，上传一个 blob
typedArray 
arrayBuffer
file 
fileReader

#### 本质是一个计算机的数据结构

表示的是一个固定长度的 缓冲区序列。

#### 声明




## 事件循环

1. process.nextTick 是一个微任务，并且在 promise 之前
2. setImmediate 是 libuv 实现的一个 API

```
             同步的代码
                 |
     process.nextTick / promise...
                 |
   ┌───────────────────────────┐
┌─>│           timers          │ 定时器： setTimeout / setInterval
│  └─────────────┬─────────────┘
|    process.nextTick / promise...
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │ 执行延迟到下一个循环迭代的I/O回调
│  └─────────────┬─────────────┘
|    process.nextTick / promise...
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │ 系统内部使用
│  └─────────────┬─────────────┘      ┌───────────────┐
|    process.nextTick / promise...
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
|    process.nextTick / promise...
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │ setImmediate 
│  └─────────────┬─────────────┘
|    process.nextTick / promise...
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │ 关闭回调函数
   └───────────────────────────┘

```



# 2023前端面试&框架高频考点解析

## 前端常见的认知误区

Job Model

- 前端开发
- 前端架构（比如prettier,eslint）
- 可视化 echarts
- node
- 图像互动： 2d 3d
- 前端体验 前端数据度量水平 & 体验
- 前端工程化 ci/cd
- 跨端应用 weex rn  flutter ->编译原理electron->tar
- 后台应用 form ui库 low code
- 多媒体流

写页面 ->更高的水平

- prettier

- editor
- eslint
- tsconfig
- husky
- create react app
- vite template

封装成团队统一的规范 cli+ 按需引入ui +埋点

## 面试常见的问题

如果项目有特点，反而八股文问的比较少

A同学 3-5年

- pc web  小程序 electron

- react vue 业务内容

- 权限管理

- CI/CD
- 推动CR脚手架 规范代码风格
- github star

jest 定制化代码规范 SSR DNS CDN

eslint npm

中小厂：提升自己的核心竞争力

大厂： 某个领域处于专家的水平 1个正式+N个外包

外企/国企：

就业城市

1-3：p5 20k+

3-5:  p6 25k-30k+

5+:   p7 35k+ +股票

## 前端框架中的函数式编程思想

react: hooks

vue: vue composition api

# React_Native 入门与原理介绍

## 1. 课程总目标（两节）

P6：

- 会使用 RN，了解RN同类别的产品，了解移动端的主要技术方案，有一定的跨端开发经验，踩过一些坑；

P6+ ～ P7：

- 知道如何与native进行数据交互，知道ios与安卓jsbridge实现原理。
- 知道移动端webview和基础能力，包括但不限于：webview资源加载优化方案；webview池管理、独立进程方案；native路由等。
- 能够给出完整的前后端对用户体系的整体技术架构设计，满足多业务形态用户体系统一。考虑跨域名、多组织架构、跨端、用户态开放等场景。

其他目标：

- 把react以及跨端相关的知识点，一起串一下。
  - 在窥探 react- native 原理的同时，给大家总结一下 react 框架上的一些知识，同时，也带大家一起了解一些 跨端编译方面的知识。

## 2.课程大纲（本节）

- 介绍 RN 的背景，与其他跨端开发之间的异同；
- 介绍 RN 的渲染模式，对比到 React 框架、小程序框架；
- 介绍 RN 的整体原理。

## 3.主要内容

### 移动端跨平台开发方案的演进

#### 当前热点

- **React Native**
- lonic
- **Expo**
- Quasar
- Flipper
- Flutter

#### 演进历史

- Webview
- ReactNative （Weex）
- Flutter
- RN + Fabric

![RN跨端演进](/Volumes/F/zyl-study/web-zhuawa/20221203/RN跨端演进.png)

### 端与跨端

- 端：数据获取、状态管理、页面渲染。(FE三板斧)
- 跨端：虚拟机、渲染引擎、原生交互、开发环境。

#### 1. 数据获取

还是老三样：fetch \ axios \ XHR 

#### 2. 状态管理

React 中的 state 模式

#### 3. 页面渲染

vDom -> yoga -> iOS / android / DOM APIs  -> iOS / android / Web

#### 4. 虚拟机

##### RN:

- JSC - Objective-c / JS
- 到原生层，用了大量的 bridge

##### Flutter:

- JIT(dev) + AOT(prod)
- Skia 

- 生态问题

#### 5. 渲染引擎

yoga

#### 6. 原生交互

Jsbridge

#### 7. 开发环境

### RN  的原理

#### React 的设计理念

在运行时开发者能够处理 React JSX 的核心基础其实在于 **React 的设计理念**，React 将自身能力充分解耦，并提供给社区接入关键环节。这里我们需要先进行一些 React 原理解析。

React 的整体设计理念可以分为三个部分：

- React Core

- React Renderer

- Reconciler
- 在这里我们需要了解的是：

自定义 renderer --- 宿主配置 **hostConfig** --- React reconciler --- react core

```js
HostConfig.getPublicInstance
HostConfig.getRootHostContext
HostConfig.getChildHostContext
HostConfig.prepareForCommit
HostConfig.resetAfterCommit
HostConfig.createInstance
HostConfig.appendInitialChild
HostConfig.finalizeInitialChildren
HostConfig.prepareUpdate
HostConfig.shouldSetTextContent
HostConfig.shouldDeprioritizeSubtree
HostConfig.createTextInstance
HostConfig.scheduleDeferredCallback
HostConfig.cancelDeferredCallback
HostConfig.setTimeout
HostConfig.clearTimeout
HostConfig.noTimeout
HostConfig.now
HostConfig.isPrimaryRenderer
HostConfig.supportsMutation
HostConfig.supportsPersistence
HostConfig.supportsHydration
// -------------------
//      Mutation
//     (optional)
// -------------------
HostConfig.appendChild
HostConfig.appendChildToContainer
HostConfig.commitTextUpdate
HostConfig.commitMount
HostConfig.commitUpdate
HostConfig.insertBefore
HostConfig.insertInContainerBefore
HostConfig.removeChild
HostConfig.removeChildFromContainer
HostConfig.resetTextContent
HostConfig.hideInstance
HostConfig.hideTextInstance
HostConfig.unhideInstance
HostConfig.unhideTextInstance
// -------------------
//     Persistence
//     (optional)
// -------------------
HostConfig.cloneInstance
HostConfig.createContainerChildSet
HostConfig.appendChildToContainerChildSet
HostConfig.finalizeContainerChildren
HostConfig.replaceContainerChildren
HostConfig.cloneHiddenInstance
HostConfig.cloneUnhiddenInstance
HostConfig.createHiddenTextInstance
// -------------------
//     Hydration
//     (optional)
// -------------------
HostConfig.canHydrateInstance
HostConfig.canHydrateTextInstance
HostConfig.getNextHydratableSibling
HostConfig.getFirstHydratableChild
HostConfig.hydrateInstance
HostConfig.hydrateTextInstance
HostConfig.didNotMatchHydratedContainerTextInstance
HostConfig.didNotMatchHydratedTextInstance
HostConfig.didNotHydrateContainerInstance
HostConfig.didNotHydrateInstance
HostConfig.didNotFindHydratableContainerInstance
HostConfig.didNotFindHydratableContainerTextInstance
HostConfig.didNotFindHydratableInstance
HostConfig.didNotFindHydratableTextInstance
```

附：

Taro 的包：https://github.com/NervJS/taro/tree/next/packages/taro-react

native的包：https://github.com/facebook/react/blob/main/packages/react-native-renderer/src/ReactNativeHostConfig.js

Dom 的包：https://github.com/facebook/react/blob/main/packages/react-dom/src/client/ReactDOMHostConfig.js

ART 的包：https://github.com/facebook/react/blob/main/packages/react-art/src/ReactARTHostConfig.js

#### RN 原理

##### 注册与发布

`AppRegistry`是所有 React Native 应用的 JS 入口。应用的根组件应当通过`AppRegistry.registerComponent`方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用`AppRegistry.runApplication`来真正运行应用。

```js
AppRegistry.registerComponent(appName, () => App);
```

##### Libraries/ReactNative/AppRegistry.js

```js
registerComponent(
    appKey: string,
    componentProvider: ComponentProvider,
    section?: boolean,
  ): string {
    let scopedPerformanceLogger = createPerformanceLogger();
    runnables[appKey] = {
      componentProvider,
      run: (appParameters, displayMode) => {
        const concurrentRootEnabled =
          appParameters.initialProps?.concurrentRoot ||
          appParameters.concurrentRoot;
        /***********************/
        renderApplication(
          componentProviderInstrumentationHook(
            componentProvider,
            scopedPerformanceLogger,
          ),
          appParameters.initialProps,
          appParameters.rootTag,
          wrapperComponentProvider && wrapperComponentProvider(appParameters),
          appParameters.fabric,
          showArchitectureIndicator,
          scopedPerformanceLogger,
          appKey === 'LogBox',
          appKey,
          coerceDisplayMode(displayMode),
          concurrentRootEnabled,
        );
      },
    };
    if (section) {
      sections[appKey] = runnables[appKey];
    }
    return appKey;
  },
    
    
  runApplication(
    appKey: string,
    appParameters: any,
    displayMode?: number,
  ): void {
    if (appKey !== 'LogBox') {
      const logParams = __DEV__
        ? '" with ' + JSON.stringify(appParameters)
        : '';
      const msg = 'Running "' + appKey + logParams;
      infoLog(msg);
      BugReporting.addSource(
        'AppRegistry.runApplication' + runCount++,
        () => msg,
      );
    }
    invariant(
      runnables[appKey] && runnables[appKey].run,
      `"${appKey}" has not been registered. This can happen if:\n` +
        '* Metro (the local dev server) is run from the wrong folder. ' +
        'Check if Metro is running, stop it and restart it in the current project.\n' +
        "* A module failed to load due to an error and `AppRegistry.registerComponent` wasn't called.",
    );

    SceneTracker.setActiveScene({name: appKey});
    runnables[appKey].run(appParameters, displayMode);
  },
```

##### Libraries/ReactNative/renderApplication.js

```js
function renderApplication<Props: Object>(
  RootComponent: React.ComponentType<Props>,
  initialProps: Props,
  rootTag: any,
  WrapperComponent?: ?React.ComponentType<any>,
  fabric?: boolean,
  showArchitectureIndicator?: boolean,
  scopedPerformanceLogger?: IPerformanceLogger,
  isLogBox?: boolean,
  debugName?: string,
  displayMode?: ?DisplayModeType,
  useConcurrentRoot?: boolean,
) {
  invariant(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);

  const performanceLogger = scopedPerformanceLogger ?? GlobalPerformanceLogger;

  let renderable = (
    <PerformanceLoggerContext.Provider value={performanceLogger}>
      <AppContainer
        rootTag={rootTag}
        fabric={fabric}
        showArchitectureIndicator={showArchitectureIndicator}
        WrapperComponent={WrapperComponent}
        initialProps={initialProps ?? Object.freeze({})}
        internal_excludeLogBox={isLogBox}>
        <RootComponent {...initialProps} rootTag={rootTag} />
      </AppContainer>
    </PerformanceLoggerContext.Provider>
  );

  if (__DEV__ && debugName) {
    const RootComponentWithMeaningfulName = getCachedComponentWithDebugName(
      `${debugName}(RootComponent)`,
    );
    renderable = (
      <RootComponentWithMeaningfulName>
        {renderable}
      </RootComponentWithMeaningfulName>
    );
  }

  performanceLogger.startTimespan('renderApplication_React_render');
  performanceLogger.setExtra('usedReactFabric', fabric ? '1' : '0');
  if (fabric) {
    require('../Renderer/shims/ReactFabric').render(
      renderable,
      rootTag,
      null,
      useConcurrentRoot,
    );
  } else {
    /*****************************/
    require('../Renderer/shims/ReactNative').render(renderable, rootTag);
  }
  performanceLogger.stopTimespan('renderApplication_React_render');
}
```

##### Libraries/Renderer/implementations/ReactNativeRenderer-dev.js

```js
// 22976
function render(element, containerTag, callback) {
  var root = roots.get(containerTag);

  if (!root) {
    // TODO (bvaughn): If we decide to keep the wrapper component,
    // We could create a wrapper for containerTag as well to reduce special casing.
    root = createContainer(containerTag, LegacyRoot, false, null, false);
    roots.set(containerTag, root);
  }

  updateContainer(element, root, null, callback); // $FlowIssue Flow has hardcoded values for React DOM that don't work with RN

  return getPublicRootInstance(root);
}
// updateContainer
// scheduleUpdateOnFiber
// performSyncWorkOnRoot
// renderRootSync
// workLoopSync
// performUnitOfWork
// completeWork
// -HostComponent-createInstance
// -> 一直走到 createInstance

function createInstance(
  type,
  props,
  rootContainerInstance,
  hostContext,
  internalInstanceHandle
) {
  var tag = allocateTag();
  var viewConfig = getViewConfigForType(type);

  {
    for (var key in viewConfig.validAttributes) {
      if (props.hasOwnProperty(key)) {
        ReactNativePrivateInterface.deepFreezeAndThrowOnMutationInDev(
          props[key]
        );
      }
    }
  }

  var updatePayload = create(props, viewConfig.validAttributes);
    /**************************************/
  ReactNativePrivateInterface.UIManager.createView(
    tag, // reactTag
    viewConfig.uiViewClassName, // viewName
    rootContainerInstance, // rootTag
    updatePayload // props
  );
  var component = new ReactNativeFiberHostComponent(
    tag,
    viewConfig,
    internalInstanceHandle
  );
  precacheFiberNode(internalInstanceHandle, tag);
  updateFiberProps(tag, props); // Not sure how to avoid this cast. Flow is okay if the component is defined
  // in the same file but if it's external it can't see the types.

  return component;
}

```

##### Renderer

<img src="/Users/zhengyali/Library/Application Support/typora-user-images/image-20230315204524326.png" alt="image-20230315204524326" style="zoom:67%;" />

#### 一起实现一个render

其他的可参考资料：

https://www.awesome-react-native.com/

# node

node中想要写esm,共有2种方法？

- package.json添加type:module
- 将.js的后缀写成.mjs
- 写一个构建配置

```js
//rollup.config.js
const  babel =require('@rollup/plugin-babel');

export default {
    input:'./server/socket/index.js',
    output:{
        file:'./dist/socket/bundle.js',
        format:'umd'
    },
    treeshake:false,
    plugins:[
        babel({
            extension:['.js','.ts'],
            exclude:'node_modules/**'
        })
    ]
}

//.babelrc
{
    "presets":[
        ["@babel/preset-env",{
            "modules":false,
            "loose":true,
            "targets":'node 14',
            "useBuiltIns":"useage",
            "corejs":{
                "version":"3.29",
                "proposals":true
            }
        }],
        "@babel/preset-react"
    ],
      "plugins":["./consolePlugin"]  
}
```

# **小程序机制&微信小程序介绍**

https://www.yuque.com/lpldplws/web/rit375?singleDoc# 《小程序机制&微信小程序介绍》 密码：ddiy

## 1.课程目标

1.学习小程序基本原理，对目前行业内小程序有基本理解

2.掌握微信小程序基本内容

3.掌握微信小程序发布流程

## 2.课程大纲

- 小程序机制解析
- 微信小程序

## 3. 小程序机制介绍

### 3.1 什么是小程序

小程序页面本质上是网页：

1. 使用技术栈与网页开发是一致的，都用到HTML、CSS和JS
2. 区别：不支持浏览器API,只能用微信提供的API

外部代码通过小程序这种形式，在手机 App 里面运行：微信、支付宝， 小程序可以视为只能用微信等 APP 作为载体打开和浏览的网站。 

### 3.2 小程序的发展历程

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649385302991-e9f50c5d-855d-45d3-a2e7-8bb2bed42254.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)

1. 微信小程序形态

   a.小程序从业务形式上更像是公众号开发的演变产物；

   b.早期微信通过 sdk 的形式，增强了开发者开发公众号网页的能力；

   c.小程序的诞生是微信本身迈向平台化超级 App 的业务行为，并且帮助用户更好的实现了「轻量级 Web App」；

2. 开发标准

   a.最初微信小程序自己定义了一套”标准“，最开始的框架甚至没有组件、没有 npm，和 Web 生态严重脱节；

   b.由于特殊的双线程模型与四不像的语法，开发者苦不堪言，小程序的开放之士队三方业务的开放而已

3. 商家涌入

   a.小程序业务的开放性 ->平台型 App；

   b.比如：支付宝小程序、百度小程序、淘宝小程序、360小程序、快应用......

   c.小程序设计目的：大多数选择了和微信类似的架构、框架，更多不是从技术角度考虑，而是想尽可能蹭微信小程序的福利，让开发者可以更快的投放到自己的平台；

### 3.3 原生微信小程序框架介绍

#### 3.3.1 小程序的目录结构

工程的工作目录中包含以下文件：

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649385302900-e497ed1c-c1a3-43d9-a9f7-8c66da5a99ce.png)



#### 3.3.2 技术选型

渲染界面的技术方案：

1. 用纯客户端原生技术渲染
2. 用纯web技术渲染
3. 用客户端原生技术与 Web 技术结合的混合技术（简称 Hybrid 技术）渲染；

方案对比：

1. 开发门槛：Web 门槛低，Native 也有像 RN 这样的框架支持；
2. 体验：Native 体验比 Web 要好太多，Hybrid 在一定程度上比 Web 接近原生体验；
3. 版本更新：Web 支持在线更新，Native 则需要打包到微信一起审核发布；
4. 管控和安全：Web 可跳转或是改变页面内容，存在一些不可控因素和安全风险；

 方案确定：

1. 小程序的宿主环境是微信等手机 APP，用纯客户端原生技术来编写小程序，那么小程序代码每次都需要与手机 APP 代码一起发版❎；

2. Web 支持有一份副本资源包放在云端，通过下载到本地，动态执行后即可渲染出界面，但纯 Web 技术在一些复杂的交互上可能会面临一些性能问题❎；

   a .在 Web 技术中，UI 渲染跟脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。

3. 两者结合起来的 Hybrid 技术来渲染小程序，用一种近似 Web 的方式来开发，并且可以实现在线更新代码✅；

   a. 扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力；

   b. 体验更好，同时也减轻 WebView 的渲染工作；

   c.用客户端原生渲染内置一些复杂组件，可以提供更好的性能；

#### 3.3.3 双线程模型

小程序的渲染层和逻辑层分别由 2 个线程管理：

1. 视图层 -> WebView 进行渲染；
2. 逻辑层 -> JsCore 线程运行 JS脚本；

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649385302978-a50aedec-7180-49b1-a709-f4890e2f1280.png)



设计目的：为了管控和安全等问题，阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口；

使用沙箱环境提供纯 JavaScript 的解释执行环境

1. 客户端系统：JavaScript 引擎；
2. iOS ： JavaScriptCore 框架；
3. 安卓：腾讯 x5 内核提供的 JsCore ；

小程序双线程模型

- 逻辑层：创建一个单独的线程去执行 JavaScript，在这里执行的都是有关小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等；
- 视图层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以视图层存在多个 WebView 线程；
- JSBridge 起到架起上层开发与Native（系统层）的桥梁，使得小程序可通过API使用原生的功能，且部分组件为原生组件实现，从而有良好体验

#### 3.3.4. 数据驱动视图变化 

问题：JS 逻辑代码放到单独的线程去运行，在 Webview 线程里没法直接操作 DOM。开发者如何实现动态更改界面呢？

DOM 的更新通过简单的数据通信来实现

逻辑层和视图层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。

JS 对象模拟 DOM 树 -> 比较两棵虚拟 DOM 树的差异 -> 把差异应用到真正的 DOM 树上。

<img src="https://cdn.nlark.com/yuque/0/2022/png/2340337/1649385302760-b87160a6-7f26-4495-8e64-0cbcb1167ed2.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0&date=1689686549151" style="zoom:70%;" />

1. 在渲染层把 WXML 转化成对应的 JS 对象；

2. 在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层；

3. 经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面；

#### 3.3.5. 事件的处理 

视图层需要进行交互，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户。

视图层的功能只是进行渲染，因此对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给JS处理。

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649385304104-d7e1cabc-e9df-42a9-bd83-9c44a928cfd0.png)

事件的派发处理包括事件捕获和冒泡两种：
通过native传递给 JSCore，通过 JS 来响应响应的事件之后，对 Dom 进行修改，改动会体现在虚拟 Dom 上，然后再进行真实的渲染。

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649385304041-5b3b06aa-e0f1-42ed-a2a5-fd205753011d.png)

#### 3.3.6. 运行机制

小程序启动机制：

1. 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动
2. 热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台；

注意：

- 小程序没有重启的概念；
- 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁；
- 当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁；

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649385304125-0d1911b3-7567-420e-978c-ca85a518b4ac.png)

### 3.4 小程序框架对比

#### 3.4.1 小程序原生语法 

 

 

1. 目前小程序生态支持开发者利用前端部分生态开发应用的；

2. 目前小程序已经能够做到前端工程化，并且植入前端生态中已有的一些理念，例如状态管理、CLI 工程化等等，与早期 npm 能力的缺失、只能通过模板渲染实现组件化不可同日而语；

3. 当业务的需求只有投放到微信或者支付宝小程序时，原生语法可以成为前端程序员们的一个选择；前端能力基本都可以在小程序上复用（如状态管理库颗粒化管理组件状态、TS等）；

#### 3.4.2. 增强型框架 

指小程序引入 npm 之后，有了更加开放的能力所带来的收益；

以小程序原生语法为主，在逻辑层引入了增强语法来优化应用性能或者提供更便捷的使用方法；

Example：腾讯开源的 [omix](https://link.zhihu.com/?target=https%3A//github.com/Tencent/omi/tree/master/packages/omix) 框架为例：

```js
// 逻辑层
create.Page(store, {
 // 声明依赖
 use: ['logs'],
 computed: {
 logsLength() {
 return this.logs.length
 }
 },
 onLoad: function () {
 //响应式，⾃动更新视图
 this.store.data.logs = (wx.getStorageSync('logs') ||
 return util.formatTime(new Date(log))
 })
 setTimeout(() => {
 //响应式，⾃动更新视图
 this.store.data.logs[0] = 'Changed!'
 }, 1000)
 }
})
//视图层
<view class="container log-list">
 <block wx:for="{{logs}}" wx:for-item="log">
 <text class="log-item">{{index + 1}}. {{log}}</text>
 </block>
</view
```

1. 整体保留⼩程序已有的语法，但在此基础之上，对它进⾏了扩充和增强；

2. ⽐如引⼊了 Vue 中⽐较有代表性的 computed，⽐如能够直接通过 this.store.data.logs[0] = 'Changed' 修改状态。可以说是在⼩程序原⽣半 Vue 半 React 的语法背景下，彻底将其 Vue 化的⼀种⽅案； 

使⽤增强型框架优势：

1. 可以在只引⼊极少依赖，并且保留对⼩程序认知的情况下，⽤更加舒爽的语 法来写代码；
2.   对于⽬标只投放到特定平台⼩程序的开发者或者⾮专业前端⽽⾔是⽐较好的 选择之⼀；因为你只需要关注很少的新增⽂档和⼩程序⾃身的⽂档就⾜够 了，底层不需要考虑；

#### 3.4.3. 转换类框架 

目的：让开发者几乎不用感受小程序原生语法，更大程度对接前端已有生态，并且可以实现「一码多端」的业务诉求，只是最后的构建产物为小程序代码。

##### 3.4.3.1. 编译时 

通过编译分析的方式，将开发者写的代码转换成小程序原生语法。

以 Rax 编译时和 Taro 2.0 为例，面向开发者的语法是类 React 语法，开发者通过写有一定语法限制的 React 代码，最后转换产物 1:1 转换成对应的小程序代码。

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649385304326-506eca59-ce6d-4296-8605-10df215c7050.png)

以一段简单的代码为例

```js
// rax
import { createElement, useEffect, useState } from 'rax'
import View from 'rax-view';
export default function Home() {
 const [name, setName] = useState('world');
 useEffect(() => {
 console.log('Here is effect.');
 }, [])
 return <View>Hello {name}</View>;
}
// 转为⼩程序后的代码
// 逻辑层
import { __create_component__, useEffect, useState } fro
function Home() {
 const [name, setName] = useState('world');
 useEffect(() => {
 console.log('Here is effect.');
 }, []);
 this._updateData({
 _d0: name
 });
}
Component(__create_component__(Home));
// 视图层
<block a:if="{{$ready}}">
 <view class="__rax-view">{{_d0}}</view>
</block
```

1. 开发者虽然写的是类 React 语法，但是转换后的代码和渐进增强型框架⾮ 常类似
2. 开发者可以⽐较清晰的看出编译前后代码的对应关系； 编译时⽅案会通过 AST 分析，将开发者写的 JSX 中 return 的模板部分构建到 视图层，剩余部分代码保留，然后通过运⾏时垫⽚模拟 React 接⼝的表现。

优势

1. 运⾏时性能损耗低；
2. ⽬标代码明确，开发者所写即所得； 
3. 运⾏时、编译时优化：⽐如框架会给予开发者更多的语法⽀持以及默认的性 能优化处理，⽐如避免多次 setData，亦或是⻓列表优化等等； 

劣势：

1. 语法限制⾼：需要完全命中开发者在模板部分所⽤到的所有语法，语法受 限，如由于是 1:1 编译转换，开发者在开发的时候还是不得不去遵循⼩程序 的开发规范，⽐如⼀个⽂件中定义只能定义⼀个组件之类的； 

##### 3.4.3.2. 运⾏时

相⽐于上⾯的编译时，最⼤的优势是可以⼏乎没有任何语法约束的去完成代码 编写。 

通过在逻辑层模拟 DOM/BOM API，将这些创建视图的⽅法转换为维护⼀棵 VDOM tree，再将其转换成对应 setData 的数据，最后通过预置好的模板递归 渲染出实际视图。 

优势：没有语法限制； 

劣势：以⼀定的性能损耗来换取更为全⾯的 Web 端特性⽀持；

## 4. 微信小程序 

### 4.1. 微信小程序基本内容 

代码github地址：https://github.com/wechat-miniprogram/miniprogram-demo

#### 4.1.1. 基础 

官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/

小程序代码组成：

- WXML：（WeiXin Markup Language）

- WXSS：（WeiXin Style Sheets）

- WXS：（WeiXin Script）

小程序框架：

1. 逻辑层

a. 官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/

b. 使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能；

c. 开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 [ServiceWorker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)，所以逻辑层也称之为 App Service；

d. 增加 App 和 Page 方法，进行[程序注册](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html)和[页面注册](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html)；

e. 增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈；

f. 提供丰富的 [API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html)，如微信用户数据，扫一扫，支付等微信特有能力；

g. 提供[模块化](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#模块化)能力，每个页面有独立的[作用域](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#文件作用域)；

h. 小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 web 中一些能力都无法使用，如 window，document 等。

2. 视图层

a. 官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/view/
基础核心

1. 小程序运行时
   a. 小程序生命周期：热启动 == 后台切前台

![](https://cdn.nlark.com/yuque/0/2022/svg/2340337/1649520479424-14b006a6-3666-49d3-84be-92c0bebc44cc.svg)

b. 更新机制
ⅰ. 启动时同步更新

1. 定期检查小程序版本；
2. 长时间未使用小程序；

ⅱ. 启动时异步更新

1. 打开发现有新版本，异步下载，下次冷启动时加载新版本；

ⅲ. 开发者手动更新

[wx.getUpdateManager](https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html) 

2. 代码注入
   a. 按需注入："lazyCodeLoading": "requiredComponents"；小程序仅注入当前页面需要的自定义组件和页面代码，在页面中必然不会用到的自定义组件不会被加载和初始化；

   b. 用时注入：在开启「按需注入」特性的前提下，指定一部分自定义组件不在小程序启动时注入，而是在真正渲染的时候才进行注入，使用占位组件在需要渲染但注入完成前展示；

3. 分包加载

   a. 原则

   ⅰ. 声明 subpackages 后，将按 subpackages 配置路径进行打包，subpackages 配置路径外的目录将被打包到 app（主包） 中；
   ⅱ. app（主包）也可以有自己的 pages（即最外层的 pages 字段）；
   ⅲ. subpackage 的根目录不能是另外一个 subpackage 内的子目录；
   ⅳ. tabBar 页面必须在 app（主包）内
   b. 独立分包
   ⅰ. 开发者可以按需将某些具有一定功能独立性的页面配置到独立分包中。当小程序从普通的分包页面启动时，需要首先下载主包;
   ⅱ. 独立分包运行时，App 并不一定被注册，因此 getApp() 也不一定可以获得 App 对象；基础库 [2.2.4](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 版本开始 getApp 支持 [allowDefault] 参数，在 App 未定义时返回一个默认实现。当主包加载，App 被注册时，默认实现中定义的属性会被覆盖合并到真正的 App 中；

4. 小程序如何调试？
   a. vconsole；
   b. sourceMap；
   c. 实时日志：重写log，使用wx.getRealtimeLogManager封装，在运营后台“开发->开发管理->运维中心->实时日志”查看；
   d. errno：针对API的cb err进行状态码的判断，便于针对业务场景语义

5. 小程序如何兼容版本

   ```js
   // 1. 版本号⽐较
   const version = wx.getSystemInfoSync().SDKVersion
   if (compareVersion(version, '1.1.0') >= 0) {
    wx.openBluetoothAdapter()
   } else {
    // 如果希望⽤户在最新版本的客户端上体验您的⼩程序，可以这样⼦提示
    wx.showModal({
    title: '提示',
    content: '当前微信版本过低，⽆法使⽤该功能，请升级到最新微信版本后重试
    })
   }
   // 2. API是否存在
   if (wx.openBluetoothAdapter) {
    wx.openBluetoothAdapter()
   } else {
    // 如果希望⽤户在最新版本的客户端上体验您的⼩程序，可以这样⼦提示
    wx.showModal({
    title: '提示',
    content: '当前微信版本过低，⽆法使⽤该功能，请升级到最新微信版本后重试
    })
   }
   // 3. wx.canIUse
   wx.showModal({
    success: function(res) {
    if (wx.canIUse('showModal.success.cancel')) {
    console.log(res.cancel)
    }
    }
   })
   // 4. 设置最低基础库版本
   运营后台设置最低基础库版本
   ```


#### 4.1.2. 框架

官方文档：https://developers.weixin.qq.com/miniprogram/dev/reference/

1. 小程序配置
   a. 全局配置
   ⅰ. 根目录下app.json；
   b. 页面配置
   ⅰ. 在page页面中对应的json文件，权重最高；
   ⅱ. 原先在根目录下的app.json中window内属性，在页面json中无需添加window；
   c. sitemap 配置
   ⅰ. 根目录下sitemap.json；

2. 框架接口
   a. 小程序App
        ⅰ. App：必须在 app.js 中调用，必须调用且只能调用一次

   1. onLaunch
   2. onShow
   3. onHide
   4. onError
   5. onPageNotFound
   6. onUnhandledRejection
   7. onThemeChange
   8. 其他：可以添加任意的函数或数据变量到 Object 参数中，app.js中用 this 可以访问； （Tips：非原生事件最好不要用on开头）
      ⅱ. getApp：外部访问App中数据的方式

   b.页面

      i. Page：在页面级别中的"app.js"

   1. data

   2. 生命周期事件
      a. onLoad：加载时触发
      b. onReady：渲染完成触发
      c. onShow
      d. onHide
      e. onUnload

   3. 页面事件处理事件

      a. onPullDownRefresh
      b. onReachBottom
      c. onPageScroll：监听页面滚动
      d. onAddToFavorites：添加到收藏并自定义收藏内容
      e. onShareAppMessage：转发事件
      f. onShareTimeline：转发朋友圈
      g. onResize
      h. onTabItemTap
      i.onSaveExitState：页面销毁前

   4. 组件事情处理

      a. wxml中绑定的自定义事件

      b. Page.route
      c. Page.prototype.setData
           ⅰ. 注意：可以以数据路径来改变数组中的某一项或对象的某个属性，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。

   5. 页面间通信

      使用 [wx.navigateTo](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html) 打开，这两个页面间将建立一条数据通道：
      a. 被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象；
      b. wx.navigateTo 的 success 回调中也包含一个 EventChannel 对象；
      c. 这两个 EventChannel 对象间可以使用 emit 和 on 方法相互发送、监听事件；

   iii. getCurrentPage

   1. 获取当前页面栈，数组中第一个元素为首页，最后一元素为当前页面；

   2. 场景：

      ```js
      1. 进⼊⼩程序⾮默认⾸⻚时，需要执⾏对应操作
      onShow() {
       let pages = getCurrentPages(); // 当前⻚⾯栈
       if (pages.length == 1) {
       //todo
       }
      }
      2. 跨⻚⾯赋值
      let pages = getCurrentPages();// 当前⻚⾯栈
      let prevPage = pages[pages.length - 2];// 上⼀⻚⾯
      prevPage.setData({
       // 直接给上移⻚⾯赋值
      });
      3. ⻚⾯跳转后⾃动刷新
      wx.switchTab({
       url: '../index/index',
       success: function (e) {
       const page = getCurrentPages().pop(); // 当前⻚⾯
       if (page == undefined || page == null) return;
       page.onLoad(); //或者其它操作
       }
      })
      4. 获取当前⻚⾯相关信息
      let pages = getCurrentPages(); // 当前⻚⾯栈
      // 当前⻚⾯为⻚⾯栈的最后⼀个元素
      let prevPage = pages[pages.length - 1];// 当前⻚⾯
      
      console.log( prevPage.route) //举例：输出为‘pages/index/index'
      ```

      3. 自定义组件
         ⅰ. Component
         ⅱ. Behavior

      4. 模块化
         ⅰ. require

         1. 引入module.export或者 export暴露出的接口，需要引入模块文件相对于当前文件的相对路径，或npm模块名，或npm模块路径。不支持绝对路径

         ii. module：当前模块对象
         ⅲ. export：module.export的引用
         ⅳ. requirePlugin：引用插件
         ⅴ. requireMiniProgram：引用当前小程序

      5. 基础功能
         ⅰ. console

         1. console.debug
         2. console.error
         3. console.log
         4. console.info
         5. console.warn
         6. console.group
         7. console.groupEnd

         ii. 定时器

         1. setTimeout
         2. clearTimeout
         3. setInterval
         4. clearInterval

   3. WXML
      a. 数据绑定
           ⅰ. 数据绑定使用 Mustache 语法（双大括号）包起来，与Page里data变量绑定起来；
           ⅱ. 支持类型

               1.  变量：<view> {{ message }} </view>
               1.  属性：<view id="item-{{id}}"> </view>

      1. 控制属性：<view wx:if="{{condition}}"> </view>
      2. 关键字（在双引号间）：<checkbox checked="{{false}}"> </checkbox> 
      3. 运算：<view> {{a + b}} + {{c}} + d </view>
      4. 逻辑：<view wx:if="{{length > 5}}"> </view> 
      5. etc......

      b. 列表渲染

      ```js
      // 默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默
      <view wx:for="{{array}}">
       {{index}}: {{item.message}}
      </view>
      Page({
       data: {
       array: [{
       message: 'foo',
       }, {
       message: 'bar'
       }]
       }
      })
      // ⼿动指定
      <view wx:for="{{array}}" wx:for-index="idx" wx:for-item=
       {{idx}}: {{itemName.message}}
      </view>
      // 重复渲染代码块
      <block wx:for="{{[1, 2, 3]}}">
       <view> {{index}}: </view>
       <view> {{item}} </view>
      </block>
      ```

      c. 条件渲染

      ```js
      <view wx:if="{{length > 5}}"> 1 </view>
      <view wx:elif="{{length > 2}}"> 2 </view>
      <view wx:else> 3 </view>
      // block
      <block wx:if="{{true}}">
       <view> view1 </view>
       <view> view2 </view>
      </block>
      wx:if vs hidden
      wx:if 有更⾼的切换消耗⽽ hidden 有更⾼的初始渲染消耗。
      因此，如果需要频繁切换的情景下，⽤ hidden 更好，如果在运⾏时条件不大可能改变则wx:if较好
      ```

      d. 模版

      ```js
      // 定义模板
      <!--
       index: int
       msg: string
       time: string
      -->
      <template name="msgItem">
       <view>
       <text> {{index}}: {{msg}} </text>
       <text> Time: {{time}} </text>
       </view>
      </template>
      // 使⽤模板
      <template is="msgItem" data="{{...item}}"/>
      
      Page({
       data: {
       item: {
       index: 0,
       msg: 'this is a template',
       time: '2016-09-15'
       }
       }
      }
      ```

      e. 引用

      ```js
      // import
      // 只会 import ⽬标⽂件中定义的 template，⽽不会 import ⽬标⽂
      <!-- item.wxml -->
      <template name="item">
       <text>{{text}}</text>
      </template>
      <import src="item.wxml"/>
      <template is="item" data="{{text: 'forbar'}}"/>
      
      // include
      // include 可以将⽬标⽂件除了 <template/> <wxs/> 外的整个代码
      
      <!-- index.wxml -->
      <include src="header.wxml"/>
      <view> body </view>
      <include src="footer.wxml"/>
      
      <!-- header.wxml -->
      <view> header </view>
      <!-- footer.wxml -->
          <view> footer </view>
      ```

4. wxs

   a. 模块
        ⅰ. 可以编写在 wxml 文件中的 <wxs> 标签内，或以 .wxs 为后缀名的文件内； 
        ⅱ. wxs支持module、src标签，src为相对路径；
        ⅲ. 每个 wxs 模块均有一个内置的 module 对象；
        ⅳ. 在wxs中，可以引入新的wxs，或者使用require引入；

   ```js
   // /pages/tools.wxs
   var foo = "'hello world' from tools.wxs";
   var bar = function (d) {
    return d;
   }
   module.exports = {
    FOO: foo,
    bar: bar,
   };
   module.exports.msg = "some msg";
   <!-- page/index/index.wxml -->
   <wxs src="./../tools.wxs" module="tools" />
   var tools = require("./tools.wxs");
   
   <view> {{tools.msg}} </view>
   <view> {{tools.bar(tools.FOO)}} </view>
   ```

​       b. 变量	

​            i. WXS 中的变量均为值的引用；
​            ⅱ. 没有声明的变量直接赋值使用，会被定义为全局变量；
​            ⅲ. 如果只声明变量而不赋值，则默认值为 undefined；
​            ⅳ. var表现与javascript一致，会有变量提升。
​       c. 注释

```js
<!-- wxml -->
<wxs module="sample">
// ⽅法⼀：单⾏注释
/*
⽅法⼆：多⾏注释
*/
/*
⽅法三：结尾注释。即从 /* 开始往后的所有 WXS 代码均被注释
var a = 1;
var b = 2;
var c = "fake";
</wxs>
```

​		d. 运算符

​			i. 同JS一致；

​		e. 语句
​			ⅰ. 同JS一致，支持if else if else、switch、for、while；
​		f. 数据类型
​            ⅰ. number ： 数值
​			ⅱ. string ：字符串
​			ⅲ. boolean：布尔值
​			ⅳ. object：对象
​			ⅴ. function：函数
​			ⅵ. array : 数组
​			ⅶ. date：日期
​			ⅷ. regexp：正则

```js
// 如何区分数据类型
1. constructor可以区分所有类型
var number = 10;
console.log( "Number" === number.constructor );
var string = "str";
console.log( "String" === string.constructor );
var boolean = true;
console.log( "Boolean" === boolean.constructor );
var object = {};
console.log( "Object" === object.constructor );
var func = function(){};
console.log( "Function" === func.constructor );
var array = [];
console.log( "Array" === array.constructor );
var date = getDate();
console.log( "Date" === date.constructor );
var regexp = getRegExp();
console.log( "RegExp" === regexp.constructor )；
2. typeof可以判断部分类型
var number = 10;
var boolean = true;
var object = {};
var func = function(){};
var array = [];
var date = getDate();
var regexp = getRegExp();
console.log( 'number' === typeof number );
console.log( 'boolean' === typeof boolean );
console.log( 'object' === typeof object );
console.log( 'function' === typeof func );
console.log( 'object' === typeof array );
console.log( 'object' === typeof date );
console.log( 'object' === typeof regexp );
console.log( 'undefined' === typeof undefine
```

#### 4.1.3 组件

官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/
参考代码内容实践基础组件及扩展能力

#### 4.1.4 API

官方文档：https://developers.weixin.qq.com/miniprogram/dev/api/

参考代码内容接口部分

业务中常用：

- 基础：小程序应用级事件；

- 页面交互：路由、跳转、转发；

- 样式：导航栏、背景、tabBar；

- 操作：下拉刷新、滚动、动画；

- 其他：支付、LBS、设备、开放接口；

 

#### 4.1.5 面试常见问题

1. 框架相关
   a. 为什么要分包？
   	 ⅰ. 目前小程序分包大小有以下限制：

    1. 整个小程序所有分包大小不超过 20M；

    2. 单个分包/主包大小不能超过 2M；

       ⅱ. 对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作；

   b. 如何提升小程序SEO？

   ​	ⅰ. 官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/search/seo.html
   ​	ⅱ. 小程序里跳转的页面 (url) 可被直接打开；
   ​	ⅲ. 页面跳转优先采用navigator组件；
   ​	ⅳ. 清晰简洁的页面参数；
   ​	ⅴ. 配置小程序sitemap；
   ​	ⅵ. 必要的时候才请求用户进行授权、登录、绑定手机号等；
   ​	ⅶ. 我们不收录 web-view 中的任何内容；
   ​	ⅷ.  设置一个清晰的标题和页面缩略图；
   c. 如何进行页面间通信？
   ​	ⅰ. WXML 数据绑定；
   ​	ⅱ. 事件：用于子组件向父组件传递数据，可以传递任意数据；
      ⅲ. 父组件通过 this.selectComponent 方法获取子组件实例对象直接访问组件的任意数据和方法

   ```js
   // ⽗组件
   Page({
    data: {},
    getChildComponent: function () {
    const child = this.selectComponent('.my-component');
    console.log(child)
    }
   })
   
   ```

   ​	iv. 使用 [wx.navigateTo](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html) 打开，这两个页面间将建立一条数据通道：

   1. 被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象；
   2. wx.navigateTo 的 success 回调中也包含一个 EventChannel 对象；
   3. 这两个 EventChannel 对象间可以使用 emit 和 on 方法相互发送、监听事件；

2. 性能相关

   a. 小程序启动流程 官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start_process.html
   b. 小程序切换页面流程 官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_nav.html
   c. 如何提升小程序性能
   	ⅰ. 启动时性能优化

   		1. [代码包体积优化](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start_optimizeA.html)；
   		1. [代码注入优化](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start_optimizeB.html)；
   		1. [首屏渲染优化](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start_optimizeC.html)；
   		1. [其他优化](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start_optimizeD.html)；

      ⅱ. 运行时性能优化；

   1. [合理使用setState](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_setData.html)；
   2. [渲染性能优化](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_render.html)；
   3. [页面切换优化](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_nav.html)；
   4. [资源加载优化](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_resource.html)；
   5. [内存优化](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_memory.html)；

### 4.2 微信小程序发布、上线流程&devTools

#### 4.2.1. 协同工作 

参考官网

[https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#协同工作)

#### 4.2.2. dev tools 

强烈建议阅读官网devtools，掌握基本的IDE操作

https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html

#### 4.2.3. 面试常见问题 

1. 域名相关

​		a. 本地开发如何不校验域名，web-view(业务域名)、TLS 版本以及 HTTPS 证书？

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649438887342-ce56b79f-e453-42c8-837e-0d1d103f6298.png)



​		b. 如何配置开发域名？ 小程序的安全域名信息，合法域名可在 [mp 管理后台](https://mp.weixin.qq.com/) 开发-开发管理-开发设置 中进行设置

2. 如何提升开发效率

​		a. 开发环境：

​			ⅰ. 开启热重载；

​			ⅱ. 开发环境下关闭域名校验；

​			ⅲ. 请求开启Mock；

​			ⅳ. 局部编译；

​		b. 账号：

​			ⅰ. 申请测试号，只需访问 [申请地址](https://mp.weixin.qq.com/wxamp/sandbox?doc=1) ，就可以开发调试；

3. 如何分析小程序性能？

​		a. 真机：使用微信安卓客户端（开发者），具体操作：https://developers.weixin.qq.com/miniprogram/dev/devtools/performancetool.html

​		b. devTools：调试器中audits，类似于chrome中的lighthouse；

​		c. 分析包依赖： 删除无依赖的文件；

4. 如何进行埋点？

​		a. 开发者工具上可以编辑和调试[自定义分析](https://mp.weixin.qq.com/debug/wxadoc/analysis/custom/)的数据上报功能，点击菜单栏中的 “工具 - 自定义分析” 即可弹窗打开自定义分析；

5. 如何进行小程序上传、发布及自动化测试？

​		a. devTools：自带发布集成；

​		b. 使用[miniprogram-ci](https://www.npmjs.com/package/miniprogram-ci)；（除非集成进自动化部署外，其余不建议使用，记得打开安全设置 CLI/HTTP 调用功能）：https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html

# **小程序开发框架解析**

https://www.yuque.com/lpldplws/web/nl6k99?singleDoc# 《小程序开发框架解析》 密码：nxr5

## 1. 课程目标

1. 小程序原生开发对比，了解行业小程序开发支撑现状；

2.  掌握多端小程序开发框架，配置开发环境；

## 2. 课程大纲 

- 行业小程序原生开发对比；

- 小程序跨端框架介绍；

## 3. 行业小程序对比 

### 3.1  产品及定位 

1. 微信：在微信内被便捷地获取和传播的连接用户与服务的方式，同时具有出色的使用体验；

2. 支付宝：运行在支付宝客户端，可以被便捷地获取和传播，为终端用户提供更优的用户体验；

3. 淘宝：服务移动开发者的平台，帮助开发者构建自己的业务阵地，并提供良好的用户体验；

4. 百度：依托以百度App为代表的全域流量，通过百度AI开放式赋能，精准连接用户，业界首家开放生态，让开发者重回业务理解和创意赛道；

总结：

1. 小程序的目标是万事万物皆可小程序
2. 超级APP的崛起为小程序提供生存土壤 -> 圈地运营；
3. 云计算发展，Saas标准化服务输出，降低了品牌建站的成本-> FaaS；

### 3.2. 官方文档 

1. 微信：[微信公众平台-小程序](https://developers.weixin.qq.com/miniprogram/introduction/index.html?t=18092610)---[文档](https://developers.weixin.qq.com/miniprogram/dev/index.html)

2. 支付宝：[蚂蚁金服开发平台-小程序](https://mini.open.alipay.com/channel/miniIndex.htm)---[文档](https://docs.alipay.com/mini/developer/getting-started)

3. 淘宝：[淘宝开发者平台](https://open.taobao.com/?spm=a219a.14658873.1.1.3d0e4dc1qltrH6)---[文档](https://open.taobao.com/doc.htm?docId=73&docType=1)

4. 百度：[智能小程序](https://smartprogram.baidu.com/mappconsole/main/login) --- [文档](https://smartprogram.baidu.com/docs/introduction/enter_application/)

### 3.3. IDE 

1. [微信IDE](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)

2. [支付宝IDE](https://docs.alipay.com/mini/ide/download)

3. [淘宝IDE](https://miniapp.open.taobao.com/docV3.htm?spm=a219a.15212435.0.0.4a78669aoT4coY&docId=119188&docType=1)

4. [百度IDE](https://smartprogram.baidu.com/docs/introduction/register_prepare/)

### 3.4. 文件结构 

1. 微信小程序

```js
## 微信小程序
- pages/               页面目录
  - page1/
    - index.wxml  // 必须，页面结构
    - index.js  // 必须，页面逻辑
    - index.wxss  // 非必须，页面样式表
    - index.json  // 非必须，页面配置
- app.js  // 必须，小程序逻辑
- app.json  // 必须，小程序公共配置
- app.wxss  // 非必须，小程序公共样式表
```

2. 支付宝小程序

   ```js
   ## 支付宝小程序
   - pages/          
     - page1/
       - index.axml  // 必须，页面结构    
       - index.js  // 必须，页面逻辑    
       - index.acss  // 非必须，页面样式表
       - index.json  // 非必须，页面配置    
   - app.json  // 必须，小程序公共设置  
   - app.js  // 必须，小程序逻辑    
   - app.acss  // 非必须，小程序公共样式表 
   ```

3. 手淘小程序

   ```js
   ## 手淘小程序：基于轻框架
   - src/
     - components/          组件目录，可以没有
       - component1.html    组件文件
       - component2.html
     - pages/               页面目录
       - page1/
         - index.html       页面入口
       - page2/
         - index.html
       - index/
         - index.html
   - manifest.json        描述项目基本信息，包括页面、tabBar等
   - app.js               程序级应用入口
   - package.json           项目工程文件
   
   ## 手淘小程序：不基于轻框架完全同支付宝小程序
    
   ```

4. 百度小程序

   ```js
   ## 百度小程序
   - pages/              
     - page1/
       - index.swan  // 模板文件
       - index.js  // 页面逻辑
       - index.css // 页面样式
   - app.js        
   - app.json  //  配置文件   
   - app.css
   - project.swan.json  
   ```

### 3.5生命周期

1. 微信小程序

   ```js
   //index.js
   Page({
   
     // {Object}：页面的初始数据
     data: { 
       text: "This is page data."
     },
     
     // {Function}：生命周期回调—监听页面加载
     onLoad: function(options) {
       // Do some initialize when page load.
     },
     
     // {Function}：生命周期回调—监听页面初次渲染完成
     onReady: function() {
       // Do something when page ready.
     },
     
     // {Function}：生命周期回调—监听页面显示
     onShow: function() {
       // Do something when page show.
     },
     
     // {Function}：生命周期回调—监听页面隐藏
     onHide: function() {
       // Do something when page hide.
     },
     
     // {Function}：生命周期回调—监听页面卸载
     onUnload: function() {
       // Do something when page close.
     },
     
     // {Function}：监听用户下拉动作
     onPullDownRefresh: function() {
       // Do something when pull down.
     },
     
     // {Function}：页面上拉触底事件的处理函数
     onReachBottom: function() {
       // Do something when page reach bottom.
     },
     
     // {Function}：用户点击右上角转发
     onShareAppMessage: function () {
       // return custom share data when user share.
     },
     
     // {Function}：页面滚动触发事件的处理函数
     onPageScroll: function() {
       // Do something when page scroll
     },
     
     // {Function}：当前是 tab 页时，点击 tab 时触发
     onTabItemTap(item) {
       console.log(item.index)
       console.log(item.pagePath)
       console.log(item.text)
     },
     // Event handler 其他：开发者可以添加任意的函数或数据到 Object 参数中，在页面的函数中用 this 可以访问
     viewTap: function() {
       this.setData({
         text: 'Set some data for updating view.'
       }, function() {
         // this is setData callback
       })
     },
     customData: {
       hi: 'MINA'
     }
   })
   
   ```

2. 支付宝小程序

   ```js
   //index.js
   Page({
     data: {
       title: "Alipay"
     },
     onLoad(query) {
       // 页面加载
     },
     onReady() {
       // 页面加载完成
     },
     onShow() {
       // 页面显示
     },
     onHide() {
       // 页面隐藏
     },
     onUnload() {
       // 页面被关闭
     },
     
     // {Function}：点击标题触发
     onTitleClick() {
       // 标题被点击
     },
     onPullDownRefresh() {
       // 页面被下拉
     },
     onReachBottom() {
       // 页面被拉到底部
     },
     onShareAppMessage() {
      // 返回自定义分享信息
     },
     viewTap() {
       // 事件处理
       this.setData({
         text: 'Set data for updat.'
       })
     },
     
     // 其他：开发者可以添加任意的函数或属性到 object 参数中，在页面的函数中可以用 this 来访问
     go() {
       // 带参数的跳转，从 page/index 的 onLoad 函数的 query 中读取 xx
       my.navigateTo({url:'/page/index?xx=1'})
     },
     customData: {
       hi: 'alipay'
     }
   })
   
   ```

   3. 淘宝小程序

      ```js
      // 不基于框架：跟支付宝小程序语法几乎完全一样
      //index.js
      Page({
        data: {
          title: "Alipay"
        },
        onLoad(query) {
          // 页面加载
        },
        onReady() {
          // 页面加载完成
        },
        onShow() {
          // 页面显示
        },
        onHide() {
          // 页面隐藏
        },
        onUnload() {
          // 页面被关闭
        },
        
        viewTap() {
          // 事件处理
          this.setData({
            text: 'Set data for updat.'
          })
        },
        go() {   
      // 带参数的跳转，从 page/index 的 onLoad 函数的 query 中读取 xx
          my.navigateTo('/page/index?xx=1')
        },
        customData: {
          hi: 'alipay'
        }
      })
      
      // 基于框架，类Rax框架，html、js、css在同一文件中，通过sfc2mp转为支付宝小程序
      <template>
        <view class="demo-page">
          <text class="title">欢迎来到{{title}}</text>
          <button :class="btn" @click="goto">开启未来</button>
        </view>
      </template>
      
      <style>
        .demo-page {
          flex-direction: column;
          justify-content: center;
          align-items: center;
        }
      
        .title {
          font-size: 40px;
          text-align: center;
        }
      
        .btn {
          width: 550px;
          height: 86px;
          margin-top: 75px;
          border-radius: 43px;
          background-color: #09ba07;
          font-size: 30px;
          color: #ffffff;
        }
      
        .clickedBtn {
          width: 550px;
          height: 86px;
          margin-top: 75px;
          border-radius: 43px;
          background-color: #09ba07;
          font-size: 30px;
          color: red;
        }
      </style>
      
      <script>
        import page from '@core/page';
      
        export default {
          data: {
            title: '示例页面',
            btn: 'btn',
          },
          methods: {
            goto () {
              this.btn = 'clickedBtn';
      
              my.navigateTo({
                url: 'test?id=1'
              });
            }
          },
          beforeCreate() {
            page.on('show', () => {});
            page.on('hide', () => {});
          },
          created (){
      
          },
          updated () {
      
          },
          destroyed () {
      
          },
        }
      </script>
      ```

   4. 百度小程序

   ```js
   
   Page({
       data: {
           name: 'swan'
       },
       onLoad: function () {
   
       },
       onReady: function() {
           // Do something when page ready.
       },
       onShow: function() {
           // Do something when page show.
       },
       onHide: function() {
           // Do something when page hide.
       },
       onUnload: function() {
           // Do something when page close.
       },
       onPullDownRefresh: function() {
           // Do something when pull down.
       },
       onReachBottom: function() {
           // Do something when page reach bottom.
       },
       onShareAppMessage: function () {
           // return custom share data when user share.
       },
       // {Function}：错误监听函数
       onError: function (e) {
         // return error info : e
       },
       
       // 其他：开发者可以添加任意的函数或数据到 object 参数中，在页面的函数中用 this 可以访问
       any: function () {
         // return custom data
       }
   });
   ```

### 3.6 视图层

#### 3.6.1 数据绑定

1. 微信：指令以wx:开头

   ```js
   <view wx:if="{{condition}}"> </view>
   ```

2. 支付宝：指令以a:开头

   ```js
   <view a:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view> 
   <view a:elif="{{view == 'APP'}}"> APP </view> <view a:else> alipay </view>
   ```

3. 淘宝：完全同支付宝

4. 百度

   ```js
   Page({
       data: {
           person: {name: 'Lebron James', pos: 'SF', age: 33},
           teams: ['Cleveland Cavaliers', 'Miami Heat', 'Los Angeles Lakers'],
           tag: 'basketball',
           flag: true
       }
   });
   
   <view s-if="flag"></view> // 1.`s-` 开头 2.`flag`没有{{}}
   <template is="team-card" data="{{ {teams} }}" /> // {{ {items} }}
   ```

#### 3.6.2 样式支持

全部支持rpx逻辑单位

### 3.7 组件

目前以微信小程序支持最为完善

1. 微信小程序

- [picker-view](https://developers.weixin.qq.com/miniprogram/dev/component/picker-view.html)：滚动选择器

- [functional-page-navigator](https://developers.weixin.qq.com/miniprogram/dev/component/functional-page-navigator.html)：跳转至插件功能页

- [live-push](https://developers.weixin.qq.com/miniprogram/dev/component/live-pusher.html)：实时音视频录制

- [ad](https://developers.weixin.qq.com/miniprogram/dev/component/ad.html)：banner广告

- [official-account](https://developers.weixin.qq.com/miniprogram/dev/component/official-account.html)：公众号关注组件

2. 支付宝小程序

- 缺少movable-area

- 缺少cover-view

- 缺少rich-text

- 缺少audio

- 缺少video

- 缺少camera

- 缺少live-player

- 缺少live-pusher

- 缺少ad

- 缺少open-data

3. 淘宝

- 缺少movable-area

- 缺少cover-view

- 缺少rich-text

- 缺少camera

- 缺少live-player

- 缺少live-pusher

- 缺少canvas

- 缺少web-view

- 缺少ad

- 缺少open-data

- 缺少offical-account

4. 百度

- [animation-view](https://smartprogram.baidu.com/docs/develop/component/base_animation-view/)：动画组件

- 缺少live-pusher

### 3.8. 总结 

小程序底层方案都是一致的，只不过在支持程度等有所不同。

以支付宝小程序为例：

1. 小程序分别运行在 worker(JSEngine) 以及 render 渲染层中， render 可以有多个， worker 只有一个，方便 app 数据在页面间的共享和交互；（渲染层 & 逻辑层）

2. worker 运行小程序的逻辑处理代码，包括事件处理，api 调用以及框架的生命周期管理；（逻辑层功能）

3. render 运行小程序的渲染代码，主要包括模版／样式和框架的跨终端的 js 组件或 native 组件，获取逻辑层的数据进行渲染；（渲染层功能）

4. worker 和所有的 render 都建立连接，将需要渲染的数据传递给对应的 render 进行渲染，worker 也会将 api 调用转给 native SDK 处理；（Hybrid通信）

5. render 则将组件的触发事件送到对应的 worker 处理，同时接受 worker 的 setData 调用 React 重新渲染。 render 可以看作一个无状态的渲染终端，状态统统保留在 app 级别的 worker 里面；（渲染层&逻辑层交互）

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649835365830-c7fa7fb7-3c78-4d81-beb9-b9df55ab1cfa.png)

## 4. 小程序跨端框架介绍

### 4.1 原生小程序开发

原生小程序适用于：需求明确只在指定小程序一端进行，保证最大程度的避免多端框架兼容带来的莫名bug。

### 4.2. 多端小程序开发 

Tips：只介绍React语言的跨端框架；

#### 4.2.1. 编译时 

用户编写的业务代码解析成AST树，然后通过语法分析强行将用户写的类React代码转换为可运行的小程序代码,代表：京东的Taro1/2、去哪儿的Nanachi，淘宝的Rax。

以下以Rax为例

##### 4.2.1.1. 概览

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649842560481-d7babadf-473b-4546-947d-6e4cfc8eddbd.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

编译时链路主要分为五个模块：

1. CLI：整个链路的入口，用户编写的所有业务代码都经由 CLI 读取、处理和输出；

2. loader：webpack loader，用于处理各种类型的文件，包括 app、page、component、script 以及静态资源等；

3. compiler：用于进行 AST 转换并生成对应的小程序代码；

4.  runtime：为生成的 js 代码提供了运行时的垫片支持；

5. universal：多端统一的 universal 组件以及 API 的基础服务支持；

###### 4.2.1.1.1. CLI 

从命令行读取各种必要参数，然后传入 webpack 执行。利用 webpack 的依赖分析能力，遍历到所有有效代码并交由对应的 loader 进行处理。

具体用途：

1. CLI 依赖 webpack 对项目进行依赖分析，然后调用 loader对对应类型的文件进行处理

2. CLI 对外提供 watch 和 build 两个指令

   a. watch：监听代码变动并实时编译；

   b. build：剔除部分调试用的代码（如 source map）并压缩代码，完成编译打包；

   ```js
   /**
    * watch and copy constant dir file change
    * @param {array} dirs
    * @param {string} distDirectory
    */
   function watch(options = {}) {
     const {
       afterCompiled,
       type = DEFAULT_TYPE,
       entry = DEFAULT_ENTRY,
       platform = DEFAULT_PLATFORM,
       workDirectory = cwd,
       distDirectory = join(cwd, DEFAULT_DIST),
       skipClearStdout = false,
       constantDir = DEFAULT_CONSTANT_DIR_ARR,
       disableCopyNpm = false,
       turnOffSourceMap = false,
       turnOffCheckUpdate = false
     } = options;
   
     watchConstantDir(constantDir, distDirectory);
   
     const needUpdate = checkNeedUpdate(turnOffCheckUpdate);
   
     let config = getWebpackConfig({
       mode: 'watch',
       entryPath: entry,
       type,
       workDirectory,
       platform,
       distDirectory,
       constantDir,
       disableCopyNpm,
       turnOffSourceMap
     });
   
     if (options.webpackConfig) {
       config = mergeWebpack(config, options.webpackConfig);
     }
     spinner.shouldClear = !skipClearStdout;
   
     const compiler = webpack(config);
   
     const watchOpts = {
       aggregateTimeout: 600
     };
     compiler.outputFileSystem = new MemFs();
     compiler.watch(watchOpts, (err, stats) => {
       handleCompiled(err, stats, { skipClearStdout });
       afterCompiled && afterCompiled(err, stats);
       if (needUpdate) {
         console.log(chalk.black.bgYellow.bold('Update for miniapp related packages available, please reinstall dependencies.'));
       }
       console.log('Watching for changes...');
     });
   }
   
   /**
    * watch and copy constant dir file change
    * @param {array} dirs
    * @param {string} distDirectory
    */
   function watchConstantDir(dirs, distDirectory) {
     const watcher = chokidar.watch(dirs);
     watcher.on('all', (event, path) => {
       copyConstantDir(path, distDirectory);
     });
   }
   
   /**
    * copy constant path to dist
    * @param {string} path
    * @param {string} distDirectory
    */
   function copyConstantDir(path, distDirectory) {
     if (!path) {
       return;
     }
     if (!existsSync(path)) {
       mkdirSync(path);
     }
     copySync(path, join(distDirectory, getCurrentDirectoryPath(path, 'src')), {
       filter: (filename) => !/\.ts$/.test(filename),
     });
   }
   
   function handleCompiled(err, stats, { skipClearStdout }) {
     if (err) {
       console.error(err.stack || err);
       if (err.details) {
         console.error(err.details);
       }
       return;
     }
     if (stats.hasErrors()) {
       const errors = stats.compilation.errors;
       if (!skipClearStdout) consoleClear(true);
       spinner.fail('Failed to compile.\n');
       for (let e of errors) {
         console.log(chalk.red(`    ${errors.indexOf(e) + 1}. ${e.error.message} \n`));
         if (process.env.DEBUG === 'true') {
           console.log(e.error.stack);
         }
       }
       console.log(chalk.yellow('Set environment `DEBUG=true` to see detail error stacks.'));
     }
   }
   
   ```

   ```js
   /**
    * Start jsx2mp build.
    * @param options
    */
   function build(options = {}) {
     const {
       afterCompiled,
       type = DEFAULT_TYPE,
       entry = DEFAULT_ENTRY,
       platform = DEFAULT_PLATFORM,
       workDirectory = cwd,
       distDirectory = join(cwd, DEFAULT_DIST),
       skipClearStdout = false,
       constantDir = DEFAULT_CONSTANT_DIR_ARR,
       disableCopyNpm = false,
       turnOffCheckUpdate = false
     } = options;
   
     // Clean the dist dir before generating
     if (existsSync(distDirectory)) {
       del.sync(distDirectory + '/**');
     }
   
     constantDir.forEach(dir => copyConstantDir(dir, distDirectory));
   
     const needUpdate = checkNeedUpdate(turnOffCheckUpdate);
   
     let config = getWebpackConfig({
       mode: 'build',
       entryPath: entry,
       platform,
       type,
       workDirectory,
       distDirectory,
       constantDir,
       disableCopyNpm
     });
   
     if (options.webpackConfig) {
       config = mergeWebpack(config, options.webpackConfig);
     }
     spinner.shouldClear = !skipClearStdout;
   
     const compiler = webpack(config);
     compiler.outputFileSystem = new MemFs();
     compiler.run((err, stats) => {
       handleCompiled(err, stats, { skipClearStdout });
       afterCompiled && afterCompiled(err, stats);
       if (needUpdate) {
         console.log(chalk.black.bgYellow.bold('Update for miniapp related packages available, please reinstall dependencies.'));
       }
     });
   }
   
   ```

   ```js
   // 依赖 webpack 对项目进行依赖分析，然后调用 loader对对应类型的文件进行处理
   
   const AppLoader = require.resolve('jsx2mp-loader/src/app-loader');
   const PageLoader = require.resolve('jsx2mp-loader/src/page-loader');
   const ComponentLoader = require.resolve('jsx2mp-loader/src/component-loader');
   const ScriptLoader = require.resolve('jsx2mp-loader/src/script-loader');
   const FileLoader = require.resolve('jsx2mp-loader/src/file-loader');
   
   
   function getEntry(type, cwd, entryFilePath, options) {
     const entryPath = dirname(entryFilePath);
     const entry = {};
     const { platform = 'ali', constantDir, mode, disableCopyNpm, turnOffSourceMap } = options;
   
     const loaderParams = {
       platform: platformConfig[platform],
       entryPath: entryFilePath,
       constantDir,
       mode,
       disableCopyNpm,
       turnOffSourceMap
     };
   
     if (type === 'project') {
       // ....
       entry.app = AppLoader + '?' + JSON.stringify({ entryPath, platform: platformConfig[platform], mode, disableCopyNpm, turnOffSourceMap }) + '!./' + entryFilePath;
       if (Array.isArray(appConfig.routes)) {
         appConfig.routes.filter(({ targets }) => {
           return !Array.isArray(targets) || targets.indexOf('miniapp') > -1;
         }).forEach(({ source, component, window = {} }) => {
           component = source || component;
           entry['page@' + component] = PageLoader + '?' + JSON.stringify(Object.assign({ pageConfig: window }, loaderParams)) + '!' + getDepPath(component, entryPath);
         });
       } else if (Array.isArray(appConfig.pages)) {
         // Compatible with pages.
         appConfig.pages.forEach((pagePath) => {
           entry['page@' + pagePath] = PageLoader + '?' + JSON.stringify(loaderParams) + '!' + getDepPath(pagePath, entryPath);
         });
       }
     }
     if (type === 'component') {
       entry.component = ComponentLoader + '?' + JSON.stringify(loaderParams) + '!' + entryFilePath;
     }
     return entry;
   }
   
   module.exports = (options = {}) => {
    
     const config = {
       mode: 'production', // Will be fast
       entry: getEntry(type, workDirectory, relativeEntryFilePath, options),
       output: {
         path: distDirectory
       },
       target: 'node',
       context: workDirectory,
       module: {
         rules: [
           {
             test: /\.t|jsx?$/,
             use: [
               {
                 loader: ScriptLoader,
                 options: {
                   mode: options.mode,
                   entryPath: relativeEntryFilePath,
                   platform: platformConfig[platform],
                   constantDir,
                   disableCopyNpm,
                   turnOffSourceMap
                 },
               },
               {
                 loader: BabelLoader,
                 options: getBabelConfig(),
               }
             ]
           },
           {
             test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/, /\.webp$/],
             loader: FileLoader,
             options: {
               entryPath: relativeEntryFilePath
             },
           },
           {
             test: /\.json$/,
             use: [{
               loader: ScriptLoader,
               options: {
                 mode: options.mode,
                 entryPath: relativeEntryFilePath,
                 platform: platformConfig[platform],
                 constantDir,
                 disableCopyNpm,
                 turnOffSourceMap
               },
             }]
           }
         ],
       },
       resolve: {
         extensions: getPlatformExtensions(platform, ['.js', '.jsx', '.ts', '.tsx', '.json']),
         mainFields: ['main', 'module']
       },
     };
   
     return config;
   };
   ```

   Q：在小程序原生开发框架中，入口文件 app.js 并没有声明依赖，而 pages 是在 app.json 中注册的，Rax入口文件是什么样的，它又是如何声明依赖的？
   A：为了保持多端统一，Rax 采用同一套工程目录

   ```js
   ├── README.md                   # 项目说明
   ├── build.json                  # 项目构建配置
   ├── package.json
   └── src                         # 源码目录
       ├── app.js                  # 应用入口文件
       ├── app.json                # 应用配置，包括路由配置，小程序 window 配置等
       ├── components              # 应用的公共组件
       │   └── Logo                # 组件
       │       ├── index.css       # Logo 组件的样式文件
       │       └── index.jsx       # Logo 组件 JSX 源码
       ├── document                # 页面的 HTML 模板
       │   └── index.jsx       
       └── pages                   # 页面
           └── Home                # home 页面
               └── index.jsx
   ```

   app.json内容

   ```js
   {
     "routes": [
       {
         "path": "/",
         "source": "pages/Home/index"
       }
     ],
     "window": {
       "defaultTitle": "Rax App 1.0"
     }
   }
   ```

   CLI 读取其中的 routes 并将所有引用到的 pages 文件以及 app.js 作为 entry，以 pages 文件为入口，所有依赖文件将依次被遍历并交由对应 loader 进行处理。loader 处理完毕后最终的编译代码将生成到目的目录。

###### 4.2.1.1.2. loader 

Rax转小程序的loader统称为：jsx2mp-loader

1. app-loader

   a. 处理 rax 源码中的 app.js

   b. 处理 app.json 中 的 `window` 属性并作支付宝/微信两端的配置抹平

   ```js
   module.exports = async function appLoader(content) {
     const query = parse(this.request);
     // Only handle app role file
     if (query.role !== 'app') {
       return content;
     }
   
     if (!existsSync(outputPath)) mkdirpSync(outputPath);
   
     const compilerOptions = Object.assign({}, compiler.baseOptions, {
       // ...options,
     });
   
     const rawContentAfterDCE = eliminateDeadCode(rawContent);
   
     let transformed;
     try {
       transformed = compiler(rawContentAfterDCE, compilerOptions);
     } catch (e) {
       console.log(chalk.red(`\n[${platform.name}] Error occured when handling App ${this.resourcePath}`));
       if (process.env.DEBUG === 'true') {
         throw new Error(e);
       } else {
         const errMsg = e.node ? `${e.message}\nat ${this.resourcePath}` : `Unknown compile error! please check your code at ${this.resourcePath}`;
         throw new Error(errMsg);
       }
     }
   
     const { style, assets } = await processCSS(transformed.cssFiles, sourcePath);
     transformed.style = style;
     transformed.assets = assets;
   
     const outputContent = {
       code: transformed.code,
       map: transformed.map,
       css: transformed.style ? defaultStyle + transformed.style : defaultStyle,
     };
     const outputOption = {
       outputPath: {
         code: join(outputPath, platform.type === QUICKAPP ? 'app.ux' : 'app.js'),
         css: join(outputPath, 'app' + platform.extension.css),
       },
       mode,
       isTypescriptFile: isTypescriptFile(this.resourcePath),
       type: 'app',
       platform,
       rootDir,
     };
   
     output(outputContent, rawContent, outputOption);
   
     return [
       `/* Generated by JSX2MP AppLoader, sourceFile: ${this.resourcePath}. */`,
       generateDependencies(transformed.imported),
     ].join('\n');
   };
   ```

2. page-loader
   a. 处理定义在 app.json 中 routes 属性内的 page 类型组件
   b. 根据 jsx-compiler 中解析到的该组件所引用组件的信息，写入 json 文件中的usingComponents ，并将这些组件加入 webpack 依赖分析链并交由 component-loader 处理
   c. 处理用户定义在 app.json 中 routes 数组内每一个页面的配置（即 window 配置项）并输出至对应页面的 json 文件中

```js
module.exports = async function pageLoader(content) {
  const query = parse(this.request);
  // Only handle page role file
  if (query.role !== 'page') {
    return content;
  }

  const compilerOptions = Object.assign({}, compiler.baseOptions, {
   // ...options
  });
  const rawContentAfterDCE = eliminateDeadCode(content);

  let transformed;
  try {
    transformed = compiler(rawContentAfterDCE, compilerOptions);
  } catch (e) {
    console.log(chalk.red(`\n[${platform.name}] Error occured when handling Page ${this.resourcePath}`));
    if (process.env.DEBUG === 'true') {
      throw new Error(e);
    } else {
      const errMsg = e.node ? `${e.message}\nat ${this.resourcePath}` : `Unknown compile error! please check your code at ${this.resourcePath}`;
      throw new Error(errMsg);
    }
  }

  const { style, assets } = await processCSS(transformed.cssFiles, sourcePath);
  transformed.style = style;
  transformed.assets = assets;

  if (!existsSync(pageDistDir)) mkdirpSync(pageDistDir);

  // ...
  
  let config = {
    ...transformed.config
  };
  if (existsSync(pageConfigPath)) {
    const pageConfig = readJSONSync(pageConfigPath);
    delete pageConfig.usingComponents;
    Object.assign(config, pageConfig);
  }
  
  // ...

  if (config.usingComponents) {
    const usingComponents = {};
    Object.keys(config.usingComponents).forEach(key => {
      const value = config.usingComponents[key];
      if (/^c-/.test(key)) {
        const result = MINIAPP_PLUGIN_COMPONENTS_REG.test(value) ? value : removeExt(addRelativePathPrefix(relative(dirname(this.resourcePath), value)));
        usingComponents[key] = normalizeOutputFilePath(result);
      } else {
        usingComponents[key] = normalizeOutputFilePath(value);
      }
    });
    config.usingComponents = usingComponents;
  }
  
  output(outputContent, content, outputOption);

  // ...

  return [
    `/* Generated by JSX2MP PageLoader, sourceFile: ${this.resourcePath}. */`,
    generateDependencies(dependencies),
  ].join('\n');
};
```

3. component-loader
   a. 处理 component 类型组件并交由 jsx-compiler 处理然后产出编译后代码，并写入至指定目标文件夹位置
   b. 根据 jsx-compiler 中解析到的该组件所引用组件的信息，写入 json 文件的 usingComponents 属性中，并将这些组件加入 webpack 依赖分析链并交由 component-loader 处理

```js
module.exports = async function componentLoader(content) {
  const query = parse(this.request);
  // Only handle component role file
  if (query.role !== 'component') {
    return content;
  }

  const compilerOptions = Object.assign({}, compiler.baseOptions, {
   // ...options,
  });

  let transformed;
  try {
    const rawContentAfterDCE = eliminateDeadCode(content);
    transformed = compiler(rawContentAfterDCE, compilerOptions);
  } catch (e) {
    console.log(chalk.red(`\n[${platform.name}] Error occured when handling Component ${this.resourcePath}`));
    if (process.env.DEBUG === 'true') {
      throw new Error(e);
    } else {
      const errMsg = e.node ? `${e.message}\nat ${this.resourcePath}` : `Unknown compile error! please check your code at ${this.resourcePath}`;
      throw new Error(errMsg);
    }
  }

  const { style, assets } = await processCSS(transformed.cssFiles, sourcePath);
  transformed.style = style;
  transformed.assets = assets;

  const config = Object.assign({}, transformed.config);
  
  if (config.usingComponents) {
    const usingComponents = {};
    Object.keys(config.usingComponents).forEach(key => {
      const value = config.usingComponents[key];

      usingComponents[key] = normalizeOutputFilePath(value);
    });
    config.usingComponents = usingComponents;
  }

  const distFileDir = dirname(distFileWithoutExt);
  if (!existsSync(distFileDir)) mkdirpSync(distFileDir);

  output(outputContent, content, outputOption);

  function isCustomComponent(name, usingComponents = {}) {
    const matchingPath = join(dirname(resourcePath), name);
    for (let key in usingComponents) {
      if (
        usingComponents.hasOwnProperty(key)
        && usingComponents[key]
        && usingComponents[key].indexOf(matchingPath) === 0
      ) {
        return true;
      }
    }
    return false;
  }
```

4. File loader

   a. 处理图片等静态文件资源，将其拷贝至指定目标文件夹

   ```js
   
   const { join, relative, dirname } = require('path');
   const { copySync } = require('fs-extra');
   
   const loaderUtils = require('loader-utils');
   
   module.exports = function fileLoader(content) {
     const { entryPath, outputPath } = loaderUtils.getOptions(this) || {};
     const rootContext = this.rootContext;
   
     const relativeFilePath = relative(
       join(rootContext, dirname(entryPath)),
       this.resourcePath
     );
     const distSourcePath = join(outputPath, relativeFilePath);
     copySync(this.resourcePath, distSourcePath);
   
     return '';
   };
   
   ```

5. script loader：负责依赖路径处理
   a. npm包：搜集代码中使用到的 npm 依赖，获取 npm 包的真实地址 => 路径处理 => babel 编译 => 输出代码至目标文件夹
   b. 来自 npm 包的第三方原生小程序库：用户使用绝对路径去使用第三方原生小程序库时，script-loader 需要读取 js 文件同目录下同名的 json 文件中的 usingComponents 字段并将其加入 webpack 的依赖分析链

   ```js
   module.exports = function scriptLoader(content) {
     const query = parse(this.request);
     if (query.role) {
       return content;
     }
   
     // ...
     
     if (isFromNodeModule(this.resourcePath)) {
       if (disableCopyNpm) {
         return isCommonJSON ? '{}' : content;
      
       const pkg = readJSONSync(sourcePackageJSONPath);
       const npmName = pkg.name; // Update to real npm name, for that tnpm will create like `_rax-view@1.0.2@rax-view` folders.
       const npmMainPath = join(sourcePackagePath, pkg.main || '');
   
       const isUsingMainMiniappComponent = pkg.hasOwnProperty(MINIAPP_CONFIG_FIELD) && this.resourcePath === npmMainPath;
       // Is miniapp compatible component.
       if (isUsingMainMiniappComponent || isRelativeMiniappComponent || isThirdMiniappComponent) {
         // ...
         
         if (isThirdMiniappComponent) {
           const source = dirname(this.resourcePath);
           const target = dirname(normalizeNpmFileName(join(outputPath, 'npm', relative(rootNodeModulePath, this.resourcePath))));
           outputDir(source, target);
           outputFile(rawContent);
         }
   
         return [
           `/* Generated by JSX2MP ScriptLoader, sourceFile: ${this.resourcePath}. */`,
           generateDependencies(dependencies),
           content
         ].join('\n');
       } else {
         outputFile(rawContent);
       }
     } else if (isFromConstantDir(this.resourcePath) && isThirdMiniappComponent) {
       const dependencies = [];
       outputFile(rawContent, false);
   
       // Find dependencies according to usingComponents config
       const componentConfigPath = removeExt(this.resourcePath) + '.json';
       const componentConfig = readJSONSync(componentConfigPath);
       for (let key in componentConfig.usingComponents) {
         const componentPath = componentConfig.usingComponents[key];
         const absComponentPath = resolve(dirname(this.resourcePath), componentPath);
         dependencies.push({
           name: absComponentPath,
           options: loaderOptions
         });
       }
       return [
         `/* Generated by JSX2MP ScriptLoader, sourceFile: ${this.resourcePath}. */`,
         generateDependencies(dependencies),
         content
       ].join('\n');
     } else if (!isAppJSon) {
       outputFile(rawContent, false);
     }
   
     return isJSON ? '{}' : transformCode(
       content, mode,
       [ require('@babel/plugin-proposal-class-properties') ]
     ).code; // For normal js file, syntax like class properties can't be parsed without babel plugins
   };
   
   
   ```

###### 4.2.1.1.3. compiler

编译：是一种利用编译程序从源语言编写的源程序产生目标程序的过程或者动作，完整的流程是从高级语言转换成计算机可以理解的二进制语言的过程：Rax -> 小程序DSL

编译在rax主要是  jsx-compiler：

1. 词法分析（tokenizing）
2. 语法分析（parsing）
3. 代码生成（generate）

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649845326644-2a59ec7c-4384-4a7c-9b62-3ef2195dcf0a.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

Example:

1. input

   ```js
   import { Component } from 'rax';
   
   export default class extends Component {
     render() {
       return (<view>hello world</view>);
     }  
   }
   ```

jsx compiler执行

- type // app, page, component.

- outputPath 

- sourcePath 

- resourcePath

  ```js
  const compile = require('jsx-compiler');
  const { baseOptions } = compile;
  
  const output = compile(code, { ...baseOptions, type: 'component' });
  ```

2. output

- ast：Babel 7格式的AST

- imported：引入的模块和本地定义变量

- exported：导出变量

- template：miniapp识别模板

- code：转义后的代码

- map：source map

- config：小程序配置

- style：样式

- usingComponents

  ```js
  {
    ast: ASTNodeTree,
    imported: {
      rax: [
        {
          local: "Component",
          default: false,
          importFrom: "Component",
          name: "rax",
          external: true
        }
      ]
    },
    exported: ["default"],
    code:
      'import { createComponent as __create_component__, Component as __component__ } from "jsx2mp-runtime";\n\nconst __def__ = class extends __component__ {\n  render() {\n    return {};\n  }\n\n};\n\nComponent(__create_component__(__def__, {\n  events: []\n}));',
    map: null,
    config: {
      component: true
    },
    style: "",
    usingComponents: {},
    template: "<view>hello world</view>"
  }
  ```

###### 4.2.1.1.4. runtime 

提供垫片，小程序 Page/Component与原生Rax支持还是有区别，使用 jsx2mp-runtime 来作了二者的桥接；

感兴趣的同学可以自行查看：

https://github.com/raxjs/miniapp/tree/master/packages/jsx2mp-runtime/src

###### 4.2.1.1.5.  univeral 

支持生态

#### 4.2.2. 运行时 

代表：有蚂蚁的Remax，京东的Taro 3，淘宝的Rax。 

小程序运行时的起点：[kbone](https://wechat-miniprogram.github.io/kbone/docs/?spm=ata.13261165.0.0.24bd6f229wae2I)

1. 小程序的技术底层依托于web技术，由于多线程架构的限制，对于有多端需求的项目来说，加一个功能或者改一个样式都可能需要改动两套代码（DOM、BOM API 无法打平）；

目的：

1 . 为了更好的复用组件，尽可能完整的支持 Web 端的特性；

2. 在小程序端的渲染结果要尽可能接近 Web 端 h5 页面；

方案：

Web组件转小程序

a. 限制大部分 Web 端特性，兼容性差，需要将 Web 端框架（比如 vue、react 等）给完整引进来 ；

b. Web框架（vue、react）底层依赖DOM、BOM，需要提供适配；

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649848628285-66cd3647-e255-4323-ac8d-39e4dd2dec22.png)



适配器：

1. 在 appService 端运行的轻型 DOM 树；

2. 提供基础的 DOM/BOM API；

3. appService 端和 webView 端的交互通过适配器来进行；

Rax类似Kbone：

1. 采用driver，小程序的driver 只需复用 web 端的 driver-dom，因为底层的 document 和 window 变量都已经模拟好；

2. 为开发者提供更贴近 web 的开发体验。这套方案意味着开发者除了使用 JSX 之外，也是支持直接使用 BOM/DOM API 创建视图，driver的API操作是可以引用的；

- driver-miniapp

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649849039032-87c0bfa0-9df1-4957-b98b-e190ed14969a.png)



```js
/**
 * Driver for Miniapp
 **/

function cached(fn) {
  const cache = Object.create(null);
  return function cachedFn(str) {
    return cache[str] || (cache[str] = fn(str));
  };
}

// opacity -> opa
// fontWeight -> ntw
// lineHeight|lineClamp -> ne[ch]
// flex|flexGrow|flexPositive|flexShrink|flexNegative|boxFlex|boxFlexGroup|zIndex -> ex(?:s|g|n|p|$)
// order -> ^ord
// zoom -> zoo
// gridArea|gridRow|gridRowEnd|gridRowSpan|gridRowStart|gridColumn|gridColumnEnd|gridColumnSpan|gridColumnStart -> grid
// columnCount -> mnc
// tabSize -> bs
// orphans -> orp
// windows -> ows
// animationIterationCount -> onit
// borderImageOutset|borderImageSlice|borderImageWidth -> erim
const NON_DIMENSIONAL_REG = /opa|ntw|ne[ch]|ex(?:s|g|n|p|$)|^ord|zoo|grid|orp|ows|mnc|^columns$|bs|erim|onit/i;
const EVENT_PREFIX_REG = /^on[A-Z]/;
const CLASS_NAME = 'className';
const CLASS = 'class';
const STYLE = 'style';
const CHILDREN = 'children';

const TEXT_CONTENT_ATTR = 'textContent';

const CREATE_COMMENT = 'createComment';
const CREATE_TEXT_NODE = 'createTextNode';
const SET_ATTRIBUTE = 'setAttribute';
const REMOVE_ATTRIBUTE = 'removeAttribute';
const EMPTY = '';

const isDimensionalProp = cached(prop => !NON_DIMENSIONAL_REG.test(prop));
const isEventProp = cached(prop => EVENT_PREFIX_REG.test(prop));


function createBody(): HTMLElement {
  return document.body;
}

function createEmpty(): Comment {
  return document[CREATE_COMMENT](EMPTY);
}

function createText(text): Text {
  return document[CREATE_TEXT_NODE](text);
}

function updateText(node: any, text: string) {
  node[TEXT_CONTENT_ATTR] = text;
}

/**
* @param {string} type node type
* @param {object} props element properties
*/
function createElement(type: string, props: object) {
  let style;
  let attrs = {};
  let events = [];

  for (let prop in props) {
    const value = props[prop];
    if (prop === CHILDREN) continue;

    if (value !== null) {
      if (prop === STYLE) {
        style = value;
      } else if (isEventProp(prop)) {
        events.push({
          name: prop.slice(2).toLowerCase(),
          handler: value
        });
      } else {
        if (prop === CLASS_NAME) {
          prop = CLASS;
        }
        attrs[prop] = value;
      }
    }
  }

  // @ts-ignore
  const node = document._createElement({
    tagName: type,
    document,
    attrs
  });

  if (style) {
    setStyle(node, style);
  }

  events.forEach(({ name, handler }) => {
    node.addEventListener(name, handler);
  });

  return node;
}

function appendChild(node: any, parent: any) {
  return parent.appendChild(node);
}

function removeChild(node: any, parent: any) {
  parent = parent || node.parentNode;
  // Maybe has been removed when remove child
  if (parent) {
    parent.removeChild(node);
  }
}

function replaceChild(newChild: any, oldChild: any, parent: any) {
  parent = parent || oldChild.parentNode;
  parent.replaceChild(newChild, oldChild);
}

function insertAfter(node: any, after: any, parent: any) {
  parent = parent || after.parentNode;
  const nextSibling = after.nextSibling;
  if (nextSibling) {
    // Performance improve when node has been existed before nextSibling
    if (nextSibling !== node) {
      insertBefore(node, nextSibling, parent);
    }
  } else {
    appendChild(node, parent);
  }
}

function insertBefore(node: any, before: any, parent: any) {
  parent = parent || before.parentNode;
  parent.insertBefore(node, before);
}

function addEventListener(node: any, eventName: string, eventHandler: any) {
  return node.addEventListener(eventName, eventHandler);
}

function removeEventListener(node: any, eventName: string, eventHandler: any) {
  return node.removeEventListener(eventName, eventHandler);
}

function removeAttribute(node: any, propKey: string) {
  if (propKey === CLASS_NAME) propKey = CLASS;

  if (propKey in node) {
    node[propKey] = null;
  }

  node[REMOVE_ATTRIBUTE](propKey);
}

function setAttribute(node: any, propKey: string, propValue) {
  if (propKey === CLASS_NAME) propKey = CLASS;

  if (propKey in node) {
    node[propKey] = propValue;
  } else {
    node[SET_ATTRIBUTE](propKey, propValue);
  }
}

/**
* @param {object} node target node
* @param {object} style target node style value
*/
function setStyle(node: any, style: object) {
  for (let prop in style) {
    const value = style[prop];
    let convertedValue;

    if (typeof value === 'number' && isDimensionalProp(prop)) {
      convertedValue = value + 'rpx';
    } else {
      convertedValue = value;
    }

    // Support CSS custom properties (variables) like { --main-color: "black" }
    if (prop[0] === '-' && prop[1] === '-') {
      // reference: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/setProperty.
      // style.setProperty do not support Camel-Case style properties.
      node.style.setProperty(prop, convertedValue);
    } else {
      node.style[prop] = convertedValue;
    }
  }
}

function beforeRender() {}

function afterRender() {}

/**
* Remove all children from node.
* @NOTE: Optimization at web.
*/
function removeChildren(node: any) {
  node.textContent = EMPTY;
}

export default {
  createBody,
  createEmpty,
  createText,
  updateText,
  createElement,
  appendChild,
  removeChild,
  replaceChild,
  insertAfter,
  insertBefore,
  addEventListener,
  removeEventListener,
  removeAttribute,
  setAttribute,
  setStyle,
  beforeRender,
  afterRender,
  removeChildren
}

```

- Rax事件系统：miniapp-render
  miniapp-render is a DOM simulator designed for MiniApp which can provides DOM-related API for developers.
  You can think of it as a lightweight jsDom running on appService.

Rax 小程序运行时中，模拟 DOM/BOM API 的库为 miniapp-render，其支持的 API 如下：

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649849057263-cfe5bf56-a257-41ab-ae0f-919a35129e22.png)

- 工程设计

Rax 小程序运行时 follow 了 Rax Web 的设计，Web 端 Webpack 打包出的 JS Bundle 可以在小程序运行时中复用。我们通过插件将 miniapp-render 模拟出的 window 和 document 变量注入该 bundle，再生成一个固定的小程序项目骨架，在 app.js 中加载 JS Bundle 即可。

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649849399615-489c3eeb-430a-4827-a760-38eda6b85483.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)

miniapp-render源码：有兴趣同学可以自行查阅：

https://github.com/raxjs/miniapp/tree/master/packages/miniapp-render

### 4.3. 框架选择 

#### 4.3.1. API 设计与性能 

- API设计

1. 小程序端总会存在无法抹平以及需要单独处理的地方；

2. 每个端独立的属性不应该入侵基础框架本身，保证基础框架的纯净有利于做更多的扩展；

```js
// Taro
import Taro, { Component } from '@tarojs/taro'
import { View, Text } from '@tarojs/components'

export default class Index extends Component {
  config = {
    navigationBarTitleText: '首页'
  }

  componentWillMount () { }

  componentDidMount () { }

  componentWillUnmount () { }

  componentDidShow () { }

  componentDidHide () { }

  render () {
    return (
      <View>
        <Text>1</Text>
      </View>
    )
  }
}

// Rax
import { createElement, Component } from 'rax';
import View from 'rax-view';
import Text from 'rax-text';
import { isMiniApp } from 'universal-api'; 
import { registerNativeListeners, addNativeEventListener, removeNativeEventListener } from 'rax-app';

function handlePageShow() {}

class Index extends Component {
  componentWillMount () { }

  componentDidMount () { 
    if (isMiniApp) {
      addNativeEventListener('onShow', handlePageShow);
    }
  }

  componentWillUnmount () {
    if (isMiniApp) {
      removeNativeEventListener('onShow', handlePageShow);
    }
  }

  render () {
    return (
      <View>
        <Text>1</Text>
      </View>
    )
  }
}

if (isMiniApp) {
  registerNativeListeners(Index, ['onShow']);
}

export default Index;
```

1. Rax 没有 componentDidShow componentDidHide 的概念，新增了和 W3C 标准类似的 addNativeEventLisenter removeEventListener 等 API；
2. 组件实例上没有一个叫做 config 的静态属性用来设置页面的 title 等配置；

react 本身是没有这些生命周期和配置的：Rax此处优势更明显；

- 性能

  ```js
  // 小程序本身需要预置生命周期，而不能动态注册：
  Page({
    onShow() {}
  });
  
  // 不生效
  const config = {}
  Page(config);
  setTimeout(() => {
    config.onShow = () => {};
  }, 1000);
  ```

- Taro：不知道是否需要注册 onShow，将所有的原生事件全部注册监听；
- Rax：引入了 registerNativeListeners ，需要先注册，才能监听；

#### 4.3.2 多端组件协议设计

1. Taro：将组件统一在项目中进行编译产出为小程序代码不同；
2. Rax：支持在Rax 小程序项目和原生小程序项目中都能正常使用 Rax 小程序组件；

- 支持渐进式接入或迁移至Rax：
  ○ Rax 小程序组件工程的构建产物符合小程序语法，可以直接在原生小程序项目中使用；
  ○ 如果想渐进式地使用 Rax 来开发小程序，可以以组件或者页面为单位迁移到 Rax ；

- 多端统一的组件使用体验

  ```js
  // Wrong
  import CustomComponent from 'custom-component/miniapp/index'
  
  // Correct，支持miniapp、web、weex等保持一致
  import CustomComponent from 'custom-component'
  ```

#### 4.3.3. 基于webpack构建

1. 基于插件体系，可定制扩展：Rax 工程以 [build-script](https://github.com/ice-lab/build-scripts) 为基础，通过插件体系支持各个场景；基于 webpack-chain 提供了灵活的 webpack 配置能力，用户可以通过组合各种插件实现工程需求；
2. 命令简洁，体验统一：Rax 小程序的编译时方案通过 webpack loader 来处理自身逻辑。以 app/page/component 等文件角色分类的 webpack loader 会调用 jsx-compiler 进行代码的 AST 分析及处理，再将处理完的代码交由 loader 生成对应的小程序文件；运行时方案直接复用 Web 端的编译配置，再通过额外的 webpack 插件生成具体的小程序代码。

补充：主流小程序框架对比

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1649923172129-aca4f3a3-bd08-494f-856c-90362b91765e.png?x-oss-process=image%2Fresize%2Cw_1500%2Climit_0)



# **微信小程序项目优化&开发实战**

https://www.yuque.com/lpldplws/web/zf77fb?singleDoc# 《微信小程序项目优化&开发实战》 密码：tdbo

## 1.  课程目标 

1. 掌握小程序项目优化方向内容；

2. 实现一个基本的2048 demo；

## 2. 课程大纲 

- 讲解小程序项目优化的基本内容；

- 实现2048的基本功能；

## 3. 微信小程序如何进行性能优化 

小程序的性能和用户的体验之间的关系密不可分。在使用小程序的过程中，用户有时会遇到小程序打开慢、滑动卡顿、响应慢等问题，这些问题都与小程序的性能有关。性能问题归根到底就是用户体验的问题，如果不能得到很好的解决，会影响用户的正常使用，甚至退出小程序。

随着小程序的迭代，页面越来越多，功能越来越复杂，小程序的性能问题也越来越突出。在开发小程序的过程中，开发者不仅应该关注功能的实现，还应该将足够的精力投入到小程序性能的优化上，保障良好的用户体验。

广义上讲，小程序的性能又可以分为「启动性能」和「运行时性能」两个主题。「启动性能」让用户能够更快的打开并看到小程序的内容，「运行时性能」保障用户能够流畅的使用小程序的功能。除了本身的功能之外，良好性能带来的良好用户体验，也是小程序能够留住用户的关键。

小程序的框架结合了 Web 开发和客户端开发的技术，并进行了进一步的创新。因此，一些 Web 开发中性能优化的方法同样适用于小程序，比如缓存的使用、网络请求的优化、代码压缩等等。此外，由于小程序技术框架的特点，小程序开发中也有一些特殊的性能优化方法。

### 3.1. 小程序启动优化 

#### 3.1.1. 小程序启动定义 

小程序启动是小程序用户体验中极为重要的一环，启动耗时过长会造成小程序用户流失，影响用户体验。

小程序的启动过程以「用户打开小程序」为起点，到小程序「首页渲染完成」为止。

「用户打开小程序」可能是由用户点击访问触发，也可能通过扫码、小程序跳小程序或 APP 打开小程序等入口触发。从扫码、APP 等场景打开小程序时，可能会有前置的跳转和校验流程，不包含在小程序启动流程的讨论范围之内。

小程序「首页渲染完成」的标志是首个页面 Page.onReady 事件触发

![](https://cdn.nlark.com/yuque/0/2022/svg/2340337/1658555897461-08b178af-647b-44de-aeb0-ad6f4fecec95.svg)



#### 3.1.2 打开率/到达率

小程序「首页渲染完成」次数与「小程序启动」次数的比值也被称为（PV）打开率或（PV）到达率。与之对应的 流失率 = 1 - 打开率。
打开率受到下列因素影响：

- 启动性能：启动耗时越长，白屏时间越久，用户越可能因为失去耐心而退出小程序，打开率也会越低；
- 用户等待意愿：用户等待意愿越强，等待时间也会更久，在启动耗时一致的情况下，打开率也会越高。用户等待意愿与使用小程序的场景有关，例如：
  ○ 扫码、搜索等用户目的性较强的场景，通常等待意愿也更强；
  ○ 广告类的场景下，用户等待意愿较低，要获得较高的打开率，启动性能优化会更加有必要；

#### 3.1.3 小程序启动性能优化

##### 3.1.3.1. 代码包体积优化 

启动性能优化最直接的手段是降低代码包大小，代码包大小直接影响了下载耗时，影响用户启动小程序时的体验。

开发者可以采取以下手段优化代码包体积；

###### 3.1.3.1.1. 合理使用分包加载 

使用 分包加载 是优化小程序启动耗时效果最明显的手段。开发者按照功能划分，将小程序的页面按使用频率和场景拆分成不同分包，实现代码包的按需加载。

优势如下：

- 承载更多功能：小程序单个代码包的体积上限为 2M，使用分包可以提升小程序代码包总体积上限，承载更多的功能与服务。

- 降低代码包下载耗时：使用分包后可以显著减少启动时需要下载的代码包大小，在不影响功能正常使用的前提下，有效降低启动耗时。

- 降低小程序代码注入耗时：若未开启按需注入，小程序编译时会将所有 js 文件打包成同一个文件一次性的注入，并执行所有页面和自定义组件的代码。分包后可以降低注入和实际执行的代码量，从而降低注入耗时。

- 降低页面渲染耗时：使用分包可以避免不必要的组件和页面初始化。

- 降低内存占用：分包能够实现页面、组件和逻辑较粗粒度的按需加载，从而降低内存的占用。

业务方式：

1. 独立分包

小程序中的某些场景（如广告页、活动页、支付页等），通常功能不是很复杂且相对独立，对启动性能有很高的要求。独立分包可以独立于主包和其他分包运行。从独立分包页面进入小程序时，不需要下载主包。建议开发者将部分对启动性能要求很高的页面放到特殊的独立分包中。

2. 分包预下载

在使用「分包加载」后，虽然能够显著提升小程序的启动速度，但是当用户在使用小程序过程中跳转到分包内页面时，需要等待分包下载完成后才能进入页面，造成页面切换的延迟，影响小程序的使用体验。分包预下载便是为了解决首次进入分包页面时的延迟问题而设计的。

3. 分包异步化

「分包异步化」将小程序的分包从页面粒度细化到组件甚至文件粒度。这使得本来只能放在主包内页面的部分插件、组件和代码逻辑可以剥离到分包中，并在运行时异步加载，从而进一步降低启动所需的包大小和代码量。

分包异步化能有效解决主包大小过度膨胀的问题。

###### 3.1.3.1.2. 避免非必要的全局自定义组件和插件 

在 app.json 中通过 usingComponents 全局引用的自定义组件和通过 plugins 全局引入的插件，会在小程序启动时随主包一起下载和注入 JS 代码，影响启动耗时。

1. 如果自定义组件只在某个分包的页面中使用，应定义在页面的配置文件中

​		a. 全局引入的自定义组件会被认为是所有分包、所有页面都需要的，会影响「按需注入」的效果和小程序代码注入的耗时。

2. 如果插件只在某个分包的中使用，请仅在分包中引用插件

​		a. 如果确实需要在主包中或被多个分包使用的插件，仍可以考虑将插件置于一个分包，并通过「分包异步化」的形式异步引入。

###### 3.1.3.1.3. 控制代码包内的资源文件 

小程序代码包在下载时会使用 ZSTD 算法进行压缩，图片、音频、视频、字体等资源文件会占用较多代码包体积，并且通常难以进一步被压缩，对于下载耗时的影响比代码文件大得多。

建议开发者在代码包内的图片一般应只包含一些体积较小的图标，避免在代码包中包含或在 WXSS 中使用 base64 内联过多、过大的图片等资源文件。这类文件应尽可能部署到 CDN，并使用 URL 引入。

###### 3.1.3.1.4. 及时清理无用代码和资源 

建议使用微信开发者工具提供的「代码静态依赖分析」，不定期地分析代码包的文件构成和依赖关系，以此优化代码包大小和内容。对于仅用于本地开发调试，不应包含在小程序代码包的文件，可以使用工具设置的 packOptions.ignore 配置忽略规则。

在使用打包工具（如 Webpack、Rollup 等）对小程序代码进行预处理时，可以利用 tree-shaking 等特性去除冗余代码，也要注意防止打包时引入不需要的库和依赖。

##### 3.1.3.2. 代码注入优化 

###### 3.1.3.2.1. 使用按需注入 

通常情况下，在小程序启动时，启动页面依赖的所有代码包（主包、分包、插件包、扩展库等）的所有 JS 代码会全部合并注入，包括其他未访问的页面以及未用到自定义组件，同时所有页面和自定义组件的 JS 代码会被立刻执行。这造成很多没有使用的代码在小程序运行环境中注入执行，影响注入耗时和内存占用。

自基础库版本 2.11.1 起，可以通过开启「按需注入」特性避免不必要的代码注入和执行，以降低小程序的启动时间和运行时内存。

```js
{
  "lazyCodeLoading": "requiredComponents"
}
```

注意：启用按需注入后，页面 JSON 配置中定义的所有组件和 app.json 中 usingComponents 配置的全局自定义组件，都会被视为页面的依赖并进行注入和加载。建议开发者及时移除 JSON 中未使用自定义组件的声明，并尽量避免在全局声明使用率低的自定义组件，否则可能会影响按需注入的效果。

###### 3.1.3.2.2. 使用用时注入 

在打开上述「按需注入」特性的前提下，可以通过「用时注入」特性使一部分自定义组件不在启动时注入，而是在真正被渲染时才进行注入，进一步降低小程序的启动和首屏时间。

###### 3.1.3.2.3. 启动过程中减少同步 API 的调用 

在小程序启动流程中，会注入开发者代码并顺序同步执行 App.onLaunch, App.onShow, Page.onLoad, Page.onShow。

在小程序初始化代码（Page，App 定义之外的内容）和上述启动相关的几个生命周期中，应尽量减少或不调用同步 API。绝大多数同步 API 会以 Sync 结尾，但有部分特例，比如 getSystemInfo。

同步 API 虽然使用起来更简单，但是会阻塞当前 JS 线程，影响代码执行。如非必要，应尽可能的使用异步 API 代替同步，并将启动过程中非必要的同步 API 调用延迟到启动完成后进行。

###### 3.1.3.2.4. 避免启动过程进行复杂运算 

在小程序初始化代码（Page，App 定义之外的内容）和启动相关的几个生命周期中，应避免执行复杂的运算逻辑。复杂运算也会阻塞当前 JS 线程，影响启动耗时。建议将复杂的运算延迟到启动完成后进行。

##### 3.1.3.3. 首屏渲染优化 

页面首屏渲染的优化，目的是让「首页渲染完成」(Page.onReady) 尽可能提前。但很多情况下「首页渲染完成」可能还是空白页面，因此更重要的是让用户能够更早的看到页面内容（First Paint 或 First Contentful Paint）

###### 3.1.3.3.1. 使用「按需注入」和「用时注入」 

除了优化代码注入的耗时外，「按需注入」和「用时注入」也可以减少需要初始化的组件数量，降低实际页面渲染的耗时，使「首页渲染完成」提前。

###### 3.1.3.3.2. 启用「初始渲染缓存」 

自基础库版本 2.11.1 起，小程序支持启用初始渲染缓存。开启后，可以在非首次启动时，使视图层不需要等待逻辑层初始化完毕，而直接提前将页面渲染结果展示给用户，这可以使「首页渲染完成」和页面对用户可见的时间大大提前。

###### 3.1.3.3.3. 避免引用未使用的自定义组件 

在页面渲染时，会初始化在当前页面配置和全局配置通过 usingComponents 引用的自定义组件，以及组件所依赖的其他自定义组件。未使用的自定义组件会影响渲染耗时。

当组件不被使用时，应及时从 usingComponents 中移除。

###### 3.1.3.3.4. 精简首屏数据 

首页渲染的耗时与页面的复杂程度正相关。对于复杂页面，可以选择进行渐进式的渲染，根据页面内容优先级，优先展示页面的关键部分，对于非关键部分或者不可见的部分可以延迟更新。

此外，与视图层渲染无关的数据应尽量不要放在 data 中，避免影响页面渲染时间。

###### 3.1.3.3.5. 提前首屏数据请求 

很多小程序在渲染首页时，需要依赖服务端的接口数据（如商品列表等），此时小程序的首页可能是空白或者骨架屏。

由于网络请求需要相对较长的时间，我们建议开发者在 Page.onLoad 或更早的时机发起网络请求，而不应等待 Page.onReady 之后再进行。

###### 3.1.3.3.6. 缓存请求数据 

小程序提供了wx.setStorage、wx.getStorage等读写本地缓存的能力，数据存储在本地，返回的会比网络请求快。如果开发者基于某些原因无法采用数据预拉取与周期性更新，我们推荐优先从缓存中获取数据来渲染视图，等待网络请求返回后进行更新。

###### 3.1.3.3.7. 骨架屏 

骨架屏通常用于在页面完全渲染之前，通过一些灰色的区块大致勾勒出轮廓，待数据加载完成后，再替换成真实的内容。

建议开发者在页面数据未准备好时（例如需要通过网络获取），尽量避免展示空白页面，而是先通过骨架屏展示页面的大致结构，请求数据返回后再进行页面更新。以提升用户的等待意愿。

##### 3.1.3.4. 其他优化 

###### 3.1.3.4.1. 合理规划版本发布 

小程序启动时如果检测到版本更新，会进行以下操作，影响启动耗时

- 重新获取小程序的基础信息

- 进行小程序代码包的增量更新

- 重新生成 JS 代码的 Code Cache

- 重新生成初始渲染缓存

能够快速迭代发布是小程序相对 APP 的一个优势，但是过于频繁的新版本发布可能会导致部分用户每次使用都需要进行小程序的更新，导致平均启动耗时变长。

在不影响小程序正常功能迭代的前提下，我们建议开发者提前做好版本规划，控制版本发布的频率。

### 3.2. 小程序运行时性能优化 

小程序的运行时性能直接决定了用户在使用小程序功能时的体验。如果运行时性能出现问题，很容易出现页面滚动卡顿、响应延迟等问题，影响用户使用。如果内存占用过高，还会出现黑屏、闪退等问题。

#### 3.2.1. 小程序运行环境 

微信小程序运行在多种平台上：iOS/iPadOS 微信客户端、Android 微信客户端、Windows PC 微信客户端、Mac 微信客户端、小程序硬件框架和用于调试的微信开发者工具等。

不同运行环境下，脚本执行环境以及用于组件渲染的环境是不同的，性能表现也存在差异：

- 在 iOS、iPadOS 和 Mac OS 上，小程序逻辑层的 JavaScript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS 14、iPad OS 14、Mac OS 11.4 等；

- 在 Android 上，小程序逻辑层的 JavaScript 代码运行在 V8 中，视图层是由基于 Mobile Chromium 内核的微信自研 XWeb 引擎来渲染的；

- 在 Windows 上，小程序逻辑层 JavaScript 和视图层都是用 Chromium 内核；

- 在 开发工具上，小程序逻辑层的 JavaScript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的。

JavaScriptCore 无法开启 JIT 编译 (Just-In-Time Compiler)，同等条件下的运行性能要明显低于其他平台。

尽管各运行环境是十分相似的，但是还是有些许区别：

- JavaScript 语法和 API 支持不一致：语法上开发者可以通过开启 ES6 转 ES5 的功能来规避；此外，小程序基础库内置了必要的Polyfill，来弥补 API 的差异。

- WXSS 渲染表现不一致：尽管可以通过开启样式补全来规避大部分的问题，还是建议开发者需要在各端分别检查小程序的真实表现。

#### 3.2.2. 小程序运行时性能优化 

##### 3.2.2.1. 合理使用setState 

setData 的过程，大致可以分成几个阶段：

- 逻辑层虚拟 DOM 树的遍历和更新，触发组件生命周期和 observer 等；

- 将 data 从逻辑层传输到视图层；

- 视图层虚拟 DOM 树的更新、真实 DOM 元素的更新并触发页面渲染更新；

对于第 2 步，由于小程序的逻辑层和视图层是两个独立的运行环境、分属不同的线程或进程，不能直接进行数据共享，需要进行数据的序列化、跨线程/进程的数据传输、数据的反序列化，因此数据传输过程是异步的、非实时的。

iOS/iPadOS/MacOS 上，数据传输是通过 evaluateJavascript 实现的，还会有额外 JS 脚本解析和执行的耗时。

数据传输的耗时与数据量的大小正相关，如果对端线程处于繁忙状态，数据会在消息队列中等待。

###### 3.2.2.1.1. data 应只包括渲染相关的数据 

setData 应只用来进行渲染相关的数据更新。用 setData 的方式更新渲染无关的字段，会触发额外的渲染流程，或者增加传输的数据量，影响渲染耗时。

- ✅ 页面或组件的 data 字段，应用来存放和页面或组件渲染相关的数据（即直接在 wxml 中出现的字段）；

- ✅ 页面或组件渲染间接相关的数据可以设置为「纯数据字段」，可以使用 setData 设置并使用 observers 监听变化；

- ✅ 页面或组件渲染无关的数据，应挂在非 data 的字段下，如 this.userData = {userId: 'xxx'}；

- ❌ 避免在 data 中包含渲染无关的业务数据；

- ❌ 避免使用 data 在页面或组件方法间进行数据共享；

- ❌ 避免滥用 纯数据字段 来保存可以使用非 data 字段保存的数据。

###### 3.2.2.1.2. 控制 setData 的频率 

每次 setData 都会触发逻辑层虚拟 DOM 树的遍历和更新，也可能会导致触发一次完整的页面渲染流程。过于频繁（毫秒级）的调用 setData，会导致以下后果：

- 逻辑层 JS 线程持续繁忙，无法正常响应用户操作的事件，也无法正常完成页面切换；

- 视图层 JS 线程持续处于忙碌状态，逻辑层 -> 视图层通信耗时上升，视图层收到消息的延时较高，渲染出现明显延迟；

- 视图层无法及时响应用户操作，用户滑动页面时感到明显卡顿，操作反馈延迟，用户操作事件无法及时传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层。

因此，开发者在调用 setData 时要注意：

- ✅ 仅在需要进行页面内容更新时调用 setData；

- ✅ 对连续的 setData 调用尽可能的进行合并；

- ❌ 避免不必要的 setData；

- ❌ 避免以过高的频率持续调用 setData，例如毫秒级的倒计时；

- ❌ 避免在 onPageScroll 回调中每次都调用 setData。

###### 3.2.2.1.3. 选择合适的 setData 范围 

组件的 setData 只会引起当前组件和子组件的更新，可以降低虚拟 DOM 更新时的计算开销。

- ✅ 对于需要频繁更新的页面元素（例如：秒杀倒计时），可以封装为独立的组件，在组件内进行 setData 操作。必要时可以使用 CSS contain 属性限制计算布局、样式和绘制等的范围。

###### 3.2.2.1.4. setData 应只传发生变化的数据 

setData 的数据量会影响数据拷贝和数据通讯的耗时，增加页面更新的开销，造成页面更新延迟。

- ✅ setData 应只传入发生变化的字段；

- ✅ 建议以数据路径形式改变数组中的某一项或对象的某个属性，如 this.setData({'array[2].message': 'newVal', 'a.b.c.d': 'newVal'})，而不是每次都更新整个对象或数组；

- ❌ 不要在 setData 中偷懒一次性传所有data：this.setData(this.data)。

###### 3.2.2.1.5. 控制后台态页面的 setData 

由于小程序逻辑层是单线程运行的，后台态页面去 setData 也会抢占前台页面的运行资源，且后台态页面的的渲染用户是无法感知的，会产生浪费。在某些平台上，小程序渲染层各 WebView 也是共享同一个线程，后台页面的渲染和逻辑执行也会导致前台页面的卡顿。

- ✅ 页面切后台后的更新操作，应尽量避免，或延迟到页面 onShow 后延迟进行；

- ❌ 避免在切后台后仍进行高频的 setData，例如倒计时更新。

##### 3.2.2.2. 渲染性能优化 

###### 3.2.2.2.1. 适当监听页面或组件的 scroll 事件 

只要用户在 Page 构造时传入了 onPageScroll 监听，基础库就会认为开发者需要监听页面 scoll 事件。此时，当用户滑动页面时，事件会以很高的频率从视图层发送到逻辑层，存在一定的通信开销。

类似的，对于 <scroll-view>、<page-meta> 等可以通过 bindscroll 监听滑动事件的组件，也会存在这一情况。

正是由于 scroll 事件触发的频率很高，因此开发者很容易误用，在使用时需要注意：

- ✅ 非必要不监听 scroll 事件；

- ✅ 在实现与滚动相关的动画时，优先考虑滚动驱动动画（仅 <scroll-view>）或 WXS 响应事件

- ❌ 不需要监听事件时，Page 构造时应不传入 onPageScroll 函数，而不是留空函数；

- ❌ 避免在 scroll 事件监听函数中执行复杂逻辑；

- ❌ 避免在 scroll 事件监听中频繁调用 setData 或同步 API。

###### 3.2.2.2.2. 选择高性能的动画实现方式 

开发者在开发界面动画时，应该选择高性能的动画实现方式。

- ✅ 优先使用 CSS 渐变、CSS 动画、或小程序框架提供的其他动画实现方式完成动画；

- ✅ 在一些复杂场景下，如果上述方式不能满足，可以使用 WXS 响应事件 动态调整节点的 style 属性做到动画效果。同时，这种方式也可以根据用户的触摸事件来动态地生成动画；

- ❌ 避免通过连续 setData 改变界面的形式来实现动画。虽然实现起来简单灵活，但是极易出现较大的延迟或卡顿，甚至导致小程序僵死；

- ✅ 如果不得不采用 setData 方式，应尽可能将页面的 setData 改为自定义组件中的 setData 来提升性能。

###### 3.2.2.2.3. 使用 IntersectionObserver 监听元素曝光 

部分业务场景会需要监控元素曝光情况，用于进行一些页面状态的变更或上报分析。

- ✅ 建议使用节点布局相交状态监听 IntersectionObserver 推断某些节点是否可见、有多大比例可见；

- ❌ 避免通过监听 onPageScroll 事件，并在回调中通过持续查询节点信息 SelectQuery 来判断元素是否可见。

###### 3.2.2.2.4. 控制 WXML 节点数量和层级 

一个太大的 WXML 节点树会增加内存的使用，样式重排时间也会更长，影响体验。

- ✅ 建议一个页面 WXML 节点数量应少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个。

##### 3.2.2.3. 资源加载优化 

###### 3.2.2.3.1. 控制图片资源的大小 

开发者应根据功能需要和实际显示区域的大小，选择合适的图片尺寸、图片格式和压缩比。

图片体积太大，可能导致下列后果

- 增加图片下载时间，导致用户看到图片时机延迟；

- 对用户造成非必要的流量消耗；

- 影响图片解码和绘制的耗时，可能更容易造成掉帧、卡顿或白屏，甚至无法正常进行滚动和页面切换（低端设备上会尤为明显）；

- 内存占用增长，尤其是大图片和长列表中的大量图片会导致内存占用急剧上升。

图片对内存的影响

iOS 系统内存紧张时，会主动回收掉一部分 WebView。大图片和长列表中的大量图片很容易引起系统对 WebView 的回收，导致小程序白屏，严重时会触发微信强制关闭小程序。

内存增长如果超过了限制，也会导致小程序出现白屏或黑屏，甚至整个小程序发生闪退。

###### 3.2.2.3.2. 避免滥用 image 组件的 widthFix/heightFix 模式 

widthFix/heightFix 模式会在图片加载完成后，动态改变图片的高度或宽度。图片高度或宽度的动态改变，可能会引起页面内大范围的布局重排，导致页面发生抖动，并造成卡顿。

对于页面的背景图或 banner 图，应尽量预先指定图片的尺寸，避免图片加载完成后再进行二次的尺寸调整。

##### 3.2.2.4. 内存优化 

###### 3.2.2.4.1. 合理使用分包加载 

使用分包加载不仅能优化启动耗时，也能够实现页面、组件和逻辑较粗粒度的按需加载，从而降低内存的占用。

###### 3.2.2.4.2. 使用按需注入和用时注入 

通过开启「按需注入」和「用时注入」，可以在运行时避免加载未使用到的页面和组件，降低运行时的内存占用。

###### 3.2.2.4.3. 内存分析 

如果要更精细的分析小程序逻辑层的内存分布情况，可以使用开发者工具调试器的「内存调试」或「真机调试 2.0」提供的「内存调试」能力。

###### 3.2.2.4.4. 处理内存告警 

当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。在 iOS 上，当微信客户端在一定时间间隔内连续收到系统内存告警时，会根据一定的策略，主动销毁小程序，并提示用户「运行内存不足，请重新打开该小程序」。

###### 3.2.2.4.5. 小程序常见的内存泄露问题 

存在内存泄露问题会导致小程序在运行过程中内存占用持续增长，引起小程序闪退或被被微信强制销毁。

- 小程序长期持有页面实例，导致页面实例和引用的组件无法正常销毁

- 事件监听未及时解绑

- 未清理的定时器

## 4. 小程序实战 

建议有兴趣的同学可以参考：

https://developers.weixin.qq.com/community/business/course/000606628dc2e86dc0ddcbb115940d

https://gitee.com/geektime-geekbang_admin/weapp_optimize

# 现代hybrid发展史&flutter 与 dart 开发入门

https://www.yuque.com/lpldplws/web/tsii7l?singleDoc# 《现代hybrid发展史&flutter 与 dart 开发入门》 密码：ov0l

## 1. 课程目标 

- 了解现代hybrid技术的使用及落地；

- 了解flutter及dart的基本概念，为明天的实战做准备；

移动互联⽹时代，业务需要既能⾼效快速的交付⼜要良好的⽤户体验，在此场景下，基于原⽣app的混合开发逐渐成为主流的移动端应⽤架构。从基于webView的hybrid开发，到react-native、weex，再到flutter，技术在不断升级和演变，也推动着我们需要不断学习对应的领域知识，⽅能更好的解决业务场景的需求。本期课程，讲会从现代移动端应⽤的开发讲起，⼀起⾛进混合开发的技术领域。 

## 2. 课程大纲 

- 传统移动应用开发发展史；

- 搭建Flutter开发环境；

- dart简介；

下图就是移动端跨平台演进的迭代方向

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666365880559-fa536122-f475-457a-afd9-6de18558fb54.png)

## 3. 传统移动端应用开发发展史

### 3.1. 原生开发的优劣势 

优点：

1. ⽤户体验好：基于原⽣客户端语⾔开发，能最⼤化的利⽤设备的性能，提供最优的产品体验；

2. 能⼒强：可以直接和操作系统交互并调⽤其API，可以实现⼏乎全部能在移动设备实现的功能和场景；

劣势：

1. 动态性：客户端开发通常是有固定的版本发布计划，⽽且受制于 Apple 的 App Store 审核规则，版本发布的不确定性还会受到政策影响，Android 在国内的渠道众多，每次发版都要反复检查渠道，⼀旦发现线上问题需要依赖再次发版，容错成本⾮常⾼，这也⼤⼤增加了对业务的局限性；

2. 开发成本：客户端的开发成本⾼，然⽽⽣态还不如 Web 丰富，npm 社区的⼏万开源包，加上更活跃的开发者社区，导致对企业来讲客户端的研发成本是⾼于 Web 开发的；

3. 跨端⼀致性：传统客户端开发⼀套业务，是需要实现 Android + iOS 两套代码的，⽽且由于Android 和 iOS 的操作系统能⼒差异，同样的需求往往会⽤不同的视觉和交互来实现，这也导致了业务成本居⾼不下；

### 3.2. hybrid开发  

H5 + 原⽣的开发形式，是混合开发的主流。使⽤原⽣技术搭建APP框架，使⽤H5动态下发内容。

由于H5代码只需要⼀次开发，就能同时在Android和iOS两个平台运⾏，这也可以减⼩开发成本。也就是说，H5部分功能越多，开发成本就越⼩。我们称这种H5+原⽣的开发模式为混合开发 ，采⽤混合模式开发的APP我们称之为混合应⽤或Hybrid APP ，如果⼀个应⽤的⼤多数功能都是H5实现的话，我们称其为Web APP 。混合开发的技术难点主要是原⽣和H5之间的交互。⼀般情况下，我们称H5与原⽣交互的⽅式叫JSBridge。

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1662781845079-5dec07bb-749f-49cc-9440-d34665004b45.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)

#### 3.2.1. WebView 

首先了解下webView，webView是移动端提供的运行JavaScript的环境，是系统渲染Web网页的一个控件，可与页面JavaScript交互，实现混合开发，其中Android和iOS又有些不同：

- Android的WebView采用的是低版本和高版本使用了不同的webkit内核，4.4后直接使用了Chrome；

- iOS中UIWebView算是自IOS2就有，但性能较差，特性支持较差，WKWebView是iOS8之后的升级版，性能更强特性支持也较好；

WebView控件除了能加载指定的url外，还可以对URL请求、JavaScript的对话框、加载进度、页面交互进行强大的处理，之后会提到拦截请求、执行JS脚本都依赖于此；

#### 3.2.2. JSBridge 

Web端和Native可以类比于Client/Server模式，Web端调用原生接口时就如同Client向Server端发送一个请求类似，JSBridge在此充当类似于HTTP协议的角色，实现JSBridge主要是两点：

1. 将Native端原生接口封装成JavaScript接口；

2. 将Web端JavaScript接口封装成原生接口；

#### 3.2.3. Native与Webview双端通信 

##### 3.2.3.1. Native -> Webview 

JavaScript作为解释性语言，最大的一个特性就是可以随时随地地通过解释器执行一段JS代码，所以可以将拼接的JavaScript代码字符串，传入JS解析器执行就可以，JS解析器在这里就是webView；

- Android 4.4之前只能用loadUrl来实现，并且无法执行回调：

  ```js
  String jsCode = String.format("window.showWebDialog('%s')", text); webView.loadUrl("javascript: " + jsCode);
  ```

- Android 4.4之后提供了evaluateJavascript来执行JS代码，并且可以获取返回值执行回调：

  ```js
  String jsCode = String.format("window.showWebDialog('%s')", text); webView.evaluateJavascript(jsCode, new ValueCallback<String>() {   @Override   public void onReceiveValue(String value) {   } }); 
  ```

- iOS的UIWebView使用stringByEvaluatingJavaScriptFromString：

  ```js
  NSString *jsStr = @"执行的JS代码"; [webView stringByEvaluatingJavaScriptFromString:jsStr]; 
  ```

- iOS的WKWebView使用evaluateJavaScript：

  ```js
  [webView evaluateJavaScript:@"执行的JS代码" completionHandler:^(id _Nullable response, NSError * _Nullable error) {    }];
  
  ```

##### 3.2.3.2 **Webview -> Native**

Web调用Native端主要有两种方式

1. 拦截Webview请求的URL Schema
   URL Schema是类URL的一种请求格式，格式如下：
   <protocol>://<host>/<path>?<qeury>#fragment

我们可以自定义JSBridge通信的URL Schema，比如：jsbridge://showToast?text=hello
Native加载WebView之后，Web发送的所有请求都会经过WebView组件，所以Native可以重写WebView里的方法，从来拦截Web发起的请求，我们对请求的格式进行判断：

- 如果符合我们自定义的URL Schema，对URL进行解析，拿到相关操作、操作，进而调用原生Native的方法；
- 如果不符合我们自定义的URL Schema，我们直接转发，请求真正的服务；

Web发送URL请求的方法有这么几种：

1. a标签；
2. location.href；
3. 使用iframe.src；
4. 发送ajax请求；
   这些方法，a标签需要用户操作，location.href可能会引起页面的跳转丢失调用，发送ajax请求Android没有相应的拦截方法，所以使用iframe.src是经常会使用的方案：
   - 安卓提供了shouldOverrideUrlLoading方法拦截
   - UIWebView使用shouldStartLoadWithRequest，WKWebView则使用decidePolicyForNavigationAction
     这种方式从早期就存在，兼容性很好，但是由于是基于URL的方式，长度受到限制而且不太直观，数据格式有限制，而且建立请求有时间耗时。

2. 向Webview中注入JS API
   这个方法会通过webView提供的接口，App将Native的相关接口注入到JS的Context（window）的对象中，一般来说这个对象内的方法名与Native相关方法名是相同的，Web端就可以直接在全局window下使用这个暴露的全局JS对象，进而调用原生端的方法。

   - Android（4.2+）提供了addJavascriptInterface注入：

     ```js
     // 注入全局JS对象
     webView.addJavascriptInterface(new NativeBridge(this), "NativeBridge");
     
     class NativeBridge {
       private Context ctx;
       NativeBridge(Context ctx) {
         this.ctx = ctx;
       }
     
       // 增加JS调用接口
       @JavascriptInterface
       public void showNativeDialog(String text) {
         new AlertDialog.Builder(ctx).setMessage(text).create().show();
       }
     }
     ```

   在Web端直接调用这个方法即可：

   ```js
   window.NativeBridge.showNativeDialog('hello'); 
   ```

   - iOS的UIWebView提供了JavaSciptCore；
   - iOS的WKWebView提供了WKScriptMessageHandler；

### 3.3 语言编译转换

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666367863674-39e8aec8-5a85-4db8-af6f-ddd696fee98b.png)

2011年出，属于语言编译转换的框架，用于通过 .NET 构建适用于 iOS、Android 和 Windows 的新式高性能应用程序。Xamarin 是一个抽象层，可管理共享代码与基础平台代码的通信。 Xamarin 在提供便利（如内存分配和垃圾回收）的托管环境中运行。
通过在iOS，Android和Windows Phone（Windows Phone的本地语言已经是C＃）的所有三个移动平台上提供单一语言（C＃，类库和运行时），同时仍编译native，即使对于要求苛刻的游戏也足够高性能的应用程序。

可以看下到目前位置[github star](https://star-history.com/#flutter/flutter&xamarin/Xamarin.Forms&facebook/react-native&Date)的对比：

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666367481111-e2148354-a299-4747-853f-9c9dabf5a854.png)



但除了这些，还是有很多好处的：

1. 底层SDK的完整绑定：

​	a. Xamarin包含iOS和Android中几乎所有底层平台SDK的绑定。另外，这些绑定是强类型的，这意味着它们易于导航和使用，并且在开发过程中提供可靠的编译时类型检查。这导致更少的运行时错误和更高质量的应用程序；

2. 提供了Objective-C，Java，C和C ++ Interop：

​	a. Xamarin提供了直接调用Objective-C，Java，C和C ++库的功能，使您可以使用已经创建的大量第三方代码。这使您可以利用Objective-C，Java或C / C ++编写的现有iOS和Android库。

3. 具有现代语言结构：

​	a. Xamarin应用程序是用C＃编写的，现代语言包括对Objective-C和Java的重大改进，如动态语言特性，功能结构（如Lambda，LINQ，并行编程功能，复杂的泛型等等）；

4. 基础类库丰富：

​	a.  Xamarin应用程序使用.NET BCL，这是一个庞大的具有强大的XML，数据库，序列化，IO，字符串和网络支持等功能的类的集合。

​	b. 现代集成开发环境（IDE）：既支持VSCode，也支持Visual Studio；

从定义我们就可以看出来，对于前端，基本上都不是.NET玩家，不建议使用，且在国外相对来说受环境程度更好一些，在国内除了外企或者很老的，有.NET开发经验的公司才推荐。

### 3.4. 跨平台技术

随着前端框架中VDOM的流行，我们可以在运行时将VDOM直接编译成原生不同平台的控件树，其最终还是调⽤的原⽣API来绘制。 主流的如阿⾥的weex和fb的ReactNative等。

- react native

![主要包括三个线程：
1UI Thread：Android/iOS（或其它平台）应用中的主线程；
2Shadow Thread：进行布局计算和构造 UI 界面的线程；
3JS Thread：React 等 JavaScript 代码都在这个线程执行](https://cdn.nlark.com/yuque/0/2022/png/2340337/1662782938774-59d44495-7ac9-4ce5-8f43-b675cb209ac5.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)



主要包括三个线程：

1. UI Thread：Android/iOS（或其它平台）应用中的主线程；
2. Shadow Thread：进行布局计算和构造 UI 界面的线程；
3. JS Thread：React 等 JavaScript 代码都在这个线程执行

- weex

  ![](https://cdn.nlark.com/yuque/0/2022/jpeg/2340337/1666368363868-78664301-2bc2-4e39-ba74-bb4a42e59263.jpeg)

通过 Rax 和 Vue 前端框架进行功能输出，前端框架下有一层 JS Framework 来实现 dom 的功能。 WeexCore 负责基础的 Flex Layout ，然后通过 Component 分别对接到 Android/iOS 的 Platform Native View 体系。

**优势**

1. 社区庞⼤，开发成本低； 

2. 使⽤前端技术框架，原⽣渲染，性能尚可； 

3. ⽀持热更新；（⽬前iOS端有⻛险，热更新应⽤禁⽌上架App Store）。 

**缺点** 

1. 因为要和原⽣通信，难以胜任复杂的绘制和动画⼯作； 

2. JS为脚本语⾔，解释执⾏，性能和原⽣开发编译后运⾏，有⼀定差距； 

### 3.5. 自绘引擎 

不依赖操作系统提供的布局、原⽣组件能⼒，直接调⽤ GPU 或者底层抽象层进⾏绘制的渲染引擎。 

Flutter 是 Google 推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter 提供了丰富的组件、接口，开发者可以很快地为 Flutter 添加 Native 扩展。下面我们整体介绍一下 Flutter 技术的主要特点。

#### 3.5.1. 跨平台自绘引擎介绍 

Flutter 与用于构建移动应用程序的其他大多数框架不同，因为 Flutter 既不使用 WebView，也不使用操作系统的原生控件。 相反，Flutter 使用自己的高性能渲染引擎来绘制 Widget（组件）。这样不仅可以保证在 Android 和iOS 上 UI 的一致性，也可以避免对原生控件依赖而带来的限制及高昂的维护成本。

Flutter 底层使用 Skia 作为其 2D 渲染引擎，Skia 是 Google的一个 2D 图形处理函数库，包含字型、坐标转换，以及点阵图，它们都有高效能且简洁的表现。Skia 是跨平台的，并提供了非常友好的 API，目前 Google Chrome浏览器和 Android 均采用 Skia 作为其 2D 绘图引擎。

#### 3.5.2. 高性能 

Flutter 高性能主要靠两点来保证：

1. Flutter APP 采用 Dart 语言开发。Dart 在 JIT（即时编译）模式下，执行速度与 JavaScript 基本持平。但是 Dart 支持 AOT，当以 AOT模式运行时，JavaScript 便远远追不上了。执行速度的提升对高帧率下的视图数据计算很有帮助；

2. Flutter 使用自己的渲染引擎来绘制 UI ，布局数据等由 Dart 语言直接控制，所以在布局过程中不需要像 RN 那样要在 JavaScript 和 Native 之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以 JavaScript 需要和 Native 之间不停的同步布局信息，这和在浏览器中JavaScript 频繁操作 DOM 所带来的问题是类似的，都会导致比较可观的性能开销；

#### 3.5.3. Dart

这个是一个很有意思但也很有争议的问题，在了解 Flutter 为什么选择了 Dart 而不是 JavaScript 之前我们先来介绍一下之前提到过的两个概念：JIT 和 AOT。
程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前程序会被提前编译为机器码（或中间字节码），通常将这种类型称为AOT （Ahead of time）即 “提前编译”。而解释执行则是在运行时将源码实时翻译为机器码来执行，通常将这种类型称为JIT（Just-in-time）即“即时编译”。
AOT 程序的典型代表是用 C/C++ 开发的应用，它们必须在执行前编译成机器码；而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持 JIT 模式。但需要注意的是 JIT 和 AOT 指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以 JIT 方式运行也可以以 AOT 方式运行，如Python，它可以在第一次执行时编译成中间字节码，然后在之后执行时再将字节码实时转为机器码执行。也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，这不应该是 JIT 吗 ? 是这样，但通常我们区分是否为AOT 的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。
现在我们看看 Flutter 为什么选择 Dart 语言？笔者根据官方解释以及自己对 Flutter 的理解总结了以下几条（由于其他跨平台框架都将 JavaScript 作为其开发语言，所以主要将 Dart 和 JavaScript 做一个对比）：

1. 开发效率高：Dart 运行时和编译器支持 Flutter 的两个关键特性的组合：
   - 基于 JIT 的快速开发周期：Flutter 在开发阶段采用，采用 JIT 模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；
   - 基于 AOT 的发布包: Flutter 在发布时可以通过 AOT 生成高效的机器码以保证应用性能。而 JavaScript 则不具有这个能力；

2. 高性能：Flutter 旨在提供流畅、高保真的的 UI 体验。为了实现这一点，Flutter 中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而 Dart 支持 AOT，在这一点上可以做的比 JavaScript 更好；

3. 类型安全：由于 Dart 是类型安全的语言，且 2.12 版本后也支持了空安全特性，所以 Dart 支持静态类型检测，可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript 是一个弱类型语言，也因此前端社区出现了很多给 JavaScript 代码添加静态类型检测的扩展语言和工具，如：微软的 TypeScript 以及Facebook 的 Flow。相比之下，Dart 本身就支持静态类型，这是它的一个重要优势；

4. Dart 团队就在你身边：看似不起眼，实则举足轻重。由于有 Dart 团队的积极投入，Flutter 团队可以获得更多、更方便的支持，正如Flutter 官网所述“我们正与 Dart 社区进行密切合作，以改进 Dart 在 Flutter 中的使用。例如，当我们最初采用 Dart 时，该语言并没有提供生成原生二进制文件的工具链（这对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为 Dart 团队专门为 Flutter 构建了它。同样，Dart VM 之前已经针对吞吐量进行了优化，但团队现在正在优化 VM 的延迟时间，这对于 Flutter 的工作负载更为重要。”；

#### 3.5.4 Flutter框架结构

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666368912935-f0e6d930-1b67-41b6-9f18-f90a5ae8b805.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)

  

简单来讲，Flutter 从上到下可以分为三层：框架层、引擎层和嵌入层，下面我们分别介绍：

##### 3.5.4.1. 框架层 

Flutter Framework，即框架层。这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下：

- 底下两层（Foundation 和 Animation、Painting、Gestures）在 Google 的一些视频中被合并为一个dart UI层，对应的是Flutter中的dart:ui包，它是 Flutter Engine 暴露的底层UI库，提供动画、手势及绘制能力；

- Rendering 层，即渲染层，这一层是一个抽象的布局层，它依赖于 Dart UI 层，渲染层会构建一棵由可渲染对象的组成的渲染树，当动态更新这些对象时，渲染树会找出变化的部分，然后更新渲染。渲染层可以说是Flutter 框架层中最核心的部分，它除了确定每个渲染对象的位置、大小之外还要进行坐标变换、绘制（调用底层 dart:ui ）；

- Widgets 层是 Flutter 提供的的一套基础组件库，在基础组件库之上，Flutter 还提供了 Material 和 Cupertino 两种视觉风格的组件库，它们分别实现了 Material 和 iOS 设计规范；

我们进行Flutter 开发时，大多数时候都是和 Flutter Framework 打交道。

##### 3.5.4.2. 引擎层 

Engine，即引擎层。毫无疑问是 Flutter 的核心， 该层主要是 C++ 实现，其中包括了 Skia 引擎、Dart 运行时、文字排版引擎等。在代码调用 dart:ui库时，调用最终会走到引擎层，然后实现真正的绘制和显示；

##### 3.5.4.3. 嵌入层 

Embedder，即嵌入层。Flutter 最终渲染、交互是要依赖其所在平台的操作系统 API，嵌入层主要是将 Flutter 引擎 ”安装“ 到特定平台上。嵌入层采用了当前平台的语言编写，例如 Android 使用的是 Java 和 C++， iOS 和 macOS 使用的是 Objective-C 和 Objective-C++，Windows 和 Linux 使用的是 C++。 Flutter 代码可以通过嵌入层，以模块方式集成到现有的应用中，也可以作为应用的主体。Flutter 本身包含了各个常见平台的嵌入层，假如以后 Flutter 要支持新的平台，则需要针对该新的平台编写一个嵌入层。

## 4. 搭建Flutter开发环境 

建议参考[文档](https://www.flutterchina.club/)进行配置

最后执行flutter docotor 没有问题即可。

## 5. Dart简介 

Dart 在设计时应该是同时借鉴了 Java 和 JavaScript，同时又引入了一些现代编程语言的特性，如空安全，除此之外还有一些独创的语法，比如级联操作符。

Dart 在静态语法方面和 Java 非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和 JavaScript 很像，如函数式特性、异步支持等。除了融合 Java 和 JavaScript 语言之所长之外，Dart 也具有一些其他很有表现力的语法，如可选命名参数、..（级联运算符）和?.（条件成员访问运算符）以及??（判空赋值运算符）。其实，在 Dart 中其实看到的不仅有 Java 和 JavaScript 的影子，它还具有其他编程语言中的身影，如命名参数在 Objective-C 和 Swift 中早就很普遍，而??操作符在PHP 7.0 语法中就已经存在了，因此我们可以看到 Google 对 Dart 语言给予厚望，是想把 Dart 打造成一门集百家之所长的编程语言。

### 5.1.变量声明 

#### 5.1.1. var 

类似于 JavaScript 中的var，它可以接收任何类型的变量，但最大的不同是 Dart 中 var 变量一旦赋值，类型便会确定，则不能再改变其类型，如： 

```js
var t = "hi world";
// 下面代码在dart中会报错，因为变量t的类型已经确定为String，
// 类型一旦确定后则不能再更改其类型。
t = 1000;

```

上面的代码在 JavaScript 是没有问题的，前端开发者需要注意一下，之所以有此差异是因为 Dart 本身是一个强类型语言，任何变量都是有确定类型的，在 Dart 中，当用var声明一个变量后，Dart 在编译时会根据第一次赋值数据的类型来推断其类型，编译结束后其类型就已经被确定，而 JavaScript 是纯粹的弱类型脚本语言，var 只是变量的声明方式而已。

### 5.2. dynamic 和 Object

Object 是 Dart 所有对象的根基类，也就是说在 Dart 中所有类型都是Object的子类(包括Function和Null)，所以任何类型的数据都可以赋值给Object声明的对象。 dynamic与Object声明的变量都可以赋值任意对象，且后期可以改变赋值的类型，这和 var 是不同的，如：

```js
dynamic t;
Object x;
t = "hi world";
x = 'Hello Object';
//下面代码没有问题
t = 1000;
x = 1000;
```

dynamic与Object不同的是dynamic声明的对象编译器会提供所有可能的组合，而Object声明的对象只能使用 Object 的属性与方法, 否则编译器会报错，如:

```js
dynamic a;
 Object b = "";
 main() {
   a = "";
   printLengths();
 }   

 printLengths() {
   // 正常
	print(a.length);
   // 报错 The getter 'length' is not defined for the class 'Object'
   print(b.length);
 }
```

dynamic的这个特点使得我们在使用它时需要格外注意，这很容易引入一个运行时错误，比如下面代码在编译时不会报错，而在运行时会报错：

```js
print(a.xx); // a是字符串，没有"xx"属性，编译时不会报错，运行时会报错
```

#### 5.1.3. final和const

如果您从未打算更改一个变量，那么使用 final或 const，不是var，也不是一个类型。 一个 final 变量只能被设置一次，两者区别在于：const 变量是一个编译时常量（编译时直接替换为常量值），final变量在第一次使用时被初始化。被final或者const修饰的变量，变量类型可以省略，如：

```js
//可以省略String这个类型声明
final str = "hi world";
//final String str = "hi world"; 
const str1 = "hi world";
//const String str1 = "hi world";
```

#### 5.1.4. 空安全（null-safety）

Dart 中一切都是对象，这意味着如果我们定义一个数字，在初始化它之前如果我们使用了它，假如没有某种检查机制，则不会报错，比如：

```js
test() {
  int i; 
  print(i*8);
}
```

在 Dart 引入空安全之前，上面代码在执行前不会报错，但会触发一个运行时错误，原因是 i 的值为 null 。但现在有了空安全，则定义变量时我们可以指定变量是可空还是不可空。

```js
test() {
  int i; 
  print(i*8);
}

```

在 Dart 引入空安全之前，上面代码在执行前不会报错，但会触发一个运行时错误，原因是 i 的值为 null 。但现在有了空安全，则定义变量时我们可以指定变量是可空还是不可空。

```js
int i = 8; //默认为不可空，必须在定义时初始化。
int? j; // 定义为可空类型，对于可空变量，我们在使用前必须判空。

// 如果我们预期变量不能为空，但在定义时不能确定其初始值，则可以加上late关键字，
// 表示会稍后初始化，但是在正式使用它之前必须得保证初始化过了，否则会报错
late int k;
k=9;
```

如果一个变量我们定义为可空类型，在某些情况下即使我们给它赋值过了，但是预处理器仍然有可能识别不出，这时我们就要显式（通过在变量后面加一个”!“符号）告诉预处理器它已经不是null了，比如：

```dart
class Test{
  int? i;
  Function? fun;
  say(){
    if(i!=null) {
      print(i! * 8); //因为已经判过空，所以能走到这 i 必不为null，如果没有显式申明，则 IDE 会报错
    }
    if(fun!=null){
      fun!(); // 同上
    }
  }
}
```

上面中如果函数变量可空时，调用的时候可以用语法糖：

```dart
fun?.call() // fun 不为空时则会被调用
```

### 5.2 函数 

Dart是一种真正的面向对象的语言，所以即使是函数也是对象，并且有一个类型Function。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。

#### 5.2.1. 函数声明

```dart
bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
```

Dart函数声明如果没有显式声明返回值类型时会默认当做dynamic处理，注意，函数返回值没有类型推断：

```dart
typedef bool CALLBACK();

//不指定返回类型，此时默认为dynamic，不是bool
isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}

void test(CALLBACK cb){
   print(cb()); 
}
//报错，isNoble不是bool类型
test(isNoble);
```

对于只包含一个表达式的函数，可以使用简写语法：

```dart
bool isNoble (int atomicNumber)=> true ;  
```

**5.2.2. 函数作为变量**

```dart
var say = (str){
  print(str);
};
say("hi world");
```

#### 5.2.3. 函数作为参数传递 

```dart
void execute(var callback) {
    callback();
}
execute(() => print("xxx"))
```

##### 5.2.3.1. 可选的位置参数 

包装一组函数参数，用[]标记为可选的位置参数，并放在参数列表的最后面：

```dart
String say(String from, String msg, [String? device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}
```

下面是一个不带可选参数调用这个函数的例子：

```dart
say('Bob', 'Howdy'); //结果是： Bob says Howdy
```

下面是用第三个参数调用这个函数的例子：

```dart
say('Bob', 'Howdy', 'smoke signal'); //结果是：Bob says Howdy with a smoke signal
```

##### 5.2.3.2. 可选的命名参数 

定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：

```dart
//设置[bold]和[hidden]标志
void enableFlags({bool bold, bool hidden}) {
    // ... 
}
```

调用函数时，可以使用指定命名参数。例如：paramName: value

```dart
enableFlags(bold: true, hidden: false);
```

可选命名参数在Flutter中使用非常多。注意，不能同时使用可选的位置参数和可选的命名参数。

### 5.3mixin

Dart 是不支持多继承的，但是它支持 mixin，简单来讲 mixin 可以 “组合” 多个类，我们通过一个例子来理解。
定义一个 Person 类，实现吃饭、说话、走路和写代码功能，同时定义一个 Dog 类，实现吃饭、和走路功能：

```dart
class Person {
  say() {
    print('say');
  }
}

mixin Eat {
  eat() {
    print('eat');
  }
}

mixin Walk {
  walk() {
    print('walk');
  }
}

mixin Code {
  code() {
    print('key');
  }
}

class Dog with Eat, Walk{}
class Man extends Person with Eat, Walk, Code{}
```

我们定义了几个 mixin，然后通过 with 关键字将它们组合成不同的类。

### 5.4. 异步支持 

Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。

async和await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。

#### 5.4.1. future 

Future与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。

##### 5.4.1.1. Future.then 

为了方便示例，在本例中我们使用Future.delayed 创建了一个延时任务（实际场景会是一个真正的耗时任务，比如一次网络请求），即2秒后返回结果字符串"hi world!"，然后我们在then中接收异步结果并打印结果，代码如下：

```dart
Future.delayed(Duration(seconds: 2),(){
   return "hi world!";
}).then((data){
   print(data);
});
```

##### 5.4.1.2. Future.catchError

如果异步任务发生错误，我们可以在catchError中捕获错误，我们将上面示例改为：

```dart

Future.delayed(Duration(seconds: 2),(){
   //return "hi world!";
   throw AssertionError("Error");  
}).then((data){
   //执行成功会走到这里  
   print("success");
}).catchError((e){
   //执行失败会走到这里  
   print(e);
});
```

在本示例中，我们在异步任务中抛出了一个异常，then的回调函数将不会被执行，取而代之的是 catchError回调函数将被调用；但是，并不是只有 catchError回调才能捕获错误，then方法还有一个可选参数onError，我们也可以用它来捕获异常：

```dart
Future.delayed(Duration(seconds: 2), () {
	//return "hi world!";
	throw AssertionError("Error");
}).then((data) {
	print("success");
}, onError: (e) {
	print(e);
});
```

##### 5.4.1.3. Future.whenComplete

有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在then或catch中关闭一下对话框，第二种就是使用Future的whenComplete回调，我们将上面示例改一下：

```dart
Future.delayed(Duration(seconds: 2),(){
   //return "hi world!";
   throw AssertionError("Error");
}).then((data){
   //执行成功会走到这里 
   print(data);
}).catchError((e){
   //执行失败会走到这里   
   print(e);
}).whenComplete((){
   //无论成功或失败都会走到这里
});
```

##### 5.4.1.4. Future.wait

有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是Future.wait，它接受一个Future数组参数，只有数组中所有Future都执行成功后，才会触发then的成功回调，只要有一个Future执行失败，就会触发错误回调。下面，我们通过模拟Future.delayed 来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下：

```dart
Future.wait([
  // 2秒后返回结果  
  Future.delayed(Duration(seconds: 2), () {
    return "hello";
  }),
  // 4秒后返回结果  
  Future.delayed(Duration(seconds: 4), () {
    return " world";
  })
]).then((results){
  print(results[0]+results[1]);
}).catchError((e){
  print(e);
});
```

执行上面代码，4秒后你会在控制台中看到“hello world”。

#### 5.4.2. async/await 

Dart中的async/await 和JavaScript中的async/await功能是一样的：异步任务串行化。

##### 5.4.2.1. 回调地狱(Callback Hell) 

如果代码中有大量异步逻辑，并且出现大量异步任务依赖其他异步任务的结果时，必然会出现Future.then回调中套回调情况。举个例子，比如现在有个需求场景是用户先登录，登录成功后会获得用户ID，然后通过用户ID，再去请求用户个人信息，获取到用户个人信息后，为了使用方便，我们需要将其缓存在本地文件系统，代码如下：

```dart
//先分别定义各个异步任务
Future<String> login(String userName, String pwd){
	...
    //用户登录
};
Future<String> getUserInfo(String id){
	...
    //获取用户信息 
};
Future saveUserInfo(String userInfo){
	...
	// 保存用户信息 
}; 

```

接下来，执行整个任务流：

```dart

login("alice","******").then((id){
 //登录成功后通过，id获取用户信息    
 getUserInfo(id).then((userInfo){
    //获取用户信息后保存 
    saveUserInfo(userInfo).then((){
       //保存用户信息，接下来执行其他操作
        ...
    });
  });
})

```

可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为回调地狱（Callback Hell）。回调地狱问题在之前 JavaScript 中非常突出，也是 JavaScript 被吐槽最多的点，但随着 ECMAScript 标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是 ECMAScript6 引入了Promise，以及ECMAScript7 中引入的async/await。 而在 Dart 中几乎是完全平移了 JavaScript 中的这两者：Future相当于Promise，而async/await连名字都没改。接下来我们看看通过Future和async/await如何消除上面示例中的嵌套问题。

##### 5.4.2.2. 消除回调地狱 

消除回调地狱主要有两种方式：

1. 使用Future消除Callback Hell

   ```dart
   login("alice","******").then((id){
     	return getUserInfo(id);
   }).then((userInfo){
       return saveUserInfo(userInfo);
   }).then((e){
      //执行接下来的操作 
   }).catchError((e){
     //错误处理  
     print(e);
   });
   ```

正如上文所述， “Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用” ，如果在then 中返回的是一个Future的话，该future会执行，执行结束后会触发后面的then回调，这样依次向下，就避免了层层嵌套。

2. 使用 async/await 消除 callback hell

   通过Future回调中再返回Future的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用async/await了，下面我们先直接看代码，然后再解释，代码如下：

   ```dart
   task() async {
      try{
       String id = await login("alice","******");
       String userInfo = await getUserInfo(id);
       await saveUserInfo(userInfo);
       //执行接下来的操作   
      } catch(e){
       //错误处理   
       print(e);   
      }  
   }
   ```

   其实，无论是在 JavaScript 还是 Dart 中，async/await 都只是一个语法糖，编译器或解释器最终都会将其转化为一个 Promise（Future）的调用链。

### 5.5 Stream

Stream也是用于接收异步事件数据，和 Future不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：

```dart

Stream.fromFutures([
  // 1秒后返回结果
  Future.delayed(Duration(seconds: 1), () {
    return "hello 1";
  }),
  // 抛出一个异常
  Future.delayed(Duration(seconds: 2),(){
    throw AssertionError("Error");
  }),
  // 3秒后返回结果
  Future.delayed(Duration(seconds: 3), () {
    return "hello 3";
  })
]).listen((data){
   print(data);
}, onError: (e){
   print(e.message);
},onDone: (){

});

```

上面的代码依次会输出：

```dart
hello 1
Error
hello 3 
```

### 5.6. Dart和Java及JavaScript对比 

将 Dart 与 Java 和 JavaScript 对比，是因为这两者分别是强类型语言和弱类型语言的典型代表，并且 Dart 语法中很多地方也都借鉴了 Java 和 JavaScript。

#### 5.6.1. Dart vs Java 

客观的来讲，Dart 在语法层面确实比 Java 更有表现力；在 VM 层面，Dart VM 在内存回收和吞吐量都进行了反复的优化，但具体的性能对比，笔者没有找到相关测试数据，但在笔者看来，只要 Dart 语言能流行，VM 的性能就不用担心，毕竟 Google 在 Go（没用VM但有GC）、JavaScript（v8）、Dalvik（ Android 上的 Java VM ）上已经有了很多技术积淀。值得注意的是 Dart 在 Flutter 中已经可以将 GC 做到 10ms 以内，所以 Dart 和 Java 相比，决胜因素并不会是在性能方面。而在语法层面，Dart 要比 Java 更有表现力，最重要的是 Dart 对函数式编程支持要远强于 Java（目前只停留在 Lambda 表达式）

#### 5.6.2. Dart vs JavaScript 

JavaScript 的弱类型一直被抓短，所以 TypeScript 甚至是 Facebook 的 Flow 才有市场。但就脚本语言而言，JavaScript 无疑是动态化支持最好的脚本语言，比如在 JavaScript 中，可以给任何对象在任何时候动态扩展属性，对于精通 JavaScript 的高手来说，这无疑是一把利剑。但是，任何事物都有两面性，JavaScript 强大的动态化特性也是把双刃剑，你可经常听到另一个声音，认为 JavaScript 的这种动态性糟糕透了，太过灵活反而导致代码很难预期，无法限制不被期望的修改。毕竟有些人总是对自己或别人写的代码不放心，他们希望能够让代码变得可控，并期望有一套静态类型检查系统来帮助自己减少错误。正因如此，在 Flutter中，Dart 几乎放弃了脚本语言动态化的特性，如不支持反射、也不支持动态创建函数等。并且 Dart 从 2.0 开始强制开启了类型检查（Strong Mode），原先的检查模式（checked mode）和可选类型（optional type）将淡出，所以在类型安全这个层面来说，Dart 和 TypeScript、CoffeeScript 是差不多的，所以单从动态性来看，Dart 并不具备什么明显优势，但综合起来看, Dart 目前真正的不足是生态，但随着 Flutter 的逐渐火热，会回过头来反推 Dart 生态加速发展，对于 Dart 来说，现在需要的是时间。

# flutter实战

https://www.yuque.com/lpldplws/web/pg3uab?singleDoc# 《flutter实战》 密码：qug7

## 1. 课程目标 

- 运行一个基础的flutter，掌握flutter的基本内容；

## 2. 课程大纲 

- 创建第一个flutter；

- 后续学习路径；

## 3. 创建第一个flutter组件 

### 3.1. 基础demo介绍 

#### 3.1.1 创建Flutter应用模板 

通过 Android Studio 或 VS Code 创建一个新的 Flutter 工程，命名为 "first_flutter_app"。创建好后，就会得到一个默认的计数器应用示例。

注意，默认计数器示例可能随着编辑器 Flutter 插件的版本变化而变化，本例中会介绍计数器示例的全部代码，所以不会对本示例产生影响。

我们先运行创建的工程，效果如下图所示

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666459465812-e70efc22-d4d1-453b-9942-846dbf1360a6.png)





htt该计数器示例中，每点击一次右下角带“+”号的悬浮按钮，屏幕中央的数字就会加1。
在这个示例中，主要Dart代码是在 lib/main.dart 文件中，源码如下：

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  MyHomePage({Key? key, required this.title}) : super(key: key);
  final String title;

  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text('You have pushed the button this many times:'),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ), // This trailing comma makes auto-formatting nicer for build methods.
    );
  }
}
```

#### 3.1.2. 模板代码分析 

下面我们分析一下生成的代码：

##### 3.1.2.1. 导入包

```dart
import 'package:flutter/material.dart';
```

此行代码作用是导入了 Material UI 组件库。[Material](https://material.io/guidelines/)是一种标准的移动端和web端的视觉设计语言， Flutter 默认提供了一套丰富的 Material 风格的UI组件。

##### 3.1.2.2 应用入口

```dart
void main() => runApp(MyApp());
```

与 C/C++、Java 类似，Flutter 应用中 main 函数为应用程序的入口。main 函数中调用了runApp 方法，它的功能是启动Flutter应用。runApp它接受一个 Widget参数，在本示例中它是一个MyApp对象，MyApp()是 Flutter 应用的根组件。读者现在只需知道 runApp 是 Flutter 应用的入口即可，关于 Flutter 应用的启动流程，我们会在本书后面原理篇中做详细介绍。

- main函数使用了(=>)符号，这是 Dart 中单行函数或方法的简写。

##### 3.1.2.应用结构

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      //应用名称  
      title: 'Flutter Demo', 
      theme: ThemeData(
        //蓝色主题  
        primarySwatch: Colors.blue,
      ),
      //应用首页路由  
      home: MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}
```

MyApp类代表 Flutter 应用，它继承了 StatelessWidget类，这也就意味着应用本身也是一个widget；

●在 Flutter 中，大多数东西都是 widget（后同“组件”或“部件”），包括对齐（Align）、填充（Padding）、手势处理（GestureDetector）等，它们都是以 widget 的形式提供；

●Flutter 在构建页面时，会调用组件的build方法，widget 的主要工作是提供一个 build() 方法来描述如何构建 UI 界面（通常是通过组合、拼装其他基础 widget ）；

●MaterialApp 是Material 库中提供的 Flutter APP 框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。MaterialApp也是一个 widget；

●home 为 Flutter 应用的首页，它也是一个 widget；

#### 3.1.3. 首页

##### 3.1.3.1. 初识Widget

```dart

class MyHomePage extends StatefulWidget {
  MyHomePage({Key? key, required this.title}) : super(key: key);
  final String title;
  
  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
 ...
}

```

MyHomePage 是应用的首页，它继承自StatefulWidget类，表示它是一个有状态的组件（Stateful widget）。关于 Stateful widget 我们将在第三章 “Widget简介” 一节仔细介绍，现在我们只需简单认为有状态的组件（Stateful widget） 和无状态的组件（Stateless widget）有两点不同：

1. Stateful widget 可以拥有状态，这些状态在 widget 生命周期中是可以变的，而 Stateless widget 是不可变的；

2. Stateful widget 至少由两个类组成：_MyHomePageState类是MyHomePage类对应的状态类。看到这里，读者可能已经发现：和MyApp 类不同， MyHomePage类中并没有build方法，取而代之的是，build方法被挪到了_MyHomePageState方法中，至于为什么这么做，先留个疑问，在分析完完整代码后再来解答。

- 一个StatefulWidget类；

- 一个 State类； StatefulWidget类本身是不变的，但是State类中持有的状态在 widget 生命周期中可能会发生变化；

#### 3.1.4. state 

##### 3.1.4.1. MyHomePageState 类解析 

接下来，我们看看_MyHomePageState中都包含哪些东西：

- 组件的状态。由于我们只需要维护一个点击次数计数器，所以定义一个_counter状态：

```dart
int _counter = 0; //用于记录按钮点击的总次数
```

_counter 为保存屏幕右下角带“+”号按钮点击次数的状态。

- 设置状态的自增函数。

```dart

void _incrementCounter() {
  setState(() {
     _counter++;
  });
}
```

当按钮点击时，会调用此函数，该函数的作用是先自增_counter，然后调用setState 方法。setState方法的作用是通知 Flutter 框架，有状态发生了改变，Flutter 框架收到通知后，会执行 build 方法来根据新的状态重新构建界面， Flutter 对此方法做了优化，使重新执行变的很快，所以你可以重新构建任何需要更新的东西，而无需分别去修改各个 widget。

- 建UI界面的build方法
  构建UI界面的逻辑在 build 方法中，当MyHomePage第一次创建时，_MyHomePageState类会被创建，当初始化完成后，Flutter框架会调用 widget 的build方法来构建 widget 树，最终将 widget 树渲染到设备屏幕上。所以，我们看看_MyHomePageState的build方法中都干了什么事：

  ```dart
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text('You have pushed the button this many times:'),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ), 
    );
  }
  ```

- Scaffold 是 Material 库中提供的页面脚手架，它提供了默认的导航栏、标题和包含主屏幕 widget 树（后同“组件树”或“部件树”）的body属性，组件树可以很复杂。本书后面示例中，路由默认都是通过Scaffold创建；
- body的组件树中包含了一个Center 组件，Center 可以将其子组件树对齐到屏幕中心。此例中， Center 子组件是一个Column 组件，Column的作用是将其所有子组件沿屏幕垂直方向依次排列； 此例中Column子组件是两个 Text，第一个Text 显示固定文本 “You have pushed the button this many times:”，第二个Text 显示_counter状态的数值；_
- _floatingActionButton是页面右下角的带“+”的悬浮按钮，它的onPressed属性接受一个回调函数，代表它被点击后的处理器，本例中直接将_incrementCounter方法作为其处理函数；

现在，我们将整个计数器执行流程串起来：当右下角的floatingActionButton按钮被点击之后，会调用_incrementCounter方法。在_incrementCounter方法中，首先会自增_counter计数器（状态），然后setState会通知 Flutter 框架状态发生变化，接着，Flutter 框架会调用build方法以新的状态重新构建UI，最终显示在设备屏幕上。

#### 3.1.4.2. 为什么要将 build 方法放在 State 中，而不是放在StatefulWidget中？

现在，我们回答之前提出的问题，为什么build()方法放在State（而不是StatefulWidget）中 ？这主要是为了提高开发的灵活性。如果将build()方法放在StatefulWidget中则会有两个问题：

1. 状态访问不便。
   试想一下，如果我们的StatefulWidget有很多状态，而每次状态改变都要调用build方法，由于状态是保存在 State 中的，如果build方法在StatefulWidget中，那么build方法和状态分别在两个类中，那么构建时读取状态将会很不方便！试想一下，如果真的将build方法放在 StatefulWidget 中的话，由于构建用户界面过程需要依赖 State，所以build方法将必须加一个State参数，大概是下面这样：

```dart
 Widget build(BuildContext context, State state){
      //state.counter
      ...
  }
```

这样的话就只能将State的所有状态声明为公开的状态，这样才能在State类外部访问状态！但是，将状态设置为公开后，状态将不再具有私密性，这就会导致对状态的修改将会变的不可控。但如果将build()方法放在State中的话，构建过程不仅可以直接访问状态，而且也无需公开私有状态，这会非常方便。

2. 继承StatefulWidget不便。
   例如，Flutter 中有一个动画 widget 的基类AnimatedWidget，它继承自StatefulWidget类。AnimatedWidget中引入了一个抽象方法build(BuildContext context)，继承自AnimatedWidget的动画 widget 都要实现这个build方法。现在设想一下，如果StatefulWidget 类中已经有了一个build方法，正如上面所述，此时build方法需要接收一个 State 对象，这就意味着AnimatedWidget必须将自己的 State 对象(记为_animatedWidgetState)提供给其子类，因为子类需要在其build方法中调用父类的build方法，代码可能如下：

   ```dart
   class MyAnimationWidget extends AnimatedWidget{
       @override
       Widget build(BuildContext context, State state){
         //由于子类要用到AnimatedWidget的状态对象_animatedWidgetState，
         //所以AnimatedWidget必须通过某种方式将其状态对象_animatedWidgetState
         //暴露给其子类   
         super.build(context, _animatedWidgetState)
       }
   }
   ```

这样很显然是不合理的，因为

- AnimatedWidget的状态对象是AnimatedWidget内部实现细节，不应该暴露给外部。

- 如果要将父类状态暴露给子类，那么必须得有一种传递机制，而做这一套传递机制是无意义的，因为父子类之间状态的传递和子类本身逻辑是无关的。

综上所述，可以发现，对于StatefulWidget，将build方法放在 State 中，可以给开发带来很大的灵活性。

### 3.2. widget介绍 

#### 3.2.1. widget概念 

我们知道在Flutter中几乎所有的对象都是一个 widget 。与原生开发中“控件”不同的是，Flutter 中的 widget 的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector 、用于APP主题数据传递的 Theme 等等，而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时可能会用到“控件”、“组件”这样的概念，读者心里需要知道他们就是 widget ，只是在不同场景的不同表述而已。由于 Flutter 主要就是用于构建用户界面的，所以，在大多数时候，读者可以认为 widget 就是一个控件，不必纠结于概念。

Flutter 中是通过 Widget 嵌套 Widget 的方式来构建UI和进行实践处理的，所以记住，Flutter 中万物皆为Widget。

#### 3.2.2. widget接口

在 Flutter 中， widget 的功能是“描述一个UI元素的配置信息”，它就是说， Widget 其实并不是表示最终绘制在设备屏幕上的显示元素，所谓的配置信息就是 Widget 接收的参数，比如对于 Text 来讲，文本的内容、对齐方式、文本样式都是它的配置信息。下面我们先来看一下 Widget 类的声明：

```dart
@immutable // 不可变的
abstract class Widget extends DiagnosticableTree {
  const Widget({ this.key });

  final Key? key;

  @protected
  @factory
  Element createElement();

  @override
  String toStringShort() {
    final String type = objectRuntimeType(this, 'Widget');
    return key == null ? type : '$type-$key';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;
  }

  @override
  @nonVirtual
  bool operator ==(Object other) => super == other;

  @override
  @nonVirtual
  int get hashCode => super.hashCode;

  static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        && oldWidget.key == newWidget.key;
  }
  ...
}
```

- @immutable 代表 Widget 是不可变的，这会限制 Widget 中定义的属性（即配置信息）必须是不可变的（final），为什么不允许 Widget 中定义的属性变化呢？这是因为，Flutter 中如果属性发生变化则会重新构建Widget树，即重新创建新的 Widget 实例来替换旧的 Widget 实例，所以允许 Widget 的属性变化是没有意义的，因为一旦 Widget 自己的属性变了自己就会被替换。这也是为什么 Widget 中定义的属性必须是 final 的原因；

- widget类继承自DiagnosticableTree，DiagnosticableTree即“诊断树”，主要作用是提供调试信息；

- Key: 这个key属性类似于 React/Vue 中的key，主要的作用是决定是否在下一次build时复用旧的 widget ，决定的条件在canUpdate()方法中；

- createElement()：正如前文所述“一个 widget 可以对应多个Element”；Flutter 框架在构建UI树时，会先调用此方法生成对应节点的Element对象。此方法是 Flutter 框架隐式调用的，在我们开发过程中基本不会调用到；

- debugFillProperties(...) 复写父类的方法，主要是设置诊断树的一些特性；

- canUpdate(...)是一个静态方法，它主要用于在 widget 树重新build时复用旧的 widget ，其实具体来说，应该是：是否用新的 widget 对象去更新旧UI树上所对应的Element对象的配置；通过其源码我们可以看到，只要newWidget与oldWidget的runtimeType和key同时相等时就会用new widget去更新Element对象的配置，否则就会创建新的Element；

有关 Key 和 widget 复用的细节将会在本书后面高级部分深入讨论，读者现在只需知道，为 widget 显式添加 key 的话可能（但不一定）会使UI在重新构建时变的高效，读者目前可以先忽略此参数，本书后面在用到时会详细解释 。

另外Widget类本身是一个抽象类，其中最核心的就是定义了createElement()接口，在 Flutter 开发中，我们一般都不用直接继承Widget类来实现一个新组件，相反，我们通常会通过继承StatelessWidget或StatefulWidget来间接继承widget类来实现。

#### 3.2.3. flutter中的四棵树 

既然 Widget 只是描述一个UI元素的配置信息，那么真正的布局、绘制是由谁来完成的呢？Flutter 框架的的处理流程是这样的：

1. 根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 Element 类。

2. 根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自RenderObject 类。

3. 根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 Layer 类。

真正的布局和渲染逻辑在 Render 树中，Element 是 Widget 和 RenderObject 的粘合剂，可以理解为一个中间代理。我们通过一个例子来说明，假设有如下 Widget 树：

```dart
Container( // 一个容器 widget
  color: Colors.blue, // 设置容器背景色
  child: Row( // 可以将子widget沿水平方向排列
    children: [
      Image.network('https://www.example.com/1.png'), // 显示图片的 widget
      const Text('A'),
    ],
  ),
);
```

如果 Container 设置了背景色，Container 内部会创建一个新的 ColoredBox 来填充背景，相关逻辑如下：

```dart
if (color != null)
  current = ColoredBox(color: color!, child: current);
```

而 Image 内部会通过 RawImage 来渲染图片、Text 内部会通过 RichText 来渲染文本，所以最终的 Widget树、Element 树、渲染树结构如下图所示：

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666460113463-d13125b0-5e40-4260-b885-d7b8832347e4.png?x-oss-process=image%2Fresize%2Cw_971%2Climit_0)

#### 3.2.4. StatelessWidget

##### 3.2.4.1. 简介 

StatelessWidget相对比较简单，它继承自widget类，重写了createElement()方法：

```dart
@override
StatelessElement createElement() => StatelessElement(this);
```

StatelessElement 间接继承自Element类，与StatelessWidget相对应（作为其配置数据）。
StatelessWidget用于不需要维护状态的场景，它通常在build方法中通过嵌套其他 widget 来构建UI，在构建过程中会递归的构建其嵌套的 widget 。我们看一个简单的例子：

```dart
class Echo extends StatelessWidget  {
  const Echo({
    Key? key,  
    required this.text,
    this.backgroundColor = Colors.grey, //默认为灰色
  }):super(key:key);
    
  final String text;
  final Color backgroundColor;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        color: backgroundColor,
        child: Text(text),
      ),
    );
  }
}
```

上面的代码，实现了一个回显字符串的Echo widget 。
按照惯例，widget 的构造函数参数应使用命名参数，命名参数中的必需要传的参数要添加required关键字，这样有利于静态代码分析器进行检查；在继承 widget 时，第一个参数通常应该是Key。另外，如果 widget 需要接收子 widget ，那么child或children参数通常应被放在参数列表的最后。同样是按照惯例， widget 的属性应尽可能的被声明为final，防止被意外改变。
然后我们可以通过如下方式使用它：

```dart
Widget build(BuildContext context) {
  return Echo(text: "hello world");
}
```

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666460166505-51e9c56f-1cf7-4945-a789-68b7e0a25ed2.png)

##### 3.2.4.2 Context

build方法有一个context参数，它是BuildContext类的一个实例，表示当前 widget 在 widget 树中的上下文，每一个 widget 都会对应一个 context 对象（因为每一个 widget 都是 widget 树上的一个节点）。实际上，context是当前 widget 在 widget 树中位置中执行”相关操作“的一个句柄(handle)，比如它提供了从当前 widget 开始向上遍历 widget 树以及按照 widget 类型查找父级 widget 的方法。下面是在子树中获取父级 widget 的一个示例：

```dart
class ContextRoute extends StatelessWidget  {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Context测试"),
      ),
      body: Container(
        child: Builder(builder: (context) {
          // 在 widget 树中向上查找最近的父级`Scaffold`  widget 
          Scaffold scaffold = context.findAncestorWidgetOfExactType<Scaffold>();
          // 直接返回 AppBar的title， 此处实际上是Text("Context测试")
          return (scaffold.appBar as AppBar).title;
        }),
      ),
    );
  }
}
```

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666460166503-07834a58-6382-470e-a1d3-d4f47a469b95.png)

注意：对于BuildContext读者现在可以先作了解，随着本书后面内容的展开，也会用到 Context 的一些方法，读者可以通过具体的场景对其有个直观的认识。关于BuildContext更多的内容，我们也将在后面高级部分再深入介绍。

#### 3.2.5 StatefulWidget 

和StatelessWidget一样，StatefulWidget也是继承自widget类，并重写了createElement()方法，不同的是返回的Element 对象并不相同；另外StatefulWidget类中添加了一个新的接口createState()。

下面我们看看StatefulWidget的类定义：

```dart
abstract class StatefulWidget extends Widget {
  const StatefulWidget({ Key key }) : super(key: key);
    
  @override
  StatefulElement createElement() => StatefulElement(this);
    
  @protected
  State createState();
}
```

- StatefulElement 间接继承自Element类，与StatefulWidget相对应（作为其配置数据）。StatefulElement中可能会多次调用createState()来创建状态（State）对象。

- createState() 用于创建和 StatefulWidget 相关的状态，它在StatefulWidget 的生命周期中可能会被多次调用。例如，当一个 StatefulWidget 同时插入到 widget 树的多个位置时，Flutter 框架就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个StatefulElement对应一个State实例。而在StatefulWidget 中，State 对象和StatefulElement具有一一对应的关系，所以在Flutter的SDK文档中，可以经常看到“从树中移除 State 对象”或“插入 State 对象到树中”这样的描述，此时的树指通过 widget 树生成的 Element 树。Flutter 的 SDK 文档中经常会提到“树” ，我们可以根据语境来判断到底指的是哪棵树。其实，无论是哪棵树，最终的目标都是为了描述 UI 的结构和绘制信息，所以在 Flutter 中遇到“树”的概念时，若无特别说明，我们都可以理解为 “一棵构成用户界面的节点树”，读者不必纠结于这些概念，还是那句话“得其神，忘其形”

##### 3.2.5.1. State生命周期

理解State的生命周期对flutter开发非常重要，为了加深读者印象，本节我们通过一个实例来演示一下 State 的生命周期。在接下来的示例中，我们仍然以计数器功能为例，实现一个计数器 CounterWidget 组件 ，点击它可以使计数器加1，由于要保存计数器的数值状态，所以我们应继承StatefulWidget，代码如下：

```dart
class CounterWidget extends StatefulWidget {
  const CounterWidget({Key? key, this.initValue = 0});

  final int initValue;

  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

```

CounterWidget接收一个initValue整型参数，它表示计数器的初始值。下面我们看一下State的代码：

```dart
class _CounterWidgetState extends State<CounterWidget> {
  int _counter = 0;

  @override
  void initState() {
    super.initState();
    //初始化状态
    _counter = widget.initValue;
    print("initState");
  }

  @override
  Widget build(BuildContext context) {
    print("build");
    return Scaffold(
      body: Center(
        child: TextButton(
          child: Text('$_counter'),
          //点击后计数器自增
          onPressed: () => setState(
            () => ++_counter,
          ),
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(CounterWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    print("didUpdateWidget ");
  }

  @override
  void deactivate() {
    super.deactivate();
    print("deactivate");
  }

  @override
  void dispose() {
    super.dispose();
    print("dispose");
  }

  @override
  void reassemble() {
    super.reassemble();
    print("reassemble");
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print("didChangeDependencies");
  }
}

```

接下来，我们创建一个新路由，在新路由中，我们只显示一个CounterWidget：

```dart
class StateLifecycleTest extends StatelessWidget {
  const StateLifecycleTest({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return CounterWidget();
  }
}
```

我们运行应用并打开该路由页面，在新路由页打开后，屏幕中央就会出现一个数字0，然后控制台日志输出：

```dart
initState
didChangeDependencies
build
```

可以看到，在StatefulWidget插入到 widget 树时首先initState方法会被调用。
然后我们点击热重载，控制台输出日志如下:

```dart
reassemble
didUpdateWidget 
build
```

可以看到此时initState 和didChangeDependencies都没有被调用，而此时didUpdateWidget被调用。
接下来，我们在 widget 树中移除CounterWidget，将 StateLifecycleTest 的 build方法改为：

```dart
 Widget build(BuildContext context) {
  //移除计数器 
  //return CounterWidget ();
  //随便返回一个Text()
  return Text("xxx");
}
```

然后热重载，日志如下：

```dart
reassemble
deactive
dispose
```

我们可以看到，在CounterWidget从 widget 树中移除时，deactive和dispose会依次被调用。
下面我们来看看各个回调函数：

- initState：当 widget 第一次插入到 widget 树时会被调用，对于每一个State对象，Flutter 框架只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用BuildContext.dependOnInheritedWidgetOfExactType（该方法用于在 widget 树上获取离当前 widget 最近的一个父级InheritedWidget，关于InheritedWidget我们将在后面章节介绍），原因是在初始化完成后， widget 树中的InheritFrom widget也可能会发生变化，所以正确的做法应该在在build（）方法或didChangeDependencies()中调用它;
- didChangeDependencies()：当State对象的依赖发生变化时会被调用；例如：在之前build() 中包含了一个InheritedWidget （第七章介绍），然后在之后的build() 中Inherited widget发生了变化，那么此时InheritedWidget的子 widget 的didChangeDependencies()回调都会被调用。典型的场景是当系统语言 Locale 或应用主题改变时，Flutter 框架会通知 widget 调用此回调。需要注意，组件第一次被创建后挂载的时候（包括重创建）对应的didChangeDependencies也会被调用；
- build()：此回调读者现在应该已经相当熟悉了，它主要是用于构建 widget 子树的，会在如下场景被调用：
  a. 在调用initState()之后；
  b. 在调用didUpdateWidget()之后；
  c. 在调用setState()之后；
  d. 在调用didChangeDependencies()之后；
  e. 在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其他位置之后；

- reassemble()：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用；
- didUpdateWidget ()：在 widget 重新构建时，Flutter 框架会调用widget.canUpdate来检测 widget 树中同一位置的新旧节点，然后决定是否需要更新，如果widget.canUpdate返回true则会调用此回调。正如之前所述，widget.canUpdate会在新旧 widget 的 key 和 runtimeType 同时相等时会返回true，也就是说在在新旧 widget 的key和runtimeType同时相等时didUpdateWidget()就会被调用；
- deactivate()：当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter 框架会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法；
- dispose()：当 State 对象从树中被永久移除时调用；通常在此回调中释放资源；
  StatefulWidget 生命周期如图所示：

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666460339376-4c686467-7d9f-457c-bf2c-6d1d73e328b6.png)

注意：在继承StatefulWidget重写其方法时，对于包含@mustCallSuper标注的父类方法，都要在子类方法中调用父类方法。

#### 3.2.6. 在 widget 树中获取State对象 

由于 StatefulWidget 的的具体逻辑都在其 State 中，所以很多时候，我们需要获取 StatefulWidget 对应的State 对象来调用一些方法，比如Scaffold组件对应的状态类ScaffoldState中就定义了打开 SnackBar（路由页底部提示条）的方法。我们有两种方法在子 widget 树中获取父级 StatefulWidget 的State 对象。

##### 3.2.6.1. 通过Context获取 

context对象有一个findAncestorStateOfType()方法，该方法可以从当前节点沿着 widget 树向上查找指定类型的 StatefulWidget 对应的 State 对象。下面是实现打开 SnackBar 的示例：

```dart
class GetStateObjectRoute extends StatefulWidget {
  const GetStateObjectRoute({Key? key}) : super(key: key);

  @override
  State<GetStateObjectRoute> createState() => _GetStateObjectRouteState();
}

class _GetStateObjectRouteState extends State<GetStateObjectRoute> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("子树中获取State对象"),
      ),
      body: Center(
        child: Column(
          children: [
            Builder(builder: (context) {
              return ElevatedButton(
                onPressed: () {
                  // 查找父级最近的Scaffold对应的ScaffoldState对象
                  ScaffoldState _state = context.findAncestorStateOfType<ScaffoldState>()!;
                  // 打开抽屉菜单
                  _state.openDrawer();
                },
                child: Text('打开抽屉菜单1'),
              );
            }),
          ],
        ),
      ),
      drawer: Drawer(),
    );
  }
}
```

一般来说，如果 StatefulWidget 的状态是私有的（不应该向外部暴露），那么我们代码中就不应该去直接获取其 State 对象；如果StatefulWidget的状态是希望暴露出的（通常还有一些组件的操作方法），我们则可以去直接获取其State对象。但是通过 context.findAncestorStateOfType 获取 StatefulWidget 的状态的方法是通用的，我们并不能在语法层面指定 StatefulWidget 的状态是否私有，所以在 Flutter 开发中便有了一个默认的约定：如果 StatefulWidget 的状态是希望暴露出的，应当在 StatefulWidget 中提供一个of 静态方法来获取其 State 对象，开发者便可直接通过该方法来获取；如果 State不希望暴露，则不提供of方法。这个约定在 Flutter SDK 里随处可见。所以，上面示例中的Scaffold也提供了一个of方法，我们其实是可以直接调用它的：

```dart

Builder(builder: (context) {
  return ElevatedButton(
    onPressed: () {
      // 直接通过of静态方法来获取ScaffoldState
      ScaffoldState _state=Scaffold.of(context);
      // 打开抽屉菜单
      _state.openDrawer();
    },
    child: Text('打开抽屉菜单2'),
  );
}),
```

又比如我们想显示 snack bar 的话可以通过下面代码调用：

```dart
Builder(builder: (context) {
  return ElevatedButton(
    onPressed: () {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("我是SnackBar")),
      );
    },
    child: Text('显示SnackBar'),
  );
}),
```

上面示例运行后，点击”显示SnackBar“，效果如图所示：

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666460339385-81a6d46f-a569-4fb2-9824-3b37bbfa88f8.png)

### 3.3. 状态管理

#### 3.3.1. 介绍 

响应式的编程框架中都会有一个永恒的主题——“状态(State)管理”，无论是在 React/Vue（两者都是支持响应式编程的 Web 开发框架）还是 Flutter 中，他们讨论的问题和解决的思想都是一致的。所以，如果你对React/Vue的状态管理有了解，可以跳过本节。言归正传，我们想一个问题，StatefulWidget的状态应该被谁管理？Widget本身？父 Widget ？都会？还是另一个对象？答案是取决于实际情况！以下是管理状态的最常见的方法：

- Widget 管理自己的状态；

- Widget 管理子 Widget 状态；

- 混合管理（父 Widget 和子 Widget 都管理状态）；

如何决定使用哪种管理方法？下面是官方给出的一些原则可以帮助你做决定：

- 如果状态是用户数据，如复选框的选中状态、滑块的位置，则该状态最好由父 Widget 管理；

- 如果状态是有关界面外观效果的，例如颜色、动画，那么状态最好由 Widget 本身来管理；

- 如果某一个状态是不同 Widget 共享的则最好由它们共同的父 Widget 管理；

在 Widget 内部管理状态封装性会好一些，而在父 Widget 中管理会比较灵活。有些时候，如果不确定到底该怎么管理状态，那么推荐的首选是在父 Widget 中管理（灵活会显得更重要一些）。

接下来，我们将通过创建三个简单示例TapboxA、TapboxB和TapboxC来说明管理状态的不同方式。 这些例子功能是相似的 ——创建一个盒子，当点击它时，盒子背景会在绿色与灰色之间切换。状态 _active确定颜色：绿色为true ，灰色为false

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666460741511-93aa7710-ab34-4c28-aceb-1b0d68c9314f.png)

#### 3.3.2. Widget管理自身状态

_TapboxAState 类:

- 管理TapboxA的状态。
- 定义_active：确定盒子的当前颜色的布尔值。
- 定义_handleTap()函数，该函数在点击该盒子时更新_active，并调用setState()更新UI。
- 实现widget的所有交互式行为。

```dart
// TapboxA 管理自身状态.

//------------------------- TapboxA ----------------------------------

class TapboxA extends StatefulWidget {
  TapboxA({Key? key}) : super(key: key);

  @override
  _TapboxAState createState() => _TapboxAState();
}

class _TapboxAState extends State<TapboxA> {
  bool _active = false;

  void _handleTap() {
    setState(() {
      _active = !_active;
    });
  }

  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _handleTap,
      child: Container(
        child: Center(
          child: Text(
            _active ? 'Active' : 'Inactive',
            style: TextStyle(fontSize: 32.0, color: Colors.white),
          ),
        ),
        width: 200.0,
        height: 200.0,
        decoration: BoxDecoration(
          color: _active ? Colors.lightGreen[700] : Colors.grey[600],
        ),
      ),
    );
  }
}
```

#### 3.3.3. 父Widget管理子Widget的状态

对于父Widget来说，管理状态并告诉其子Widget何时更新通常是比较好的方式。 例如，IconButton是一个图标按钮，但它是一个无状态的Widget，因为我们认为父Widget需要知道该按钮是否被点击来采取相应的处理。
在以下示例中，TapboxB通过回调将其状态导出到其父组件，状态由父组件管理，因此它的父组件为StatefulWidget。但是由于TapboxB不管理任何状态，所以TapboxB为StatelessWidget。
ParentWidgetState 类:

- 为TapboxB 管理_active状态。_
- _实现_handleTapboxChanged()，当盒子被点击时调用的方法。
- 当状态改变时，调用setState()更新UI。
  TapboxB 类:
- 继承StatelessWidget类，因为所有状态都由其父组件处理。
- 当检测到点击时，它会通知父组件。

```dart
// ParentWidget 为 TapboxB 管理状态.

//------------------------ ParentWidget --------------------------------

class ParentWidget extends StatefulWidget {
  @override
  _ParentWidgetState createState() => _ParentWidgetState();
}

class _ParentWidgetState extends State<ParentWidget> {
  bool _active = false;

  void _handleTapboxChanged(bool newValue) {
    setState(() {
      _active = newValue;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      child: TapboxB(
        active: _active,
        onChanged: _handleTapboxChanged,
      ),
    );
  }
}

//------------------------- TapboxB ----------------------------------

class TapboxB extends StatelessWidget {
  TapboxB({Key? key, this.active: false, required this.onChanged})
      : super(key: key);

  final bool active;
  final ValueChanged<bool> onChanged;

  void _handleTap() {
    onChanged(!active);
  }

  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _handleTap,
      child: Container(
        child: Center(
          child: Text(
            active ? 'Active' : 'Inactive',
            style: TextStyle(fontSize: 32.0, color: Colors.white),
          ),
        ),
        width: 200.0,
        height: 200.0,
        decoration: BoxDecoration(
          color: active ? Colors.lightGreen[700] : Colors.grey[600],
        ),
      ),
    );
  }
}
```

#### 3.3.4. 混合状态管理

对于一些组件来说，混合管理的方式会非常有用。在这种情况下，组件自身管理一些内部状态，而父组件管理一些其他外部状态。
在下面 TapboxC 示例中，手指按下时，盒子的周围会出现一个深绿色的边框，抬起时，边框消失。点击完成后，盒子的颜色改变。 TapboxC 将其_active状态导出到其父组件中，但在内部管理其_highlight状态。这个例子有两个状态对象_ParentWidgetState和_TapboxCState。
_ParentWidgetStateC类:

- 管理_active 状态。_
- 实现 _handleTapboxChanged() ，当盒子被点击时调用。
- 当点击盒子并且_active状态改变时调用setState()更新UI。

_TapboxCState 对象:

- 管理_highlight 状态。_
- GestureDetector监听所有tap事件。当用户点下时，它添加高亮（深绿色边框）；当用户释放时，会移除高亮。
- _当按下、抬起、或者取消点击时更新_highlight状态，调用setState()更新UI。
- 当点击时，将状态的改变传递给父组件。

```dart
//---------------------------- ParentWidget ----------------------------

class ParentWidgetC extends StatefulWidget {
  @override
  _ParentWidgetCState createState() => _ParentWidgetCState();
}

class _ParentWidgetCState extends State<ParentWidgetC> {
  bool _active = false;

  void _handleTapboxChanged(bool newValue) {
    setState(() {
      _active = newValue;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      child: TapboxC(
        active: _active,
        onChanged: _handleTapboxChanged,
      ),
    );
  }
}

//----------------------------- TapboxC ------------------------------

class TapboxC extends StatefulWidget {
  TapboxC({Key? key, this.active: false, required this.onChanged})
      : super(key: key);

  final bool active;
  final ValueChanged<bool> onChanged;
  
  @override
  _TapboxCState createState() => _TapboxCState();
}

class _TapboxCState extends State<TapboxC> {
  bool _highlight = false;

  void _handleTapDown(TapDownDetails details) {
    setState(() {
      _highlight = true;
    });
  }

  void _handleTapUp(TapUpDetails details) {
    setState(() {
      _highlight = false;
    });
  }

  void _handleTapCancel() {
    setState(() {
      _highlight = false;
    });
  }

  void _handleTap() {
    widget.onChanged(!widget.active);
  }

  @override
  Widget build(BuildContext context) {
    // 在按下时添加绿色边框，当抬起时，取消高亮  
    return GestureDetector(
      onTapDown: _handleTapDown, // 处理按下事件
      onTapUp: _handleTapUp, // 处理抬起事件
      onTap: _handleTap,
      onTapCancel: _handleTapCancel,
      child: Container(
        child: Center(
          child: Text(
            widget.active ? 'Active' : 'Inactive',
            style: TextStyle(fontSize: 32.0, color: Colors.white),
          ),
        ),
        width: 200.0,
        height: 200.0,
        decoration: BoxDecoration(
          color: widget.active ? Colors.lightGreen[700] : Colors.grey[600],
          border: _highlight
              ? Border.all(
                  color: Colors.teal[700],
                  width: 10.0,
                )
              : null,
        ),
      ),
    );
  }
}
```

#### 3.3.5. 全局状态管理 

当应用中需要一些跨组件（包括跨路由）的状态需要同步时，上面介绍的方法便很难胜任了。比如，我们有一个设置页，里面可以设置应用的语言，我们为了让设置实时生效，我们期望在语言状态发生改变时，App中依赖应用语言的组件能够重新 build 一下，但这些依赖应用语言的组件和设置页并不在一起，所以这种情况用上面的方法很难管理。这时，正确的做法是通过一个全局状态管理器来处理这种相距较远的组件之间的通信。目前主要有两种办法：

1. 实现一个全局的事件总线，将语言状态改变对应为一个事件，然后在APP中依赖应用语言的组件的initState 方法中订阅语言改变的事件。当用户在设置页切换语言后，我们发布语言改变事件，而订阅了此事件的组件就会收到通知，收到通知后调用setState(...)方法重新build一下自身即可。

2. 使用一些专门用于状态管理的包，如 Provider、Redux，可以在 pub 上查看其详细信息。

### 3.4. 路由管理 

路由（Route）在移动开发中通常指页面（Page），这跟 Web 开发中单页应用的 Route 概念意义是相同的，Route 在 Android中 通常指一个 Activity，在 iOS 中指一个 ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。Flutter 中的路由管理和原生开发类似，无论是 Android 还是 iOS，导航管理都会维护一个路由栈，路由入栈（push）操作对应打开一个新页面，路由出栈（pop）操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。

#### 3.4.1. 简单示例 

1. 创建一个新路由，命名“NewRoute”

   ```dart
   class NewRoute extends StatelessWidget {
     @override
     Widget build(BuildContext context) {
       return Scaffold(
         appBar: AppBar(
           title: Text("New route"),
         ),
         body: Center(
           child: Text("This is new route"),
         ),
       );
     }
   }
   ```

新路由继承自StatelessWidget，界面很简单，在页面中间显示一句"This is new route"。

2. 在_MyHomePageState.build方法中的Column的子widget中添加一个按钮（TextButton） 

   ```dart
   Column(
     mainAxisAlignment: MainAxisAlignment.center,
     children: <Widget>[
       ... //省略无关代码
       TextButton(
         child: Text("open new route"),
         onPressed: () {
           //导航到新路由   
           Navigator.push( 
             context,
             MaterialPageRoute(builder: (context) {
               return NewRoute();
             }),
           );
         },
       ),
     ],
    )
   ```

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666461078876-28b354b6-31c6-467e-a1c4-2b013afbf2cd.png)





#### 3.4.2. MaterialPageRoute

MaterialPageRoute继承自PageRoute类，PageRoute类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。MaterialPageRoute 是 Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画：

- 对于 Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。
- 对于 iOS，当打开页面时，新的页面会从屏幕右侧边缘一直滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧而消失；当关闭页面时，正好相反，当前页面会从屏幕右侧滑出，同时上一个页面会从屏幕左侧滑入。
  下面我们介绍一下MaterialPageRoute 构造函数的各个参数的意义：

```dart
 MaterialPageRoute({
  WidgetBuilder builder,
  RouteSettings settings,
  bool maintainState = true,
  bool fullscreenDialog = false,
})
```

builder 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例；

- settings 包含路由的配置信息，如路由名称、是否初始路由（首页）；

- maintainState：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为 false；

- fullscreenDialog表示新的路由页面是否是一个全屏的模态对话框，在 iOS 中，如果fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）；

#### 3.4.3. navigator 

Navigator是一个路由管理的组件，它提供了打开和退出路由页方法。Navigator通过一个栈来管理活动路由集合。通常当前屏幕显示的页面就是栈顶的路由。Navigator提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法：

1. Future push(BuildContext context, Route route)

将给定的路由入栈（即打开新的页面），返回值是一个Future对象，用以接收新路由出栈（即关闭）时的返回数据。

2. bool pop(BuildContext context, [ result ])

将栈顶路由出栈，result 为页面关闭时返回给上一个页面的数据。

Navigator 还有很多其他方法，如Navigator.replace、Navigator.popUntil等，详情请参考API文档或SDK 源码注释，在此不再赘述。下面我们还需要介绍一下路由相关的另一个概念“命名路由”。

3. 实例方法

Navigator类中第一个参数为context的静态方法都对应一个Navigator的实例方法， 比如Navigator.push(BuildContext context, Route route)等价于Navigator.of(context).push(Route route) ，下面命名路由相关的方法也是一样的。

#### 3.4.4. 路由传值

很多时候，在路由跳转时我们需要带一些参数，比如打开商品详情页时，我们需要带一个商品id，这样商品详情页才知道展示哪个商品信息；又比如我们在填写订单时需要选择收货地址，打开地址选择页并选择地址后，可以将用户选择的地址返回到订单页等等。下面我们通过一个简单的示例来演示新旧路由如何传参。
下面我们通过一个例子来演示：创建一个TipRoute路由，它接受一个提示文本参数，负责将传入它的文本显示在页面上，另外TipRoute中我们添加一个“返回”按钮，点击后在返回上一个路由的同时会带上一个返回参数，下面我们看一下实现代码

```dart
lass TipRoute extends StatelessWidget {
  TipRoute({
    Key key,
    required this.text,  // 接收一个text参数
  }) : super(key: key);
  final String text;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("提示"),
      ),
      body: Padding(
        padding: EdgeInsets.all(18),
        child: Center(
          child: Column(
            children: <Widget>[
              Text(text),
              ElevatedButton(
                onPressed: () => Navigator.pop(context, "我是返回值"),
                child: Text("返回"),
              )
            ],
          ),
        ),
      ),
    );
  }
}
```

下面是打开新路由TipRoute的代码：

```dart
class RouterTestRoute extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: ElevatedButton(
        onPressed: () async {
          // 打开`TipRoute`，并等待返回结果
          var result = await Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) {
                return TipRoute(
                  // 路由参数
                  text: "我是提示xxxx",
                );
              },
            ),
          );
          //输出`TipRoute`路由返回结果
          print("路由返回值: $result");
        },
        child: Text("打开提示页"),
      ),
    );
  }
}

```

运行上面代码，点击RouterTestRoute页的“打开提示页”按钮，会打开TipRoute页，运行效果如图2-11所示下：

![](https://cdn.nlark.com/yuque/0/2022/png/2340337/1666461293681-ca29f327-135a-4f34-9cb0-0ea71a103b2d.png)

需要说明：

1. 提示文案“我是提示xxxx”是通过TipRoute的text参数传递给新路由页的。我们可以通过等待Navigator.push(…)返回的Future来获取新路由的返回数据。

2. 在TipRoute页中有两种方式可以返回到上一页；第一种方式是直接点击导航栏返回箭头，第二种方式是点击页面中的“返回”按钮。这两种返回方式的区别是前者不会返回数据给上一个路由，而后者会。下面是分别点击页面中的返回按钮和导航栏返回箭头后，RouterTestRoute页中print方法在控制台输出的内容：

   ```dart
   路由返回值: 我是返回值
   路由返回值: null
   ```

#### 3.4.5. 命名路由 

##### 3.4.5.1. 路由表 

要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名字与哪个路由组件相对应。其实注册路由表就是给路由起名字，路由表的定义如下：

```dart
Map<String, WidgetBuilder> routes;
```

它是一个Map，key为路由的名字，是个字符串；value是个builder回调函数，用于生成相应的路由widget。我们在通过路由名字打开新路由时，应用会根据路由名字在路由表中查找到对应的WidgetBuilder回调函数，然后调用该回调函数生成路由widget并返回。

##### 3.4.5.2. 注册路由表 

路由表的注册方式很简单，我们回到之前“计数器”的示例，然后在MyApp类的build方法中找到MaterialApp，添加routes属性，代码如下：

```dart
MaterialApp(
  title: 'Flutter Demo',
  theme: ThemeData(
    primarySwatch: Colors.blue,
  ),
  //注册路由表
  routes:{
   "new_page":(context) => NewRoute(),
    ... // 省略其他路由注册信息
  } ,
  home: MyHomePage(title: 'Flutter Demo Home Page'),
);

```

现在我们就完成了路由表的注册。上面的代码中home路由并没有使用命名路由，如果我们也想将home注册为命名路由应该怎么做呢？其实很简单，直接看代码：

```dart
MaterialApp(
  title: 'Flutter Demo',
  initialRoute:"/", //名为"/"的路由作为应用的home(首页)
  theme: ThemeData(
    primarySwatch: Colors.blue,
  ),
  //注册路由表
  routes:{
   "new_page":(context) => NewRoute(),
   "/":(context) => MyHomePage(title: 'Flutter Demo Home Page'), //注册首页路由
  } 
);

```

我们只需在路由表中注册一下MyHomePage路由，然后将其名字作为MaterialApp的initialRoute属性值即可，该属性决定应用的初始路由页是哪一个命名路由。

##### 3.4.5.3. 通过路由名打开新路由页 

要通过路由名称来打开新路由，可以使用Navigator 的pushNamed方法：

```dart
Future pushNamed(BuildContext context, String routeName,{Object arguments})
```

Navigator 除了pushNamed方法，还有pushReplacementNamed等其他管理命名路由的方法，读者可以自行查看API文档。接下来我们通过路由名来打开新的路由页，修改TextButton的onPressed回调代码，改为：

```dart
onPressed: () {
  Navigator.pushNamed(context, "new_page");
  //Navigator.push(context,
  //  MaterialPageRoute(builder: (context) {
  //  return NewRoute();
  //}));  
},
```

热重载应用，再次点击“open new route”按钮，依然可以打开新的路由页

##### 3.4.5.4. 命名路由参数传递 

在Flutter最初的版本中，命名路由是不能传递参数的，后来才支持了参数；下面展示命名路由如何传递并获取路由参数：

我们先注册一个路由：

```dart
routes:{
 "new_page":(context) => EchoRoute(),
} ,
```

在路由页通过RouteSetting对象获取路由参数：

```dart
class EchoRoute extends StatelessWidget {

  @override
  Widget build(BuildContext context) {
    //获取路由参数  
    var args=ModalRoute.of(context).settings.arguments;
    //...省略无关代码
  }
}
```

在打开路由时传递参数

```dart
Navigator.of(context).pushNamed("new_page", arguments: "hi");
```

#### 3.4.6. 路由生成钩子

假设我们要开发一个电商App，当用户没有登录时可以看店铺、商品等信息，但交易记录、购物车、用户个人信息等页面需要登录后才能看。为了实现上述功能，我们需要在打开每一个路由页前判断用户登录状态！如果每次打开路由前我们都需要去判断一下将会非常麻烦，那有什么更好的办法吗？答案是有！
MaterialApp有一个onGenerateRoute属性，它在打开命名路由时可能会被调用，之所以说可能，是因为当调用Navigator.pushNamed(...)打开命名路由时，如果指定的路由名在路由表中已注册，则会调用路由表中的builder函数来生成路由组件；如果路由表中没有注册，才会调用onGenerateRoute来生成路由。onGenerateRoute回调签名如下：

```dart
Route<dynamic> Function(RouteSettings settings)
```

有了onGenerateRoute回调，要实现上面控制页面权限的功能就非常容易：我们放弃使用路由表，取而代之的是提供一个onGenerateRoute回调，然后在该回调中进行统一的权限控制，如：

```dart

MaterialApp(
  ... //省略无关代码
  onGenerateRoute:(RouteSettings settings){
	  return MaterialPageRoute(builder: (context){
		   String routeName = settings.name;
       // 如果访问的路由页需要登录，但当前未登录，则直接返回登录页路由，
       // 引导用户登录；其他情况则正常打开路由。
     }
   );
  }
);
```

## 4. 后续学习路径

●[《Flutter实战·第二版》](https://book.flutterchina.club/)
● [awesome-flutter](https://github.com/Solido/awesome-flutter)
● [flutter demo](https://github.com/CarGuo/gsy_github_app_flutter)

# **Electron入门和实战(上)**

https://www.yuque.com/tingxiaoting/fr28z2/vszo27?#《Electron入门和实战(上)》 密码：vt8b

## 一、课程目标

- 传统桌面端应用
- electron 介绍
- electron 核心技术
- electron 开发体验
- electron 入门内容介绍

- - 快速创建应用
  - electron 通信
  - 小 demo

## 二、课程内容

### 2.1  传统桌面端应用

桌面应用程序，又称为 GUI 程序（Graphical User Interface），我们电脑上使用的各种客户端程序都属于桌面应用程序。

传统的桌面应用开发方式，一般是下面两种。

1）原生开发：

直接将语言编译成可执行文件，直接调用系统API，完成UI绘制等。这类开发技术，有着较高的运行效率，但一般来说，开发速度较慢，技术要求较高，例如：

a. windows: 使用C++ / MFC开发Windows应用/QT； 

b. macos: 使用Objective-C、swift开发MAC应用。 

2）托管平台： 

一开始就有本地开发和UI开发。一次编译后，得到中间文件，通过平台或虚机完成二次加载编译或解释运行。运行效率低于原生编译，但平台优化后，其效率也是比较可观的。就开发速度方面，比原生编译技术要快一些。例如：

a. 使用C# / .NET Framework(只能开发Windows应用)； b. Java / Swing。不过，上面两种对前端开发人员太不友好了，基本是前端人员不会涉及的领域，但是在这个"大前端"的时代，前端开发者正在想方设法涉足各个领域，使用WEB技术开发客户端的方式横空出世——这就是本文正在介绍的“Electron”技术。  

```js
js 前端/后端/手机 app/GUI 程序

nw.js electron
```

### 2.2 Eelctron介绍

[Electron](https://links.jianshu.com/go?to=https%3A%2F%2Felectronjs.org%2F)是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将[Chromium](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.chromium.org%2FHome)和[Node.js](https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2F)合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。通过Node它提供了通常浏览器所不能提供的能力。 

Electron于2013年作为构建Github上可编程的文本编辑器[Atom](https://links.jianshu.com/go?to=https%3A%2F%2Fatom.io%2F)的框架而被开发出来（PS：据说这个Atom看起来很漂亮，但很难用...）。这两个项目在2014春季开源。

### 2.3 都有谁在用 Electron？

- vscode
- postman
- yuque
- atom
- 等

### 2.4 什么时候使用 electron

#### 特定领域软件

- 财务软件
- 开发者工具
- 打印场景
- 同时开发 web+桌面应用

### 2.5 Electron核心技术

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1666714397698-e80e33df-330c-49f3-84ae-0c577f8104a7.png?x-oss-process=image%2Fresize%2Cw_990%2Climit_0)

- **Chromium**: Chromium是 Google 为发展 Chrome 浏览器而启动的开源项目，Chromium 相当于 Chrome 的工程版或称实验版，新功能会率先在 Chromium 上实现，待验证后才会应用在Chrome 上，故 Chrome 的功能会相对落后但较稳定。**Chromium为Electron提供强大的UI能力**，可以在不考虑兼容性的情况下开发界面。
- **Node.js**: 是一个让 JavaScript 运行在服务端的开发平台，Node 使用事件驱动，非阻塞I/O 模型而得以轻量和高效。**单单靠Chromium是不能具备直接操作原生GUI能力的，Electron内集成了Nodejs，这让其在开发界面的同时也有了操作系统底层 API 的能力**，Nodejs 中常用的 Path、fs、Crypto 等模块在 Electron 可以直接使用。

- **Native API:** 为 **Electron** 提供原生系统的 **GUI** 支持，借此 **Electron** 可以调用原生应用程序接口。

总结起来，**Chromium** 负责页面 **UI** 渲染，**Node.js** 负责业务逻辑，**Native API** 则提供原生能力和跨平台。

### 2.6 Electron的开发体验

#### 优势

**兼容性：**虽然你还在用WEB技术进行开发，但是你不用再考虑兼容性问题了，你只需要关心你当前使用Electron的版本对应Chrome的版本，一般情况下它已经足够新来让你使用最新的API和语法了，你还可以手动升级Chrome版本。同样的，你也不用考虑不同浏览器带的样式和代码兼容问题。

**NodeJS环境：**这可能是很多前端开发者曾经梦想过的功能，在WEB界面中使用Node.js提供的强大API，这意味着你在WEB页面直接可以操作文件，调用系统API，甚至操作[数据库](https://cloud.tencent.com/solution/database?from=10680)。当然，除了完整的 Node API，你还可以使用额外的百万个npm模块。

**跨域：**你可以直接使用Node提供的request模块进行网络请求，这意味着你无需再被跨域所困扰。

强大的扩展性：借助node-ffi，为应用程序提供强大的扩展性

#### 劣势

**应用体积过大：**由于内部包装了Chromium和Node.js，使得打包体积（使用electron-builder）在mac上至少是45M+起步，在windows上稍微好一点，不过也要35M+起步。不过相比早期打包体积100M+起步来说，已经好了不少。不过解压后安装依然是100M+起步。

**支持度：**受限于Node.js和Native APIs的一些支持度的问题，它依然有所局限。一些功能依然无法实现。比如无法获取在系统文件夹里选中的文件，而必须调用web的File或者node的fs接口才可以访问系统文件。

**性能：**应用性能依旧是个问题。所以做轻量级应用没问题，重量级应用尤其是CPU密集型应用的话很是问题。

### 2.7 基本原理

#### Chromium 架构


JavaScript 是单线程语言，但浏览器是多线程的，Chromium 作为 Chrome 的实验版，自然也是基于多线程工作机制。 

![img](https://cdn.nlark.com/yuque/0/2022/png/739887/1667032451540-254e2645-c497-41cf-91b1-990c4211d4eb.png)



Chromium 的**多进程模式**主要由三部分组成: 浏览器端(Browser)、渲染器端(Render)、浏览器与渲染器的通信方式(IPC)

- **浏览器进程**

浏览器进程 Browser 只有一个，当 Chrome 打开时，进程启动。 浏览器为每个渲染进程维护对应的 RenderProcessHost，负责浏览器与渲染器的交互。RenderViewHost 则是与 RenderView 对象进行交互，渲染网页的内容。浏览器与渲染器通过 IPC 进行通信。

- **渲染进程管理**

每个渲染进程都有一个全局 RenderProcess 对象，可以管理其与父浏览器进程之间的通信，并维护其全局状态。

页面在**RenderView**中基于Webkit排版展示出来的。

**ResourceDispatcher**，处理资源请求，当我们页面需要请求资源时， 通过ResourceDispatcher创建一个请求ID，转发到IPC，在Browser进程处理返回。

- **view 管理**

每个渲染器可以维护多个 RenderView 对象，当新开标签页或弹出窗口后，渲染进程就会创建一个 RenderView，RenderView 对象与它在浏览器进程中对应的 RenderViewHost 和 Webkit 嵌入层通信，渲染出网页网页内容(这里是我们日常主要关注的地方)。

- **IPC 通信**

RenderViewHost 和 RenderProcess 专门处理IPC通信

#### Electron 架构解析

**Electron** 架构参考了 **Chromium** 的多进程架构模式，即将主进程和渲染进程隔离，并且在 **Chromium** 多进程架构基础上做一定扩展。

由于Electron使用了Chromium来展示web页面，所以Chromium的多进程架构也会被使用到Electron中，在Electron中也分为主进程和渲染进程，但是跟Chromium不一样的有两点：

1. 在各个进程中暴漏了Native Api
2. 引入了Node.js

![img](https://cdn.nlark.com/yuque/0/2022/png/739887/1667041973895-51ed7d40-1cdc-4049-9274-2b450700c7e1.png)

Electron 的主从进程模型是基本的常识。每个 Electron 应用有且只要一个主进程(Main Process)、以及一个或多个渲染进程(Renderer Process), 对应多个 Web 页面。除此之外还有 GPU 进程、扩展进程等等。可以通过 [Electron Application Architecture](https://link.juejin.cn?target=https%3A%2F%2Felectronjs.org%2Fdocs%2Ftutorial%2Fapplication-architecture%23main-and-renderer-processes) 了解 Electron 的基本架构。

**主进程负责创建页面窗口、协调进程间通信、事件分发，****主进程在 Node.js 环境中运行**。为了安全考虑，原生 GUI 相关的 API 是无法在渲染进程直接访问的，它们必须通过 IPC 调用主进程。这种主从进程模型缺点也非常明显，即主进程单点故障。主进程崩溃或者阻塞，会影响整个应用的响应。比如主进程跑长时间的 CPU 任务，将阻塞渲染进程的用户交互事件。

对我们的应用来说，目前有以下进程, 以及它们的职责:

**① 主进程**

- 进程间通信、窗口管理
- 全局通用服务。
- 一些只能或适合在主进程做的事情。例如浏览器下载、全局快捷键处理、托盘、session。
- 维护一些必要的全局状态
- 上面说的通用混合层也跑在这个进程。通过 Node C++ 插件暴露接口。

**② 渲染进程**

负责 Web 页面的渲染, 具体页面的业务处理，运行在**浏览器环境中**，也意味着**渲染器无权直接访问 require 或其他 Node.js API**。

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1666715955882-61613581-5847-476f-8820-39d91ed2dc15.png?x-oss-process=image%2Fresize%2Cw_719%2Climit_0)



## 三、Electron具体内容介绍

### 3.1 生命周期

![img](https://cdn.nlark.com/yuque/0/2022/png/739887/1667043802034-21215927-09e6-444d-9a8e-fb66ba4c38e1.png)

这里把这些事件分成三部分，App 事件、BrowserWindow 事件以及 Renderer 进程中的 Web 事件。

### 3.2 快速入门

**安装Electron**

```js
npm install --save-dev electron
```

#### 添加script脚本

```js
"main": "main.js",
"start": "nodemon --exec electron ."
```

#### 添加nodemon.json文件

```js
{
  "watch": ["main.js", "renderer.js"],
  "options": {
    	"extensions": ["js"]
  	}
	}
}
```

#### 热更新

```js
npm install --save-dev electron-reloader
```

```js
// 热加载
try {
  require('electron-reloader')(module,{});
} catch (_) {}
```

#### **创建页面 index.html**

````js
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'">
    <title>Hello World!</title>
  </head>
  <body>
    <h1>Hello World!</h1>
    We are using Node.js <span id="node-version"></span>,
    Chromium <span id="chrome-version"></span>,
    and Electron <span id="electron-version"></span>.
  </body>
</html>
````

#### 在窗口中打开页面

需要 两个Electron模块：

- [app](https://www.electronjs.org/zh/docs/latest/api/app) 模块，它控制应用程序的事件生命周期。

- [BrowserWindow](https://www.electronjs.org/zh/docs/latest/api/browser-window) 模块，它创建和管理应用程序 窗口。

```js

//  main.js
const { app, BrowserWindow } = require('electron')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 800,
    height: 600,
     webPreferences: {
    // 在Electron5.0版本后，渲染进程默认是不能调用Node.js的API的，经过设置后才可以
    	nodeIntegration: true,  //设置为true就可以在这个渲染进程中调用Node.js
      contextIsolation: false,
      preload: path.join(__dirname, 'preload.js'),
  	}
  })

  win.loadFile('index.html')
}

// 只有在 app 模块的 ready 事件被激发后才能创建浏览器窗口
app.whenReady().then(() => {
	createWindow();
	app.on('activate', function () {
    // macos应用被重新激活
    // On macOS it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

// 窗口都关闭了 windows默认会退出应用 mac不会
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});
```

### 3.3 preload

Electron 的主进程是一个拥有着完全操作系统访问权限的 Node.js 环境。 除了 [Electron 模组](https://www.electronjs.org/zh/docs/latest/api/app) 之外，你也可以使用 [Node.js 内置模块](https://nodejs.org/dist/latest/docs/api/) 和所有通过 npm 安装的软件包。 另一方面，出于安全原因，渲染进程默认跑在网页页面上，而并非 Node.js里。

为了将 Electron 的不同类型的进程桥接在一起，我们需要使用被称为 **预加载** 的特殊脚本，**预加载脚本在渲染器进程加载之前加载**，并有权访问**两个渲染器全局** (例如 window 和 document) 和 Node.js 环境。

在**非上下文隔离环境下**，预加载脚本与浏览器共享同一个全局 [Window](https://developer.mozilla.org/en-US/docs/Web/API/Window) 接口，并且可以访问 Node.js API，所以它通过在全局 window 中暴露任意 API 来增强渲染器，以便你的网页内容使用。

创建一个名为 preload.js 的新脚本如下：

```js
window.addEventListener('DOMContentLoaded', () => {
  const replaceText = (selector, text) => {
    const element = document.getElementById(selector)
    if (element) element.innerText = text
  }

  for (const dependency of ['chrome', 'node', 'electron']) {
    replaceText(`${dependency}-version`, process.versions[dependency])
  }
})
```

需要在创建窗口的地方引入preload.js脚本

```js
// include the Node.js 'path' module at the top of your file
const path = require('path')

// modify your existing createWindow() function
const createWindow = () => {
  const win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js')
    }
  })

  win.loadFile('index.html')
}
// ...
```

#### 上下文隔离contextIsolation

上下文隔离功能将确保您的 预加载脚本 和 Electron的内部逻辑 运行在所加载的 [webcontent](https://www.electronjs.org/zh/docs/latest/api/web-contents)网页 之外的另一个独立的上下文环境里。 **这对安全性很重要**，因为**它有助于阻止网站访问 Electron 的内部组件 和 您的预加载脚本可访问的高等级权限的API** 。

这意味着，实际上，您的预加载脚本访问的 window 对象**并不是**网站所能访问的对象。 例如，如果您在预加载脚本中设置 window.hello = 'wave' 并且启用了上下文隔离，当网站尝试访问window.hello对象时将返回 undefined。

自 Electron 12 以来，默认情况下已启用上下文隔离，并且它是 *所有应用程序***推荐的安全设置**。预加载脚本默认 沙盒化 ，**不再拥有完整 Node.js 环境的访问权**。 实际上，这意味着你只拥有一个 polyfilled 的 require 函数，这个函数只能访问一组有限的 API。

| **可用的 API**        | **详细信息**                                                 |
| --------------------- | ------------------------------------------------------------ |
| Electron 模块         | 渲染进程模块                                                 |
| Node.js 模块          | [events](https://nodejs.org/api/events.html)、[timers](https://nodejs.org/api/timers.html)、[url](https://nodejs.org/api/url.html) |
| Polyfilled 的全局模块 | [Buffer](https://nodejs.org/api/buffer.html)、[process](https://www.electronjs.org/zh/docs/latest/api/process)、[clearImmediate](https://nodejs.org/api/timers.html#timers_clearimmediate_immediate)、[setImmediate](https://nodejs.org/api/timers.html#timers_setimmediate_callback_args) |

#### 通过contextBridge桥接api

预加载脚本像 Chrome 扩展的 [内容脚本](https://developer.chrome.com/docs/extensions/mv3/content_scripts/)（Content Script）一样，**会在渲染器的网页加载之前注入**。 如果你想向渲染器加入需要特殊权限的功能，你可以通过 [contextBridge](https://www.electronjs.org/zh/docs/latest/api/context-bridge) 接口定义 [全局对象](https://developer.mozilla.org/en-US/docs/Glossary/Global_object)。

```js
/*
*  @electron-toolkit/preload
 * 预加载脚本会在渲染器的网页加载之前注入。
 * 如果你想向渲染器加入需要特殊权限的功能，你可以通过 contextBridge 接口定义 全局对象。
 */
const { contextBridge } = require('electron');
// import { electronAPI } from '@electron-toolkit/preload';

window.addEventListener('DOMContentLoaded', () => {
  const replaceText = (selector, text) => {
    const element = document.getElementById(selector);
    element && (element.innerText = text);
  };
  for (const dependency of ['chrome', 'node', 'electron']) {
    replaceText(`${dependency}-version`, process.versions[dependency]);
  }
});

// window.electron = electronAPI;

if (process.contextIsolated) {
  contextBridge.exposeInMainWorld('versions', {
    node: () => process.versions.node,
    chrome: () => process.versions.chrome,
    electron: () => process.versions.electron,
  });
}

```

```js
/*
*  @electron-toolkit/preload
 * 预加载脚本会在渲染器的网页加载之前注入。
 * 如果你想向渲染器加入需要特殊权限的功能，你可以通过 contextBridge 接口定义 全局对象。
 */
const { contextBridge } = require('electron');
import { electronAPI } from '@electron-toolkit/preload'

// Custom APIs for renderer
const api = {}

// Use `contextBridge` APIs to expose Electron APIs to
// renderer only if context isolation is enabled, otherwise
// just add to the DOM global.
if (process.contextIsolated) {
  try {
    contextBridge.exposeInMainWorld('electron', electronAPI)
    contextBridge.exposeInMainWorld('api', api)
  } catch (error) {
    console.error(error)
  }
} else {
  // @ts-ignore (define in dts)
  window.electron = electronAPI
  // @ts-ignore (define in dts)
  window.api = api
}
```

### 3.4 进程间通信

Electron 的主进程和渲染进程有着清楚的分工并且不可互换。 这代表着无论是从渲染进程直接访问 Node.js 接口，亦或者是从主进程访问 HTML 文档对象模型 (DOM)，都是不可能的。

解决这一问题的方法是使用进程间通信 (IPC)。可以使用 Electron 的 ipcMain 模块和 ipcRenderer 模块来进行进程间通信。

#### 3.4.1 主进程主动向渲染进程发送消息

```js
// 主进程（main.js）

//主进程向渲染进程发送消息，'did-finish-load':当导航完成时发出事件，onload 事件也完成
// 导航完成时触发
win.webContents.on('did-finish-load', () => {
  win.webContents.send('msg', '消息来自主进程')
})
```

渲染进程(index.html)

```js
// renderer.js
const {ipcRenderer} = require('electron')
ipcRenderer.on('msg', (event, message) => {
    console.log(message) // 消息来自主进程
})
```

#### 3.4.2 渲染进程主动向主进程发送消息

```js
// 渲染进程(index.html)

const {ipcRenderer} = require('electron')
ipcRenderer.send('indexMsg','消息来自渲染进程')
```

```js
// 主进程（main.js）
const {ipcMain} = require('electron')
ipcMain.on('indexMsg',(event,msg) => {
    console.log(msg) //消息来自渲染进程
})
```

#### **3.4.3 渲染进程向主进程发送消息并异步等待结果**

```js
// renderer.js
const { ipcRenderer } = require('electron');
// 渲染进程向主进程发送消息并异步等待结果
async function notification() {
  let res = await ipcRenderer.invoke('work-notification');
  console.log(res);
}
notification();


// main.js
const { app, BrowserWindow, ipcMain, Notification } = require('electron');

 ipcMain.handle('work-notification', async () => {
    return await new Promise((resolve, reject) => {
      let notification = new Notification({
        title: '任务结束',
        body: '是否开始休息',
        actions: [{ text: '开始休息', type: 'button' }],
        closeButtonText: '继续工作',
      });
      notification.show();
      notification.on('action', () => resolve('rest'));
      notification.on('close', () => resolve('work'));
    });
});
```

#### 3.4.4 渲染进程之间如何通信？ 

没有直接的方法可以使用 ipcMain 和 ipcRenderer 模块在 Electron 中的渲染器进程之间发送消息。

- 将主进程作为渲染器之间的消息代理。 这需要将消息从一个渲染器发送到主进程，然后主进程将消息转发到另一个渲染器。

- 从主进程将一个 [MessagePort](https://www.electronjs.org/zh/docs/latest/tutorial/message-ports) 传递到两个渲染器。 这将允许在初始设置后渲染器之间直接进行通信。

利用主进程做消息中转站 

```js
//主进程
ipcMain.on('msg1', (event, message) => {
  yourWindow.webContents.send('msg2', message);
}

//渲染进程1
ipcRenderer.send('msg1', '来自渲染进程1的消息')

//渲染进程2
ipcRenderer.on('msg2', (event, message) => {
    console.log(message)  //来自渲染进程1的消息
  }
)
```

**消息通信总结**

```js
ipcRenderer.invoke：渲染进程发送消息给主进程，这是一个promise，可以在其resolve中获取ipcMain.handle的返回值
ipcMain.handle：接收invoke发送的信息，可以return值给ipcRenderer.invoke

ipcRenderer.send：渲染进程发送消息给主进程
ipcMain.on：接收send的信息

ipcRenderer.on：接收主进程的消息
webContents.send：主进程发送消息给渲染进程

ipcRenderer.sendTo：可以通过webContentsId直接发送信息到对应的渲染进程窗口
```

### 3.5 调试您的Electron应用

```js
// main.js 开启开发者工具面板
win.webContents.openDevTools();
```

使用VSCode调试

添加文件 .vscode/launch.json，内容为

````js
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Main Process",
      "type": "node",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      // 使用什么命令启动
      "runtimeExecutable": "${workspaceFolder}/node_modules/.bin/electron", 
      "windows": {
        "runtimeExecutable": "${workspaceFolder}/node_modules/.bin/electron.cmd"
      },
        // 启动时的参数
      "args" : ["."]
    }
  ]
}
````

- request，必填项，有两种类型，分别是 launch 和 attach，前者的意思就是 VSCode 会打开这个程序然后进入调试，后者的意思是你已经打开了程序，然后接通 Node.js 的内部调试协议进行调试，如果你看过上面的“Node.js 的调试原理”一文，应该可以大致理解；

### 3.6 倒计时demo

安装

```js
npm install timer.js -D
```

```js
// renderer.js
const Timer = require('timer.js');
const { ipcRenderer } = require('electron');

ipcRenderer.on('msg', (event, message) => {
  alert(message);
});

ipcRenderer.send('msg-from-render', '消息来自渲染进程');

function StartWork() {
  let workTimer = new Timer({
    ontick: (ms) => {
      updateTimer(ms);
    },
    onend: () => {
      notification();
    },
  });
  workTimer.start(10);
}
function updateTimer(ms) {
  let timerCointainer = document.getElementById('timer-container');
  let s = (ms / 1000).toFixed(0);
  let ss = s % 60;
  let mm = (s / 60).toFixed(0);

  timerCointainer.innerText = `${mm
    .toString()
    .padStart(2, 0)}:${ss.toString().padStart(2, 0)}`;
}
async function notification() {
  const ret = await ipcRenderer.invoke('work-notification');
  console.log(ret);
  if (ret === 'rest') {
    setTimeout(() => {
      alert('休息');
    });
  } else if (ret === 'work') {
    StartWork();
  }
}

StartWork();
```

```js
const { app, BrowserWindow, ipcMain, Notification } = require('electron');

// main.js
function handleIPC() {
 ipcMain.handle('work-notification', async () => {
  return await new Promise((resolve, reject) => {
    let notification = new Notification({
      title: '任务结束',
      body: '是否开始休息',
      actions: [{ text: '开始休息', type: 'button' }],
      closeButtonText: '继续工作',
    });
    notification.show();
    notification.on('action', () => resolve('rest'));
    notification.on('close', () => resolve('work'));
  });
});
}
```

### 3.7 打包应用程序

**打包工具**

- electronforge https://www.electronforge.io/
- electron-builder 功能更多
- electron-packager

#### 使用electronforge

1. 将 Electron Forge 添加到您应用的开发依赖中，并使用其"import"命令设置 Forge 的脚手架：

```js
npm install --save-dev @electron-forge/cli
npx electron-forge import
```

2. 使用 Forge 的 make 命令来创建可分发的应用程序：

```js
npm run make
```

Electron-forge 会创建 out 文件夹，您的软件包将在那里找到：

![](https://cdn.nlark.com/yuque/0/2023/png/739887/1682997344726-74b5ec91-0394-4a8f-9d40-d0d5e60d61ce.png)

**使用electron-builder 

安装

```js
npm i electron-builder -D
```

package.json中添加打包配置

```js
 "build": {
    "productName": "my_ele_demo",
    "appId": "com.example.app",
    "directories": {
      "output": "./dist"
    }
  }
```

添加打包脚本

```js
"release": "electron-builder --mac --arm64" 
```

执行打包操作

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1666801307655-10ed887d-d2ec-499f-997f-d4a6058dfbd9.png)

# Electron入门和实战(下)

https://www.yuque.com/tingxiaoting/fr28z2/cie26y17r14fpkb3?singleDoc# 《Electron入门和实战(下)》 密码：wmgw

## 基于webRTC+Electron实现远程控制 

WebRTC（Web Real-Time Communications）是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。

**应用场景**

- 直播

- 游戏

- 视频会议/在线教育

- 屏幕共享、远程控制

 **目标**： 

能够远程控制用户电脑，提供点击和键入功能

 **⻆⾊** 

控制端：客服人员/研发人员

傀儡端：用户

**流程**

1.  傀儡端告知控制端本机控制码 
2.  控制端输入控制码连接傀儡端 
3.  傀儡端将捕获的画面传至控制端 
4.  控制端的鼠标和键盘指令传送至傀儡端 
5.  傀儡端响应控制指令 

**汇总：**

**服务端**

建立端与控制码的联系

通过控制码找到用户

**客户端**

捕获画面、播放画面

捕获指令

响应指令

![img](https://cdn.nlark.com/yuque/0/2023/png/739887/1673170150664-f7292163-d917-481a-bf87-eccb9611e2f7.png)

## 技术点

1. 怎么捕获画面

   a. electron desktopCapturer 

   b. https://www.electronjs.org/zh/docs/latest/api/desktop-capturer

1. 怎么完成用户间连接、画面+指令传输？

   a. webRTC web real-time communication

   b.

   <img src="https://cdn.nlark.com/yuque/0/2023/png/739887/1673170277659-006b44f2-7fc5-4a44-bcde-43e440bb3bb1.png" style="zoom:50%;" />

1. c. RTCPeerConnection 接口代表一个由本地计算机到远端的 WebRTC 连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。

2. d. 一个基本的 RTCPeerConnection 使用需要协调本地机器以及远端机器的连接，它可以通过在两台机器间生成 Session Description 的数据交换协议来实现。呼叫方发送一个 offer(请求)，被呼叫方发出一个 answer（应答）来回答请求。双方 - 呼叫方以及被呼叫方，最开始的时候都要建立他们各自的

3. e. https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection

3. 怎么响应指令

1. a. robotjs

## 工程搭建

```js
npm create @quick-start/electron
```

## 工程介绍

```js
 const mainWindow = new BrowserWindow({
    width: 900,
    height: 670,
    show: false, // 先隐藏
    autoHideMenuBar: true,
    ...(process.platform === 'linux' ? { icon } : {}),
    webPreferences: {
      preload: join(__dirname, '../preload/index.js'),
      sandbox: false
    }
  })

// 在加载页面时，渲染进程第一次完成绘制时，
// 如果窗口还没有被显示，渲染进程会发出 ready-to-show 事件 。 
// 在此事件后显示窗口将没有视觉闪烁：
  mainWindow.on('ready-to-show', () => {
    mainWindow.show()
  })

// .eslintrc.cjs
'@typescript-eslint/explicit-function-return-type': 'off',
```

## renderer页面开发

![img](https://cdn.nlark.com/yuque/0/2023/png/739887/1677294568668-1e5069f2-0663-4e33-817e-06d784b4dbb6.png)



```js
// renderer/src/App.tsx

import { useState, useEffect } from 'react'
import Versions from './components/Versions'

function App(): JSX.Element {
  const { ipcRenderer } = window.electron
  const [remoteCode, setRemoteCode] = useState('')
  const [localCode, setLocalCode] = useState('')
  const [controlText, setControlText] = useState('')

  // 登录状态在主进程维护
  const login = async () => {
    const code = await ipcRenderer.invoke('login')
    setLocalCode(code)
  }

  useEffect(() => {
    login()
    // 监听ipc事件 监听状态变化
    ipcRenderer.on('control-state-change', handleControlState)

    return () => {
      // 事件卸载
      ipcRenderer.removeListener('control-state-change', handleControlState)
    }
  }, [])

  const startControl = () => {
    // 发起请求 控制控制码对应的用户
    ipcRenderer.send('control', remoteCode)
  }

  const handleControlState = (e, name, type) => {
    let text = ''

    if (type === 1) {
      // 控制别人
      text = `正在远程控制${name}`
    } else if (type === 2) {
      // 被控制
      text = `被${name}控制中`
    }

    setControlText(text)
  }

  return (
    <div className="container">
      <Versions></Versions>
      {controlText ? (
        <div>{controlText}</div>
      ) : (
        <>
          <div>你的控制码{localCode}</div>
          <input type="text" value={remoteCode} onChange={(e) => setRemoteCode(e.target.value)} />
          <button onClick={startControl}>确认</button>
        </>
      )}
    </div>
  )
}

export default App
```

```js
// 主进程改动
// main/windows/main.ts
import { BrowserWindow, shell } from 'electron'
import * as path from 'path'
import { is } from '@electron-toolkit/utils'

let mainWindow

export const create = () => {
  mainWindow = new BrowserWindow({
    width: 900,
    height: 670,
    show: false,
    autoHideMenuBar: true,
    ...(process.platform === 'linux'
      ? {
          icon: path.join(__dirname, '../../build/icon.png')
        }
      : {}),
    webPreferences: {
      preload: path.join(__dirname, '../preload/index.js'),
      sandbox: false,
      nodeIntegration: true,
      contextIsolation: false
    }
  })

  mainWindow.on('ready-to-show', () => {
    mainWindow.show()
  })

  mainWindow.webContents.setWindowOpenHandler((details) => {
    shell.openExternal(details.url)
    return { action: 'deny' }
  })

  if (is.dev && process.env['ELECTRON_RENDERER_URL']) {
    mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL'])
    mainWindow.webContents.openDevTools()
  } else {
    mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'))
  }
}

export const send = (channel, ...args) => {
  mainWindow.webContents.send(channel, ...args)
}

// main/index.ts
import { app, shell, BrowserWindow } from 'electron'
import { join } from 'path'
import { electronApp, optimizer, is } from '@electron-toolkit/utils'
import { create as createMainWindow } from './windows/main'
import handleIPC from './ipc'
import robot from './robot'

app.whenReady().then(() => {
  electronApp.setAppUserModelId('com.electron')

  app.on('browser-window-created', (_, window) => {
    optimizer.watchWindowShortcuts(window)
  })

  createMainWindow()
  handleIPC()
  robot()

  app.on('activate', function () {
    if (BrowserWindow.getAllWindows().length === 0) createMainWindow()
  })
})

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})
```

## 主进程消息通信

```js
// main/ipc.ts

import { ipcMain } from 'electron'
import { send as sendMainWindow } from './windows/main'
import { create as createControlWindow } from './windows/control'

export default function () {
  ipcMain.handle('login', async () => {
    // mock 返回控制码
    const code = Math.floor(Math.random() * (999999 - 100000)) + 100000

    return code
  })

  ipcMain.on('control', async (e, remoteCode) => {
    // 这里跟服务端交互 但是先mock返回
    sendMainWindow('control-state-change', remoteCode, 1)
    createControlWindow()
  })
}

```

**control端页面逻辑	**

```js
import { BrowserWindow, desktopCapturer } from 'electron'
import * as path from 'path'
import { is } from '@electron-toolkit/utils'

let win

export const create = () => {
  win = new BrowserWindow({
    width: 900,
    height: 670,
    show: false,
    autoHideMenuBar: true,
    webPreferences: {
      sandbox: false,
      nodeIntegration: true,
      contextIsolation: false,
      preload: path.join(__dirname, '../preload/index.js')
    }
  })
  win.on('ready-to-show', () => {
    win.show()
  })

  win.webContents.on('did-finish-load', () => {})

  if (is.dev && process.env['ELECTRON_RENDERER_URL']) {
    win.loadURL(`${process.env['ELECTRON_RENDERER_URL']}/pages/control/index.html`)
    win.webContents.openDevTools()
  } else {
    win.loadFile(path.join(__dirname, '../renderer/index.html'))
  }
}
```

## WebRTC

**WebRTC**（Web Real-Time Communications）是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。

-   getUserMedia

- - 获取多媒体数据（视频、音频）
  - 获取桌面视频流

- RTCPeerConnection

- - 建立P2P连接
  - 传输多媒体数据

- RTCDataChannel 传输数据
- MediaStream API

- - 媒体流内容
  - 一个流对象可以包含多轨道 包含音频和视频轨道等
  - 能通过WebRTC传输
  - 通过<video>标签播放

![img](https://cdn.nlark.com/yuque/0/2023/png/739887/1673170673864-a848c2da-bd36-4dd2-a9f0-ece33ac01b42.png)

## 如何捕获媒体流

navigator.mediaDevices.getUserMedia API 获取的可以用来从桌面捕获音频和视频的媒体源的信息。

### 如何捕获桌面/窗口流

- desktopCapturer.getSources(options)

- - 返回 Promise<DesktopCapturerSource[]> - resolve 一个[DesktopCapturerSource](https://www.electronjs.org/zh/docs/latest/api/structures/desktop-capturer-source) 对象类型的数组，每个 DesktopCapturerSource 代表一个屏幕或一个可以被捕获的独立窗口。

- navigator.mediaDevices.getUserMedia

```js
// 主进程
// main/windows/control.ts

 win.on('ready-to-show', () => {
  win.show()
  desktopCapturer.getSources({ types: ['screen'] }).then(async (sources) => {
    win.webContents.send('SET_SOURCE', sources[0].id)
  })
})
```

### 渲染进程control

```js
<style>
  * {
    margin: 0;
  }
  #screen-video {
    width: 100%;
    height: 100%;
    object-fit: fill;
  }
</style>

// control/index.html
<video id="screen-video"></video>
<script type="module" src="./app.js"></script>


// app.js
import peer from './peer-control'

peer.on('add-stream', (stream) => {
  play(stream)
})

const video = document.getElementById('screen-video')

function play(stream) {
  video.srcObject = stream
  video.onloadedmetadata = function () {
    video.play()
  }
}

```

**peer-control**

```js
// 渲染进程
// peer-control.js
const { EventEmitter } = require('events')
const peer = new EventEmitter()

async function getScreenStream() {
  const { ipcRenderer } = window.electron
  ipcRenderer.on('SET_SOURCE', async (e, sourceId) => {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: sourceId,
          maxWidth: window.screen.width,
          maxHeight: window.screen.height
        }
      }
    })

    peer.emit('add-stream', stream)
  })
}

getScreenStream()

export default peer
```

### 如何接收和响应指令

程序可以控制键盘和鼠标

**安装**

```js
yarn add robotjs
```

**robotjs介绍** 

nodejs桌面自动化的库，可以控制键盘&鼠标

- 用于控制鼠标、键盘
- node.js、C++库
- 支持mac、windows、linux

**功能**

- 鼠标移动：robot.moveMouse(x, y)
- 鼠标点击：robot.mouseClick([button], [double])
- 按键： robot.keyTap(key,[modifier])

注意：robot使用C++开发的，在不同平台，不同node版本，需要编译后才可使用

**手动编译**

- process.versions.electron 查看electron版本
- process.versions.node 查看node版本，在[abi_croosswalk](https://github.com/mapbox/node-pre-gyp/blob/master/lib/util/abi_crosswalk.json) 查找abi

**自动编译** 

```js
yarn add electron-rebuild
npx electron-rebuild
```

**响应键盘事件**

- modifier(修饰键)处理： shift、ctrl、alt、meta(win/command)

- 按键转换（vkey） 需要将数组转换为对应的键

  ```js
  npm install vkey
  ```

**监听键盘和鼠标事件**

- window.onkeydown

  ```js
  // control/app.js
  window.onkeydown = function (e) {
    // data {keyCode, meta, alt, ctrl, shift}
    console.log(e)
    let data = {
      keyCode: e.keyCode,
      shift: e.shiftKey,
      meta: e.metaKey,
      control: e.ctrlKey,
      alt: e.altKey
    }
    peer.emit('robot', 'key', data)
  }
  ```

- window.onmouseup

  - 鼠标位置缩放 按比例
  - x1 = x*videoWidth /screenWidth*
  - *y1 = y*videoHeight /screenHeight

  ```js
  
  // control/app.js
  
  window.onmouseup = function (e) {
    // data {clientX, clientY, screen: {width, height}, video: {width, height}}
    let data = {}
    data.clientX = e.clientX
    data.clientY = e.clientY
    data.video = {
      width: video.getBoundingClientRect().width,
      height: video.getBoundingClientRect().height
    }
    peer.emit('robot', 'mouse', data)
  }
  
  ```

**control**

```js
// peer-control.js

peer.on('robot', (type, data) => {
  console.log('robot', type, data)
  if (type === 'mouse') {
    data.screen = {
      width: window.screen.width,
      height: window.screen.height
    }
  }
  setTimeout(() => {
    ipcRenderer.send('robot', type, data)
  }, 2000)
})
```

### **main robot**

```js
// main/robot.ts
import { ipcMain } from 'electron'
import robot from 'robotjs'
import vkey from 'vkey'

function handleMouse(data) {
  let { clientX, clientY, screen, video } = data
  // data {clientX, clientY, screen: {width, height}, video: {width, height}}
  let x = (clientX * screen.width) / video.width
  let y = (clientY * screen.height) / video.height
  console.log(x, y)
  robot.moveMouse(x, y)
  robot.mouseClick()
}

function handleKey(data) {
  // data {keyCode, meta, alt, ctrl, shift}
  const modifiers: string[] = []

  if (data.meta) modifiers.push('meta')
  if (data.shift) modifiers.push('shift')
  if (data.alt) modifiers.push('alt')
  if (data.ctrl) modifiers.push('ctrl')
  // 按键转换
  const key = vkey[data.keyCode].toLowerCase()
  if (key[0] !== '<') {
    //<shift>
    robot.keyTap(key, modifiers)
  }
}

export default function () {
  ipcMain.on('robot', (e, type, data) => {
    console.log('handle', type, data)
    if (type === 'mouse') {
      handleMouse(data)
    } else if (type === 'key') {
      handleKey(data)
    }
  })
}

// main.ts
import robot from './robot'

function createWindow(): void {
  robot()
}

```

### 视频流传输 RTCPeerConnection

![](https://cdn.nlark.com/yuque/0/2023/png/739887/1673170694363-6bdf318e-157e-4fc8-b06d-766f435aaf1d.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)







![img](https://cdn.nlark.com/yuque/0/2023/png/739887/1673170694363-6bdf318e-157e-4fc8-b06d-766f435aaf1d.png)

**RTCPeerConnection** 接口代表一个由本地计算机到远端的 WebRTC 连接。该接口提供了创建，保持，监控，关闭连接的方法的实现

**最简单的建立传输过程**

传输视频过程

一个基本的 RTCPeerConnection 使用需要协调本地机器以及远端机器的连接，它可以通过在两台机器间生成 Session Description 的数据交换协议来实现。呼叫方发送一个 offer(请求)，被呼叫方发出一个 answer（应答）来回答请求。双方 - 呼叫方以及被呼叫方，最开始的时候都要建立他们各自的 RTCPeerConnection 对象

offer是一个sdp 本质是一个协议



![img](https://cdn.nlark.com/yuque/0/2023/png/739887/1673171827800-3bcc97dd-8f18-449c-a230-ac235cbd0869.png)

控制端和傀儡端的p2p连接已经可以开始了

**SDP**

SDP（Session Description Protocol）是**一种会话描述协议**，用来描述多媒体 会话，**主要用于协商双方通讯过程，传递基本信息。**

- SDP的格式包含多行，每行为<type>=<value>
- <type>：字符，代表特定的属性，比如v，代表版本
- <value>：结构化文本，格式与属性类型有关，UTF8编码

**控制端**

```js
// renderer/pages/control/peer-control.js
const EventEmitter = require('events') 
const peer = new EventEmitter()
// const {ipcRenderer, desktopCapturer} = require('electron')
const { ipcRenderer ,desktopCapturer} = window.electron
const pc = new window.RTCPeerConnection({})

async function createOffer() {
    let offer = await pc.createOffer({
        offerToReceiveAudio: false,
        offerToReceiveVideo: true
    })
    await pc.setLocalDescription(offer)
    console.log('create-offer\n', JSON.stringify(pc.localDescription))
    return pc.localDescription
}
createOffer().then((offer) => {
    console.log('forward', 'offer', offer)
    ipcRenderer.send('forward', 'offer', {type: offer.type, sdp: offer.sdp})
})

ipcRenderer.on('answer', (e, answer) => {
    setRemote(answer)
})

ipcRenderer.on('candidate', (e, candidate) => {
    addIceCandidate(candidate)
})

async function setRemote(answer) {
    await pc.setRemoteDescription(answer)
    console.log('create-answer', pc)
}
window.setRemote = setRemote

pc.onicecandidate = (e) => {
	console.log('candidate', JSON.stringify(e.candidate))
    ipcRenderer.send('forward', 'control-candidate', e.candidate)
	// 告知其他人
}
const candidates = []
async function addIceCandidate(candidate) {
    if(!candidate || !candidate.type) return
    candidates.push(candidate)
    if(pc.remoteDescription && pc.remoteDescription.type) {
        for(let i = 0; i < candidates.length; i ++) {
            await pc.addIceCandidate(new RTCIceCandidate(candidates[i]))
        }
        candidates = []
    } 
}
window.addIceCandidate = addIceCandidate

pc.onaddstream = (e) => {
	console.log('addstream', e)
	peer.emit('add-stream', e.stream)

}

let dc = pc.createDataChannel('robotchannel', {reliable: false});
console.log('before-opened', dc)
dc.onopen = function() {
    console.log('opened')
    peer.on('robot', (type, data) => {
        dc.send(JSON.stringify({type, data}))
    })
}
dc.onmessage = function(event) {
    console.log('message', event)
}
dc.onerror = (e) => {console.log(e)}


// 先把robot屏蔽
// peer.on('robot', (type, data) => {
//     console.log('robot', type, data)
//     if(type === 'mouse') {
//         data.screen = {
//             width: window.screen.width, 
//             height: window.screen.height
//         }
//     }
//     setTimeout(() => {
//     ipcRenderer.send('robot', type, data)
//     }, 2000)
//
// })
module.exports = peer

```

**傀儡端**

```js
import EventEmitter from 'events'
import { ipcRenderer, desktopCapturer } from 'electron'
let peer = new EventEmitter()
window.peer = peer // 为了直接模拟过程，信令结束后，会删掉
ipcRenderer.on('offer', (e, offer) => {
  console.log('init pc', offer)
  const pc = new window.RTCPeerConnection()

  pc.ondatachannel = (e) => {
    console.log('data', e)
    e.channel.onmessage = (e) => {
      console.log('onmessage', e, JSON.parse(e.data))
      let { type, data } = JSON.parse(e.data)
      console.log('robot', type, data)
      if (type === 'mouse') {
        data.screen = {
          width: window.screen.width,
          height: window.screen.height
        }
      }
      ipcRenderer.send('robot', type, data)
    }
  }

  async function getScreenStream() {
    const sources = await desktopCapturer.getSources({ types: ['screen'] })
    return new Promise((resolve, reject) => {
      navigator.webkitGetUserMedia(
        {
          audio: false,
          video: {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sources[0].id,
              maxWidth: window.screen.width,
              maxHeight: window.screen.height
            }
          }
        },
        (stream) => {
          console.log('add-stream', stream)
          resolve(stream)
        },
        reject
      )
    })
  }

  pc.onicecandidate = (e) => {
    // 告知其他人
    ipcRenderer.send('forward', 'puppet-candidate', e.candidate)
  }

  async function addIceCandidate(candidate) {
    if (!candidate || !candidate.type) return
    await pc.addIceCandidate(new RTCIceCandidate(candidate))
  }
  window.addIceCandidate = addIceCandidate

  async function createAnswer(offer) {
    let stream = await getScreenStream()
    pc.addStream(stream)
    await pc.setRemoteDescription(offer)
    await pc.setLocalDescription(await pc.createAnswer())
    console.log('create answer \n', JSON.stringify(pc.localDescription))
    // send answer
    return pc.localDescription
  }
  createAnswer(offer).then((answer) => {
    ipcRenderer.send('forward', 'answer', { type: answer.type, sdp: answer.sdp })
  })
})
export default peer

```

# 性能优化

## **⼀. ⽹⻚性能衡量与指标**

1. 衡量⽹⻚性能因素与指标

​	a) ⽹⻚的加载

​	b) ⽹⻚的交互

2. ⽹⻚开发中的分段渲染与性能评估

3. 混合开发中的性能评估

## **⼆、前端性能优化的发展⽅向及细节路径**

1. Core Web Vitals宗旨及其细节

​	a) CWV 概念

​	b) CWV 的分区模型

​	c) 宗旨与实际⽅案

参考⽂档：

https://baijiahao.baidu.com/s?id=1677330875057509648&wfr=spider&for=pc

2. 前端性能利器Performance的使⽤

​	a) performance⾯板的合理使⽤

​	b) Performance⼯具接⼝

参考⽂档：

https://developer.mozilla.org/zh-CN/docs/Learn/Performance

3. 加载上的优化

​	a) 异步加载

​	b) 按需加载

​	c) 新时代的异类 - bigpipe **三、 浏览器层⾯的优化点**

4.  浏览器存储的优化⽅案

5. .PWA 概念架构

## **四. ⻚⾯性能纬度体系**

i. 回到那道⾯试题 – 各阶段性能衡量纬度拓展

ii. 性能体系的拆分独⽴ => 衡量标准

## **五. MVVM框架层⾯的性能优化**

i. 基础类优化

1. 利⽤框架本身设计思路进⾏优化

2. 利⽤第三⽅⼯具进⾏优化

ii. 技巧类

## **六. ⼤⼚可视化性能监控⽅案体系**

a) 埋点上报 => 点到点 + 信息采集

b) 数据处理 => 阈值设置 / 数据分类 / 数据重组

c) 可视化展现

​	i. ⾃研报表监控

​	ii. grafana 

d) 告警处理

i. 告警触发

ii. 触发分派 => 钉钉、企微、邮件

# **设计模式**

## **⼀、代码的最佳实践** **——** **设计模式**

**1.** **系统性多赢**

**2.** **代码编制的真正⼯程化**

## **⼆、设计模式扮演的⻆⾊**

**1. **帮助组织模块**

帮助我们组织模块

通过⼀些设计模式，组织模块间的组成结构

**2.** **帮助设计沟通**

有的设计模式可以帮助我们设计模块间的组成结构

**3.** **提⾼代码质量**

通过设计模式，让代码更加优雅

## **三、设计原则**

**1.** **开闭原则**(OCP)

程序要对扩展开放，对修改关闭

```js
// 开闭原则（OCP: open closed principle）- 对拓展开放、对修改关闭
// 目标：已有的场景下，对于需要拓展的功能进行开放、拒绝直接的功能修改

// sprint1 - 母亲节活动，吃鸡要高亮 + LOL要弹出折扣
// render
if (game === 'PUBG') {
    // 高亮
} else {
    // ....
}

// event
if (game === 'LOL') {
    // 弹出折扣框
} else {
    // 付款
}

// sprint2 - 要对部分游戏进行置灰下架 + 付款页面要显示停止发售（R）
// render
if (game === 'PUBG') {
    // 高亮
} else if (game === 'R'){
    // 灰色
} else {
    // ....
}

// event
if (game === 'LOL') {
    // 弹出折扣框
} else if (game === 'R'){
    // break + 提示停止发售
} else {
    // 付款
}

// 重构 => 分配
// render
gameManager(game).setColor();

// event
gameManager(game).openDialog();

// 游戏管理器
function gameManager(game) {
    return `${game}Manager`;
}

const LOLManager = {
    setColor() {
        // 正常
    },
    openDialog() {
        // 折扣
    }
}

const PUBGManager = {
    setColor() {
        // 高亮
    },
    openDialog() {
        // 付款
    }
}

// 重构2
class Game {
    constructor(name) {
        this.name = name;
    }

    setColor() {
        // 默认设置
    }

    openDialog() {
        // 普通付款框
    }
}

class LOL extends Game {
    openDialog() {
        // 弹出折扣框
    }
}

class PUBG extends Game {
    setColor() {
        // 高亮
    }
}
```

**2.** **单⼀职责原则**(SRP)

模块只做⼀件事情，模块的职责越单⼀越好

```js
// SRP - 通过解耦让每一个职责更加独立
// 目标：一个功能只做一件事情

// sprint
// game store
class PUBGManager {
    openDialog() {
        // 弹折扣框
        // 计算折扣金额
        setPrice();
    }
}

const game = new PUBGManager();
game.openDialog(); // 弹框 < = > 计算金额 两个功能耦合

// 重构
// gameManager.js - 业务
class PUBGManager {
    constructor(command) {
        this.command = command;
    }
    openDialog(price) {
        // 弹折扣框
        // 计算折扣金额
        this.command.setPrice(price);
    }
}

// optManager.js - 底层库
class PriceManager {
    setPrice(price) {
        // 计算金额
    }
    calcPrice(price) {}
}
// class PasswordManager {
//     // ……
// }

// function OptManager (name){
//     return `${name}Manager`
// }

// export {
//     PriceManager,
//     PasswordManager
// }

// main.js
// import opt from './optManager'

const exe = new PriceManager();
const game1 = new PUBGManager(exe);
game1.openDialog(15);
exe.setPrice(10);
 
```

**3.** **依赖倒置原则**(DIP)

上层模块不要依赖与具体的下层模块，应该依赖于抽象

```js
// DIP
// 目标：面向抽象进行coding，而不是面向实现进行代码书写。降低需求与实现之间的耦合的

// 需求：
// sprint 1
// 分享功能
class Store {
    constructor() {
        this.share = new Share();
    }
}

class Share {
    shareTo() {
        // 分享到不同平台
    }
}

const store = new Store();
store.share.shareTo('wx');

// sprint2
// 评分功能
class Store {
    constructor() {
        this.share = new Share();
        this.rate = new Rate();
    }
}

class Share {
    shareTo(pltf) {
        // 分享到不同平台
    }
}

class Rate {
    star(stars) {
        // 打分
    }
}

const store1 = new Store();
store1.rate.stars(5);

// 重构
// 目标：暴露挂载 => 动态挂载
class Store {
    // 维护模块名单
    static modules = new Map();
    // 支持外部注册名单
    static inject(module) {
        Store.modules.set(module.constructor.name, module);
    }

    constructor() {
        // 遍历名单做初始化挂载
        for(let module of Store.modules.values()) {
            // 每个模块做初始化即可
            module.init(this);
        }
    }
}

class Share {
    init(store) {
        store.share = this;
    }
    shareTo(pltf) {
        // 分享到不同平台
    }
}

class Rate {
    init(store) {
        store.rate = this;
    }
    star(stars) {
        // 打分
    }
}

// 依次注册完所有模块
const rate = new Rate();
Store.inject(rate);

const store2 = new Store();
store2.rate.star(4);
```

**4.** **接⼝隔离原则**(ISP)

接⼝要细化，功能要单⼀，⼀个接⼝不要调⽤太多⽅法，使其能⼒单⼀

```js
// ISP
// 目标：多个专业的接口比单个胖接口好用

// 需求
// 已经可以开发游戏了，但是实现游戏中台 - 快速生产游戏
// PUBG LOL  => run shot mega
class Game {
    constructor(name) {
        this.name = name;
    }
    run() {
        // 跑
    }
    shot() {
        // 开枪
    }
    mega() {
        // 开大
    }
}

class PUBG extends Game {
    constructor() {
        // pubg constructor
    }
}
class LOL extends Game {
    constructor() {
        // lol constructor
    }
}

pubg = new PUBG('pubg');
pubg.run();
pubg.shot();
bubg.mega();

// 重构 - 用多个接口来替代他，每个接口服务于一个子模块
class Game {
    constructor(name) {
        this.name = name;
    }
    run() {
        // 跑
    }
}

class FPS {}
class MOBA {}

class PUBG extends Game {
    constructor() {
        // pubg constructor
    }
    shot() {}
}
class LOL extends Game {
    constructor() {
        // lol constructor
    }
    mega() {}
}
```

**5.** **⾥⽒替换原则**(LSP)

它主要关注于继承，它的意义是任何使⽤⽗类的地⽅都可以⽤⼦类去替换

```js
// 里氏替换原则
// 子类能够覆盖父类进行拓展，但不可改变父类

// sprint 1
class Game {
    start() {
        // 开机逻辑
    }
    shutdown() {
        // 关机逻辑
    }
}

class MobileGame extends Game {
    // 墓碑机制
    tombStone() {

    }
}

class PCGame extends Game {
    // 加速器
    speed() {
        
    }
}
```

## **三、设计原则**

**1.** **创建型**

⼯⼚模式、建造者模式、单例模式

```js
// 元素创建型
// 功能：创建元素
// 目的：规范元素的创建步骤

// 1. 工厂模式 - 大批量 | 同类型
// 隐藏创建过程、暴露共同接口
// 需求：游戏商店里下载初始化游戏，并且可以运行游戏
class Shop {
    create(name) {
        return new Game(name, {version: yy});
    }
}

class Game {
    constructor(name, ...arg) {
        this.name = name;
    }
    init() {}
    run() {}
}

const shop = new Shop();
const pubg = shop.create('pubg');
const pubg2 = new Game('pubg');
// 创建商店时快速生产游戏

// 2. 建造者模式 过程 | 顺序
// 拆分简单模块、独立执行 => 注重过程与搭配
// 需求：优惠套餐单元，商品 + 皮肤 进行打折售卖
class Product {
    constructor(name) {
        this.name = name;
    }
    init() {
        console.log(this.name + 'product');
    }
}
class Skin {
    constructor(name) {
        this.name = name;
    }
    init() {
        console.log(this.name + 'skin');
    }
}

class Shop {
    constructor() {
        this.package = '';
    }
    create(name) {
        this.package = new PackageBuilder(name);
    }
    getGamePackage() {
        return this.package.getPackage();
    }
}

class PackageBuilder {
    constructor(name) {
        this.game = new Product(name);
        this.skin = new Skin(name);
    }
    getPackage() {
        return this.game.init() + this.skin.init();
    }
}

// 3. 单例模式 唯一性
// 全局只有一个实例
class PlayStation {
    constructor() {
        this.state = 'off';
    }
    play() {
        if(this.state === 'on') {
            console.log('别闹，已经在happy了');
            return;
        }
        this.state = 'on';
        console.log('准备开始happy');
    }
    shutdown() {
        if(this.state === 'off') {
            console.log('已经关闭');
            return;
        }
        this.state = 'off';
        console.log('已经关机，请放心');
    }
    // static instance = undefined;
    // static getInstance() {
    //     return function() {
    //         if (!PlayStation.instance) {
    //             PlayStation.instance = new PlayStation();
    //         }
    //         return PlayStation.instance;
    //     }();
    // }
}

// main.js
PlayStation.instance = undefined;
PlayStation.getInstance = (function() {
    return function() {
        if (!PlayStation.instance) {
            PlayStation.instance = new PlayStation();
        }
        return PlayStation.instance;
    }();
})

const ps1 = PlayStation.getInstance();
ps1.play();

const ps2 = PlayStation.getInstance();
ps2.shutdown();
// 全局只要一个实例，防止属性的混乱

// 模式场景
// 1. 批量生产同类型应用来满足频繁使用同一种类型需求时 - 工厂模式
// 2. 我们需要模块化拆分一个大的模块，同时模块间独立解耦顺序分工 - 建造者模式
// 3. 全局只需要一个实例，并且注重统一一体化 - 单例模式

// 实际应用
// Button Producer：生成不同类型的按钮 => 本质相同，根据传参区分不同类型的属性元素 => 工厂
// 全局应用 router store => 只需要一个实例 => 单例模式
// 页头组件Header: 包含了title | button | breadcum => 生产多重不同类型的元素、彼此又有顺序 => 建造者模式
```

**2.** **结构型**

适配器模式、装饰器模式、代理模式

```js
// 结构型
// 功能：优化结构的实现方式

// 适配器模式 - adapter
// 适配独立模块，保证模块间的独立解耦以及连接兼容

// 买了一个PS，插头是港行的，插座国标
class HKDevice {
    getPlug() {
        // 港行双圆柱插头
    }
}

class Target {
    constructor() {
        this.plug = new HKDevice();
    }
    // 适配器
    getPlug() {
        return Target.adapter(this.plug.getPlug());
    }
    static adapter(oldPlug) {
        return oldPlug + '+ 港行双圆柱转换器';
    }
}

const target = new Target();
target.getPlug();

// 装饰器模式
// 动态地将责任附加在对象之上，从而扩展其能力
// 设备升级
class Device {
    create() {
        console.log('Playstation4');
    }
}

class Phone {
    create() {
        console.log('iphone24');
    }
}

class Decorator {
    constructor(device) {
        this.device = device;
    }
    create() {
        this.device.create();
        this.update(device);
    }
    update(device) {
        console.log(device + 'pro');
    }
}

const device = new Device();
device.create();

const newDevice = new Decorator(device);
newDevice.create();

// 代理模式
// 使用代理人来替代原始对象从而集约整体操作流程

// 游戏防沉迷机制
class Game {
    play() {
        return "playing";
    }
}

class Player {
    constructor(age) {
        this.age = age;
    }
}

class GameProxy {
    constructor(player) {
        this.player = player;
    }
    play() {
        return this.player.age < 16
            ? 'too young'
            : new Game().play();
    }
}

const player = new Player(18);
const game = new GameProxy(player);

game.play();

// 模式场景
// 中间转换参数、保持模块独立的前提下，做已有方案的兼容 - 适配器模式
// 附着于多个元素上，提供批量动态能力赋予的功能 - 装饰器模式
// 将代理人对象与调用对象分离，使用时通过代理人来启动目标对象的方法 - 代理模式

// 实际应用
// 1. 两个模块： 筛选器和表格需要做一个联动。筛选器数据不能直接传入表格，需要数据结构的转换
// => 模块之间独立，传递参数需要转换 => 适配器模式
// 2. 目前有button | title | icon三个组件。希望开发一个模块，让三个组件同时具备相同的能力
// => 统一能力的替身，且可以动态添加改变 => 装饰器模式
// 3. ul中有多个li，每个li上的点击事件 => 利用冒泡做代理，事件绑定在ul上
// => 绑定一个监听即可以完成所有节点被点击行为的捕捉 => 代理模式
```

**3.** **⾏为型**

命令模式、模板模式、观察者模式

```js
// 行为型
// 不同对象模块间的责任划分和算法抽象化

// 命令模式
// 请求以命令的方式包裹在对象中，并传给调用对象

// 在游戏中对于角色的控制
// 接受者
class Receiver {
    execute() {
        // 执行操作
    }
}

// 触发者
class Operator {
    constructor(command) {
        this.command = command;
    }
    run() {
        this.command.execute();
    }
}

// 指令器
class Command {
    constructor(receiver) {
        this.receiver = receiver;
    }
    execute() {
        this.receiver.execute();
    }
}

const linker = new Receiver();
const order = new Command(linker);
const player = new Operator(order);

player.run();

// 模板模式
// 在模板中，定义好每个方法的执行步骤。方法本身关注于自己的事情
class Device {
    constructor(executePipeLine) {
        // executePipeLine...
    }
    powerOn() {
        // 打开电源
    }
    login() {
        // 登录
    }
    clickIcon() {
        // 点击开始游戏
    }
    enterGame() {
        // 进入游戏
    }
    play() {
        this.powerOn();
        this.login();
        this.clickIcon();
        this.enterGame();
    }
}

// 观察者模式
// 当一个属性发生状态改变时，观察者会连续引发所有状态的改变

class MediaCenter {
    constructor() {
        this.state = '';
        this.observers = [];
    }
    attach(observer) {
        this.observers.push(observer);
    }
    getState() {
        return this.state;
    }
    setState() {
        this.state = state;
        this.notifyAllobservers();
    }
    notifyAllobservers() {
        this.observers.forEach(ob => {
            ob.update();
        })
    }
}

class observer {
    constructor(name, center) {
        this.name = name;
        this.center = center;
        this.center.attach(this);
    }
    update() {
        // 更新当前状态
    }
}

const center = new MediaCenter();
const ps = new observer('ps', center);
const tv = new observer('tv', center);

center.setState('on');

// 职责链
// 1. 链式调用 2. 职责独立 3. 顺序执行
class Action {
    constructor(name) {
        this.name = name;
        this.nextAction = null;
    }
    setNextAction(action) {
        this.nextAction = action;
    }
    handle() {
        // 请假内容
        if (this.nextAction !== null) {
            this.nextAction.handle();
        }
    }
}

const leader = new Action('leader');
const cto = new Action('cto');
const boss = new Action('boss');

leader.setNextAction(cto);
cto.setNextAction(boss);

leader.handle();

// 模式场景
// 发出指令，中间层传递命令本身，命中包含执行对象 - 命令模式
// 通过模板定义执行顺序，做独立操作 - 模板模式
// 通过观察者，可以让被观察值进行统一变化，触发相应依赖值统一更新的 - 观察者模式
// 独立指责的单元通过链式执行，逐步操作流程 - 职责链

// 实际应用
// 1. 提交表单，逐行进行校验。链式调用validate => 职责链
// 2. echarts：canvas、config、init、draw(),顺序严格按照规划执行 => 模板模式
// 3. 调度器接受到大的对象，将内容封装到指令命令中，通过不同的方法做集成。=> 命令模式
// 4. 输入框输入值和隔壁下拉框的备选项联动 => 观察选中值，设置输入框类型 => 观察者模式
```

## **四、模式设计实战**

**系统设计类题⽬**

# 微前端

https://www.yuque.com/g/aliang-khvnv/kb/gss67kry0e7m6ehg/collaborator/join?token=fotRM4sX09Xqy4qa# 《微前端(上)》

微前端背景 

2014年：Martin Fowler和James Lewis共同提出了 微服务 的概念。微服务是⼀种开发软件的架 

构和组织⽅法，其中软件由通过明确定义的API进⾏通信的 ⼩型独⽴服务 组成。 

微服务的主要思路是： 

● 将应⽤ 分解 为⼩的、互相连接的微服务，⼀个微服务完成某个 特定功能 。 

● 每个微服务都有⾃⼰的业务逻辑和适配器，不同的微服务，可以使⽤ 不同的技术 去实现。 

● 使⽤ 统⼀的⽹关 进⾏调⽤。 

可以看到微服务的主要思路是化繁为简，通过更加细致的划分，使得服务内部更加内聚，服务之间 

耦合性降低，有利于项⽬的团队开发和后期维护。把微服务的概念应⽤到前端， 前端微服务/微前 

端服务 就诞⽣了，简称其为微前端。 

微前端的概念是由ThoughtWorks在2016年提出的。 

2018年: 第⼀个微前端⼯具single-spa在github上开源。 

2019年: 基于single-spa的qiankun问世。 

2020年：Module Federation(webpack5）把项⽬中模块分为本地模块和远程模块，远程模块不 

属于当前构建，在运⾏时从所谓的容器加载。加载远程模块是异步操作。当使⽤远程模块时，这些 

异步操作将被放置在远程模块和⼊⼝之间的下⼀个chunk的加载操作中，从⽽实现微前端的构建。

本期课程两部分 

第⼀部分主要讲解微前端解决的问题，微前端的特点，如何实现微前端，并以qiankun为例，教⼤家我们 

的应⽤如何接⼊微前端。 

第⼆部分主要讲解微前端的核⼼实现原理，并⼿把⼿从0-1实现简单的微前端框架。 

## 课程⽬标 

1. 微前端概念； 

2. 现有⽅案介绍； 

3. 掌握使⽤qiankun搭建微应⽤ 

## 微前端是什么？ 

![micro-frontends](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontends.jpg)

微前端是⼀种架构⻛格，它允许可独⽴交付的前端应⽤程序被组合成⼀个更⼤的整体。 

## 课程⼤纲 

1. 微前端背景 

2. 微前端的价值 

3. 微前端解决⽅案 

4. 基于qiankun的实践 

## 微前端背景 

1.  微前端是什么？ 

微前端是⼀种架构⻛格，它允许可独⽴交付的前端应⽤程序被组合成⼀个更⼤的整体。 

微前端三要素：⽆技术栈限制，应⽤单独开发，多应⽤整合

2. 现在web应⽤⾯临的问题

代码分布情况： 

1. 多个系统在⼀个仓库应⽤中，不同⼦应⽤独⽴SPA模式 

2. 系统分为多个仓库，独⽴上线部署，采⽤MPA模式 

带来的问题： 

● DX(developer experience) 

​     ○ 业务领域的代码库不够独⽴和⾼度可重⽤ 

​	○ 相同的产品功能由多个团队开发 / 产品功能难以保持统⼀ 

​	○ 新的产品理念⽆法在不同的应⽤中快速复⽤ / 实现 

​	○ 快速迭代新⼦业务 / ⼲净移除将被淘汰的⼦业务 

● UX(user experience)(在考虑DX的情况下) 

​	○ 性能体验 

​	○ ⻚⾯跳转等⽤户体验问题

## 微前端价值 

1. 微前端的特点

![micro-frontends-value](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontends-value.jpg)

● 技术栈⽆关 主框架不限制接⼊应⽤的技术栈，⼦应⽤可⾃主选择技术栈

● 独⽴开发/部署 各个团队之间仓库独⽴，单独部署，互不依赖 

● 增量升级 当⼀个应⽤庞⼤之后，技术升级或重构相当麻烦，⽽微应⽤具备渐进式升级的特性 

● 独⽴运⾏时 微应⽤之间运⾏时互不依赖，有独⽴的状态管理 

● 提升效率 应⽤越庞⼤，越难以维护，协作效率越低下。微应⽤可以很好拆分，提升效率

2. 微前端的意义 

   ![micro-frontends-meaning](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontends-meaning.jpg)



任何新技术的产⽣都是为了解决现有场景和需求下的技术痛点，微前端也不例外： 

1. 拆分和细化：当下前端领域，单⻚⾯应⽤（SPA）是⾮常流⾏的项⽬形态之⼀，⽽随着时间的推移 

以及应⽤功能的丰富，单⻚应⽤变得不再单⼀⽽是越来越庞⼤也越来越难以维护，往往是改⼀处⽽

动全身，由此带来的发版成本也越来越⾼。微前端的意义就是将这些庞⼤应⽤进⾏拆分，并随之解 

耦，每个部分可以单独进⾏维护和部署，提升效率。 

2. 整合历史系统：在不少的业务中，或多或少会存在⼀些历史项⽬，这些项⽬⼤多以采⽤⽼框架类似 

（Backbone.js，Angular.js 1）的B端管理系统为主，介于⽇常运营，这些系统需要结合到新框架中 

来使⽤还不能抛弃，对此我们也没有理由浪费时间和精⼒重写旧的逻辑。⽽微前端可以将这些系统

进⾏整合，在基本不修改来逻辑的同时来同时兼容新⽼两套系统并⾏运⾏ 

## 微前端的能⼒ 

![micro-frontends-capility](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontends-capility.jpg)



## 微前端解决⽅案 

1 技术⽅案介绍 

1.1 基于 iframe 完全隔离的⽅案 

介绍：略 

优点： 

1. ⾮常简单，⽆需任何改造 

2. 完美隔离，JS、CSS 都是独⽴的运⾏环境 

3. 不限制使⽤，⻚⾯上可以放多个 iframe 来组合业务 

缺点： 

1. 每次进来都要加载，状态不能保留 
2. 完全的隔离导致与⼦应⽤的通信不⽅便(postMessage，hash等) 
3. 布局限制，⽐如⼦应⽤⾥有⼀个 Modal，显示的时候只能在那⼀⼩块地⽅展示，不能全屏展示 
4. ⽆法进⾏资源共享，整个应⽤全量资源加载，加载太慢 

1.2 webpack module federation 

host: 引⽤了其他应⽤的应⽤ 

remote: 被其他应⽤所使⽤的应⽤ 

介绍： 

![micro-frontends- solution](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontends- solution.jpg)



优点： 

1. 基于webpack，改造和学习成本低 

缺点： 

1. 样式隔离需要⾃⼰实现 

2. 跨技术栈⽆统⼀⽅案，需要⾃⼰实现：https://github.com/module-federation/module-federation-examples/blob/master/react-in-vue/layout/src/ReactButton.js 

3. ⼊⼝⽂件的缓存问题

1.3 web components 

介绍：

● Custom elements（⾃定义元素）：⼀组JavaScript API，允许您定义custom elements及其⾏ 

为，然后可以在您的⽤户界⾯中按照需要使⽤它们

Shadow DOM（影⼦DOM）：⼀组JavaScript API，⽤于将封装的“影⼦”DOM树附加到元素（与

主⽂档DOM分开呈现）并控制其关联的功能。通过这种⽅式，您可以保持元素的功能私有，这样它 

们就可以被脚本化和样式化，⽽不⽤担⼼与⽂档的其他部分发⽣冲突。 

HTML templates（HTML模板）： <template> 和 <slot> 元素使您可以编写不在呈现⻚⾯中显示 

的标记模板。然后它们可以作为⾃定义元素结构的基础被多次重⽤ 

1. 技术栈⽆关：Web Components是浏览器原⽣组件，那即是在任何框架中都可以使⽤。 

2. 独⽴开发：使⽤Web Components开发的应⽤⽆需与其他应⽤间产⽣任何关联。 

3. 应⽤间隔离： Shadow DOM的特性，各个引⼊的微应⽤间可以达到相互隔离的效果。 

可以使⽤web components开发⼦应⽤，整个⼦应⽤都是使⽤web components开发的 

缺点： 

**1.** 语法强制（技术栈⽆关，但限制了开发时使⽤的技术栈） 

**2.** 有部分兼容性问题: stencil

```js
class CustomButton extends HTMLElement {
 connectedCallback() {
 this.innerHTML = `<button type="button">⾃定义按钮</button>`;
 }
 disconnectedCallback() { alert('1') } }
window.customElements.define('custom-button', CustomButton);
```



1.4服务端拼接

![micro-frontend-1](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontend-1.jpg)



```html
 <html lang="en" dir="ltr">
 <head>
 <meta charset="utf-8">
 <title>Feed me</title>
 </head>
 <body>
 <h1>🍽 Feed me</h1>
 <!--# include file="$PAGE.html" -->
 </body>
</html> 
```

```nginx
server {
 listen 8080;
 server_name localhost;
 root /usr/share/nginx/html;
 index index.html;
 ssi on;
 # Redirect / to /browse
 rewrite ^/$ http://localhost:8080/browse redirect;
 # Decide which HTML fragment to insert based on the URL
 location /browse {
 set $PAGE 'browse';
 }
 location /order {
 set $PAGE 'order';
 }
 location /profile {
 set $PAGE 'profile'
 }
 # All locations should render through index.html
 error_page 404 /index.html;
}
```

1.5 esm+import map

将⼦模块通过esm的⽅式引⼊，并通过import map进⾏环境配置，也可以实现想要的结果 

优点： 

1. 浏览器原⽣⽀持，⽆需额外⼯具 

缺点： 

1. 部分浏览器兼容性不好 

## 微前端框架

### single-spa

https://single-spa.js.org/ 

single-spa 就做了两件事情： 

加载微应⽤（加载⽅法还得⽤户⾃⼰来实现） 

管理微应⽤的状态（初始化、挂载、卸载）

single-spa 仅仅是⼀个⼦应⽤⽣命周期的调度者。single-spa 借鉴了组件⽣命周期的思想，它为应⽤设 

置了针对路由的⽣命周期。当应⽤匹配路由/处于激活状态时，应⽤会把⾃身的内容挂载到⻚⾯上；反之 

则卸载。典型的 single-spa 由 html ⻚⾯、应⽤注册脚本、应⽤脚本⾃身构成。 

single-spa ⼜约定应⽤脚本包含以下⽣命周期： 

load：当应⽤匹配路由时就会加载脚本（⾮函数，只是⼀种状态） 

bootstrap：引导函数（对接 html，应⽤内容⾸次挂载到⻚⾯前调⽤） 

mount：挂载函数 

unmount：卸载函数（须移除事件绑定等内容） 

unload：⾮必要（

unload 之后会重新启动 bootstrap 流程；借助 unload 可实现热更新）

![micro-frontend-1](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontend-1.jpg)

### qiankun

iankun 是⼀个基于 single-spa 的微前端实现库，旨在帮助⼤家能更简单、⽆痛的构建⼀个⽣产可⽤微前端架构系统。 

qiankun 孵化⾃蚂蚁⾦融科技，在经过⼀批线上应⽤的充分检验及打磨后，我们将其微前端内核抽取出来并开源，希望能同时帮助社区有类似需求的系统更⽅便的构建⾃⼰的微前端系统，同时也希望通过区的帮助将 qiankun 打磨的更加成熟完善。 

⽬前 qiankun 已在蚂蚁内部服务了超过 2000+ 线上应⽤，在易⽤性及完备性上，绝对是值得信赖的。

通过 import-html-entry 包解析 HTML 获取资源路径，然后对资源进⾏解析、加载。

通过对执⾏环境的修改，它实现了 JS 沙箱、样式隔离 等特性。

![micro-frontend-2](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontend-2.jpg)



### EMP 

https://emp2.netlify.app/develop/

![micro-frontend-3](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontend-3.jpg)

基于module federation的微前端⽅案 

## 前端微应⽤实践 

采⽤ React 作为主应⽤基座，接⼊Vue技术栈的微应⽤。 

我们先使⽤ create-react-app⽣成⼀个 React 的项⽬，初始化主应⽤。 

create-react-app 是 React 官⽅提供的脚⼿架⼯具，⽤于快速搭建⼀个 React 项⽬。 

将普通的项⽬改造成 qiankun 主应⽤基座，需要进⾏三步操作： 

1. 创建微应⽤容器 - ⽤于承载微应⽤，渲染显示微应⽤； 

2. 注册微应⽤ - 设置微应⽤激活条件，微应⽤地址等等； 

3. 启动 qiankun； 

**主应⽤依赖包**

```js
npm i react-router-dom -S
npm i antd -S
```

**创建微应⽤容器**

我们先在主应⽤中创建微应⽤的承载容器，这个容器规定了微应⽤的显示区域，微应⽤将在该容器 内渲染并显示。 

我们先设置路由，路由⽂件规定了主应⽤⾃身的路由匹配规则，代码实现如下

index.js

```js
import antd/dist/reset.css;
```

App.js

```js
import { BrowserRouter as Router, Link } from 'react-router-dom'
import { Menu } from 'antd'
import './App.css'
const menus = [
 {
 key: 'Home',
 label: <Link to="/">主⻚</Link>,
 },
 {
 key: 'app-vue1',
 label: <Link to="/app-vue1">vue微应⽤1</Link>,
 },
 {
 key: 'app-vue2',
 label: <Link to="/app-vue2">vue微应⽤2</Link>,
 }, ];
function App() {
 let style = {
 width: '100vw',
 height: '100vh',
 }
 return (
 <Router>
 <div className="App">
 <Menu
 style={{
 width: 256,
 }}
 theme="dark"
 mode="inline"
 items={menus}
 ></Menu>
 <h1>主应⽤启动成功</h1>
 <div id="micro-container" style={style}></div>
 </div>
 </Router>
 ) }

```

**注册微应⽤**

在构建好了主框架后，我们需要使⽤ qiankun 的 registerMicroApps ⽅法注册微应⽤，代码实现 如下：

```js
// micro-app.js
export const MicroApps = [
 {
 name: "vue1App",
 entry: "//localhost:3001",
 container: "#micro-container",
 activeRule: "/app-vue1",
 },
 {
 name: "vue2App",
 entry: "//localhost:3002",
 container: "#micro-container",
 activeRule: "/app-vue2",
 }, ];
```

我们在注册好了微应⽤，通过 start 函数后，我们需要在合适的地⽅调⽤ start 启动主应⽤。

index.js

````js
import React from "react";
import ReactDOM from "react-dom/client";
import { registerMicroApps, start } from "qiankun";
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";
import { MicroApps } from "./micro-app";
registerMicroApps(MicroApps);
start();
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
 <React.StrictMode>
 <App />
 </React.StrictMode>
);
// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
````

**接入微应用**

我们现在的主应⽤基座只有⼀个主⻚，现在我们需要接⼊微应⽤。 

qiankun 内部通过 import-entry-html 加载微应⽤，要求微应⽤需要导出⽣命周期钩⼦函数（⻅下图）。 

![micro-frontend-4](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontend-4.jpg)

从上图可以看出，qiankun 内部会校验微应⽤的⽣命周期钩⼦函数，如果微应⽤没有导出这三个⽣命周期钩⼦函数，则微应⽤会加载失败。 

如果我们使⽤了脚⼿架搭建微应⽤的话，我们可以通过 webpack 配置在⼊⼝⽂件处导出这三个⽣命周期 钩⼦函数。如果没有使⽤脚⼿架的话，也可以直接在微应⽤的 window 上挂载这三个⽣命周期钩⼦函数。

**接入vue微应用**

使⽤ vue-cli 先创建⼀个 Vue 的项⽬，在命令⾏运⾏如下命令： 

```bash
npm install -g @vue/cli
vue create micro-sub-app-vue // 选择vue2
```

**配置微应⽤**

在主应⽤注册好了微应⽤后，我们还需要对微应⽤进⾏⼀系列的配置。⾸先，我们在 Vue 的⼊⼝⽂件 main.js 中，导出 qiankun 主应⽤所需要的三个⽣命周期钩⼦函数，代码实现如下：

Main.js

```js
import './public-path';
import Vue from 'vue';
import App from './App.vue';
Vue.config.productionTip = false;
let instance = null;
function render() {
 instance = new Vue({
 render: (h) => h(App),
 }).$mount('#app'); }
render();
// 独⽴运⾏时
if (!window.__POWERED_BY_QIANKUN__) {
 render(); }
export async function bootstrap() {
 console.log('[vue1] vue1 app bootstraped'); }
export async function mount(props) {
 console.log('[vue1] props from main framework mount', props);
 render(props); }
export async function unmount() {
 instance.$destroy();
 instance = null; }
```

在配置好了⼊⼝⽂件 main.js 后，我们还需要配置 webpack，使 main.js 导出的⽣命周期钩⼦函 数可以被 qiankun 识别获取。 

我们直接配置 vue.config.js 即可，代码实现如下：

```js
const { name } = require("./package");
module.exports = {
 devServer: {
 // 配置下⾯内容 否则主应⽤访问会报跨域
 headers: {
 // 配置跨域请求头，解决开发环境的跨域问题
 "Access-Control-Allow-Origin": "*",
 },
 port: "3001",
 },
 configureWebpack: {
 output: {
 library: `${name}-[name]`,
 libraryTarget: "umd", // 把微应⽤打包成 umd 库格式
 chunkLoadingGlobal: `webpackJsonp_${name}`,
 },
 }, }
```

我们需要重点关注⼀下 output 选项，当我们把 libraryTarget 设置为 umd 后，我们的 library 就暴露为所有的模块定义下都可运⾏的⽅式了，主应⽤就可以获取到微应⽤的⽣命周期钩⼦函数了。 

在 vue.config.js 修改完成后，我们重新启动 Vue 微应⽤，然后打开主应⽤基座 http://localhost:3000。我们点击左侧菜单切换到微应⽤，此时我们的 Vue 微应⽤被正确加载！ 

到这⾥，Vue 微应⽤就接⼊成功了！ 

Public-path.js

```js
if (window.__POWERED_BY_QIANKUN__) {
 window.__webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN
__
}
```

**参考链接**

qiankun https://qiankun.umijs.org/zh 

# **微前端（下）**

### **1. 课程目标**

1. qiankun整体运行流程

2. 微前端实现方案

### **2. 课程大纲**

1. qiankun整体流程

2. 微前端方案实现

3. DIY微前端核心能力

### **3 微前端方案实现**

- 基于 iframe 完全隔离的方案、使用纯的Web Components构建应用

- EMP基于webpack module federation

- qiankun、icestark 自己实现JS以及样式隔离

### **4. qiankun整体运行流程**

![micro-frontend-5](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontend-5.jpg)



### **5 DIY微前端核心能力**

**应用注册** **registerMicroApps(apps, lifeCycles?)**

- 参数

- - apps - Array<RegistrableApp> - 必选，微应用的一些注册信息

- - lifeCycles - LifeCycles - 可选，全局的微应用生命周期钩子

- 类型

- - RegistrableApp

- - - name - string - 必选，微应用的名称，微应用之间必须确保唯一。

- - - entry - string - 必选，微应用的入口。

- - - container - string | HTMLElement - 必选，微应用的容器节点的选择器或者 Element 实例

- - - activeRule - string | (location: Location) => boolean | Array<string | (location: Location) => boolean> - 必选，微应用的激活规则

- - LifeCyclest

- - - type Lifecycle = (app: RegistrableApp) => Promise<any>;

- - - beforeMount - Lifecycle | Array<Lifecycle> - 可选

- - - beforeUnmount - Lifecycle | Array<Lifecycle> - 可选

- - - afterUnmount - Lifecycle | Array<Lifecycle> - 可选

**监听路由变化**

hash模式

history模式

**如何实现前端路由？**

要实现前端路由，需要解决两个核心问题：

如何改变 URL 却不引起页面刷新？

如何检测 URL 变化了？

下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。

**hash 实现**

hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新

通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：

通过浏览器前进后退改变 URL

通过标签改变 URL

通过window.location改变URL

这几种情况改变 URL 都会触发 hashchange 事件

```js
// 监听路由变化

window.addEventListener('hashchange', onHashChange)
```

**history 实现**history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新

history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：

- 通过浏览器前进后退改变 URL 时会触发 popstate 事件，

- 通过pushState/replaceState或标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState

/replaceState的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。

```js
// 监听浏览器前进后退改变URL

window.addEventListener("popstate", onPopState);
```

![micro-frontend-6](/Volumes/F/zyl-study/web-zhuawa/20221203/micro-frontend-6.jpg)



### **路由劫持**

- 路由变化时匹配子应用

- 子应用生命周期

- 加载子应用

**生命周期**

- 主应用

- - beforeLoad: 挂载子应用前

- - mounted: 挂载子应用后

- - ummounted: 卸载子应用后

- 子应用

- - bootstrap： bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。

- - mount: 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法unmount: 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例

**资源加载**

- 加载样式表

- 加载js资源

- 执行js代码

**预加载**

### **具体实现**

**依赖包**

```js
"import-html-entry": "^1.12.0",
"path-to-regexp": "^6.2.1",
"qiankun": "^2.7.4"
```

**start入口**

```js
import { IAppInfo, ILifeCycle } from './types';
import { setAppList, getAppList } from './appList/index';
import { setLifeCycle } from './lifeCycle/index';
import { hackRoute, reRoute } from './route/index';
export const registerMicroApps = (
 appList: IAppInfo[],
 lifeCycle?: ILifeCycle
) => {
 appList && setAppList(appList);
 lifeCycle && setLifeCycle(lifeCycle);
};
export const start = () => {
     const list = getAppList();
 if (!list.length) {
 throw new Error('请先注册应用');
 }
 hackRoute();
 reRoute(window.location.href);
};
```

**存储appList**

```js
// appList/index
import { IAppInfo } from '../types';
let appList: IAppInfo[] = [];
export const setAppList = (list: IAppInfo[]): void => {
 appList = list;
};
export const getAppList = () => {
 return appList;
};
// 存储全局应用信息
```

**存储lifeCycle 以及生命周期方法的实现**

```js
import { ILifeCycle, IInternalAppInfo, IAppInfo } from '../types';
import { EAppStatus } from '../enum';
import { loadHTML } from '../loader'
let lifeCycle: ILifeCycle = {};
export const setLifeCycle = (lifeCycles: ILifeCycle): void => {
 lifeCycle = lifeCycles;
};
export const getLifeCycle = () => {
 return lifeCycle;
};
// 存储全局生命周期
// 卸载
export const runUnMounted = async (app: IInternalAppInfo) => {
 app.status = EAppStatus.UNMOUNTING;
 await app.unmounted?.(app);
 app.status = EAppStatus.NOT_MOUNTED;
 await runLifeCycle('unmounted', app);
};
// 初始化 只执行一次
export const runBootstrap = async (app: IInternalAppInfo) => {
 if (app.status !== EAppStatus.LOADED) {
 return app;
 }
 app.status = EAppStatus.BOOTSTRAPING;
     await app.bootstrap?.(app);
 app.status = EAppStatus.NOT_MOUNTED;
};
// 挂载 可多次执行
export const runMounted = async (app: IInternalAppInfo) => {
 app.status = EAppStatus.MOUNTING;
 await app.mounted?.(app);
 app.status = EAppStatus.MOUNTED;
 // 处理对应子应用生命周期
 await runLifeCycle('mounted', app);
};
// 加载前
export const runBeforeLoad = async (app: IInternalAppInfo) => {
 app.status = EAppStatus.LOADING;
 await runLifeCycle('beforeLoad', app);
 // 加载子应用资源
 // app = await loadHTML(app)
 app.status = EAppStatus.LOADED;
};
const runLifeCycle = async (name: keyof ILifeCycle, app: IAppInfo) => {
 // lifeCycles - LifeCycles - 可选，全局的微应用生命周期钩子
 const fn = lifeCycle[name];
 if (fn instanceof Array) {
 await Promise.all(fn.map((item) => item(app)));
 } else {
 await fn?.(app);
 }
};
```

**TS相关类型-枚举**

```js
export enum EAppStatus {
 NOT_FOUND = 'NOT_FOUND',
 NOT_LOADED = 'NOT_LOADED',
 LOADING = 'LOADING',
 LOADED = 'LOADED',
 BOOTSTRAPPING = 'BOOTSTRAPPING',
 NOT_MOUNTED = 'NOT_MOUNTED',
 MOUNTING = 'MOUNTING',
 UNMOUNTED = 'UNMOUNTED',
 MOUNTED = 'MOUNTED',
 UNMOUNTING = 'UNMOUNTING',
}
```

**TS相关类型**

```js
export interface IAppInfo {
 name: string
 entry: string
 container: string
 activeRule: string
}
export type Lifecycle = (app: IAppInfo) => Promise<any>
export interface ILifecycle {
 beforeLoad?: Lifecycle | Lifecycle[]
 mounted?: Lifecycle | Lifecycle[]
 unmounted?: Lifecycle | Lifecycle
}
export interface IInternalAppInfo extends IAppInfo {
 status: EAppStatus
 bootstrap?: Lifecycle
 mount?: Lifecycle
 unmount?: Lifecycle
 proxy: any
}
export type EventType = 'hashchange' | 'popstate'
```

**路由拦截实现**

```js
import { EventType } from '../types'
import {
 runBoostrap,
 runBeforeLoad,
 runMounted,
 runUnmounted,
} from '../lifeCycle'
import { getAppListStatus } from '../utils'
const capturedListeners: Record<EventType, Function[]> = {
 hashchange: [],
 popstate: [],
}
// 劫持和 history 和 hash 相关的事件和函数
// 然后我们在劫持的方法里做一些自己的事情
// 比如说在 URL 发生改变的时候判断当前是否切换了子应用
const originalPush = window.history.pushState
const originalReplace = window.history.replaceState
let historyEvent: PopStateEvent | null = null
let lastUrl: string | null = null
export const reroute = (url: string) => {
 if (url !== lastUrl) {
 const { actives, unmounts } = getAppListStatus()
 Promise.all(
 unmounts
 .map(async (app) => {
 await runUnmounted(app)
 })
 .concat(
 actives.map(async (app) => {
 await runBeforeLoad(app)
      await runBoostrap(app)
 await runMounted(app)
 })
 )
 ).then(() => {
 callCapturedListeners()
 })
 }
 lastUrl = url || location.href
}
const handleUrlChange = () => {
 reroute(location.href)
}
export const hackRoute = () => {
 window.history.pushState = (...args) => {
 originalPush.apply(window.history, args)
 historyEvent = new PopStateEvent('popstate')
 args[2] && reroute(args[2] as string)
 }
 window.history.replaceState = (...args) => {
 originalReplace.apply(window.history, args)
 historyEvent = new PopStateEvent('popstate')
 args[2] && reroute(args[2] as string)
 }
 window.addEventListener('hashchange', handleUrlChange)
 window.addEventListener('popstate', handleUrlChange)
 window.addEventListener = hackEventListener(window.addEventListener)
 window.removeEventListener = hackEventListener(window.removeEventListener)
}
const hasListeners = (name: EventType, fn: Function) => {
 return capturedListeners[name].filter((listener) => listener === fn).length
}
const hackEventListener = (func: Function): any => {
 return function (name: string, fn: Function) {
 if (name === 'hashchange' || name === 'popstate') {
 if (!hasListeners(name, fn)) {
 capturedListeners[name].push(fn)
 return
 } else {
 capturedListeners[name] = capturedListeners[name].filter(
 (listener) => listener !== fn
 )
 }
 }
 return func.apply(window, arguments)
 }
}
export function callCapturedListeners() {
 if (historyEvent) {
 Object.keys(capturedListeners).forEach((eventName) => {
 const listeners = capturedListeners[eventName as EventType]
 if (listeners.length) {
 listeners.forEach((listener) => {
 // @ts-ignore
 listener.call(this, historyEvent)
 })
 }
 })
 historyEvent = null
 }
}
export function cleanCapturedListeners() {
 capturedListeners['hashchange'] = []
 capturedListeners['popstate'] = []
}
```

**loader 加载器**

```js
import { IInternalAppInfo } from '../types'
import { importEntry } from 'import-html-entry'
import { ProxySandbox } from './sandbox'
export const loadHTML = async (app: IInternalAppInfo) => {
 const { container, entry } = app
 const { template, getExternalScripts, getExternalStyleSheets } =
 await importEntry(entry)
 const dom = document.querySelector(container)
 if (!dom) {
 throw new Error('容器不存在')
 }
 dom.innerHTML = template
 await getExternalStyleSheets()
 const jsCode = await getExternalScripts()
 jsCode.forEach((script) => {
 const lifeCycle = runJS(script, app)
 if (lifeCycle) {
 app.bootstrap = lifeCycle.bootstrap
 app.mount = lifeCycle.mount
 app.unmount = lifeCycle.unmount
 }
 })
 return app
}
const runJS = (value: string, app: IInternalAppInfo) => {
 if (!app.proxy) {
 app.proxy = new ProxySandbox()
 // @ts-ignore
 window.__CURRENT_PROXY__ = app.proxy.proxy
 }
     app.proxy.active()
 const code = `
 return (window => {
 ${value}
 return window['${app.name}']
 })(window.__CURRENT_PROXY__)
 `
 return new Function(code)()
}
```

**ProxySandbox**

```js
export class ProxySandbox {
 proxy: any
 running = false
 constructor() {
 const fakeWindow = Object.create(null)
 const proxy = new Proxy(fakeWindow, {
 set: (target: any, p: string, value: any) => {
 if (this.running) {
 target[p] = value
 }
 return true
 },
 get(target: any, p: string): any {
 switch (p) {
 case 'window':
 case 'self':
 case 'globalThis':
 return proxy
 }
 if (
 !window.hasOwnProperty.call(target, p) &&
 window.hasOwnProperty(p)
 ) {
 // @ts-ignore
 const value = window[p]
 if (typeof value === 'function') return value.bind(window)
 return value
 }
 return target[p]
 },
 has() {
 return true
 },
 })
 this.proxy = proxy
 }
 active() {
 this.running = true
 }
 inactive() {
 this.running = false
 }
}
```

**预加载**

```js
export const prefetch = async (app: IInternalAppInfo) => {
 requestIdleCallback(async () => {
 const { getExternalScripts, getExternalStyleSheets } = await importEntry(
 app.entry
 )
 requestIdleCallback(getExternalStyleSheets)
 requestIdleCallback(getExternalScripts)
 })
}
```

# 前端AST & 脚手架实现

https://www.yuque.com/lpldplws/web/og6swa9wsde8lc8b?#《前端AST》 密码：lxee

### 1. 课程目标 

1. AST 介绍

2. 掌握编译原理的基本思路

3. 掌握一个简单的编译器的实现

4. 脚手架的核心原理

### 2. 课程大纲 

- 什么是编译器；

- 编译器的基本思路；

- 一个简单的编译器的实现；

### 3.什么是AST 

AST技术是现代前端基建和工程化建设的基石，可能很多人没有听说过AST，但是现在开发框架，尤其是构建工具中，离不开AST的相关技术。

● 构建工具
	○ webpack plugin  loader
	○  babel
	○ postcss
	○ eslint
● 开发框架
	○ vue 模板解析 compile
	○ React的jsx解析 

### 为什么语言需要降级 

ECMAScript的标准的发布，很多时候要优先于浏览器厂商的更新，更加优先于用户浏览器的更新。

#### AST概念 

抽象语法树（abstract syntax code，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，之所以说是抽象的，抽象表示把js代码进行了结构化的转化，转化为一种数据结构。这种数据结构其实就是一个大的json对象，json我们都熟悉，他就像一颗枝繁叶茂的树。有树根，有树干，有树枝，有树叶，无论多小多大，都是一棵完整的树。 

### 4. AST流程 

什么是编译？ 

从一种高级语言，转换成另一种低级语言。

高级语言：JS、JAVA、C、Golang等有很多用于描述逻辑的语言特性，比如 分支、循环、函数、判断等，接近人的思维，可以让开发快速掌握。

低级语言： 汇编语言 机器语言，和硬件和执行细节有关的，会操作寄存器、内存。需要开发者理解熟悉计算机的工作原理。

转化过程就是编译原理的过程。

前端：从比较高级的语言->比较低级 应用层面

前端编译：

- ES6->ES5

- Less/Sass -> css

- TS -> js

compiler也叫编译器，是一种电脑程序，它会将用某种编程语言写成的源代码，转换成另一种编程语言。

从维基百科的定义来看，编译器就是个将当前语言转为其他语言的过程，回到babel上，它所做的事就是语法糖之类的转换，比如ES6/ES7/JSX转为ES5或者其他指定版本，因此称之为compiler也是正确的，换言之，像我们平时开发过程中所谓的其他工具，如：

- Less/Saas

- TypeScript/coffeeScript

- Eslint

- etc...

都可以看到compiler的身影，也是通过这些工具，才使得目前的前端工程化能走入相对的深水区，以下会详细介绍下compiler的实现思路及具体demo，帮助同学们了解compiler的基本实现。

### 5. 编译器的基本思路 

此处主要讲解compiler的思路

#### 5.1. 词法分析(tokenizer) 

#### 5.1.1. 目的 

将文本分割成一个个的“token”，例如：init、main、init、x、;、x、=、3、;、}等等。同时它可以去掉一些注释、空格、回车等等无效字符；

#### 5.1.2. 生成方式 

词法分析生成token的办法有2种：

 1. 使用正则进行词法分析

需要写大量的正则表达式，正则之间还有冲突需要处理，不容易维护，性能不高，所以正则只适合一些简单的模板语法，真正复杂的语言并不合适。并且有的语言并不一定自带正则引擎。

2. 使用自动机进行词法分析

自动机可以很好的生成token；

有穷状态自动机（finite state machine）：在有限个输入的情况下，在这些状态中转移并期望最终达到终止状态。

有穷状态自动机根据确定性可以分为：

“确定有穷状态自动机”（DFA - Deterministic finite automaton）

在输入一个状态时，只得到一个固定的状态。DFA 可以认为是一种特殊的 NFA；

“非确定有穷自动机”（NFA - Non-deterministic finite automaton）

当输入一个字符或者条件得到一个状态机的集合。JavaScript 正则采用的是 NFA 引擎，具体看后文；

### 5.2. 语法分析(Syntactic Analysis) 

我们日常所说的编译原理就是将一种语言转换为另一种语言。编译原理被称为形式语言，它是一类无需知道太多语言背景、无歧义的语言。而自然语言通常难以处理，主要是因为难以识别语言中哪些是名词哪些是动词哪些是形容词。例如：“进口汽车”这句话，“进口”到底是动词还是形容词？所以我们要解析一门语言，前提是这门语言有严格的语法规定的语言，而定义语言的语法规格称为文法。

1956年，乔姆斯基将文法按照规范的严格性分为0型、1型、2型和3型共4中文法，从0到3文法规则是逐渐增加严的。一般的计算机语言是2型，因为0和1型文法定义宽松，将大大增加解析难度、降低解析效率，而3型文法限制又多，不利于语言设计灵活性。2型文法也叫做上下文无关文法（CFG）。  语法分析的目的就是通过词法分析器拿到的token流 + 结合文法规则，通过一定算法得到一颗抽象语法树（AST）。抽象语法树是非常重要的概念，尤其在前端领域应用很广。典型应用如babel插件，它的原理就是：es6代码 → Babylon.parse → AST → babel-traverse → 新的AST → es5代码。  从生成AST效率和实现难度上，前人总结主要有2种解析算法：自顶向下的分析方法和自底向上的分析方法。自底向上算法分析文法范围广，但实现难度大。而自顶向下算法实现相对简单，并且能够解析文法的范围也不错，所以一般的compiler都是采用深度优先索引的方式。

### 5.3. 代码转换（Transformation） 

在得到AST后，我们一般会先将AST转为另一种AST，目的是生成更符合预期的AST，这一步称为代码转换。

代码转换的优势：主要是产生工程上的意义

- 易移植：与机器无关，所以它作为中间语言可以为生成多种不同型号的目标机器码服务；

- 机器无关优化：对中间码进行机器无关优化，利于提高代码质量；

- 层次清晰：将AST映射成中间代码表示，再映射成目标代码的工作分层进行，使编译算法更加清晰 ；

对于一个Compiler而言，在转换阶段通常有两种形式：

同语言的AST转换；

AST转换为新语言的AST；

这里有一种通用的做法是，对我们之前的AST从上至下的解析（称为traversal），然后会有个映射表（称为visitor），把对应的类型做相应的转换。

### 5.4. 代码生成 (Code Generation) 

在实际的代码处理过程中，可能会递归的分析（recursive）我们最终生成的AST，然后对于每种type都有个对应的函数处理，当然，这可能是最简单的做法。总之，我们的目标代码会在这一步输出，对于我们的目标语言，它就是HTML了。

### 5.5. 完整链路(Compiler) 

至此，我们就完成了一个完整的compiler的所有过程：

```js
input => tokenizer => tokens; // 词法分析
tokens => parser => ast; // 语法分析，生成AST
ast => transformer => newAst; // 中间层代码转换
newAst => generator => output; // 生成目标代码
```

## 6. 一个简单的编译器的实现 

此处实现一个基础的compiler

### 6.1. 前置内容

```js
/**
 * 今天我们会一起编写一个编译器。一个非常非常简化的微型编译器！这个编译器非常小，如果你移除这个
 * 文件里的注释，那么这个文件只剩下大概200行代码。
 *
 * 我们会将类似于LISP的函数调用编译成类似于C的函数调用。
 *
 * 如果你对这两个语言中的一个或者两个不熟悉。下面是一个快速的介绍。
 *
 * 如果我有两个函数`add`和`subtract`，它们会像下面这样被写出来：
 *
 *                  LISP                      C
 *
 *   2 + 2          (add 2 2)                 add(2, 2)
 *   4 - 2          (subtract 4 2)            subtract(4, 2)
 *   2 + (4 - 2)    (add 2 (subtract 4 2))    add(2, subtract(4, 2))
 *
 * 非常简单直观不是吗？
 *
 * 非常好，因为这就是我们要编译的代码。尽管这并不是一个完整的LISP或者C的编译器，但是它足够展示
 * 现代编译器的很多大部分组成部件。
 */


/**
 * 大多数编译器分为三个主要阶段：解析、转换、
 * 和代码生成
 *
 * 1. *解析* 将原始代码转化为更抽象的代码
 * 代码的表示。
 *
 * 2. *转换* 采用这种抽象表示并进行操作
 * 无论编译器想要什么。
 *
 * 3. *代码生成*采用转换后的代码表示，并
 * 将其转换为新代码。
 */
```

```js
/**
 * 解析
 * --------
 *
 * 解析通常分为两个阶段：词法分析和
 * 句法分析。
 *
 * 1. *词法分析*获取原始代码并将其拆分成这些东西
 * 被称为标记器（或词法分析器）的东西称为标记。
 *
 * Tokens 是一组微小的对象，描述了一个孤立的部分
 * 的语法。它们可以是数字、标签、标点符号、运算符、
 *    任何。
 *
 * 2. *句法分析*获取标记并将它们重新格式化为
 * 描述语法的每个部分及其关系的表示
 *    彼此。这被称为中间表示或
 * 抽象语法树。
 *
 * 抽象语法树，简称 AST，是一个深度嵌套的对象，
 * 以一种既易于使用又能告诉我们很多信息的方式表示代码
 * 信息。
 *
 * 对于以下语法：
 *
 * (加 2 (减 4 2))
 *
 * 令牌可能看起来像这样：
 *
 *   [
 *     { type: 'paren',  value: '('        },
 *     { type: 'name',   value: 'add'      },
 *     { type: 'number', value: '2'        },
 *     { type: 'paren',  value: '('        },
 *     { type: 'name',   value: 'subtract' },
 *     { type: 'number', value: '4'        },
 *     { type: 'number', value: '2'        },
 *     { type: 'paren',  value: ')'        },
 *     { type: 'paren',  value: ')'        },
 *   ]
 *
 * 抽象语法树 (AST) 可能如下所示：
 *
 *   {
 *     type: 'Program',
 *     body: [{
 *       type: 'CallExpression',
 *       name: 'add',
 *       params: [{
 *         type: 'NumberLiteral',
 *         value: '2',
 *       }, {
 *         type: 'CallExpression',
 *         name: 'subtract',
 *         params: [{
 *           type: 'NumberLiteral',
 *           value: '4',
 *         }, {
 *           type: 'NumberLiteral',
 *           value: '2',
 *         }]
 *       }]
 *     }]
 *   }
 */
```

```js
/**
 * 转换
 * --------------
 *
 * 编译器的下一个阶段是转换。再次，这只是
 * 从最后一步获取 AST 并对其进行更改。它可以操纵
 * 使用相同语言的 AST，或者它可以将其翻译成全新的
 * 语。
 *
 * 让我们看看如何转换 AST。
 *
 * 您可能会注意到我们的 AST 中的元素看起来非常相似。
 * 这些对象具有类型属性。这些中的每一个都被称为
 * AST 节点。这些节点在它们上定义了描述一个
 * 树的隔离部分。
 *
 * 我们可以有一个“NumberLiteral”的节点：
 *
*   {
 *     type: 'NumberLiteral',
 *     value: '2',
 *   }
 *
 * Or maybe a node for a "CallExpression":
 *
 *   {
 *     type: 'CallExpression',
 *     name: 'subtract',
 *     params: [...nested nodes go here...],
 *   }
 *
 * 转换 AST 时，我们可以通过以下方式操作节点
 * 添加/删除/替换属性，我们可以添加新节点，删除节点，或者
 * 我们可以不理会现有的 AST 并创建一个全新的基于
 * 在上面。
 *
 * 由于我们的目标是一种新语言，我们将专注于创建一个
 * 特定于目标语言的全新 AST。
 *
 * 遍历
 * ---------
 *
 * 为了浏览所有这些节点，我们需要能够
 * 遍历它们。这个遍历过程会到达 AST 中的每个节点
 * 深度优先。
 *
 *   {
 *     type: 'Program',
 *     body: [{
 *       type: 'CallExpression',
 *       name: 'add',
 *       params: [{
 *         type: 'NumberLiteral',
 *         value: '2'
 *       }, {
 *         type: 'CallExpression',
 *         name: 'subtract',
 *         params: [{
 *           type: 'NumberLiteral',
 *           value: '4'
 *         }, {
 *           type: 'NumberLiteral',
 *           value: '2'
 *         }]
 *       }]
 *     }]
 *   }
 *
 * 所以对于上面的 AST，我们会去：
 *
 * 1. Program - 从 AST 的顶层开始
 * 2. CallExpression (add) - 移动到程序主体的第一个元素
 * 3. NumberLiteral (2) - 移动到 CallExpression 参数的第一个元素
 * 4. CallExpression (subtract) - 移动到 CallExpression 参数的第二个元素
 * 5. NumberLiteral (4) - 移动到 CallExpression 参数的第一个元素
 * 6. NumberLiteral (2) - 移动到 CallExpression 参数的第二个元素
 *
 * 如果我们直接操作这个 AST，而不是创建一个单独的 AST，
 * 我们可能会在这里引入各种抽象。但只是参观
 * 树中的每个节点都足以完成我们正在尝试做的事情。
 *
 * 我使用“访问”这个词的原因是因为有这样的模式
 * 表示对对象结构元素的操作。
*
 * Visitors
 * --------
 *
 * 这里的基本思想是我们将创建一个“访问者”对象，
 * 具有将接受不同节点类型的方法。
 *
 *   var visitor = {
 *     NumberLiteral() {},
 *     CallExpression() {},
 *   };
 *
 * 当我们遍历我们的 AST 时，我们会在任何时候调用这个访问者的方法
 * “输入”一个匹配类型的节点。
 *
 * 为了使它有用，我们还将传递节点和引用
 * 父节点。
 *
 *   var visitor = {
 *     NumberLiteral(node, parent) {},
 *     CallExpression(node, parent) {},
 *   };
 *
 * 但是，也存在在“退出”时调用事物的可能性。想象
 * 我们之前的树形结构以列表形式：
 *
 *   - Program
 *     - CallExpression
 *       - NumberLiteral
 *       - CallExpression
 *         - NumberLiteral
 *         - NumberLiteral
 *
 * 当我们向下遍历时，我们将到达有死胡同的分支。正如我们
 * 完成我们“退出”它的树的每个分支。所以我们顺着树走
 *“进入”每个节点，然后返回我们“退出”。
 *
 *   -> Program (enter)
 *     -> CallExpression (enter)
 *       -> Number Literal (enter)
 *       <- Number Literal (exit)
 *       -> Call Expression (enter)
 *          -> Number Literal (enter)
 *          <- Number Literal (exit)
 *          -> Number Literal (enter)
 *          <- Number Literal (exit)
 *       <- CallExpression (exit)
 *     <- CallExpression (exit)
 *   <- Program (exit)
 *
 * 为了支持这一点，我们的访问者的最终形式将如下所示：
 *
 *   var visitor = {
 *     NumberLiteral: {
 *       enter(node, parent) {},
 *       exit(node, parent) {},
 *     }
 *   };
 */
 
```

```js
/**
 * 代码生成
 * ---------------
 *
 * 编译器的最后阶段是代码生成。有时编译器会做
 * 与转换重叠的东西，但大部分是代码
 * 生成只是意味着取出我们的 AST 和字符串化代码。
 *
 * 代码生成器有几种不同的工作方式，一些编译器会重用
 * 早期的令牌，其他人将创建一个单独的表示
 *代码，以便他们可以线性打印节点，但据我所知
 * 将使用我们刚刚创建的相同 AST，这是我们将重点关注的内容。
 *
 * 实际上，我们的代码生成器将知道如何“打印”所有不同的
 * AST的节点类型，它会递归调用自己打印嵌套
 * 节点，直到所有内容都打印成一长串代码。
 */

/**
 *就是这样！这就是编译器的所有不同部分。
 *
 * 现在这并不是说每个编译器看起来都和我在这里描述的完全一样。
 * 编译器有许多不同的用途，它们可能需要更多的步骤
 * 我有详细的。
 *
 * 但是现在您应该对大多数编译器的外观有一个大致的高级概念
 * 喜欢。
 *
 * 现在我已经解释了所有这些，你们都可以自己写了
 * 编译器对吗？
 *
 * 开个玩笑，这就是我来帮忙的：P
 *
 * 那么让我们开始吧...
 */
```

### **6.2. 词法分析**

```js
/**
 * ============================================================================
 *                                   (/^▽^)/
 *                                词法分析！
 * ============================================================================
 */

function tokenizer(input) {
  let current = 0;

  let tokens = [];

  while (current < input.length) {
    let char = input[current];

    if (char === '(') {
      tokens.push({
        type: 'paren',
        value: '(',
      });

      current++;

      continue;
    }

    if (char === ')') {
      tokens.push({
        type: 'paren',
        value: ')',
      });
      current++;
      continue;
    }

    let WHITESPACE = /\s/;
      if (WHITESPACE.test(char)) {
      current++;
      continue;
    }

    let NUMBERS = /[0-9]/;
    if (NUMBERS.test(char)) {
      let value = '';

      while (NUMBERS.test(char)) {
        value += char;
        char = input[++current];
      }

      tokens.push({ type: 'number', value });

      continue;
    }

    if (char === '"') {
      let value = '';

      char = input[++current];

      while (char !== '"') {
        value += char;
        char = input[++current];
      }

      char = input[++current];

      tokens.push({ type: 'string', value });

      continue;
    }

    let LETTERS = /[a-z]/i;
    if (LETTERS.test(char)) {
      let value = '';

      while (LETTERS.test(char)) {
        value += char;
        char = input[++current];
      }

      tokens.push({ type: 'name', value });

      continue;
    }
    throw new TypeError('I dont know what this character is: ' + char);
  }
  return tokens;
}
```

### **6.3. 语法分析**

```js
/**
 * ============================================================================
 *                                 ヽ/❀o ل͜ o\ﾉ
 *                                THE 解析!!!
 * ============================================================================
 */

function parser(tokens) {
  let current = 0;

  function walk() {
    let token = tokens[current];

    if (token.type === 'number') {
      current++;

      return {
        type: 'NumberLiteral',
        value: token.value,
      };
    }

    if (token.type === 'string') {
      current++;

      return {
        type: 'StringLiteral',
        value: token.value,
      };
    }

    if (token.type === 'paren' && token.value === '(') {
      token = tokens[++current];

      let node = {
        type: 'CallExpression',
        name: token.value,
        params: [],
      };

      token = tokens[++current];

      while (token.type !== 'paren' || (token.type === 'paren' && token.value !== ')')) {
        node.params.push(walk());
        token = tokens[current];
      }

      current++;

      return node;
    }

    throw new TypeError(token.type);
  }

  let ast = {
    type: 'Program',
    body: [],
  };

  while (current < tokens.length) {
    ast.body.push(walk());
  }
  return ast;
}
```

### **6.4. 代码转换**

```js
/**
 * ============================================================================
 *                                 ⌒(❀>◞౪◟<❀)⌒
 *                              代码转换方法!!!
 * ============================================================================
 */

function traverser(ast, visitor) {
  function traverseArray(array, parent) {
    array.forEach(child => {
      traverseNode(child, parent);
    });
  }

  function traverseNode(node, parent) {
    let methods = visitor[node.type];

    if (methods && methods.enter) {
      methods.enter(node, parent);
    }

    switch (node.type) {
      case 'Program':
        traverseArray(node.body, node);
        break;

      case 'CallExpression':
        traverseArray(node.params, node);
        break;

      case 'NumberLiteral':
      case 'StringLiteral':
        break;

      default:
        throw new TypeError(node.type);
    }

    if (methods && methods.exit) {
      methods.exit(node, parent);
    }
  }

  traverseNode(ast, null);
}

/**
 * ============================================================================
 *                                   ⁽(◍˃̵͈̑ᴗ˂̵͈̑)⁽
 *                              代码转换!!!
 * ============================================================================
 */

/**
 *
 * ----------------------------------------------------------------------------
 *   Original AST                     |   Transformed AST
 * ----------------------------------------------------------------------------
 *   {                                |   {
 *     type: 'Program',               |     type: 'Program',
 *     body: [{                       |     body: [{
 *       type: 'CallExpression',      |       type: 'ExpressionStatement',
 *       name: 'add',                 |       expression: {
 *       params: [{                   |         type: 'CallExpression',
 *         type: 'NumberLiteral',     |         callee: {
 *         value: '2'                 |           type: 'Identifier',

*       }, {                         |           name: 'add'
 *         type: 'CallExpression',    |         },
 *         name: 'subtract',          |         arguments: [{
 *         params: [{                 |           type: 'NumberLiteral',
 *           type: 'NumberLiteral',   |           value: '2'
 *           value: '4'               |         }, {
 *         }, {                       |           type: 'CallExpression',
 *           type: 'NumberLiteral',   |           callee: {
 *           value: '2'               |             type: 'Identifier',
 *         }]                         |             name: 'subtract'
 *       }]                           |           },
 *     }]                             |           arguments: [{
 *   }                                |             type: 'NumberLiteral',
 *                                    |             value: '4'
 * ---------------------------------- |           }, {
 *                                    |             type: 'NumberLiteral',
 *                                    |             value: '2'
 *                                    |           }]
 *  (sorry the other one is longer.)  |         }
 *                                    |       }
 *                                    |     }]
 *                                    |   }
 * ----------------------------------------------------------------------------
 */

function transformer(ast) {
  let newAst = {
    type: 'Program',
    body: [],
  };

  ast._context = newAst.body;

  traverser(ast, {
    NumberLiteral: {
      enter(node, parent) {
        parent._context.push({
          type: 'NumberLiteral',
          value: node.value,
        });
      },
    },

    StringLiteral: {
      enter(node, parent) {
        parent._context.push({
          type: 'StringLiteral',
          value: node.value,
        });
      },
    },

    CallExpression: {
      enter(node, parent) {
        let expression = {
          type: 'CallExpression',
          callee: {
            type: 'Identifier',
            name: node.name,
          },
          arguments: [],
        };

        node._context = expression.arguments;

        if (parent.type !== 'CallExpression') {
          expression = {
            type: 'ExpressionStatement',
            expression: expression,
          };
        }

        parent._context.push(expression);
      },
    },
  });

  return newAst;
}

```

### 6.5代码生成

```js
/**
 * ============================================================================
 *                               ヾ（〃＾∇＾）ﾉ♪
 *                            代码生成!!!!
 * ============================================================================
 */

function codeGenerator(node) {
  switch (node.type) {
    case 'Program':
      return node.body.map(codeGenerator).join('\n');

    case 'ExpressionStatement':
      return (
        codeGenerator(node.expression) + ';' // << (...because we like to code the *correct* way)
      );

    case 'CallExpression':
      return codeGenerator(node.callee) + '(' + node.arguments.map(codeGenerator).join(', ') + ')';

    case 'Identifier':
      return node.name;

    case 'NumberLiteral':
      return node.value;

    case 'StringLiteral':
      return '"' + node.value + '"';

    default:
      throw new TypeError(node.type);
  }
}
```

### **6.6. 完整流程**

```js
/**
 * ============================================================================
 *                                  (۶* ‘ヮ’)۶”
 *                         !!!!!!!!完整流程!!!!!!!!
 * ============================================================================
 */

/**
 *
 *   1. input  => tokenizer   => tokens
 *   2. tokens => parser      => ast
 *   3. ast    => transformer => newAst
 *   4. newAst => generator   => output
 */

function compiler(input) {
  let tokens = tokenizer(input);
  let ast = parser(tokens);
  let newAst = transformer(ast);
  let output = codeGenerator(newAst);

  return output;
}

```

## 7.标准 

AST也是有标准的，JS parser的AST的[标准](https://github.com/estree/estree)，Babel的编译，也是遵循这个标准来的。

- Literal 字面量  string | boolean | null | number | RegExp | bigint;

- Identifier 标识符：变量名、属性名、参数名等各种声明和引用的名字

```js
const name = 'bigbear';

function foo(){
  console.log(name)
}
```

- Statement 语句
  ○ 可以独立执行的单位 break、continue、debugger、return、if、while、for、
- Declaration 
  **○** 声明语句
  ○ FunctionDeclaration
  ○ VariableDeclaration
- Expression 
  ○ 表达式

## 8 实战AST DEMO 

聊聊Babel 

用途 

● 转译 esnext、typescript等到目标环境支持的js

● 代码的静态检查

​	○ linter工具、也是基于AST，对代码检查

从 babel7 开始，所有的官方插件和主要模块，都放在了 @babel 的命名空间下。从而可以避免在 npm 仓库中 babel 相关名称被抢注的问题，并且采用了Babel Monorepo风格的仓库。

● @babel/parser: 接受源码，进行词法分析、语法分析，生成AST。

● @babel/traverse：接受一个AST，并对其遍历，根据preset、plugin进行逻辑处理，进行替换、删除、添加节点。

● @babel/generator：接受最终生成的AST，并将其转换为代码字符串，同时此过程也可以创建source map。

● @babel/types：用于检验、构建和改变AST树的节点

```js
const parser = require('@babel/parser');
const traverse = require('@babel/traverse');
const generator = require('@babel/generator');

const transToLet = (code) => {
  const ast = parser.parse(code);
  // 访问者对象
  const visitor = {
    // 遍历声明表达式
    VariableDeclaration(path) {
      if (path.node.type === 'VariableDeclaration') {
        // 替换
        if (path.node.kind === 'var') {
          path.node.kind = 'let';
        }
      }
    },
  };
  traverse.default(ast, visitor);
  // 生成代码
  const newCode = generator.default(ast, {}, code).code;
  return newCode;
};

const code = `const a = 1
var b = 2
let c = 3`;
console.log(transToLet(code));
```

## 9. 附录 

● [the super tiny compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)；

● [JavaScript compiler](https://github.com/jacksplwxy/JavaScript-compiler)；

● [estree](https://github.com/estree/estree)

## 10 脚手架

# webpack

https://www.yuque.com/lpldplws/web/itd4rdqaqqioga10?#《webpack》 密码：nn2p 

```js
const {Configuration} =require('webpack');
/**
 * @type {Configuration} //配置智能提示
 *
 */
```

## webpack 核心概念 

#### Entry 

入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。

进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。

每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。

#### Output 

output 属性告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。

基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。

#### Module 

模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。

#### Chunk 

代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。

#### Loader 

loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。

loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。

本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。

#### Plugin 

loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。

插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。

#### webpack 构建流程 

Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。

2. 开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。

3. 确定入口：根据配置中的 entry 找出所有的入口文件。

4. 编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。

5. 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。

6. 输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。

7. 输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。

在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

## 一、入门webpack配置 

### 1. 初始化项目 

新建一个目录，初始化

```js
npmn  init -y
```

webpack是运行在node环境中的,我们需要安装以下两个npm包

```js
npm i webpack -D
npm i webpack-cli -D
```

- npm i -D 为npm install --save-dev的缩写
- npm i -S 为npm install --save的缩写

### 2 .开始我们自己的配置

上面一个简单的例子只是webpack自己默认的配置，下面我们要实现更加丰富的自定义配置 新建一个build文件夹,里面新建一个webpack.config.js

```js
// webpack.config.js

const path = require('path');
module.exports = {
    mode:'development', // 开发模式 自动优化打包速度 添加一些调试辅助工具
    entry: path.resolve(__dirname,'../src/main.js'),    // 入口文件
    output: {
        filename: 'output.js',      // 打包后的文件名称
        path: path.resolve(__dirname,'../dist'),  // 打包后的目录
        clean: true,
    }
}
```

更改我们的打包命令 

````js
"scripts": {
    "build": "webpack --config build/webpack.config.js"
  },
````

面试题：webpack打包产出特点？分为几大块？每块的作用？

1. 整体为立即执行函数 =》 每个模块都是IIFE =》 避免泄露 =》 webpack通过立即执行函数进行模块化隔离

2. 定义了若干全局变量用来存储和归类模块（缓存模块）+ webpack的模块化功能区域 + 主入口import的执行 +主功能代码逻辑（压缩版）

### 3 配置html模板

#### 3.1 基础配置 

js文件打包好了,但是我们不可能每次在html文件中手动引入打包好的js

这里可能有的朋友会认为我们打包js文件名称不是一直是固定的嘛(output.js)？这样每次就不用改动引入文件名称了呀？实际上我们日常开发中往往会这样配置:

```js
module.exports = {
    mode:'development', // 开发模式
    entry: path.resolve(__dirname,'../src/main.js'),    // 入口文件
    output: {
        filename: '[name].[hash:8].js',      // 打包后的文件名称
        path: path.resolve(__dirname,'../dist')  // 打包后的目录
      }
}
```

这时候生成的dist目录文件如下 

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1670518101565-6a67763a-8498-49a1-ad75-f46d986b8d34.png)



新建一个build同级的文件夹public,里面新建一个index.html，通过HtmlWebpackPlugin生成HTML
**HtmlWebpackPlugin**
简化HTML文件的创建，该插件为你生成一个HTML文件， 在 body 中使用 script 标签引入你所有 webpack 生成的 bundle，插件中引入的script中包含哈希值，伴随着每次编译而改变。

```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development', // 开发模式
  entry: path.resolve(__dirname, '../src/main.js'), // 入口文件
  output: {
    filename: '[name].[hash:8].js', // 打包后的文件名称
    path: path.resolve(__dirname, '../dist'), // 打包后的目录
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, '../public/index.html'),
    }),
  ],
};
```

生成的内容如下

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1670600088459-09f40068-59d6-40b8-8bf6-420b6f5cd947.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)

#### 3.2 自定义HTML注入变量

插件没有配置loader时默认支持的ejs模板引擎

```js
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>

```

[可查看更多配置](https://github.com/jaketrent/html-webpack-template/blob/86f285d5c790a6c15263f5cc50fd666d51f974fd/index.html)

#### 3.3 htmlWebpackPlugin配置项

- template 页面模板
- filename HTML页面名称
- chunks 页面需要引入的js文件
- title 页面标题
- inject script文件插入到HTML中的位置 默认true
- minify: true, // development 默认不压缩 production 默认压缩
  [更多配置项](https://github.com/jantimon/html-webpack-plugin#options)

```js
 plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, '../public/index.html'),
      filename: 'index.html',
      chunks: ['main'],
      title: 'main',
      inject: 'body', // script文件插入到HTML中的位置 默认true 
    }),
    new HtmlWebpackPlugin({
      filename: 'header.html',
      chunks: ['header'],
      title: 'header22',
      minify: true, // development 默认不压缩 production 默认压缩
    }),
  ],
```

#### 3.4 多入口文件如何开发

生成多个html-webpack-plugin实例来解决这个问题

```js
// webpack.config.js

const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development', // 开发模式
  // entry: path.resolve(__dirname, '../src/main.js'), // 入口文件
  entry: {
    main: path.resolve(__dirname, '../src/main.js'),
    header: path.resolve(__dirname, '../src/header.js'),
  },
  output: {
    filename: '[name].[hash:8].js', // 打包后的文件名称
    path: path.resolve(__dirname, '../dist'), // 打包后的目录
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, '../public/index.html'),
      filename: 'index.html',
      chunks: ['main'],
    }),
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, '../public/header.html'),
      filename: 'header.html',
      chunks: ['header'],
    }),
  ],
};
```

此时会发现生成以下目录 

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1670601044216-07ecc389-f6fb-4bcd-abe7-c3105aaae88c.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)



#### **3.5 devServer**

```js
yarn add webpack-dev-server -D
// 
"scripts": {
  "build": "webpack serve --config build/webpack.config.js"
}
```

### 4 引用CSS 

#### 4.1 基础用法 

我们的入口文件是js，所以我们在入口js中引入我们的css文件 

```js
import css from './less/index.css';
console.log(css);

let body = document.getElementsByTagName('body')[0];
let style = document.createElement('style');
style.innerText = css[0][1];
body.appendChild(style);
```

webpack只使用css-loader效果，css-loader打包处理css文件，分析各个css文件之间的依赖关系，返回解析的css内容

```js
module: {
  rules: [
    {
      test: /\.css$/,
      use: ['css-loader'], // 从右往左解析原则
    },
  ],
}
```

css-loader产物

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1670656891715-e92bf644-6253-4198-af74-eaf13b5943ba.png?x-oss-process=image%2Fresize%2Cw_979%2Climit_0)

如果没有style-loader，需要自己挂载css-loader解析的内容

```js
import css from './less/index.css';
console.log(css);

let body = document.getElementsByTagName('body')[0];
let style = document.createElement('style');
style.innerText = css[0][1];
body.appendChild(style);
```

使用style-loader，将css-loader生成的css代码挂载到页面得header部分

```js
module: {
  rules: [
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader'], // 从右往左解析原则
    },
  ],
},
```

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1670657076468-319f33e2-8b7e-4f4b-b807-64bbaf440d18.png?x-oss-process=image%2Fresize%2Cw_792%2Climit_0)



#### 4.2 使用less或者sass等css预处理语言

如果我们使用less来构建样式，则需要多安装两个

```js
npm i -D less less-loader
```

配置文件如下

```js
module: {
  rules: [
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader'], // 从右往左解析原则
    },
    {
      test: /\.less$/,
      use: ['style-loader', 'css-loader', 'less-loader'],
    },
  ],
},
```

浏览器打开html如下

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1670657591456-1b1b98d0-a3ec-48ac-a8b6-eaf648108d9e.png)

#### 4.2 拆分css

因为CSS的下载和JS可以并行,当一个HTML文件很大的时候，我们可以把CSS单独提取出来加载。这也是性能优化手段之一。 webpack4.0以后，官方推荐使用mini-css-extract-plugin插件来打包css文件，此时需要去掉style-loader，两者冲突。

```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

plugins: [
 new MiniCssExtractPlugin({
    filename: '[name].[hash].css',
    chunkFilename: '[id].css',
  }),
],
module: {
  rules: [
    {
      test: /\.css$/,
      use: [MiniCssExtractPlugin.loader, 'css-loader'], // 从右往左解析原则
    },
    {
      test: /\.less$/,
      use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'],
    },
  ],
},

```

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1670659704925-6be496ec-3737-4b74-abb5-2e7d9372c263.png?x-oss-process=image%2Fresize%2Cw_682%2Climit_0)

### 5 打包 图片、字体、媒体、等文件

file-loader就是将文件在进行一些处理后（主要是处理文件名和路径、解析文件url），并将文件移动到输出的目录中 url-loader 一般与file-loader搭配使用，功能与 file-loader 类似，如果文件小于限制的大小。则会返回 base64 编码，否则使用 file-loader 将文件移动到输出的目录中

```js

// webpack.config.js
module.exports = {
  // 省略其它配置 ...
  module: {
    rules: [
      // ...
      {
        test: /\.(jpe?g|png|gif)$/i, //图片文件
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 10240,
              fallback: {
                loader: 'file-loader',
                options: {
                    name: 'img/[name].[hash:8].[ext]'
                }
              }
            }
          }
        ]
      },
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, //媒体文件
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 10240,
              fallback: {
                loader: 'file-loader',
                options: {
                  name: 'media/[name].[hash:8].[ext]'
                }
              }
            }
          }
        ]
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/i, // 字体
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 10240,
              fallback: {
                loader: 'file-loader',
                options: {
                  name: 'fonts/[name].[hash:8].[ext]'
                }
              }
            }
          }
        ]
      },
    ]
  }
}
```

### 6 用babel转义js文件

为了使我们的js代码兼容更多的环境我们需要安装依赖

- 注意 babel-loader与babel-core的版本对应关系
  1. babel-loader 8.x 对应babel-core 7.x
  2. babel-loader 7.x 对应babel-core 6.x 

Babel其实是几个模块化的包：

- @babe-l/core：babel核心库
- babel-loader：webpack的babel插件，让我们可以在webpack中运行babel
- @babel/preset-env：将ES6转换为向后兼容的JavaScript，一组预先设定的插件 默认支持所有最新的JS（ES2015，ES2016等）特定
- @babel/plugin-transform-runtime：处理async，await、import()等语法关键字的帮助函数

```js
yarn add @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime -D
```

配置如下

```js
// webpack
module: {
  rules: [
    {
      test: /\.css$/,
      use: [MiniCssExtractPlugin.loader, 'css-loader'], // 从右往左解析原则
    },
    {
      test: /\.less$/,
      use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'],
    },
    {
      test: /(\.jsx|\.js)$/,
      use: ['babel-loader'],
      exclude: /node_modules/,
    },
  ],
}

// .babelrc
{
  "presets": ["@babel/preset-env"], // 一组预先设定的插件 默认支持所有最新的JS（ES2015，ES2016等）特定
  "plugins": ["@babel/plugin-transform-runtime"]
}
```

上面的babel-loader只会将 ES6/7/8语法转换为ES5语法，但是对新api并不会转换 例如(promise、Generator、Set、Maps、Proxy等)，可使用@babel/plugin-transform-runtime来解决问题。

```js
// main.js
function test() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(1111);
    }, 0);
  });
}

async function main() {
  const result = await test();
  console.log(result);
}

main();

```

上面的实践是我们对webpack的功能有了一个初步的了解，但是要想熟练应用于开发中，我们需要一个系统的实战。让我们一起摆脱脚手架尝试自己搭建一个vue开发环境  

## 二、区分开发环境与生产环境

安装 webpack-merge 用于配置合并

```js
yarn add -D webpack-merge
```

提取webpack.common.js

```js
// webpack.common.js

const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const { VueLoaderPlugin } = require('vue-loader'); // vue加载器
const FileListPlugion = require('../plugin/index');

module.exports = {
  // entry: path.resolve(__dirname, '../src/main.js'), // 入口文件
  entry: {
    main: path.resolve(__dirname, '../src/main.js'),
    header: path.resolve(__dirname, '../src/header.js'),
  },
  output: {
    filename: '[name].[hash:8].js', // 打包后的文件名称
    path: path.resolve(__dirname, '../dist'), // 打包后的目录
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, '../public/index.html'),
      filename: 'index.html',
      chunks: ['main'],
      title: 'main',
      inject: 'body', // script文件插入到HTML中的位置 默认true
    }),
    new HtmlWebpackPlugin({
      filename: 'header.html',
      chunks: ['header'],
      title: 'header22',
      minify: true, // development 默认不压缩 production 默认压缩
    }),
    new MiniCssExtractPlugin({
      filename: '[name].[hash].css',
      chunkFilename: '[id].css',
    }),
    new FileListPlugion(),
    new VueLoaderPlugin(),
  ],
  resolve: {
    // 别名
    alias: {
      '@': path.resolve(__dirname, '../src'),
    },
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: ['vue-loader'], // 解析.vue模板
        include: [path.resolve(__dirname, '../src')],
      },
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader'], // 从右往左解析原则
      },
      {
        test: /\.less$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'],
      },
      {
        test: /(\.jsx|\.js)$/,
        use: [
          'babel-loader',
          // path.resolve(__dirname, '../loader/drop-console.js'),
        ],
        exclude: /node_modules/,
      },
    ],
  },
};
```

#### **webpack.dev.js 开发环境配置文件**

```js
// 开发环境主要实现的是热更新,不要压缩代码，完整的sourceMap

const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');
const path = require('path');

module.exports = merge(common, {
  mode: 'development',
  devServer: {
    hot: true, // 热更新
    open: true,
    static: {
      // 告诉服务器从哪里提供内容。只有在你希望提供静态文件时才需要这样做。
      directory: path.resolve(__dirname, './public'),
    },
  },
});
```

#### **webpack.prod.js 生产环境配置文件**

```js
// 生产环境主要实现的是压缩代码、提取css文件、合理的sourceMap、分割代码
const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');

module.exports = merge(common, {
  mode: 'production',
});
```

## 三、搭建vue开发环境 

上面的小例子已经帮助而我们实现了打包css、图片、js、html等文件。 但是我们还需要以下几种配置

#### 3.1 安装

```js
yarn add -D vue-template-compiler@2.6.14 vue-loader@15.9.8
```

注意 vue和vue-template-compiler版本号一定要一样，如果要更新vue，vue-template-compiler也要进行相应的更新，也要注意vue-loader的版本，这里使用vue2，安装15.9.8版本

- vue-loader，用于解析.vue文件
- vue-template-compiler，用于模板编译

#### 3.2 配置

```js
// webpack.common.js

const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const { VueLoaderPlugin } = require('vue-loader'); // vue加载器
const FileListPlugion = require('../plugin/index');

module.exports = {
  // entry: path.resolve(__dirname, '../src/main.js'), // 入口文件
  entry: {
    main: path.resolve(__dirname, '../src/main.js'),
    header: path.resolve(__dirname, '../src/header.js'),
  },
  output: {
    filename: '[name].[hash:8].js', // 打包后的文件名称
    path: path.resolve(__dirname, '../dist'), // 打包后的目录
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, '../public/index.html'),
      filename: 'index.html',
      chunks: ['main'],
      title: 'main',
      inject: 'body', // script文件插入到HTML中的位置 默认true
    }),
    new HtmlWebpackPlugin({
      filename: 'header.html',
      chunks: ['header'],
      title: 'header22',
      minify: true, // development 默认不压缩 production 默认压缩
    }),
    new MiniCssExtractPlugin({
      filename: '[name].[hash].css',
      chunkFilename: '[id].css',
    }),
    new FileListPlugion(),
    new VueLoaderPlugin(),
  ],
  resolve: {
    // 别名
    alias: {
      '@': path.resolve(__dirname, '../src'),
    },
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: ['vue-loader'], // 解析.vue模板
        include: [path.resolve(__dirname, '../src')],
      },
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader'], // 从右往左解析原则
      },
      {
        test: /\.less$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'],
      },
      {
        test: /(\.jsx|\.js)$/,
        use: [
          'babel-loader',
          // path.resolve(__dirname, '../loader/drop-console.js'),
        ],
        exclude: /node_modules/,
      },
    ],
  },
  externals: {
    vue: 'Vue',
    'vue-router': 'VueRouter',
  },
};
```

#### 3.3 vue文件内容

index.html 引入vue、vue-routercdn资源

```js
<!-- vue模板 -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><%= htmlWebpackPlugin.options.title %></title>
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.14/vue.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/vue-router/3.5.3/vue-router.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
```

入口main.js

```js
import App from './vue-views/App.vue';
import router from './router';

Vue.config.productionTip = false;

new Vue({
  router,
  render: (h) => h(App),
}).$mount('#root');

```

router/index.js

```js
Vue.use(VueRouter);

const Home = () =>
  import(/* webpackChunkName: "Home" */ '@/vue-views/home.vue');

const About = () =>
  import(/* webpackChunkName: "About" */ '@/vue-views/about.vue');

const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About },
];
const router = new VueRouter({ routes });

export default router;
```

src/vue-views/App.vue

```js
<template>
  <div class="app">
    <router-link to="/">home</router-link>
    <router-link to="/about">about</router-link>
    <router-view />
  </div>
</template>
<script>
export default { name: 'App' };
</script>
<style scoped>
.app {
  font-size: 14px;
  color: aquamarine;
}
</style>
```

src/vue-views/home.vue

```js
<!--  -->
<template>
  <div class="">home</div>
</template>

<script>
export default {
  //import所引入的组件注册
  components: {},

  data() {
    return {};
  },

  //方法集合
  methods: {},

  //创建完成 访问当前this实例
  created() {},
};
</script>
<style scoped></style>

```

修改package.json配置

```js
"scripts": {
    "dev": "webpack serve --config build/webpack.dev.js",
    "build": "webpack --config build/webpack.prod.js"
  },
```

## 四、优化webpack配置 

### 4.1 优化前置内容 

#### 4.1.1 编译进度条 

一般来说，中型项目的首次编译时间为 5-20s，没个进度条等得多着急，通过 [progress-bar-webpack-plugin](https://www.npmjs.com/package/progress-bar-webpack-plugin)插件查看编译进度，方便我们掌握编译情况。

```js
yarn add progress-bar-webpack-plugin -D
yarn add chalk@4.1.2 -D // chalk 5 是esm写法 cjs无法使用
```

```js
// webpack.common.js

const chalk = require('chalk');
const ProgressBarPlugin = require('progress-bar-webpack-plugin');

// 进度条
new ProgressBarPlugin({
  format: `  :msg [:bar] ${chalk.green.bold(':percent')} (:elapsed s)`,
}),
```

包含内容、进度条、进度百分比、消耗时间，进度条效果如下：

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1671248720334-d810d09c-1171-4dcf-bd1b-fa24c11266f5.png)

#### 4.1.2 编译速度分析

优化 webpack 构建速度，首先需要知道是哪些插件、哪些 loader 耗时长，方便我们针对性的优化。
通过 [speed-measure-webpack-plugin](https://www.npmjs.com/package/speed-measure-webpack-plugin)插件进行构建速度分析，可以看到各个 loader、plugin 的构建时长，后续可针对耗时 loader、plugin 进行优化。

````js
yarn add -D speed-measure-webpack-plugin
````

```js
// webpack.dev.js
// 打包速度分析
const SpeedMeasurePlugin = require('speed-measure-webpack-plugin');
const smp = new SpeedMeasurePlugin();

module.exports = smp.wrap(
  merge(common, {
    mode: 'development',
    devServer: {
      hot: true, // 热更新
      open: true,
      static: {
        // 告诉服务器从哪里提供内容。只有在你希望提供静态文件时才需要这样做。
        directory: path.resolve(__dirname, './public'),
      },
    },
  })
);
```

#### 4.1.3 打包体积分析

使用 [webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)查看打包后生成的 bundle 体积分析，将 bundle 内容展示为一个便捷的、交互式、可缩放的树状图形式。帮助我们分析输出结果来检查模块在何处结束。
（1）安装

```js
yarn add webpack-bundle-analyzer -D
```

（2）配置

```js
//webpack.prod.js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; 

plugins:[
    new BundleAnalyzerPlugin()
]

```

（3）运行 npm run build ，编译结束新开一个页面，默认8888端口，可以看到bundle之间的关系。

### 4.2 优化打包速度 

构建速度指的是我们每次修改代码后热更新的速度以及发布前打包文件的速度。

使用最新的webpack版本， 通过webpack自身的迭代优化，来加快构建速度。

这一点是非常有效的，如 webpack5 较于 webpack4，新增了持久化缓存、改进缓存算法等优化，webpack5 新特性可查看 [参考资料](https://zhuanlan.zhihu.com/p/56796027)。

#### 4.2.1 缩小文件的搜索范围(配置include exclude alias extensions) 

- alias: 当我们代码中出现 import 'vue'时， webpack会采用向上递归搜索的方式去node_modules 目录下找。

​		○ 为了减少搜索范围我们可以直接告诉webpack去哪个路径下查找。也就是别名(alias)的配置。

​		○ 也能使我们编写代码更加方便

- include exclude 同样配置include exclude也可以减少webpack loader的搜索转换时间

```js
module: {
  rules: [
    {
      test: /\.vue$/,
      use: ['vue-loader'], // 解析.vue模板
      include: [path.resolve(__dirname, '../src')],
    },
    {
      test: /\.css$/,
      use: [MiniCssExtractPlugin.loader, 'css-loader'], // 从右往左解析原则
    },
    {
      test: /\.less$/,
      use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'],
    },
    {
      test: /(\.jsx|\.js)$/,
      use: [
        'babel-loader',
        // path.resolve(__dirname, '../loader/drop-console.js'),
      ],
      exclude: /node_modules/,
    },
  ],
},
```

- extensions webpack会根据extensions定义的后缀查找文件(频率较高的文件类型优先写在前面) 

​		○ 如果有多个文件有相同的名字，但后缀名不同，webpack 会解析列在数组首位的后缀的文件 并跳过其余的后缀

​		○ 但是要确保同一个目录下面没有重名的，不同后缀的文件

```js
// 创建 import 或 require 的别名，来确保模块引入变得更简单
resolve: {
  // 别名
  alias: {
    '@': path.resolve(__dirname, '../src'),
  },
  // 尝试按顺序解析这些后缀名。如果有多个文件有相同的名字，
  // 但后缀名不同，webpack 会解析列在数组首位的后缀的文件 并跳过其余的后缀。
  // 但是要确保同一个目录下面没有重名的 css 或者 js 文件
  extensions: ['.js', '.json', '.vue'],
},

```

#### 4.2.2 缓存Cache

缓存生成的 webpack 模块和 chunk，来改善构建速度，无须在使用dll、cache-loader，使用cache帮助缓存。
可以将构建过程的 webpack 模板进行缓存，大幅提升二次构建速度、打包速度，当构建突然中断，二次进行构建时，可以直接从缓存中拉取，可提速 90% 左右。
cache

- type  'memory' | 'filesystem'

  ○ memory  webpack 在内存中存储缓存，不允许额外的配置
  ○ filesystem 文件系统

- store
  ○ 当编译器空闲时，将缓存数据存放到一个文件中

```js
// webpack.common.js
cache: {
  type: 'filesystem', // string: 'memory' | 'filesystem' 内存/文件系统
},
```

![](https://cdn.nlark.com/yuque/0/2022/png/739887/1671263951397-0bd0d3af-918e-4611-9047-a27a22273281.png)

#### 4.2.3 多进程

可以通过多进程来实现，试想将loader 放在一个独立的 worker 池中运行，就不会阻碍其他 loader 的构建了，可以大大加快构建速度。
通过 [thread-loader](https://webpack.docschina.org/loaders/thread-loader/#root)将耗时的 loader 放在一个独立的 worker 池中运行，加快 loader 构建速度。
[happypack](https://github.com/amireh/happypack)同样是用来设置多线程，但是在 webpack5 就不要再使用 [happypack](https://github.com/amireh/happypack)了，官方也已经不再维护了，推荐使用上文介绍的 thread-loader。

```js
yarn add -D thread-loader
```

```js
{
  test: /(\.jsx|\.js)$/,
  use: [
    'thread-loader',
    'babel-loader',
    // path.resolve(__dirname, '../loader/drop-console.js'),
  ],
  exclude: /node_modules/,
}
```

由于 thread-loader 引入后，需要 0.6s 左右的时间开启新的 node 进程，本项目代码量小，可见引入 thread-loader 后，构建时间反而增加了。

因此，我们应该仅在非常耗时的 loader 前引入 thread-loader。

### 4.3 优化打包文件体积 

打包的速度我们是进行了优化，但是打包后的文件体积却是十分大，造成了页面加载缓慢，浪费流量等，接下来让我们从文件体积上继续优化

#### 4.3.1 externals 

按照官方文档的解释，如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置Externals。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用 Externals的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 CDN 的方式，去引用它们。

有时我们希望我们通过script引入的库，如用CDN的方式引入的jquery，我们在使用时，依旧用require的方式来使用，但是却不希望webpack将它又编译进文件中。这里官网案例已经足够清晰明了，大家有兴趣可以点击了解 

```js
externals: {
  vue: 'Vue',
  'vue-router': 'VueRouter',
},
```

#### 4.3.2 JS压缩（Terser）

使用 [TerserWebpackPlugin](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fplugins%2Fterser-webpack-plugin%2F) 来压缩 JavaScript。webpack5 自带最新的 terser-webpack-plugin，无需手动安装。
optimizatoin 优化，所有的优化都可以手动配置和重写。

- minimizer 允许你通过提供一个或多个定制过的TerserPlugin实例，覆盖默认的压缩工具

```js
// webpack.prod.js
const TerserWebpackPlugin = require('terser-webpack-plugin');

optimization: {
  minimizer: [
    new TerserWebpackPlugin({
      parallel: threads,
    }),
  ],
},
```

#### 4.3.3 CSS压缩

使用 [CssMinimizerWebpackPlugin](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fplugins%2Fcss-minimizer-webpack-plugin%2F%23root) 压缩 CSS 文件，CssMinimizerWebpackPlugin 将在 Webpack 构建期间搜索 CSS 文件，优化、压缩 CSS。
和 [optimize-css-assets-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FNMFR%2Foptimize-css-assets-webpack-plugin) 相比，[css-minimizer-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fplugins%2Fcss-minimizer-webpack-plugin%2F%23root) 在 source maps 和 assets 中使用查询字符串会更加准确，而且支持缓存和并发模式下运行。

```js
yarn add -D css-minimizer-webpack-plugin
```

```js
// webpack.prod.js
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

optimization: {
  minimizer: [
    new TerserWebpackPlugin({
      parallel: threads,
    }),
    new CssMinimizerPlugin({
      parallel: threads,
    }),
  ],
},
```

#### 4.3.4 代码分离 

代码分离能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，可以缩短页面加载时间。

抽取重复代码 SplitChunk

```js
// webpack.common.js
optimization: {
  splitChunks: {
    // include all types of chunks
    chunks: 'all',
    // 重复打包问题
    cacheGroups: {
      vendors: {
        // node_modules里的代码
        test: /[\\/]node_modules[\\/]/,
        chunks: 'all',
        // name: 'vendors', 一定不要定义固定的name
        priority: 10, // 优先级
        enforce: true,
      },
    },
  },
}
```

**CSS 文件分离**

```js
yarn add -D mini-css-extract-plugin
```

#### 4.3.5 Tree Shaking(摇树)

 摇树，顾名思义，就是将枯黄的落叶摇下来，只留下树上活的叶子。枯黄的落叶代表项目中未引用的无用代码，活的树叶代表项目中实际用到的源码。
但是要想使其生效，生成的代码必须是ES6模块
通过 package.json 的 "sideEffects" 属性，来实现这种方式。

```js
{
  "name": "your-project",
  "sideEffects": false
}
```

```js
module.exports = {
  mode: 'development', // 我们先使用开发模式下验证
  devtool: 'cheap-module-source-map',  //使用source map的这个模式
  optimization: {
    usedExports: true,  // 表示开启使用tree shaking
  },
}
```

添加 TreeShaking 后，未引用的代码，将不会被打包

设置mode为production的时候已经自动开启了tree-shaking。

但是要想使其生效，生成的代码必须是ES6模块。不能使用其它类型的模块如CommonJS之流。

#### 4.3.6 按需加载 

通过 webpack 提供的 [import() 语法](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fapi%2Fmodule-methods%2F%23import-1) [动态导入](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fguides%2Fcode-splitting%2F%23dynamic-imports) 功能进行代码分离，通过按需加载，大大提升网页加载速度。

使用方式如下：

```js
Vue.use(VueRouter);

const Home = () =>
  import(/* webpackChunkName: "Home" */ '@/vue-views/home.vue');

const About = () =>
  import(/* webpackChunkName: "About" */ '@/vue-views/about.vue');

const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About },
];
const router = new VueRouter({ routes });

export default router;

```

## 五、手写webpack系列 

经历过上面两个部分，我们已经可以熟练的运用相关的loader和plugin对我们的代码进行转换、解析。接下来我们自己手动实现loader与plugin，使其在平时的开发中获得更多的乐趣。

### 5.1 手写webpack loader 

loader从本质上来说其实就是一个node模块。

loader编写原则

- 单一原则: 每个 Loader 只做一件事；

- 链式调用: Webpack 会按顺序链式调用每个 Loader；

- 统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用； 

在日常开发环境中，为了方便调试我们往往会加入许多console打印。但是我们不希望在生产环境中存在打印的值。那么这里我们自己实现一个loader去除代码中的console。

知识点普及之AST。抽象语法树，将代码转化为树形的结构，可通过AST进行代码转换。这里推荐一篇不错的AST文章 [AST快速入门](https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000016231512)

```js
npm i -D @babel/parser @babel/traverse @babel/generator @babel/types
```

- @babel/parser 将源代码解析成 AST

- @babel/traverse 对AST节点进行递归遍历，生成一个便于操作、转换的path对象

- @babel/generator 将AST解码生成js代码

- @babel/types通过该模块对具体的AST节点进行进行增、删、改、查
  新建drop-console.js

  ```js
  const parser = require('@babel/parser');
  const traverse = require('@babel/traverse').default;
  const generator = require('@babel/generator').default;
  const t = require('@babel/types');
  
  module.exports = function (source) {
    const ast = parser.parse(source, { sourceType: 'module' });
    traverse(ast, {
      CallExpression(path) {
        if (
          t.isMemberExpression(path.node.callee) &&
          t.isIdentifier(path.node.callee.object, { name: 'console' })
        ) {
          // 
          path.remove();
        }
      },
    });
  
    const output = generator(ast, {}, source);
  
    return output.code;
  };
  ```

  如何使用

  ```js
  // webpack.config.js
  
  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const MiniCssExtractPlugin = require('mini-css-extract-plugin');
  
  module.exports = {
    mode: 'development', // 开发模式
    // entry: path.resolve(__dirname, '../src/main.js'), // 入口文件
    entry: {
      main: path.resolve(__dirname, '../src/main.js'),
      header: path.resolve(__dirname, '../src/header.js'),
    },
    output: {
      filename: '[name].[hash:8].js', // 打包后的文件名称
      path: path.resolve(__dirname, '../dist'), // 打包后的目录
      clean: true,
    },
    plugins: [
      new HtmlWebpackPlugin({
        template: path.resolve(__dirname, '../public/index.html'),
        filename: 'index.html',
        chunks: ['main'],
        title: 'main',
        inject: 'body', // script文件插入到HTML中的位置 默认true
      }),
      new HtmlWebpackPlugin({
        filename: 'header.html',
        chunks: ['header'],
        title: 'header22',
        minify: true, // development 默认不压缩 production 默认压缩
      }),
      new MiniCssExtractPlugin({
        filename: '[name].[hash].css',
        chunkFilename: '[id].css',
      }),
    ],
    module: {
      rules: [
        {
          test: /\.css$/,
          use: [MiniCssExtractPlugin.loader, 'css-loader'], // 从右往左解析原则
        },
        {
          test: /\.less$/,
          use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'],
        },
        {
          test: /(\.jsx|\.js)$/,
          use: [
            'babel-loader',
            path.resolve(__dirname, '../loader/drop-console.js'),
          ],
          exclude: /node_modules/,
        },
      ],
    },
    watch: true,
  };
  ```

  实际上在webpack4中已经集成了去除console功能，在minimizer中可配置 [去除console](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fterser-webpack-plugin%2F%23root)

  附上官网 [如何编写一个loader](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fcontribute%2Fwriting-a-loader%2F)

### 5.2 手写webpack plugin 

在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过Webpack提供的API改变输出结果。通俗来说：一盘美味的 [盐豆炒鸡蛋](https://link.juejin.cn/?target=https%3A%2F%2Fwww.meishij.net%2Fzuofa%2Fyandouchaojidan.html) 需要经历烧油 炒制 调味到最后的装盘等过程，而plugin相当于可以监控每个环节并进行操作，比如可以写一个少放胡椒粉plugin,监控webpack暴露出的生命周期事件(调味)，在调味的时候执行少放胡椒粉操作。那么它与loader的区别是什么呢？上面我们也提到了loader的单一原则,loader只能一件事，比如说less-loader,只能解析less文件，plugin则是针对整个流程执行广泛的任务。

一个基本的plugin插件结构如下

```js
// 文件列表插件
class FileListPlugion {
  constructor(filename) {
    this.filename = filename;
  }
  apply(compiler) {
    compiler.hooks.done.tap('firstPlugin', () => {
      console.log('编译完成');
    });
  }
}

module.exports = FileListPlugion;

```

compiler 、compilation是什么？

- compiler 对象包含了Webpack 环境所有的的配置信息。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。

- compilation对象包含了当前的模块资源、编译生成资源、变化的文件等。当运行webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。

compiler和 compilation的区别在于  

- compiler代表了整个webpack从启动到关闭的生命周期，而compilation 只是代表了一次新的编译过程
- compiler和compilation暴露出许多钩子，我们可以根据实际需求的场景进行自定义处理

webpack提供三种触发钩子的方法：
tap：以同步的方式触发钩子
tapAsync：以异步的方式触发钩子
tapPromise：以异步的方式触发钩子，返回Promise

发布订阅者模式的插件plugin机制

[compiler钩子文档](https://link.juejin.cn/?target=https%3A%2F%2Fwww.webpackjs.com%2Fapi%2Fcompiler-hooks%2F) 
[compilation钩子文档](https://link.juejin.cn/?target=https%3A%2F%2Fwww.webpackjs.com%2Fapi%2Fcompilation-hooks%2F)
下面我们手动开发一个简单的需求,在生成打包文件之前自动生成一个关于打包出文件的大小信息
新建一个webpack-firstPlugin.js

```js
// 文件列表插件
class FileListPlugion {
  constructor(filename) {
    this.filename = filename;
  }
  apply(compiler) {
    // compiler.hooks.done.tap('firstPlugin', () => {
    //   console.log('编译完成');
    // });
    // 输出 asset 到 output 目录之前执行
    compiler.hooks.emit.tap('FileListPlugin', (compilation) => {
      let assets = compilation.assets;
      let content = '';
      Object.entries(assets).forEach(([filename, statObj]) => {
        content += `文件名: ${filename} 大小：${statObj.size()} \n`;
      });

      console.log(content);
    });
  }
}

module.exports = FileListPlugion;

```

如何使用
执行 npm run build即可看到在dist文件夹中生成了一个包含打包文件信息

上面两个loader与plugin案例只是一个引导，实际开发需求中的loader与plugin要考虑的方面很多，建议大家自己多动手尝试一下。

# **⼯程化⼯具**

## **⼀、⼯具的⼯作模式**

**1.** **模式：原⽣** **=>** **脚本加⼯** **=>** **⾃动化脚本加⼯**

**2.** **代表作品：****gulp****、****grunt……** 

## **⼆、经典流式构建⼯具** **—— gulp** 

### gulp - 流式工程化

#### 准备

1. 安装
   npm install -g gulp

2. 新建依赖主入口gulpfile.js - 主文件脚本入口

#### 工作方式 - 三步走

```js
  var gulp = require('gulp')
  gulp.src('xxx.js')   // 获取流的api
    .pipe(gulp.dest('dist/xxx.js'))  // 写文件的api
```

1. gulp.src() - 获取到想要处理的文件流

```js
  gulp.src(glob[, options]) // => 并非原本的文件流，而是虚拟文件对象流 => 减少对于实体文件的IO次数

  // 1. globs 文件匹配模式
  // 使用数组的方式来匹配多种文件
  gulp.src(['./js/*.js'])

  // 2. options 处理文件的配置项
  // options.buffer - boolean返回buffer => false时 返回stream而非文件本身
  // options.read - boolean文件内容返回 => 判断文件内容是或否读取返回 => false时候，file.content 返回空值
  // options.base - 文件基础路径
  gulp.src('zhaowa/js/**/*.js', {base: 'zhaowa'})
```

2. .pipe() - 把文件流通过pipe方法导入到gulp插件中

```js
  gulp.src('zhaowa/js/*.js')
    .pipe(minify()) // 压缩 or 其他操作
    .pipe(gulp.dest('build')) // 写入 'build/**/somefile.js'

  gulp.src('zhaowa/js/*.js', { base:'zhaowa' })
    .pipe(minify())
    .pipe(gulp.dest('build')) // 面试题：产出是什么？和上面一样吗？
    // 写入了'build/js/somefile.js'将zhaowa替换为build
```

3. gulp.dest() - 处理后的流内容写入到文件中

```js
  gulp.dest(path[, options])
  // 1. path - 写入文件的路径
  // 2. options可选参数
    // options.mode - string 0777 所在目录的权限
```

4. gulp.watch() - 监视文件的变化，用以触发相应的任务流开展

```js
  gulp.watch(glob[, options], tasks);
  // glob - 监视文件的匹配模式
  // tasks - 文件变化后要执行的任务

  // 创建任务
  gulp.task('minify', function() {
    // 任务内容
  })
  gulp.task('uglify', function() {
    // 任务内容
  })

  // < 4.0
  gulp.watch('./page/**/*.js', ['uglify', 'minify'])
  // 4.0
  gulp.watch(
    './page/**/*.js',
    gulp.parallel(
      ['uglify', 'minify']
    )
  )
```

### 性能优化

#### 1. 自我救赎 —— webpack自身升级的本质

##### v3 => v4的升级

* 配置项：

1. 提出零配置的概念
   => 不强制依赖webpack.config.js做配置 => 默认项
   entry: ./src/index.js + output: ./dist/main.js
   webpack-cli 分离安装

2. 区分开了开发与编译态
   => 提供mode区分 development & production
   => 提升开发的编译效率 & 专注于编译产品

3. 配置差异
   移除了 commonTrunkPlugin => optimization.splitChunks

##### v4优化方向 => 速度

对于产品打包、开发编译速度都做了优化

##### v4 => v5的升级

1. 持久化缓存 - 构建结果持久化缓存到本地 => 直接利用缓存结果反向跳过构建部分步骤
   module.exports = {
     cache: {
    type: 'fileSystem',
    buildDependencies: {
      config: [__filename]
    }
     }
   }

2. 资源模块
   old
   raw-loader | url-loader | file-loader

new
asset/resource
asset/source  导出资源的源代码

=> 优化取消资源文件引入的loader => 直接与路径关联优化配置

3. 打包优化
   优化了tree-shaking
   优化splitchunk，支持更加全面精细的调整

```js
  splitChunks: {
    chunks: 'all',
    minSize: {
      javascript: 30000,
      style: 50000
    }
  }
```

=> v5 => 进一步优化配置 & 优化编译速度以及包大小

#### 2. 外援辅助 —— webpack插件的帮忙

##### 1. 缓存加速派

cache-loader —— 指向性针对一些耗时的工作进行缓存
terser-webpack-plugin | uglifyjs-webpack-plugin

##### 2. 减肥瘦身派

purifycss-webpack css未执行的部分自动删除
optimize-css-assets-webpack-plugin css管理压缩

##### 3. 贴心小助手派

cleanWebpackPlugin 自动清理无用文件

### 工程化进阶

#### vite ——— 新一代效率导向工程化工具

* 模式：

1. 冷启动 / 冷服务 => 开发状态下不出包
2. 热更新 => 更新源文件视图的直接更新
3. 按需更新，不刷新所有节点，只更新改动部分

* 原理对比：

1. webpack - 编译支撑开发
   src => 打包生成bundle => 启动dev—server => 建立开发环境
   HMR把改动的模块以及相关依赖全部编译

2. vite - 路由劫持 + 实时编译
   启动dev-server => 直接请求所需模块的的路由，并直接实时编译（利用了新一代浏览器支持esm的能力）
   HMR只需要只需要让浏览器重新请求该模块
   => 利用浏览器的缓存机制（源码模块协商缓存、依赖模块强缓存）来优化资源请求

* 开发环境 vs 正式环境 => 运行时 vs 编译打包
  dev:

1. 依赖预构建 cjs/UMD => ESM
   => 面试：vite如何提高依赖于构建效率？
2. 依赖缓存到node_modules/.vite
   => 面试：如何更新缓存？有没有遇到缓存的坑？怎么解决的？ --force
3. package.json / lockfile / vite.config.js => 三者之一发生变化 => 重新预构建
4. 通过路由直接访问esm模块，通过浏览器缓存解析依赖进行强缓存优化

prod:

1. 依赖与rollup进行打包
2. 整体同webpack

##### 安装

```js
  // 安装vite
  npm init vite-app zhaowa
```

一键式可以搭建完成vue3.0的环境

###### 特性

* 1. 原生支持ts

```js
  <script lang="ts"></script>
```

* 2. 原生文件的支持
     支持json的直接打包引入

```js
  import mockData from '../mock.json'
```

支持css的直接引入

```js
  import '../reset.css'
```

* 3. 新增额外依赖配置
     <!-- vite.config.js vite文档 config章节 -->

#### 原理展现

1. ESM为静态定义，编译时加载 => 生成只读引用
2. 路由根据脚本进入，查找只读引用去模块内取值 => 运行时编译代码
   （结合了浏览器缓存机制）
3. 单vue文件进一步拆分
4. 热更新 => 独立服务websocket去推送热更新的提醒

#### 前端测试

##### 单元测试

* 1. 覆盖率

```js
  function top10(number, sum) {
    if (number < 10) {
      return sum += number;
    }
    return sum;
  }

  top10(8);
  top9(9);
  // 覆盖率 50%
```

* 2. 单元拆分定义 => 逻辑层面

* 3. 环境准备

```js
  // 1. 安装依赖
  npm i --save-dev jest
  npm i @types/jest babel-jest @vue/test-utils@next @testing-library/jest-dom ts-jest vue-jest --save-dev

  // 2. 配置babel
  // 配置babel支持es6语法

  // 3. 配置jest
  // jest.config.js
  // 单元测试用例
```

###### E2E 测试

端到端测试 => 业务功能出发，不关注具体实现，只验证是否实现业务功能 => 测试提供case

1. 安装
   npm init -y
   npm i -D cypress

# Web图形学： Canvas与WebGL 

背景

思考：Web图形学的范畴，有哪些典型应⽤？

![web图形学](/Volumes/F/zyl-study/web-zhuawa/20221203/web图形学.jpg)

### Echarts 项⽬案例（2D） 

• https://echarts.apache.org/examples/zh/index.html 

### ThreeJS 项⽬案例（3D） 

• https://threejs.org/ 

2D图形： SVG 

可缩放⽮量图形（Scalable Vector Graphics，SVG）, SVG 格式提供的是⽮量图，这意味着它的图像能够被⽆限放⼤⽽不失真或降低质量。 

探索⼀下svg的渲染及内部代码

![paypal](/Volumes/F/zyl-study/web-zhuawa/20221203/paypal.jpg)

SVG常⻅元素 

```js
<svg>：SVG的根元素，⽤于定义SVG⽂档的开始和结束。
<rect>：绘制矩形的元素，可以通过指定位置、宽度和⾼度来定义矩形的形状。 
<circle>：绘制圆形的元素，可以通过指定圆⼼坐标和半径来定义圆的形状。
<ellipse>：绘制椭圆的元素，可以通过指定中⼼点坐标、⽔平和垂直半径来定义椭圆的形状。
<line>：绘制直线的元素，可以通过指定起始点和结束点的坐标来定义直线的形状。
<polyline>：绘制折线的元素，可以通过指定⼀系列连接的点坐标来定义折线的形状。
<polygon>：绘制多边形的元素，可以通过指定⼀系列连接的点坐标来定义多边形的形状。 
<path>：绘制路径的元素，可以通过指定⼀系列路径指令和参数来定义复杂的形状，如直线段、曲线、弧 
<text>：⽤于在SVG中呈现⽂本的元素，可以指定⽂本内容、位置、字体样式等属性。 
<g>：⽤于创建分组的元素，可以将多个元素组合在⼀起，并对整个组应⽤变换、样式等属性。 
 路径命令： 
 M：移动到指定点（绝对坐标） 
 m：移动到指定点（相对坐标） 
 L：绘制直线到指定点（绝对坐标） 
 l：绘制直线到指定点（相对坐标） 
 H：绘制⽔平线（绝对坐标） 
 h：绘制⽔平线（相对坐标）
 V：绘制垂直线（绝对坐标） 
 v：绘制垂直线（相对坐标） 
 C：绘制三次⻉塞尔曲线（绝对坐标） 
 c：绘制三次⻉塞尔曲线（相对坐标） 
 S：平滑的三次⻉塞尔曲线（绝对坐标） 
 s：平滑的三次⻉塞尔曲线（相对坐标） 
 Q：绘制⼆次⻉塞尔曲线（绝对坐标） 
 q：绘制⼆次⻉塞尔曲线（相对坐标） 
 T：平滑的⼆次⻉塞尔曲线（绝对坐标） 
 t：平滑的⼆次⻉塞尔曲线（相对坐标） 
 A：绘制椭圆弧（绝对坐标） 
 a：绘制椭圆弧（相对坐标） 
 Z：关闭路径
```

### SVG的尺⼨ 

探索width、height尺⼨对 svg渲染的影响 

https://codepen.io/ricardocao-biker/pen/LYXEYxP 

### 2D图形： Canvas 

Canvas API 提供了⼀个通过JavaScript 和 HTML的 <canvas> 元素来绘制图形的⽅式。它可以⽤于动 

画、游戏画⾯、数据可视化、图⽚编辑以及实时视频处理等⽅⾯。 

#### 渲染上下⽂

```js
const context = canvas.getContext("2d");
```

#### 上下⽂类型： 

• 2d ：创建⼀个⼆维渲染上下⽂ 

• webgl ：创建⼀个三维渲染上下⽂

### Canvas Context API 

```js
https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D 
fillStyle: 设置图形的填充颜⾊或样式。 
strokeStyle: 设置图形的边框颜⾊或样式。 
fillRect(x, y, width, height): 绘制⼀个填充的矩形。 
strokeRect(x, y, width, height): 绘制⼀个矩形的边框。 
clearRect(x, y, width, height): 清除指定矩形区域内的像素，使其变为透明。 
beginPath(): 开始绘制路径。 
moveTo(x, y): 将绘图游标移动到指定的坐标点。 
lineTo(x, y): 绘制⼀条直线，从当前点到指定的坐标点。 
closePath(): 封闭路径，连接起点和终点。
fill(): 填充当前路径的内部区域。 
stroke(): 绘制当前路径的边框。 
arc(x, y, radius, startAngle, endAngle, clockwise): 绘制弧或圆。 
drawImage(image, x, y): 在指定位置绘制图像。 
translate(x, y): 平移坐标系统的原点。 
scale(scaleX, scaleY): 缩放坐标系统。 
rotate(angle): 旋转坐标系统。
```

### 坐标

以左上⻆为起点，向右、向下计算x、y轴。

![canvas](/Volumes/F/zyl-study/web-zhuawa/20221203/canvas.jpg)

###  Canvas属性

canvas标签只有两个属性：width和height，作为画布尺⼨ 

```js
<canvas id="myCanvas" width="150" height="150"></canvas>
```

问题：canvas的width和height与css中的width、height是什么关系？会冲突 

么？

https://codepen.io/ricardocao-biker/pen/ExOxGoN 

实战：使⽤canvas绘制图形 

1. 绘制矩形 

context.fillRect(x, y, width, height) 

2. 绘制路径步骤 

a. 创建路径起始点 beginPath() 

b. 画出路径 

i. moveTo(x,y) 

ii. lineTo(x, y) 

c. 闭合路径 closePath() 

d. 渲染图形 

i. stroke() 描边 

ii. fill() 填充 

https://codepen.io/ricardocao-biker/pen/rNQBLNb 

探索：Echarts是如何通过canvas绘制图表？ 

Echarts在canvas绘制库 ZRender的上层进⾏继续封装。

![zrender](/Volumes/F/zyl-study/web-zhuawa/20221203/zrender.jpg)



⽂档：https://ecomfe.github.io/zrender-doc/public/api.html 

使⽤：https://codepen.io/ricardocao-biker/pen/zYMxrBG 

### 实战： 使⽤Echarts绘制图表 

https://codepen.io/ricardocao-biker/pen/YzRPBjB?editors=1010 

#### 使⽤框架：基于React/Vue的Echarts 

• https://github.com/ecomfe/vue-echarts 

• https://github.com/hustcc/echarts-for-react 

#### ⾼频⾯试题： 

Canvas和SVG的区别是什么？如何技术选型？

|        | 操作对象        | 渲染方式 | 适用场景             |
| ------ | --------------- | -------- | -------------------- |
| canvas | 像素            | 像素     | 性能优先，自由度优先 |
| svg    | XML矢量描述标签 | DOM      | 缩放还原度优先       |

更⽣动的回答：根据具体场景举例 

• 剪映Web端编辑器 / Canva可画编辑器 

• ⼤数据量可视化 

• 流程图编辑 

## 3D图形：WebGL 

OpenGL： 

OpenGL是⼀种跨平台的图形编程接⼝，⽤于渲染2D和3D图形。它提供了⼀系列函数和命令，⽤于操作图形硬件以进⾏⾼性能的图形渲染。 

WebGL（Web 图形库）是⼀个 JavaScript API，可在任何兼容的 Web 浏览器中渲染⾼性能的交互式 3D 和 2D 图形，⽽⽆需使⽤插件。WebGL 通过引⼊⼀个与 OpenGL ES 2.0 ⾮常⼀致的 API 来做到这⼀ 点，该 API 可以在 HTML5 <canvas> 元素中使⽤。这种⼀致性使 API 可以利⽤⽤⼾设备提供的硬件图形加速。 

### 问题：openGL和WebGL是什么关系？ 

WebGL（Web Graphics Library）则是⼀种基于OpenGL的Web标准，⽤于在Web浏览器中进⾏图形渲染。WebGL是HTML5的⼀部分，使⽤JavaScript API与浏览器的图形引擎进⾏交互，将OpenGL的 功能暴露给Web开发者。

WebGL使⽤OpenGL ES 2.0着⾊器语⾔来编写顶点着⾊器和⽚段着⾊器 

### WebGL核⼼概念 

1. 顶点缓冲区（Vertex Buffer）：顶点缓冲区是存储顶点数据的内存缓冲区，⽤于描述3D模型的⼏何形状。开发者将顶点数据加载到顶点缓冲区中，然后通过WebGL绘制指令使⽤这些顶点进⾏渲染。 

2. 着⾊器（Shader）：着⾊器是⼀段在GPU上执⾏的程序，⽤于控制WebGL渲染管线中的不同阶段。WebGL使⽤顶点着⾊器（

Vertex Shader）和⽚元着⾊器（Fragment Shader）来处理顶点和像素的计算和渲染。 

3. 纹理（Texture）：纹理是应⽤到3D模型表⾯的图像或图案。WebGL⽀持加载和使⽤纹理，可以将纹理映射到⼏何形状的表⾯，实现真实感和细节。 

### WebGL 核⼼API 

• gl.POINTS 

• gl.LINES 

• gl.TRIANGLES 

只能会点、线、三⻆形，所有的图形都是通过 这三种基础图形构成。 

![webGl](/Volumes/F/zyl-study/web-zhuawa/20221203/webGl.jpg)

### 坐标系

![webGL坐标系](/Volumes/F/zyl-study/web-zhuawa/20221203/webGL坐标系.jpg)

### 绘图流程步骤 

WebGL流程概览 

1. 获取顶点坐标 

2. 图元装配（即画出⼀个个三⻆形） 

3. 光栅化（⽣成⽚元，即⼀个个像素点）

![光栅化](/Volumes/F/zyl-study/web-zhuawa/20221203/光栅化.jpg)





1. 获取顶点坐标

![顶点坐标](/Volumes/F/zyl-study/web-zhuawa/20221203/顶点坐标.jpg)

### 问题： 为什么要写⼊缓存区？ 

#### 图元装配 

![图元装配](/Volumes/F/zyl-study/web-zhuawa/20221203/图元装配.jpg)

顶点着⾊器，它由opengl es编写，由javascript以字符串的形式定义并传递给GPU⽣成。 

```js
attribute vec4 position;
uniform mat4 matrix;
void main() {
    gl_Position = position * matrix;
}
```

attribute修饰符⽤于声明由浏览器（javascript）传输给顶点着⾊器的变量值； 

position即我们定义的顶点坐标； 

gl_Position是⼀个内建的传出变量; 

矩阵matrix，将三维世界坐标转换成屏幕坐标，这个矩阵叫投影矩阵，由javascript传⼊

![顶点着色器](/Volumes/F/zyl-study/web-zhuawa/20221203/顶点着色器.jpg)

### 光栅化 

在图元⽣成完毕之后，我们需要给模型“上⾊”，⽽完成这部分⼯作的，则是运⾏在GPU的“⽚元着⾊器”来完成。 

它同样是⼀段opengles程序，模型看起来是什么质地（颜⾊、漫反射贴图等）、灯光等由⽚元着⾊器来计算

![片元着色器](/Volumes/F/zyl-study/web-zhuawa/20221203/片元着色器.jpg)



```js
precision mediump float; 
 void main(void) { 
           gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); 
}
```

gl_FragColor即输出的颜⾊值。 

顶点着⾊器是有多少顶点，运⾏了多少次，⽽⽚元着⾊器则是，⽣成多少⽚元（像素），运⾏多少次。

### WebGL完整⼯作流程 

![webGl完整工作流程](/Volumes/F/zyl-study/web-zhuawa/20221203/webGl完整工作流程.jpg)

### 整体流程

![整体流程](/Volumes/F/zyl-study/web-zhuawa/20221203/整体流程.jpg)

例⼦：使⽤WebGL实现⼀个正⽅体 

https://codepen.io/ricardocao-biker/pen/NWEWXKO 

### 3D图形框架：ThreeJS 

ThreeJS提供了更简单、⾼级的⽅式来创建和渲染3D场景。提供了许多有⽤的功能和⼯具，如相机、 灯光、⼏何体、纹理映射、动画等，使开发者能够更轻松地构建复杂的3D场景。

![threejs](/Volumes/F/zyl-study/web-zhuawa/20221203/threejs.jpg)

⻩⾊和绿⾊部分，都是three.js参与的部分，其中⻩⾊是javascript部分，绿⾊是opengl es部分。 

我们发现，能做的，three.js基本上都帮我们做了。 

• 辅助我们导出了模型数据； 

• ⾃动⽣成了各种矩阵； 

• ⽣成了顶点着⾊器； 

• 辅助我们⽣成材质，配置灯光； 

• 根据我们设置的材质⽣成了⽚元着⾊器。 

## ThreeJS核⼼概念 

```js
https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene 
Scene（场景）：表⽰整个3D场景，⽤于存放和管理所有的物体、光源和相机。 
（渲染器）：负责将场景中的3D物体渲染到屏幕上。您可以设置渲染器的参数，如画布⼤ ⼩、背景⾊、渲染模式等。 
Camera（相机）：⽤于定义观察场景的视⻆和投影⽅式。
Three.js提供了多种相机类型，如透视相机 （PerspectiveCamera）和正交相机（OrthographicCamera）。
Object3D（对象）：是所有3D物体的基类，⽤于表⽰3D场景中的物体。可以设置对象的位置、旋转、 缩放和层次结构等属性。
Geometry（⼏何体）：表⽰3D物体的⼏何形状。Three.js提供了许多预定义的⼏何体类型，如⽴⽅体 （BoxGeometry）、球体（SphereGeometry）和平⾯（PlaneGeometry），同时也⽀持⾃定义⼏何体。
Material（材质）：定义物体的外观和渲染⽅式。Three.js提供了多种材质类型，如基本材质 （MeshBasicMaterial）、光照材质（MeshLambertMaterial）和Phong材质 （MeshPhongMaterial），还可以创建⾃定义材质。
Mesh（⽹格）：将⼏何体和材质组合起来形成可渲染的物体。Mesh是Object3D的⼀个⼦类，它表⽰⼀个具有⼏何形状和外观的物体。
Light（光源）：⽤于模拟场景中的光照效果。Three.js提供了多种光源类型，如环境光 （AmbientLight）、平⾏光（DirectionalLight）和点光源（PointLight）。 
Texture（纹理）：⽤于将图像或视频应⽤到⼏何体上，以实现更丰富的外观效果。可以加载和创建纹 理，并将其应⽤于材质。
Animation（动画）：⽤于实现物体的动画效果。Three.js提供了动画系统，可以定义和控制物体的 位置、旋转、缩放等属性随时间的变化。
```

### Camera 

• PerspectiveCamera: 这⼀投影模式被⽤来模拟⼈眼所看到的景象，它是3D场景的渲染中使⽤得最 

普遍的投影模式。 

• OrthographicCamera: 在这种投影模式下，⽆论物体距离相机距离远或者近，在最终渲染的图⽚中 

物体的⼤⼩都保持不变。 

探索更多ThreeJS配置项 

https://threejs.org/docs/#api/zh/lights/AmbientLight 

### ThreeJS绘制步骤 

![threejs绘制步骤](/Volumes/F/zyl-study/web-zhuawa/20221203/threejs绘制步骤.jpg)

### 实战：使⽤ThreeJS绘制3D场景 

https://codepen.io/ricardocao-biker/pen/jOQOaoX?editors=1010 

#### 复杂模型的加载：

Blender： https://www.blender.org/ 

模型市场：https://sketchfab.com/

```js
// 创建 GLTFLoader 加载器 
var loader = new THREE.GLTFLoader(); 
// 加载 glTF ⽂件 
loader.load(  './ford_mustang/scene.gltf', 
            function (gltf) { 
    // 加载成功回调函数 
    // 获取 glTF 场景对象 
    var model = gltf.scene; 
    // 将模型添加到场景中 
    scene.add(model); 
    // 调整模型位置、旋转等 
    // 渲染循环 
    function animate() { 
        requestAnimationFrame(animate); 
        // 在这⾥可以添加模型的动画或其他操作 
        // 渲染场景 
        renderer.render(scene, camera); 
    } 
    // 开始渲染循环 
    animate(); 
}, 
            function (xhr) { 
    // 正在加载回调函数 
    console.log((xhr.loaded / xhr.total * 100) + '% loaded'); 
}, 
            function (error) { 
    // 加载失败回调函数 
    console.error('An error happened', error); 
} 
           );
```

### 使⽤框架： 

React Three Fiber 

在react下⽅便快速地使⽤封装的ThreeJS 

### 官⽅⽂档：

https://docs.pmnd.rs/react-three-fiber/getting-started/introduction 

案例： 

https://codesandbox.io/s/rrppl0y8l4?file=/src/App.js 

#### ThreeJS with Vue 

#### 官⽅⽂档： 

https://github.com/troisjs/trois 

#### 探索更多 

https://github.com/brunosimon/my-room-in-3d 

#### Threejs学习更多 

Threejs journey

# 低代码基础及实战

## 低代码使⽤场景及意义 

### 定义和概述 

低代码是⼀种软件开发⽅法，团队可借助此⽅法在编写最少量代码的情况下开发数字解决⽅案并创建企业应⽤程序。 低代码开发平台为⽤⼾提供了⼀套⼯具、⾃定义代码组件和样板脚本。 然后，⽤⼾可以⾼效地开发新流程和应⽤程序‒ 所有这些任务都不需要编写⼤量的代码，也不需要执⾏脚本测试。 这些平台提供具有简单拖放功能的可视化开发环境。 

核⼼构成 

• 组件区：提供可以被反复拖拽的组件 

• 配置区：可以定制化的配置每⼀个拖到设计区的组件 

• 设计区：可以将组件拖拽到设计区，并移动位置 

https://h2dwof.aliwork.com/dingtalk/web/APP_LJN42QU68MIWHN3D0D29/design/pageDesigner?formUuid=FORM-MFA66S91R2UB3XHJB314D6SPUN983E5AVF6JL5&

![低代码核心构成](/Volumes/F/zyl-study/web-zhuawa/20221203/低代码核心构成.jpg)

## 企业和开发者中的应⽤场景 

### Shopify / Shopline 

跨境电商店铺搭建⽹站 

https://www.shopify.com/ 

#### 更多低代码 

https://github.com/taowen/awesome-lowcode 

#### 优势和劣势

![应用场景优势和劣势](/Volumes/F/zyl-study/web-zhuawa/20221203/应用场景优势和劣势.jpg)

### 低代码搭建技术⽅案 

组件

• 可重⽤性和模块化 

• 界⾯⼀致性和可定制性 

```js
// ⼀个具有界⾯⼀致性和可定制性的卡⽚组件 
const Card = ({ title, content, backgroundColor, textColor }) => { 
    const cardStyle = {
        backgroundColor: backgroundColor || "#FFFFFF", 
        color: textColor || "#000000", 
        padding: "16px", 
        borderRadius: "8px", 
        boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)", 
    }; 
    return ( 
        <div style={cardStyle}> 
        <h2>{title}</h2> 
<p>{content}</p> 
</div> 
); 
};
// 使⽤卡⽚组件的⽰例
const App = () => {
    return (
        <div>
        <h1>我的应⽤程序</h1> 
        <Card
        title="欢迎使⽤低代码平台" 
        content="这是⼀个具有界⾯⼀致性和可定制性的卡⽚组件⽰例。"
        backgroundColor="#F5F5F5"
        textColor="#333333"
        />
        </div>
    ); 
};
// 渲染⽰例组件到根元素
 ReactDOM.render(<App />, document.getElementById("root")); 
        
```

• 交互和事件处理 

• 可配置性和可扩展性 

• ⽂档和⽰例 

### 可拖拽 

Drag Events（拖放事件）： 

◦ dragstart ：当拖动操作开始时触发，通常在拖动源元素上使⽤。 

◦ drag ：在拖动过程中持续触发，通常在拖动源元素上使⽤

◦ dragenter ：当被拖动的元素进⼊可放置⽬标时触发，通常在⽬标元素上使⽤。 

◦ dragover ：当被拖动的元素在可放置⽬标上⽅移动时触发，通常在⽬标元素上使⽤。需要阻⽌默认⾏为才能接受拖放。 

◦ dragleave ：当被拖动的元素离开可放置⽬标时触发，通常在⽬标元素上使⽤。 

◦ drop ：当被拖动的元素放置在可放置⽬标上时触发，通常在⽬标元素上使⽤。需要阻⽌默认⾏为才能接受拖放。 

◦ dragend ：当拖动操作结束时触发，⽆论是成功放置还是取消拖放，通常在拖动源元素上使⽤。 

## 数据与预览 

我们需要⼀套统⼀的数据，⽤于承载⻚⾯信息

![数据与预览-承载页面](/Volumes/F/zyl-study/web-zhuawa/20221203/数据与预览-承载页面.jpg)



```js
{
  "title": "My Low-Code Page",
  "components": [
    {
      "type": "Button",
      "props": {
        "text": "Click me"
      },
      "children": []
    },
    {
      "type": "Input",
      "props": {
        "placeholder": "Enter your name"
      },
      "children": []
    }
  ]
}
```

```js
import React from 'react';
// ⽰例按钮组件 
const Button = ({ text }) => {
  return <button>{text}</button>;
};
// ⽰例输⼊框组件 
const Input = ({ placeholder }) => {
  return <input type="text" placeholder={placeholder} />;
};
// ⻚⾯组件 
const Page = ({ title, components }) => {
  return (
    <div>
      <h1>{title}</h1>
      {components.map((component, index) => {
        const Component = componentMapping[component.type];
        return <Component key={index} {...component.props} />;
      })}
    </div>
  );
};
// 组件映射 
const componentMapping = {
  Button,
  Input
};
// 应⽤程序 
const App = () => {
  const jsonData = {
    // JSON数据 
  };
  return <Page title={jsonData.title} components={jsonData.components} />;
};
export default App; 
```

## 基于React的低代码平台实战 

初始化项⽬

```js
 npx create-react-app my-low-code
```

⻚⾯布局 

组件区/ 设计区/ 配置区 

组件设计 

问题：组件区如何能知道我的组件库⾥⾯有哪些组件？ 

问题：组件的样式如何通过prop控制？ 

问题：组件区的组件和设计区的组件关系是什么？ 

拖拽逻辑 

问题：如何知道拖拽的是哪个组件？ 

拖拽事件中使⽤ dataTransfer 对象来携带⼀些⾃定义数据 

```js
const handleDragStart = (event, componentId) => {
  // 设置拖动数据 
  event.dataTransfer.setData('text/plain', componentId);
};
const handleDragOver = (event) => {
  // 阻⽌默认⾏为以允许放置 
  event.preventDefault();
  // 获取拖动数据 
  const componentId = event.dataTransfer.getData('text/plain');
  // 根据组件标识符识别组件 
  const draggedComponent = findComponentById(componentId);
  // 处理拖放⽬标元素的逻辑 
  // ... 
};
```

### 设计区渲染 

问题：设计区的组件如何渲染出来的？

```js
const DesignArea = ({ components }) => {
  return (
    <div className="design-area">
      {components.map((component, index) => (
        <div key={index} style={component.style}>
          {renderComponent(component)}
        </div>
      ))}
    </div>
  );
};
const renderComponent = (component) => {
  // 根据组件类型，渲染相应的组件 
  switch (component.type) {
    case 'Button':
      return <Button {...component.props} />;
    case 'Input':
      return <Input {...component.props} />;
    // 添加更多的组件类型 
    default:
      return null;
  }
};
```

问题：数据如何存储？

```js
{
  "components": [
    {
      "id": "1",
      "type": "Button",
      "props": {
        "text": "Click me",
        "color": "blue"
      },
      "style": {
        "width": "120px",
        "height": "40px",
        "margin": "10px"
      }
    },
    {
      "id": "2",
      "type": "Input",
      "props": {
        "placeholder": "Enter text"
      },
      "style": {
        "width": "200px",
        "height": "30px",
        "margin": "10px"
      }
    }
  ],
  "info": {
    "title": "测试⻚⾯",
    "creator": "创建者"
  }
} 
```

问题：组件如何嵌套？ 

### 配置区实现 

问题：如何知晓当前要配置的是哪个组件？ 

问题：配置选项有哪？

## 低代码进阶及实战

https://vgbixa7nr9.feishu.cn/docx/NHdydNNquog9fzxkIrkcVnDknyc

![低代码](/Volumes/F/zyl-study/web-zhuawa/20221203/低代码.png)

[低代码的数据](https://vgbixa7nr9.feishu.cn/docx/NHdydNNquog9fzxkIrkcVnDknyc)

## BUG修复

- A组件和B组件的配置表单切换时没有刷新数值

> key唯一值

## UI优化

- TopBar
- DragOver时设计区active样式
- 配置区优化

## AntDesign组件支持

除了支持我们自己内部封装的组件，当然我们还希望可以引入更多的第三方开源组件，以增强我们低代码平台的组件丰富度，如何实现第三方引入的npm库组件的引入呢？

Antd文档：https://ant-design.gitee.io/components/button-cn

### 安装antd

```js
yarn add antd
```

### 引入组件并导出

思考：除了引入组件之外还需要做什么？以达到设计区和配置区可以识别该组件的目的

### 配置区表单的动态配置

问题：字符串引发的prop异常导致antd组件

### 增加样式配置

> 通用样式配置区

将style作为props中的一项参数处理。

### 设计区内部拖动

我们现在仅支持了组件区向设计区的拖动，并且只能添加到结尾处，如何实现设计区内部的拖动呢？

```js
import React, { useState } from 'react';

const DesignArea = () => {
  const [items, setItems] = useState(['Item 1', 'Item 2', 'Item 3', 'Item 4']);

  const handleDragStart = (event, index) => {
    event.dataTransfer.setData('text/plain', index);
  };

  const handleDragOver = (event) => {
    event.preventDefault();
  };

  const handleDrop = (event, index) => {
    event.preventDefault();

    const dragIndex = event.dataTransfer.getData('text/plain');
    const newItems = [...items];
    const draggedItem = newItems[dragIndex];

    newItems.splice(dragIndex, 1);
    newItems.splice(index, 0, draggedItem);

    setItems(newItems);
  };

  return (
    <div>
      <h3>设计区</h3>
      {items.map((item, index) => (
        <div
          key={index}
          draggable
          onDragStart={(event) => handleDragStart(event, index)}
          onDragOver={handleDragOver}
          onDrop={(event) => handleDrop(event, index)}
        >
          {item}
        </div>
      ))}
    </div>
  );
};

export default DesignArea;

```

### 设计区层叠关系拖动

> 参考https://h2dwof.aliwork.com/dingtalk/web/APP_LJN42QU68MIWHN3D0D29/design/pageDesigner?formUuid=FORM-MFA66S91R2UB3XHJB314D6SPUN983E5AVF6JL5&

有些组件支持层叠嵌套逻辑，比如一个轮播容器组件 应该支持内部添加卡片组件

- 层叠后，子组件成为父组件的children字段

参考第三方库SortableJS：

https://sortablejs.github.io/Sortable/#nested

问题：**如何实现的层叠识别？**

### 组件区可直接拖拽至设计区并定位最终位置

我们需要实现从组件区拖拽过来即可直接实现层叠位置的确定，这样可以一步到位地直接完成组件位置的定位。

**思路：为每一个节点增加onDrop事件处理函数，在节点间留出空隙，用于父级节点的drop空间。**

```jsx
import React, { useState } from 'react';

// 示例的节点数据
const json = {
  id: 1,
  title: 'Node 1',
  children: [
    {
      id: 2,
      title: 'Node 2',
      children: []
    },
    {
      id: 3,
      title: 'Node 3',
      children: []
    }
  ]
};

// 节点组件
const Node = ({ node, onDrop }) => {
  const [isDragging, setIsDragging] = useState(false);

  // 拖拽开始时的事件处理函数
  const handleDragStart = (e) => {
    e.stopPropagation();
    setIsDragging(true);
  };

  // 拖拽结束时的事件处理函数
  const handleDragEnd = (e) => {
    e.stopPropagation();
    setIsDragging(false);
  };

  // 放置事件处理函数
  const handleDrop = (e) => {
    e.preventDefault();
    setIsDragging(false);

    // 获取被拖拽的节点的ID
    const draggedNodeId = parseInt(e.dataTransfer.getData('text/plain'), 10);

    // 调用父组件传递的回调函数，将节点放置为当前节点的子节点
    onDrop(draggedNodeId, node.id);
  };

  return (
    <div
      draggable
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      onDrop={handleDrop}
      className={`node ${isDragging ? 'dragging' : ''}`}
    >
      {node.title}
      {node.children.map(child => (
        <Node key={child.id} node={child} onDrop={onDrop} />
      ))}
    </div>
  );
};

// 主组件
const App = () => {
  const [data, setData] = useState(json);

  // 放置回调函数，用于处理节点放置的逻辑
  const handleDrop = (draggedNodeId, targetNodeId) => {
    // 根据节点ID查找被拖拽的节点和目标节点
    const draggedNode = findNode(data, draggedNodeId);
    const targetNode = findNode(data, targetNodeId);

    // 在目标节点的子节点中添加被拖拽的节点
    targetNode.children.push(draggedNode);

    // 移除被拖拽的节点在原位置的引用
    const parent = findParentNode(data, draggedNodeId);
    parent.children = parent.children.filter(node => node.id !== draggedNodeId);

    // 更新数据
    setData({ ...data });
  };

  // 辅助函数，用于在数据中查找节点
  const findNode = (node, targetNodeId) => {
    if (node.id === targetNodeId) {
      return node;
    }
    for (let child of node.children) {
      const foundNode = findNode(child, targetNodeId);
      if (foundNode) {
        return foundNode;
      }
    }
    return null;
  };

  // 辅助函数，用于在数据中查找节点的父节点
  const findParentNode = (node, targetNodeId) => {
    for (let child of node.children) {
      if (child.id === targetNodeId) {
        return node;
      }
      const parent = findParentNode(child, targetNodeId);
      if (parent) {
        return parent;
      }
    }
    return null;
  };

  return (
    <div>
      <h1>Sortable Nodes</h1>
      <Node node={data} onDrop={handleDrop} />
    </div>
  );
};

export default App;

```

### 页面搭建数据持久化

我们希望搭建好的页面可以持久化地保存和二次编辑，我们需要处理全局JSON的保存和还原

### 页面标签内缓存

- 刷新可缓存
- 关闭、新开标签后消失

### 组件事件处理

组件的事件抛出后，事件需要在全局层面进行处理，在其他组件中增加对指定事件的响应。

- 全局事件监听、处理

### 页面部署

当我们完成低代码设计后，如何将该设计应用到线上呢？

方案一：打包，部署打包后的代码

**如何打包？**

- 打包无需前端，后台可执行
- 后端工程通过接口控制webpack打包

> 缺点：对服务端压力大
>
> 优点：性能好

方案二： 不打包，线上使用JSON渲染

> 优点：足够灵活
>
> 缺点：注意安全，防止注入，对服务端压力小

### 未来发展方向

1. **拓展功能和扩展性：**未来的低代码平台将更加注重提供更丰富的功能和更高的可扩展性。开发人员将能够使用更多的组件、集成第三方服务和自定义代码来满足更复杂的应用需求。
2. **增强用户体验**：用户体验将成为低代码平台发展的重要方向。平台将提供更直观、易用且美观的用户界面，使非技术人员能够轻松创建和定制应用程序，提高工作效率和用户满意度。
3. **智能化和自动化**：低代码平台将更多地采用智能化和自动化技术，例如机器学习、自然语言处理和自动代码生成等。这些技术将帮助开发人员更快速地构建应用程序，减少手动工作量，提高开发效率。
4. **多平台和跨设备支持**：未来的低代码平台将更好地支持多平台和跨设备的应用开发。开发人员将能够同时创建适用于多种操作系统和设备类型的应用程序，如移动设备、Web、桌面和物联网设备等。
   1. > TailwindCSS的接入
5. **更强的集成能力**：低代码平台将进一步加强与其他系统和服务的集成能力，如云服务、数据源、第三方API等。这将使开发人员能够轻松地连接和交互不同的系统，实现更强大的应用功能和数据流。

https://www.yuque.com/lpldplws/web/wsp422ie5fpedsn4?singleDoc# 《阿里前端面试官带你深度剖析面试真题&React Fiber源码解析》 密码：rgzl

https://rax.js.org/docs/guide/about-miniapp

https://github.com/raxjs/miniapp

https://leetcode.cn/problem-list/2ckc81c/

https://www.yuque.com/lpldplws/web/og6swa9wsde8lc8b?#《前端AST》 密码：lxee

https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js

https://www.yuque.com/lpldplws/web/zf77fb?singleDoc# 《微信小程序项目优化&开发实战》 密码：tdbo

https://www.yuque.com/lpldplws/web/avn0gl?singleDoc# 《小程序课程课后习题汇总》 密码：nr6

https://github.com/umijs/qiankun/pull/1061

![https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js](https://cdn.nlark.chttps://cdn.nlark.com/yuque/0/2022/png/739887/1670518101565-6a67763a-8498-49a1-ad75-f46d986b8d34.pngm/yuque/0/2022/png/739887/1670518101565-6a67763a-8498-49a1-ad75-f46d986b8d34.png)

https://getbyteoffer.feishu.cn/docx/H4ykdC8ZwokzJex1u9qcaH07nqd


https://www.yuque.com/lpldplws/web/itd4rdqaqqioga10?#《webpack》 密码：nn2p 
------


# 浏览器中输入URL以后，发生了什么？

本质上，浏览器最终加载的还是js

![image-20230323222003568](/Users/zhengyali/Library/Application Support/typora-user-images/image-20230323222003568.png)

# 浏览器事件循环

1. 事件循环是谁提供的？

2. 宿主环境（浏览器）提供了事件循环的机制v8-js引擎
   - 宏任务、微任务
   - 宏任务、微任务、RAF、界面绘制、RequestIdCallback

![image-20230323221209698](/Users/zhengyali/Library/Application Support/typora-user-images/image-20230323221209698.png)

- 事件循环依赖于宿主环境，如果说的是浏览器的事件循环，我拿谷歌的事件循环来举例
- 一般分为以下几个阶段，用户的输入，js的timers,beignframe,raf,layout,paint
  - 输入事件包含了阻塞输入事件和非阻塞输入事件
  - js的timers
  - beignframe：处理跟框架之前的事情
  - raf:用于连续对话，性能优化
  - layout:

- 对于谷歌来说所有的这个过程都遵循一个消息队列，以消息队列的方式回去处理task，这个过程中会清空job的队列

# 浏览器的5个Observer

1. IntersectionObserver可以监听一个元素和可视区域的相交
2. MutationObserver可以监听一个普通JS对象/DOM的变化
3. ResizeObserver [resize事件只能监听窗口]，echarts,框框发生变化，可以用来监听元素大小的变化
4. PerformanceObserver 替换window.performance
5. ReportingObserver回调上报

# 面试

## 面试前

### 1. 打包工程化 --熟悉，思考

### 2.工程流程 

- 每个项目需要的流程
- 看公司的开发是否符合规范

### 3. 熟悉程度

- 简历上查一下自己对项目的成熟度

### 4. 合理安排面试时间

- 不要随意改动自己的面试时间

## 第一面：技术骨干（有没有其他方面补充，就是想发现你其他方面的闪光点，想捞你）

### 目标

1. 确认与简历信息基本吻合，并且进一步定位深浅

2. 确认具备快速学习上手干活的能力--查看有没有解决问题的能力

3. 基础知识能力能够满足岗位的最低需求

4. 能否快速适应团队的工作，并且有一定的提升空间

### 面试人

1. 简历上技术一定要熟悉，并且按照级别深度准备
2. 以往业务经理，学会回头看
3. 基础知识的扫盲以及提高
4. 寻找机会展示自己的学习思考能力

### 技术考察

- HTML、计算机网络、浏览器、性能
- 样式css=>派生
- js基础=>基础类型=>继承=>OOP=>es6=>手写=>技巧变量提升、函数提升、闭包、防抖、节流
- 代理、垃圾回收、event loop，设计模式，AST
- 框架MVVM，工具类-network,router.babel,打包-webpack
- 实操&算法
  - 字符串内容替换、数组去重、对象全等
  - 排序，场景类

## 二面

### 面试官-leader

- 除了基础实践层面，知识体系的完成度
- 除了业务开发外，实际解决问题的能力
  - 和设计师有没有共同讨论某个东西怎么实现完成

- 领域场景以及架构设计能力

### 面试人

- 知识体系图谱-知识图谱
- 解决问题的能力-回顾项目、沟通、业务设想

- 框架设计、架构能力《web站点搭建》《前端架构》《大话设计模式》

### 考察

- 网络类
- 框架类
- web架构类
- 新技术敏感度

## 三面

### 目标

#### 广度和个人思考

#### 历史类

#### 抽象处理类

#### 个人思考

## 简历

### 面试官

1. 技术掌握程度-提问的顺序以及深度
2. 技术栈、端、长期涉足领域-提问的方式、感兴趣程度
3. 业务方向以及成熟程度-提问的重点

### 面试人

1. 从深度到了解、并按照顺序来书写和准备

2. 明确罗列技术栈、端、业务领域
3. 尽量不要写自己未知的领域、主动暴露自己擅长的领域

#### 比如

xxx通应用        PC/H5       2020/10-至今   前端开发负责

独立负责xxxx、xxx、xxx、模块的前端部分工作。应用：vue、react、ant-d...独立完成了所有模块的设计开发，

1. 抽离/解藕出网络层统一化对网络请求报错做了上报处理（性能做了监控处理），从而沉淀实现了一套主动运营问题发现并及时解决的方案
2. 并且沉淀出独立组件库，实现多模块复用。在沉淀过程中，对于按需加载/xxx做了调研，最终借鉴xxx的方式，实现了本模块按需加载逻辑。后续可以在xxx方面进一步优化

# 突击课 HTML

https://vgbixa7nr9.feishu.cn/drive/folder/fldcnA1evRprBZvnk8iFCLAegEc

## HTML DOCTYPE 的含义？什么是 HTML 的标准模式与混杂模式？

HTML的文档类型声明，doctype ，说明这个页面是用什么来编写的。

- h5 html5 有一个比较宽松的语法，基本上完全向后兼容。

```html
<!doctype html>
```

- h4.0.1
  - strict 结构中不能有出现格式或表现的内容
    - `<b></b>`，`<p font='5'></p>`
  - tansitional

```html
<!-- strict html -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- strict xhtml -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- transitional html -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- transitional xhtml -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

## HTML5有哪些语义化标签及其特性？HTML元素有哪些分类与特性？

让我们根据结构化的内容，选择合适的标签。

- seo 有利；
- 代码的可读性，更好；
- 标签上加上 alt, title 
- accessibility 方便一些其他的设备进行解析。

## 如何检测浏览器是否支持HTML5特性？

- canvas
- video, audio
- 本地缓存的支持 localStorage, Worker
- article, footer, header
- form: calender, date
- esm es module, script 是不再需要 type 属性了。

1. 检查特定的属性和方法

```js
!!navigator.geolocation
!!window.localStorage
!!window.Worker
```

2. 创建一个元素，看看特定元素，有没有属性和方法

```js
document.createElement('canvas').getContext()
document.createElement('video').canPlayType;
```

3. 第三方库
   http://modernizr.cn/

## jump HTML中meta的作用？

## HTML的标签有哪些可以优化SEO？

1. meta 中的相关属性
   `<meta name="author" content="aaa@gmail.com">`
   `<meta name="description" content="XXX XRM XXX 系统" >`
   `<meta name="keywords" content="XXX XRM XXX 系统" >`

2. 标签
   1. title 
   2. meta
   3. header
   4. nav
   5. article
   6. aside
   7. footer

A:

1. 首先要保证是SSR的；
2. meta 中相关的属性；
3. 语义化标签，以一些结构化的为主。 费效比。

## DOM和BOM有什么区别？

JavaScript 在浏览器环境下，一般由三部分组成。

- ECMAScript 核心。描述了JS的语法和基本对象；
- DOM 文档对象模型， document. 你有一些 API，可以操作 文档。
- BOM 浏览器对象模型，browser. 你有一些 API，可以操作 浏览器。

## 如何实现移动端适配？

### 1px 问题

先放大 200% ,然后 scale(0.5)

### rem 方案

rem 指的是 html 的 font-size 的大小。

## 如何禁用页面中的右键、打印、另存为、复制等功能？

```js
// 右键
document.onmousedown = function(event) {
    if(event.button === 2) {
        return false;
    }
}

document.oncontextmenu = function(event) {
    return false;
}

// 复制
// <body oncopy="nocopy()">
function nocopy(event) {
    event.returnValue = false;
}

// f12
document.onkeydown = function(e) {
    if(window.event && window.event.keyCode === 123) {
        window.event.returnValue = false;
    }
}
```

## href="javascript:void(0)"和href="#"区别是什么？

href="#" 我的锚点，默认是 #top,会让你网页往上走。
javascript:void(0) 死链接。

## 对target="_blank"的理解？有什么安全性问题？如何防范？

target="_blank", 类似于 window.open, 你的子页面，会拿到你当前的句柄(句柄就塞windows的对象)。
window.opener

```js
if(window.opener) {
    window.opener.loacation.href = "bad.html"
}
```

```html
<a href="x.html" target="_blank" rel="noopener noreferer">跳转</a>
```

```js
var otherWindow = window.open('xxx');
otherWindow.opener = null;
```

## 简述页面的存储区别？什么是本地存储？怎么做离线缓存？

1. cookie 
   每个cookie 不能超过 4kb
   每个域 20个
   [key, value, domain, expireTime, httpOnly, sec, ss]

2. web storage 
   localstorage 
   sessionstorage
   5MB 

3. indexedDB [webSQL]
4. application cache
   - pwa
   - service worker

## 什么是canvas？什么时候需要使用canvas？

canvas 的中文：画布。
css div 普通的网页；
svg 和传统的html 差别不大。html 处理矢量绘图的能力不足。
canvas 2d 
canvas webGL OpenGL 的 ES 规范，在 web 端的实现。利用 GPU 去渲染一些，3d/2d 的图形。 

## 什么是PWA？

渐进式网页应用。
核心技术：

- app manifest
- service worker 客户端代理的工作
- web push

## 什么是Shadow DOM？

web component 做到真正的组件化。

- 原生规范，无需框架
- 原生使用，无需编译
- 真正意义上的 css scope

```js
customElements.define('shadow-test', class extends HTMLElemenet {
    connectedCallback() {
        const shadow = this.attachShadow({mode: 'open'})
        shadow.innerHTML = "this is a shadow dom"
    }
})

```

<!-- stencil 框架 -->

## iframe有哪些应用？

- 最常见的一种微前端手段
- ajax 上传文件
- 广告
- 跨域

## 如何处理iframe通信？

- 同域下面

```js
document.demain = "baidu.com";
frame.contentWindow.xxx;
```

- post message


## 浏览器的渲染和布局逻辑是什么？

- DOM 树构建
- CSS 树构建
- 渲染树构建
- 页面布局
- 页面绘制

## 页面的重绘回流是什么？

回流
回流又称重排，指改变几何属性的渲染。感觉“回流”较高大上，后续统称回流吧。

可理解为将整个网页填白，对内容重新渲染一次。只不过以人眼的感官速度看浏览器回流是不会有任何变化的，若你拥有闪电侠的感官速度看浏览器回流(实质是将时间调慢)，就会发现每次回流都会将网页清空，从左上角第一个像素点从左到右从上到下这样一点一点渲染，直至右下角最后一个像素点。每次回流都会呈现该过程，只是感受不

到而已。

渲染树的节点发生改变，影响了节点的几何属性，导致节点位置发生变化，此时就会触发浏览器回流并重新生成渲染树。回流意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。

重绘
重绘指改变外观属性而不影响几何属性的渲染。相比回流，重绘在两者中会温和一些，后续谈到的CSS性能优化就会基于该特性展开。

渲染树的节点发生改变，但不影响节点的几何属性。由此可见，回流对浏览器性能的消耗高于重绘且回流一定伴随重绘，重绘却不一定伴随回流。

为何回流一定伴随重绘？整个节点的位置都变了，肯定要重新渲染它的外观属性啊！

回流必定引发重绘，重绘不一定引发回流，可利用该法则解决一些因为回流重绘而引发的性能问题。在优化性能前，需了解什么情况可能产生性能问题，以下罗列一些常见情况。

改变窗口大小
修改盒模型
增删样式
重构布局
重设尺寸
改变字体
改动文字

## 怎样计算首屏和白屏的时间？常统计的页面性能数据指标包括？

FP FCP 

PerformanceObserver

## 页面上有哪些领域可以做进一步的性能优化？

- visibility:hidden --> display:none
- 避免使用 table
- 避免层级过多
- dom insert -- fragment
- requestIdelCallback

FCP CLS FID


## 浏览器之间的线程调度是怎么做的？

● 最新的Chrome浏览器包括：1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程，和多个插件进程；
  ○ 浏览器进程： 负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能
  ○ GPU进程：负责整个浏览器界面的渲染。Chrome刚开始发布的时候是没有GPU进程的，而使用GPU的初衷是为了实现3D CSS效果，只是后面网页、Chrome的UI界面都用GPU来绘制，这使GPU成为浏览器普遍的需求，最后Chrome在多进程架构上也引入了GPU进程
  ○ 网络进程：负责发起和接受网络请求，以前是作为模块运行在浏览器进程一时在面的，后面才独立出来，成为一个单独的进程
  ○ 插件进程：主要是负责插件的运行，因为插件可能崩溃，所以需要通过插件进程来隔离，以保证插件崩溃也不会对浏览器和页面造成影响
  ○ 渲染进程：负责控制显示tab标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，排版引擎Blink和JS引擎V8都是运行在该进程中，默认情况下Chrome会为每个Tab标签页创建一个渲染进程

- 渲染进程中的线程 
  - GUI渲染线程：负责渲染页面，解析html和CSS、构建DOM树、CSSOM树、渲染树、和绘制页面，重绘重排也是在该线程执行
  -  JS引擎线程：一个tab页中只有一个JS引擎线程(单线程)，负责解析和执行JS。它GUI渲染进程不能同时执行，只能一个一个来，如果JS执行过长就会导致阻塞掉帧
  - 计时器线程：指setInterval和setTimeout，因为JS引擎是单线程的，所以如果处于阻塞状态，那么计时器就会不准了，所以需要单独的线程来负责计时器工作
  -  异步http请求线程： XMLHttpRequest连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待JS引擎空闲执行
  -  事件触发线程：主要用来控制事件循环，比如JS执行遇到计时器，AJAX异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件触发时，就把事件添加到待处理队列的队尾，等JS引擎处理

Chrome为例，有四种进程模型，分别是

- Process-per-site-instance：默认模式。访问不同站点创建新的进程，在旧页面中打开的新页面，且新页面与旧页面属于同一站点的话会共用一个进程不会创建
-  Process-per-site：同一站点使用同一进程
-  Process-per-tab：每一个标签页都创建新的进程
- Single Process：单进程模式

线程模型中的线程都是干嘛的呢？

- MessagePumpForIO：处理进程间通信的线程，在Chrome中，这类线程都叫做IO线
-  MessagePumpForUI：处理UI的线程用的
-  MessagePumpDefault：一般的线程用到的

典型进程通信方式有：

- 管道通信：就是操作系统在内核中开辟一段缓冲区，进程1可以将需要交互的数据拷贝到这个缓冲区里，进程2就可以读取了
- 消息队列通信：消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，不过和管道通信一样每个数据块有最大长度限制
- 共享内存通信：就是映射一段能被其他进程访问的内存，由一个进程创建，但多个进程都可以访问，共享进程最快的是IPC方式
- 信号量通信：比如信号量初始值是1，进程1来访问一块内存的时候，就把信号量设为0，然后进程2也来访问的时候看到信号量为0，就知道有其他进程在访问了，就不访问了
-  socket：其他的都是同一台主机之间的进程通信，而在不同主机的进程通信就要用到socket的通信方式了，比如发起http请求，服务器返回数据

# 突击课-css

## 面试方式

### 分级

初级 => 中级 *
概念 + 原理 + 场景

中级 **
实际应用 + 复合场景

高级 ***
技巧 + 工程化

### 面试方式

特点：相对零散，从点到面

### 面试题：

### display有哪些属性？*

none - 不展示
block - 块类型
inline - 行内
inline-block - 默认行内块状
list-item | table
inherit - 继承

### inline & inline-block的区别能说说么？ *

inline: 共享一行，行内概念
block: 独占一行
inline-block：共享一行，内容作为block对象呈现

### 行内元素和块级元素有什么区别呢？ *

- 行内元素：
  无法设置宽高
  水平方向可设置margin + padding，垂直方向则无法设置
  不会自动换行

- 块级元素：
  可以设置宽高
  水平垂直方向可设置margin + padding
  可以自动换行
  多个块状是默认从上往下换行排列

### 有哪些行内和块级元素？*

块级元素
div form h1 pre table ul……
行内
a br code em img i input strong textarea……

### 块级元素和内联元素有哪几种转换方式？ **

1. display
2. float
   float: left/right => display: block ** => 去除行内元素之间的空白问题 ***
3. position
   position: absolute / fixed => 块级

### 选择器 & 优先级

1. #### 选择器的优先级是什么样的？ 选择器如何做样式判断？ 这段样式能不能生效？ *

   内联样式                    1000
   id选择器    #id             100
   类选择器    .class          10
   属性选择器  a[ref="link"]   10
   标签选择器  div             1
   伪类选择器  li:last-child   10
   伪元素选择器 li:before      1

​      兄弟选择器  div+p           0
​      子选择器    ul>li           0
​      后代选择器  li a            0

​      通配符      *               0

2. #### 特殊场景的优先级如何判断？ *

   !important 优先级最高
   如果优先级相同，则后者高于前者
   继承得到的样式，优先级最低

3. #### 可继承的样式有哪些？ **

   - 字体
      font-family,font-weight,font-size,font-style
   - 文本
      text-indent,text-align,line-height,word-spacing,letter-spacing,color
   - 元素
      visibility
   - 列表布局
      list-style
   - 光标
      cursor

### 隐藏和显示相关

1. #### 有哪些可以隐藏过一个元素的方法？有什么区别？ **

   display: none; 不占位
   visibility: hidden; 占位

​       opacity: 0;  占位
​       position: absolute;  不占位
​       z-index: 负值;   不占位
​       clip   占位
​       transform: scale(0, 0)  占位

2. #### display vs visibility有什么区别？ ** 

   他们俩都是让元素隐藏和展示。

浏览器渲染时，display不占据空间，渲染树中会不存在
visibility，占据一根树枝

继承属性来说，display不会被继承，visibility会被继承

性能影响上，display造成文档的重排，但是修改visibility只会导致文本的重绘

### 盒模型及其特性

1. 简单说说标准盒模型、IE盒模型分别是什么？怎么转换? *
   盒模型特点：
   content + padding + border + margin
   区别：
   标准盒模型 - width和height只包含content部分
   IE盒模型 - width和height包含了content + padding + border部分
   转换：
   box-sizing: content-box / border-box;

2. 伪元素和伪类是什么？如何使用？区别是什么？ *
   伪元素：只出现在css样式表中，不存在于doc中。

```js
    p::before {
        content: 'zhaowa'
    }
    p::first-line {
        background: red;
    }
```

伪类：已有的元素上加上特殊类别，不产生新的元素。

```js
    div:hover {
        color: red;
    }
```

### 图片格式以及CSS-sprites

1. 图片格式有哪些？怎么应用？如何选择？*
   BMP，无损、没有压缩。通常体积较大。
   GIF，无损、采用了LZW压缩算法。仅支持8bit索引色，支持动图。
   JPEG，有损、直接色存储，适合还原度要求较高的照片。
   PNG-8，无损、使用索引色。体积更优秀，并且支持透明度调节。
   PNG-24，无损、使用直接色，压缩。
   SVG，无损、svg放大不会失真，所以适合logo、icon。
   webP，有损+无损、直接色、支持透明度、压缩。chrome、opera支持

2. CSS-sprites 精灵图、雪碧图怎么处理？ *
   所有涉及到的图片，放到一张大图中去
   background-image, background-repeat, background-position

### 像素密度与图片应用

1. 像素密度有了解吗？ *
   经典设备宽高 414px * 896px
   物理像素 1242px * 2688px => 1242 / 414 = 3
   => 逻辑像素：物理像素 = 1：3 => 像素密度3 => 3倍屏

2. 如何在图片的加载上应用动态密度？ *
   设计师提供 @2x，@3x，@4x
   200 * 300 => 3倍屏幕 => 600 * 900

```js
    image {
        background: ('1x.png');
    }
    // 利用媒体查询
    @media only screen and (min-deivce-pixel-ratio: 3) {
        image {
            background: ('3x.png');
        }
    }
```

### css工程化与预处理

1. css类库 与工程化的理解？ ***
   预处理器：less scss stylus
   => 利用编译库提供能力，提供层级、mixin、变量、循环、函数

后处理器：postCss
=> 利用后处理编译，属性增加前缀，实现跨浏览器兼容

### 单行多行文本超出

1. 手写一个单行 & 多行的文本超出省略 *

```js
    // 单行超出
    overflow: hidden;
    text-overflow: ellipsis; // 超出省略号
    white-space: nowrap;   // 不换行，因为是块级元素有宽高，会默认换行，这里强制性不要要行

    // 多行超出，这里只能-webkit上能
    overflow: hidden;
    text-overflow: ellipsis; // 超出省略号
    display: -webkit-box;  // 弹性伸缩盒子模型
    -webkit-box-orient: vertical; // 从上往下垂直排列
    -webkit-line-clamp: 3;  // 显示的行数

    // 兼容性方案
    p {
        position: relative;
        line-height: 18px;
        height: 40px;//这里是不足之处
        overflow: hidden;
    }
    p::after {
        content: '...';
        position: absolute;
        bottom: 0;
        right: 0;
    }
    // 方案有什么不足之处 => 固定行高 => js处理 后处理器
```

### px em rem

1. 多种单位的差别 *
   百分比：子元素的百分比相对于直接父元素的对应属性

em: 相对于父元素的字体大小倍数
rem: 相对于根元素字体大小的倍数

vw: 视窗宽度，满视窗宽度为 100vw
vh: 视窗高度，满视窗高度为 100vh
vmin: vw和vh中较小值
vmax: vw和vh中较大值

2. 如何利用rem实现响应式？ 项目如何实现响应式的？
   根据当前设备的视窗宽度与设计稿的宽度得到一个比例
   根据比例设置根节点的font-size
   所有长度单位都用rem

### 布局

1. 定位浮动 - 简单聊聊看浮动的影响还有原理？ *
   浮动工作原理：
   浮动元素脱离文档流，不占据空间 => 不受原有文档流的影响，同时无法影响原有父类 => 高度塌陷

2. 浮动停留的条件？浮动元素移动遵循的空间？*
   浮动元素碰到包含他的边框或者其他浮动元素的时候会停留
   => 浮动元素可以左右移动
   => 浮动元素高度独立，不会再影响撑开原有父类的高度

3. 高度塌陷原因，如何解决高度塌陷？*
   - 给父级定义height
   - 浮动元素之后，给一个div，clear: both;
   - 父级标签增加overflow:hidden;
   -  用伪元素模拟div

4. 简单说说如何创建BFC，以及如何解决相应一些问题？ **
   创建BFC的条件：
   根元素body
   元素设置浮动：float除了none之外
   position 脱离文本流的操作
   display的inlin-block table-cell table-caption flex
   overflow的 hidden auto scroll

BFC的特点：
垂直方向上，自上而下排列的，和文档流的排列方式一致
BFC中上下相邻的两个容器margin会重叠
计算BFC高度时要计算浮动元素
BFC不会影响外部元素

5. BFC正作用有哪些？**
   解决margin重叠问题、解决高度塌陷、创建自适应布局


6. 有几种办法能实现两列布局？实现一个左边宽度固定，右侧宽度自适应的两列布局？*

```js
    // 1. 浮动 + 生成BFC不重叠
    .left {
        width: 100px;
        height: 200px;
        float: left;
    }
    .right {
        height: 200px;
        overflow: hidden;
    }

    // 2. 浮动 + width auto
    .container {
        height: 200px;
    }
    .left {
        width: 200px;
        height: 200px;
        float: left;
    }
    .right {
        margin-left: 200px;
        width: auto;
    }

    // 3. flex大法好
    .container {
        height: 200px;
        display: flex;
    }
    .left {
        width: 200px;
    }
    .right {
        flex: 1;
    }
```

7. 两列布局可以，那再加一列呢？左右两栏宽度固定，中间自适应？***

```js
    // 1. 绝对布局法
    .container {
        position: relative;
        height: 200px;
    }
    .left {
        position: absolute;
        width: 100px;
        height: 200px;
    }
    .right {
        position: absolute;
        width: 200px;
        height: 200px;
        top: 0;
        right: 0;
    }
    .center {
        margin-left: 100px;
        margin-right: 200px;
        height: 200px;
    }
    // 2. flex大法好
    .container {
        display: flex;
        height: 200px;
    }
    .left {
        width: 100px;
    }
    .right {
        width: 200px;
    }
    .center {
        flex: 1;
    }
    // 3. 圣杯布局,主要利用父边距
    .container {
        height: 200px;
        padding-left: 100px;
        padding-right: 200px;
    }
    .center {
        float: left;
        width: 100%;
        height: 200px;
    }//此时center已经是整行了
    .left {
        position: relative;
        left: -100px;
    
        float: left;
        margin-left: -100%;//这里是跑到上面的关键
        width: 100px;
        height: 200px;
    }
    .right {
        position: relative;
        left: 200px;
    
        float: right;
        margin-left: -200px;
        width: 200px;
        height: 200px;
    }
    // 4. 双飞翼
    .container {
        height: 200px;
    }
    .left {
        float: left;
        margin-left: -100%;
        width: 100px;
        height:200px;
    }
    .right {
        float: left;
        margin-left: -200px;
        width: 200px;
        height: 200px;
    }
    .wrapper {
        float: left;
        width: 100%;
        height: 200px;
    }
    .center {
        margin-left: 100px;
        margin-right: 200px;
        height: 200px;
    }
```

8. 水平垂直居中问题？ **

```js
    // 1. 绝对定位
    div {
        position: absolute;
        left: 50%;
        top: 50%;
        margin-top: -height/2;
        margin-left: -width/2;
    }
    // 2. 自我拉扯
    div {
        margin: auto;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
    }
    // 3. flex大法好
    .parent {
        display: flex;
        justify-content: center;
        align-items: center;
    }
```

### 奇技淫巧

三角形 => 梯形 => 扇形 => 基础元素 + 技巧
1px、12px font => 变形进行处理
动画 => 幻灯片 / 电影



https://www.electronjs.org/zh/docs/latest/api/desktop-capturer

